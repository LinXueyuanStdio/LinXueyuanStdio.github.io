<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XiChen</title>
  
  <subtitle>XiChen&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xichen.pub/"/>
  <updated>2019-04-01T15:44:33.723Z</updated>
  <id>http://xichen.pub/</id>
  
  <author>
    <name>Lin Xueyuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mac shadowsocks</title>
    <link href="http://xichen.pub/2019/03/22/2019-03-22-mac-shadowsocks/"/>
    <id>http://xichen.pub/2019/03/22/2019-03-22-mac-shadowsocks/</id>
    <published>2019-03-22T05:11:00.000Z</published>
    <updated>2019-04-01T15:44:33.723Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://16bing.com/2017/02/18/mac-shadowsocks/" target="_blank" rel="noopener">http://16bing.com/2017/02/18/mac-shadowsocks/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://16bing.com/2017/02/18/mac-shadowsocks/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://16bing.com/2017/02/18/mac-shadowsocks/&lt;/a&gt;&lt;
      
    
    </summary>
    
      <category term="Mac" scheme="http://xichen.pub/categories/Mac/"/>
    
    
      <category term="Mac" scheme="http://xichen.pub/tags/Mac/"/>
    
      <category term="Shadowsocks" scheme="http://xichen.pub/tags/Shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>【Android TimeCat】ANR in com.time.cat</title>
    <link href="http://xichen.pub/2019/03/14/2019-02-13-ANR/"/>
    <id>http://xichen.pub/2019/03/14/2019-02-13-ANR/</id>
    <published>2019-03-14T05:11:00.000Z</published>
    <updated>2019-04-01T15:47:12.261Z</updated>
    
    <content type="html"><![CDATA[<p>E/ANRManager: ANR in com.time.cat, time=428313880<br>    Reason: Broadcast of Intent { act=android.appwidget.action.APPWIDGET_UPDATE flg=0x114 cmp=com.time.cat/com.timecat.module.master.mvp.ui.widgets.NoteWidgetProvider (has extras) }</p><p>引起这个错误的原因是，在一个BroadcastReceiver中的onReceive方法中的处理不能超过10秒，如果超过就会出现ANR错误。</p><p>所有尽量不要在onReceive中做耗时的处理，最好用Service来处理。（不要另外开启线程，因为这个线程会随着onReceive的返回而终止。）</p><p>以下在Google API中的原文：</p><p>so you should never perform long-running operations in it (there is a timeout of 10 seconds that the system allows </p><p>before considering the receiver to be blocked and a candidate to be killed). You cannot launch a popup dialog in your </p><h2 id="implementation-of-onReceive"><a href="#implementation-of-onReceive" class="headerlink" title="implementation of onReceive()."></a>implementation of onReceive().</h2><p>作者：huangliop<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/huangliop/article/details/7615262" target="_blank" rel="noopener">https://blog.csdn.net/huangliop/article/details/7615262</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;E/ANRManager: ANR in com.time.cat, time=428313880&lt;br&gt;    Reason: Broadcast of Intent { act=android.appwidget.action.APPWIDGET_UPDATE flg=
      
    
    </summary>
    
      <category term="Android" scheme="http://xichen.pub/categories/Android/"/>
    
    
      <category term="ANR" scheme="http://xichen.pub/tags/ANR/"/>
    
  </entry>
  
  <entry>
    <title>深度学习资料推荐</title>
    <link href="http://xichen.pub/2019/03/14/2019-03-12-deeplearning_resources/"/>
    <id>http://xichen.pub/2019/03/14/2019-03-12-deeplearning_resources/</id>
    <published>2019-03-14T05:11:00.000Z</published>
    <updated>2019-04-01T15:52:08.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深度学习资料推荐"><a href="#深度学习资料推荐" class="headerlink" title="深度学习资料推荐"></a>深度学习资料推荐</h1><p>深度学习火起来之后，网上关于深度学习的资料很多。但是其质量参差不齐。我从2013年开始就关注深度学习，见证了它从一个小圈子的领先技术到一个大众所追捧的热门技术的过程。也看了很多资料。我认为一个高质量的学习资料可以帮助你真正的理解深度学习的本质，并且更好地掌握这项技术，用于实践。</p><p>以下是我所推荐的学习资料</p><h2 id="1-视频课程"><a href="#1-视频课程" class="headerlink" title="1. 视频课程"></a>1. 视频课程</h2><h3 id="Yaser-Abu-Mostafa"><a href="#Yaser-Abu-Mostafa" class="headerlink" title="Yaser Abu-Mostafa"></a>Yaser Abu-Mostafa</h3><p>加州理工的Yaser Abu-Mostafa教授出品的机器学习网络课程，非常系统地讲解了机器学习背后的原理，以及主要的技术。讲解非常深入浅出，让你不光理解机器学习有哪些技术，还能理解它们背后的思想，为什么要提出这项技术，机器学习的一些通用性问题的解决方法（比如用正则化方法解决过拟合）。强烈推荐。</p><ul><li>课程名称：Machine Learning Course - CS 156</li><li>视频地址：<a href="https://www.youtube.com/watch?v=mbyG85GZ0PI&amp;list=PLD63A284B7615313A" target="_blank" rel="noopener">https://www.youtube.com/watch?v=mbyG85GZ0PI&amp;list=PLD63A284B7615313A</a></li></ul><h3 id="Geoffrey-Hinton"><a href="#Geoffrey-Hinton" class="headerlink" title="Geoffrey Hinton"></a>Geoffrey Hinton</h3><p>深度学习最重要的研究者。也是他和另外几个人（Yann LeCun，Yoshua Bengio等）在神经网络被人工智能业界打入冷宫，进入低谷期的时候仍然不放弃研究，最终取得突破，才有了现在的深度学习热潮。他在Coursera上有一门深度学习的课程，其权威性自不待言，但是课程制作的质量以及易于理解的程度，实际上比不上前面Yaser Mostafa的。当然，因为其实力，课程的干货还是非常多的。</p><ul><li>课程名称：Neural Networks for Machine Learning</li><li>课程地址：<a href="https://www.coursera.org/learn/neural-networks" target="_blank" rel="noopener">https://www.coursera.org/learn/neural-networks</a></li></ul><h3 id="UdaCity"><a href="#UdaCity" class="headerlink" title="UdaCity"></a>UdaCity</h3><p>Google工程师出品的一个偏重实践的深度学习课程。讲解非常简明扼要，并且注重和实践相结合。推荐。</p><ul><li>课程名称：深度学习</li><li>课程地址：<a href="https://cn.udacity.com/course/deep-learning--ud730" target="_blank" rel="noopener">https://cn.udacity.com/course/deep-learning--ud730</a></li></ul><h3 id="小象学院"><a href="#小象学院" class="headerlink" title="小象学院"></a>小象学院</h3><p>国内小象学院出品的一个深度学习课程，理论与实践并重。由纽约城市大学的博士李伟主讲，优点是包含了很多业内最新的主流技术的讲解。值得一看。</p><ul><li>课程名称：深度学习（第四期）</li><li>课程地址： <a href="http://www.chinahadoop.cn/classroom/45/courses" target="_blank" rel="noopener">http://www.chinahadoop.cn/classroom/45/courses</a></li></ul><h2 id="2-书"><a href="#2-书" class="headerlink" title="2. 书"></a>2. 书</h2><h3 id="《Deep-Learning-the-Book》"><a href="#《Deep-Learning-the-Book》" class="headerlink" title="《Deep Learning the Book》"></a>《Deep Learning the Book》</h3><p>这本书是前面提到的大牛Yoshua Begio的博士生Goodfellow写的。Goodfellow是生成式对抗网络的提出者，生成式对抗网络被Yann LeCun认为是近年最激动人心的深度学习技术想法。这本书比较系统，专业，偏重理论，兼顾实践。是系统学习深度学习不可多得的好教材。</p><ul><li>英文版见 <a href="http://deeplearningthebook.com" target="_blank" rel="noopener">http://deeplearningthebook.com</a></li><li>目前Github上已经有人翻译出了中文版<a href="https://github.com/exacity/deeplearningbook-chinese。" target="_blank" rel="noopener">https://github.com/exacity/deeplearningbook-chinese。</a></li></ul><h2 id="3-推荐路径"><a href="#3-推荐路径" class="headerlink" title="3.推荐路径"></a>3.推荐路径</h2><p>不同的人有不同的需求，有些人希望掌握好理论基础，然后进行实践，有些人希望能够快速上手，马上做点东西，有些人希望理论与实践兼顾。下面推荐几条学习路径，照顾到不同的需求。大家可以根据自己的特点进行选择。</p><h3 id="Hard-way"><a href="#Hard-way" class="headerlink" title="Hard way"></a>Hard way</h3><p><code>Yaser -&gt; Geoffrey Hinton -&gt; UdaCity -&gt; 小象学院 -&gt; Good Fellow</code><br>特点：理论扎实，步步为营。最完整的学习路径，也是最“难”的。<br>推荐指数 4星</p><h3 id="Good-way"><a href="#Good-way" class="headerlink" title="Good way"></a>Good way</h3><p><code>Yaser -&gt; UdaCity -&gt; 小象学院 -&gt; Good Fellow</code><br>特点：理论扎实，紧跟潮流，兼顾实战，最后系统梳理。比较平衡的学习路径。<br>推荐指数 5星</p><h3 id="“Fast”-way"><a href="#“Fast”-way" class="headerlink" title="“Fast” way"></a>“Fast” way</h3><p><code>UdaCity -&gt; Good Fellow</code><br>特点：快速上手，然后完善理论。<br>推荐指数 4星</p><h3 id="“码农”-way"><a href="#“码农”-way" class="headerlink" title="“码农” way"></a>“码农” way</h3><p><code>UdaCity</code><br>特点：快速上手，注重实践。<br>推荐指数 3星</p><p>以上路径按照从完整到精简的顺序排列。如果要我只推荐一条路径的话，那么就是2 <code>Good way（Yaser -&gt; UdaCity -&gt; 小象学院 -&gt; Good Fellow）</code>，完整同时又兼顾效率，理论与实践并进的学习路径。强烈推荐。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深度学习资料推荐&quot;&gt;&lt;a href=&quot;#深度学习资料推荐&quot; class=&quot;headerlink&quot; title=&quot;深度学习资料推荐&quot;&gt;&lt;/a&gt;深度学习资料推荐&lt;/h1&gt;&lt;p&gt;深度学习火起来之后，网上关于深度学习的资料很多。但是其质量参差不齐。我从2013年开始就关注
      
    
    </summary>
    
      <category term="resource" scheme="http://xichen.pub/categories/resource/"/>
    
      <category term="Deep Learning" scheme="http://xichen.pub/categories/resource/Deep-Learning/"/>
    
    
      <category term="Deep Learning" scheme="http://xichen.pub/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>关于git的各种chrome拓展</title>
    <link href="http://xichen.pub/2019/03/14/2019-03-14-git-extension/"/>
    <id>http://xichen.pub/2019/03/14/2019-03-14-git-extension/</id>
    <published>2019-03-14T05:11:00.000Z</published>
    <updated>2019-04-01T15:46:24.063Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://yifeng.studio/2017/09/06/recommended-extension-tools-about-github/" target="_blank" rel="noopener">http://yifeng.studio/2017/09/06/recommended-extension-tools-about-github/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://yifeng.studio/2017/09/06/recommended-extension-tools-about-github/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://yifeng.studio/2
      
    
    </summary>
    
      <category term="Git" scheme="http://xichen.pub/categories/Git/"/>
    
    
      <category term="Git" scheme="http://xichen.pub/tags/Git/"/>
    
      <category term="Chrome" scheme="http://xichen.pub/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>【Android TimeCat】 解决魅族无法彻底卸载 app 问题</title>
    <link href="http://xichen.pub/2018/10/29/2018-10-29-Android-TimeCat-%E8%A7%A3%E5%86%B3%E9%AD%85%E6%97%8FFlyme6%E6%97%A0%E6%B3%95%E5%BD%BB%E5%BA%95%E5%8D%B8%E8%BD%BDapp%E9%97%AE%E9%A2%98/"/>
    <id>http://xichen.pub/2018/10/29/2018-10-29-Android-TimeCat-解决魅族Flyme6无法彻底卸载app问题/</id>
    <published>2018-10-29T05:11:00.000Z</published>
    <updated>2019-04-01T15:18:44.242Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>卸载重装老是提示不能重复安装。<br>卸载了某些软件（例如通过开发者模式调试安装的应用）后，实际这个应用还残留在系统，当用低版本或者其他签名的apk覆盖安装的时候会提示“安装失败”，要求卸载后重新安装。但是就是不提示安装在哪里，反正已安装列表里已经不见了。无论从应用列表寻找还是清理垃圾，都根本找不到这个应用。<br>现在介绍的这个方法不需要ROOT，不需要任何第三方软件。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><h2 id="1-进入手机的“设置”-“安全”-（指纹和安全）"><a href="#1-进入手机的“设置”-“安全”-（指纹和安全）" class="headerlink" title="1.进入手机的“设置”-“安全” （指纹和安全）"></a>1.进入手机的“设置”-“安全” （指纹和安全）</h2><div class="image-package"><br><img src="/assets/blog/img/2018-10-29/0.webp" width="700"><br><br><br><div class="image-caption"><br>1<br></div><br></div><h2 id="2-选择进入访客默认"><a href="#2-选择进入访客默认" class="headerlink" title="2.选择进入访客默认"></a>2.选择进入访客默认</h2><div class="image-package"><br><img src="/assets/blog/img/2018-10-29/1.webp" width="700"><br><br><br><div class="image-caption"><br>2<br></div><br></div><h2 id="3-打开访客模式，记住密码"><a href="#3-打开访客模式，记住密码" class="headerlink" title="3. 打开访客模式，记住密码"></a>3. 打开访客模式，记住密码</h2><p>默认密码一般是1234。如果你的密码是1234，那访客模式的密码是4321。</p><div class="image-package"><br><img src="/assets/blog/img/2018-10-29/2.webp" width="700"><br><br><br><div class="image-caption"><br>3<br></div><br></div><h2 id="4-锁屏，用刚刚的“访客密码”进入系统，记住是访客密码，不是你平时的密码"><a href="#4-锁屏，用刚刚的“访客密码”进入系统，记住是访客密码，不是你平时的密码" class="headerlink" title="4.锁屏，用刚刚的“访客密码”进入系统，记住是访客密码，不是你平时的密码"></a>4.锁屏，用刚刚的“访客密码”进入系统，记住是访客密码，不是你平时的密码</h2><div class="image-package"><br><img src="/assets/blog/img/2018-10-29/3.webp" width="700"><br><br><br><div class="image-caption"><br>4<br></div><br></div><h2 id="5-你会在访客模式中看到你要卸载的app，这里我们简称“幽灵App”，只要把对应的幽灵App删除，然后进入正常的模式就可以安装新的app了。"><a href="#5-你会在访客模式中看到你要卸载的app，这里我们简称“幽灵App”，只要把对应的幽灵App删除，然后进入正常的模式就可以安装新的app了。" class="headerlink" title="5.你会在访客模式中看到你要卸载的app，这里我们简称“幽灵App”，只要把对应的幽灵App删除，然后进入正常的模式就可以安装新的app了。"></a>5.你会在访客模式中看到你要卸载的app，这里我们简称“幽灵App”，只要把对应的幽灵App删除，然后进入正常的模式就可以安装新的app了。</h2><p>访客模式的桌面是使用了开源项目 <a href="https://github.com/LawnchairLauncher/Lawnchair" target="_blank" rel="noopener">LawnchairLauncher/Lawnchair</a>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/7717fb3df4e8" target="_blank" rel="noopener">解决魅族Flyme6无法彻底卸载app问题</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;卸载重装老是提示不能重复安装。&lt;br&gt;卸载了某些软件（例如通过开发者模式调试安装的应用）后，实际这个应用还残留在系统，当用低版本或者其他签名
      
    
    </summary>
    
      <category term="Android" scheme="http://xichen.pub/categories/Android/"/>
    
    
      <category term="Android" scheme="http://xichen.pub/tags/Android/"/>
    
      <category term="Keyboard" scheme="http://xichen.pub/tags/Keyboard/"/>
    
  </entry>
  
  <entry>
    <title>tensorflow GPU版安装问题</title>
    <link href="http://xichen.pub/2018/10/29/2019-02-12-tensorflow%E5%92%8Ctensorflow-gpu%E5%88%87%E6%8D%A2%E5%AE%89%E8%A3%85/"/>
    <id>http://xichen.pub/2018/10/29/2019-02-12-tensorflow和tensorflow-gpu切换安装/</id>
    <published>2018-10-29T05:11:00.000Z</published>
    <updated>2019-04-01T15:52:08.059Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Step-0-Uninstall-protobuf"><a href="#Step-0-Uninstall-protobuf" class="headerlink" title="Step 0: Uninstall protobuf"></a>Step 0: Uninstall protobuf</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">pip uninstall protobuf</span></span><br></pre></td></tr></table></figure><h3 id="Step-1-Uninstall-tensorflow"><a href="#Step-1-Uninstall-tensorflow" class="headerlink" title="Step 1: Uninstall tensorflow"></a>Step 1: Uninstall tensorflow</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">uninstall</span> tensorflow</span><br><span class="line">pip <span class="keyword">uninstall</span> tensorflow-gpu</span><br></pre></td></tr></table></figure><h3 id="Step-2-Force-reinstall-Tensorflow-with-GPU-support"><a href="#Step-2-Force-reinstall-Tensorflow-with-GPU-support" class="headerlink" title="Step 2: Force reinstall Tensorflow with GPU support"></a>Step 2: Force reinstall Tensorflow with GPU support</h3><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">pip</span> <span class="comment">install</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">upgrade</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">force</span><span class="literal">-</span><span class="comment">reinstall</span> <span class="comment">tensorflow</span><span class="literal">-</span><span class="comment">gpu</span></span><br></pre></td></tr></table></figure><h3 id="Step-3-If-you-haven’t-already-set-CUDA-VISIBLE-DEVICES"><a href="#Step-3-If-you-haven’t-already-set-CUDA-VISIBLE-DEVICES" class="headerlink" title="Step 3: If you haven’t already, set CUDA_VISIBLE_DEVICES"></a>Step 3: If you haven’t already, set CUDA_VISIBLE_DEVICES</h3><p>So for me with 2 GPUs it would be<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">CUDA_VISIBLE_DEVICES</span>=0,1</span><br></pre></td></tr></table></figure></p><h1 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h1><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">C:</span><span class="regexp">/Users/</span>dlink<span class="regexp">/AppData/</span>Local<span class="regexp">/Programs/</span>Python<span class="regexp">/Python35/</span>python.exe -m pip install tensorflow-gpu -i <span class="string">https:</span><span class="comment">//pypi.douban.com/simple/</span></span><br></pre></td></tr></table></figure><h1 id="注"><a href="#注" class="headerlink" title="注"></a>注</h1><p>国内安装时可用<code>-i https://pypi.douban.com/simple/</code>豆瓣源加速</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Step-0-Uninstall-protobuf&quot;&gt;&lt;a href=&quot;#Step-0-Uninstall-protobuf&quot; class=&quot;headerlink&quot; title=&quot;Step 0: Uninstall protobuf&quot;&gt;&lt;/a&gt;Step 0: Un
      
    
    </summary>
    
      <category term="TensorFlow" scheme="http://xichen.pub/categories/TensorFlow/"/>
    
      <category term="Deep Learning" scheme="http://xichen.pub/categories/TensorFlow/Deep-Learning/"/>
    
    
      <category term="TensorFlow" scheme="http://xichen.pub/tags/TensorFlow/"/>
    
      <category term="bug" scheme="http://xichen.pub/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>【Android TimeCat】 解决 context.startforegroundservice() did not then call service.startforeground()</title>
    <link href="http://xichen.pub/2018/10/25/2018-10-25-Android-TimeCat-context.startforegroundservice()didnotthencallservice.startforeground()/"/>
    <id>http://xichen.pub/2018/10/25/2018-10-25-Android-TimeCat-context.startforegroundservice()didnotthencallservice.startforeground()/</id>
    <published>2018-10-25T04:11:00.000Z</published>
    <updated>2019-04-01T15:18:44.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>因为这个适配没做好，被用户干了。。。</p><p>Android 8.0 有一项复杂功能；系统不允许后台应用创建后台服务。 因此，Android 8.0 引入了一种全新的方法，即 Context.startForegroundService()，以在前台启动新服务。<br>在系统创建服务后，应用有5秒的时间来调用该服务的 startForeground() 方法以显示新服务的用户可见通知。如果应用在此时间限制内未调用 startForeground()，则系统将停止服务并声明此应用为 ANR。</p><p>但是目前在调用：context.startForegroundService(intent)时报如下ANR，startForegroundService()文档说明在service启动后要调用startForeground()。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">android</span><span class="selector-class">.app</span><span class="selector-class">.RemoteServiceException</span>: <span class="selector-tag">Context</span><span class="selector-class">.startForegroundService</span>() <span class="selector-tag">did</span> <span class="selector-tag">not</span> <span class="selector-tag">then</span> <span class="selector-tag">call</span> <span class="selector-tag">Service</span><span class="selector-class">.startForeground</span>()</span><br></pre></td></tr></table></figure></p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><h2 id="第一步：使用Context-startForegroundService-启动服务后，在service的onCreate方法中调用startForeground-。"><a href="#第一步：使用Context-startForegroundService-启动服务后，在service的onCreate方法中调用startForeground-。" class="headerlink" title="第一步：使用Context.startForegroundService()启动服务后，在service的onCreate方法中调用startForeground()。"></a>第一步：使用<code>Context.startForegroundService()</code>启动服务后，在<code>service</code>的<code>onCreate</code>方法中调用<code>startForeground()</code>。</h2><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NotificationChannel</span> channel = <span class="function"><span class="keyword">new</span> <span class="title">NotificationChannel</span>(<span class="type">CHANNEL_ID</span>,<span class="type">CHANNEL_NAME</span>,</span></span><br><span class="line"><span class="function">                <span class="type">NotificationManager</span>.<span class="type">IMPORTANCE_HIGH</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">NotificationManager</span> <span class="title">manager</span> = (<span class="type">NotificationManager</span>) <span class="title">getSystemService</span>(<span class="type">Context</span>.<span class="type">NOTIFICATION_SERVICE</span>);</span></span><br><span class="line"><span class="function"><span class="title">manager</span>.<span class="title">createNotificationChannel</span>(channel);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Notification</span> <span class="title">notification</span> = <span class="title">new</span> <span class="title">Notification</span>.<span class="title">Builder</span>(getApplicationContext(),<span class="title">CHANNEL_ID</span>).<span class="title">build</span>();</span></span><br><span class="line"><span class="function"><span class="title">startForeground</span>(<span class="number">1</span>, notification);</span></span><br></pre></td></tr></table></figure><h2 id="第二步：在onStart里再次调用startForeground"><a href="#第二步：在onStart里再次调用startForeground" class="headerlink" title="第二步：在onStart里再次调用startForeground()"></a>第二步：在<code>onStart</code>里再次调用<code>startForeground()</code></h2><h2 id="Why？"><a href="#Why？" class="headerlink" title="Why？"></a>Why？</h2><ol><li>Android 8.0 系统不允许后台应用创建后台服务，故只能使用<code>Context.startForegroundService()</code>启动服务</li><li>创建服务后，应用必须在5秒内调用该服务的 <code>startForeground()</code> 显示一条可见通知，声明有服务在挂着，不然系统会停止服务 + ANR 套餐送上。</li><li>Notification 要加 Channel，系统的要求</li><li>为什么要在<code>onStart</code>里再次调用<code>startForeground()</code>？答：这一条主要是针对后台保活的服务，如果在服务<code>A</code>运行期间，保活机制又<code>startForegroundService</code>启动了一次服务<code>A</code>，那么这样不会调用服务<code>A</code>的<code>onCreate</code>方法，只会调用<code>onStart</code>方法。如果不在<code>onStart</code>方法里再挂个通知的话，系统会认为你使用了 <code>startForegroundService</code> 却不在 5 秒内给通知，很傻地就停止服务 + ANR 套餐送上了。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/lylddingHFFW/article/details/78219327" target="_blank" rel="noopener">lyldding-HFFW 在Android O上启动Service遇到问题记录</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;因为这个适配没做好，被用户干了。。。&lt;/p&gt;
&lt;p&gt;Android 8.0 有一项复杂功能；系统不允许后台应用创建后台服务。 因此，Andr
      
    
    </summary>
    
      <category term="Android" scheme="http://xichen.pub/categories/Android/"/>
    
    
      <category term="Android" scheme="http://xichen.pub/tags/Android/"/>
    
      <category term="Keyboard" scheme="http://xichen.pub/tags/Keyboard/"/>
    
  </entry>
  
  <entry>
    <title>nodejs 中同步异步多种写法</title>
    <link href="http://xichen.pub/2018/09/04/2018-09-04-js-async-await/"/>
    <id>http://xichen.pub/2018/09/04/2018-09-04-js-async-await/</id>
    <published>2018-09-03T20:11:00.000Z</published>
    <updated>2019-04-01T15:18:44.240Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>nodejs 的同步异步写起来真爽，特别是结合 typescript，简直上天！感觉可以取代 go 的异步呢，哈哈。</p><h2 id="同步循环"><a href="#同步循环" class="headerlink" title="同步循环"></a>同步循环</h2><p>传统 for 循环：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> item = array[i]</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进阶 forEach：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="异步循环"><a href="#异步循环" class="headerlink" title="异步循环"></a>异步循环</h2><h3 id="全部异步，不关心结果"><a href="#全部异步，不关心结果" class="headerlink" title="全部异步，不关心结果"></a>全部异步，不关心结果</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doArray</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  array.forEach(<span class="keyword">async</span>(item) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> doItem(item)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'loop done! But each item is sitll doing'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="依次同步"><a href="#依次同步" class="headerlink" title="依次同步"></a>依次同步</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doArray</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> array) &#123;</span><br><span class="line">    <span class="keyword">await</span> doItem(item)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'every item done!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步执行，同步等结果"><a href="#异步执行，同步等结果" class="headerlink" title="异步执行，同步等结果"></a>异步执行，同步等结果</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doArray</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> promises = array.map(<span class="function"><span class="params">item</span> =&gt;</span> doItem(item))</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.all(promises)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'every item done!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;nodejs 的同步异步写起来真爽，特别是结合 typescript，简直上天！感觉可以取代 go 的异步呢，哈哈。&lt;/p&gt;
&lt;h2 id=
      
    
    </summary>
    
      <category term="区块链" scheme="http://xichen.pub/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="异步" scheme="http://xichen.pub/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="nodejs" scheme="http://xichen.pub/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】 QTUM 的有限供应量 - 减半</title>
    <link href="http://xichen.pub/2018/08/13/2018-08-13-%E7%BF%BB%E8%AF%91-QTUM%E7%9A%84%E6%9C%89%E9%99%90%E4%BE%9B%E5%BA%94%E9%87%8F-%E5%87%8F%E5%8D%8A/"/>
    <id>http://xichen.pub/2018/08/13/2018-08-13-翻译-QTUM的有限供应量-减半/</id>
    <published>2018-08-13T06:11:00.000Z</published>
    <updated>2019-04-01T15:18:44.238Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://medium.com/@jb395official/qtum-capped-supply-the-halving-b650b7fb955e" target="_blank" rel="noopener">https://medium.com/@jb395official/qtum-capped-supply-the-halving-b650b7fb955e</a><br>译者：中山大学数学学院（珠海）林学渊<br>大二时给量子做的翻译，转载注明出处，谢谢</p><h1 id="QTUM-的有限供应量-减半"><a href="#QTUM-的有限供应量-减半" class="headerlink" title="QTUM 的有限供应量 - 减半"></a>QTUM 的有限供应量 - 减半</h1><p>QTUM Capped Supply — The Halving</p><p>这是社区中常问的一个问题：QTUM 的供应量是否有限？有多少？</p><p>本报告回答了这个问题 - 是的，供应量是有限的 - 并给出了最大供应量。</p><p>TL;DR QTUM 的供应量上限为 107,822,406.25，约 31 年发完。</p><p>我是一名独立研究员，偶尔是博主，社交版主，并中意 Qtum 团队的技术指导和社区的高谈阔论。如果你对本文有任何意见或更正，请在社交媒体上联系我。</p><hr><h2 id="新资源管理器"><a href="#新资源管理器" class="headerlink" title="新资源管理器"></a>新资源管理器</h2><p>首先，让我安利一个新资源管理器：<a href="http://qtum.info" target="_blank" rel="noopener">qtum.info</a>.</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*Jjcubf7UuFyVtC2f2jMGKQ.jpeg" alt=""></p><p>这个功能强大的资源管理器有干净的布局，可以轻松导航到地址的第一个交易，还有一个覆盖 98,345 个地址（有些不那么富有）的“富豪榜(Rich List)”。</p><h2 id="网络权重"><a href="#网络权重" class="headerlink" title="网络权重"></a>网络权重</h2><p>在 2018 年 2 月 26 日至 3 月 4 日期间，已知余额为 600 万以上的大钱包共赢得 712 块奖励，总计 4,185，即 17.01％，网络权重为 3520 万，年回报率为 2.49％。</p><hr><h2 id="有限供应量"><a href="#有限供应量" class="headerlink" title="有限供应量"></a>有限供应量</h2><p>一对情侣相距 50 米对视。作为大学数学系的学生，他们决定相互靠近一半，一直到25米，然后再一半接近12.5米，然后又一半，再接近一半，等等。作为数学家，他们知道每次他们减少一半的距离，但永远不会真正接触到彼此，但作为现实主义者，他们知道他们会<em>为了所有实际目的而足够接近</em>。</p><p>在研究之前，我认为 QTUM 没有上限，但事实证明 QTUM 的上限类似于比特币的上限。很多人都知道比特币的最大数量是 21,000,000。那 QTUM 的最大数量是多少？</p><h2 id="减半"><a href="#减半" class="headerlink" title="减半"></a>减半</h2><p>要计算出 QTUM 的最大数量，我们需要考虑减半（取一半）。我使用比特币作为参考，因为到目前为止它已经减半，所以每个人都知道这个数字是 2100 万。许多人都知道比特币的块奖励每 4 年下降一半（“减半”）。比特币开始时有 50 个代币用于区块奖励，减半到 25，到目前区块奖励是 12.5 个代币。</p><p>Qtum 遵循类似的减半模式，由钱包中的代码设置减半时间：</p><p><img src="https://cdn-images-1.medium.com/max/1280/1*50l2ob3FhEsR5Pc973TpyQ.jpeg" alt=""></p><p>该代码表示​​减半间隔是 985,500 块，对当前块间距来说约为 4 年半。Qtum 的第一次减半将在块 990,501，大约在 2022 年 3 月 9 日，在 UTC 时间 07:48:48（在你的日历标记一下！）[2]。</p><p>我们在情侣中看到了“为了所有实际目的”的问题，在计算 Qtum 块奖励的源代码中也有一个硬限制（hard limit）。 在下面列出的参考文献[1]中计算比特币的上限（考虑一些不同的因素）。 要获得 QTUM 的最大数量，下表显示了块奖励如何连续减半以及未来 31 年总 QTUM 如何累积：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*IC-PtTp4JhDGBch9RsJO0g.jpeg" alt=""></p><p>这张表有一些解释。</p><p>创世块 <a href="http://qtum.info/block/1" target="_blank" rel="noopener">1</a>-5,000 创造了原始的 100,000,000 QTUM，每个块创造了 20,000 QTUM（像比特币那样的 coinbase 块奖励，而不是像 Qtum 那样的 coinstake 块奖励）。从块 5,001 开始，块奖励是 4.0 QTUM，并持续 985,500 块到块 990,500，这将增加 3,942,000 个新 QTUM。从块 990,501 开始，块奖励将减半至 2.0 QTUM，之后每隔 4 年块奖励将减半。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*0ZrZ5oRyysMGg1TrlUSr5g.jpeg" alt=""></p><hr><p>有关暗网的报道称，Satoshi 团队（Team Satoshi）的左侧臀部有 21,000,000 的数字纹身。我既不能证实也不否认 Qtum 团队的任何人也自豪地在他们的皮肤上 <a href="https://goo.gl/maps/PyjfAUDVq2Q2" target="_blank" rel="noopener">签上</a>数字 107,822,406.25 [4]。我希望现在每个人都能记住 107,822,406.25 这个数字，因为这是上限，永远不会有更多的 QTUM。</p><p>Jackson</p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] 比特币维基，<a href="https://en.bitcoin.it/wiki/Controlled_supply" target="_blank" rel="noopener">控制供应量</a></p><p>[2] 日期计算：Epoch 和 Unix 时间戳<a href="https://www.epochconverter.com/" target="_blank" rel="noopener">转换器</a> - 每块使用144秒。</p><p>[3] Qtum 的 validations.cpp 代码:</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*rFRg5IkHZkLTNBKWa9HY3w.jpeg" alt=""></p><p>解释</p><p>1375行：对于前 5,000 个区块（nLastPOWBlock），区块奖励为 20,000 QTUM。 这些是创世块。</p><p>1378行：halfvings =（当前块 - 5,001）/ 985,500 的整数（忽略小数部分）</p><p>1380行：如果减半大于或等于7，则将块奖励设置为0。从块 6,903,501 开始。</p><p>1382，1385 行：否则，块奖励为4.0 QTUM 除以 2 x 减半数。</p><p>[4] 这些句子是个玩笑，但 107,822,406.25 是真的！</p><p>[5] 如果你同样痴迷于创世块创造世界的故事，你可能会喜欢 <a href="http://qtum.info/block/0" target="_blank" rel="noopener">0 区块</a>，它早于 Mainnet 的发布，并且似乎拥有 50.0 QTUM 的未花费区块奖励。事实上，这个地址在最近的空投中收到了 BOT。 我没有将这 50 QTUM 包括在上面的上限计算中，但是你可以自己加进去算一遍。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;https://medium.com/@jb395official/qtum-capped-supply-the-halving-b650b7fb955e&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://medium.
      
    
    </summary>
    
      <category term="区块链" scheme="http://xichen.pub/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://xichen.pub/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Qtum" scheme="http://xichen.pub/tags/Qtum/"/>
    
      <category term="翻译" scheme="http://xichen.pub/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】 调试日志，虚拟机日志</title>
    <link href="http://xichen.pub/2018/08/13/2018-08-13-%E7%BF%BB%E8%AF%91-%E8%B0%83%E8%AF%95%E6%97%A5%E5%BF%97-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%97%A5%E5%BF%97/"/>
    <id>http://xichen.pub/2018/08/13/2018-08-13-翻译-调试日志-虚拟机日志/</id>
    <published>2018-08-12T20:11:00.000Z</published>
    <updated>2019-04-01T15:18:44.239Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://medium.com/@jb395official/the-debug-log-the-virtual-machine-log-march-13-2018-76ddbe568f2" target="_blank" rel="noopener">https://medium.com/@jb395official/the-debug-log-the-virtual-machine-log-march-13-2018-76ddbe568f2</a><br>译者：中山大学数学学院（珠海）林学渊<br>大二时给量子做的翻译，转载注明出处，谢谢</p><h1 id="调试日志，虚拟机日志，2018-年-3-月-13-日"><a href="#调试日志，虚拟机日志，2018-年-3-月-13-日" class="headerlink" title="调试日志，虚拟机日志，2018 年 3 月 13 日"></a>调试日志，虚拟机日志，2018 年 3 月 13 日</h1><p><img src="https://cdn-images-1.medium.com/max/2000/1*xcYyb6Iu9J6c-h1ZTVH9UQ.jpeg" alt=""></p><p>这个星期我们研究 debug.log。当你怀疑你的钱包有问题时（或者如果你只是对 Qtum 感到好奇的话），debug.log 就是你的好朋友。我们来看看如何找到调试日志（debug log），如何阅读它，以及如何从中发现问题。特别奖主题是虚拟机日志 vm.log。</p><p>我是一名独立研究员，偶尔是博主，社交版主，并中意 Qtum 团队的技术指导和社区的高谈阔论。如果你对本文有任何意见或更正，请在社交媒体上联系我。</p><hr><h2 id="网络权重，节点数"><a href="#网络权重，节点数" class="headerlink" title="网络权重，节点数"></a>网络权重，节点数</h2><p>从 3 月 4 日至 11 日，已知余额为 590.5 万的大钱包赢得了总 4,779 块奖励中的 709 块，或者说 14.84％，网络权重为 3980 万，年回报率为 2.20％。本计算用了大约 11 倍的数据点，并且用了比钱包计算网络权重更好的算法（IMHO），但这个数字是每周更新，而钱包计算的网络权重是每块更新。（编辑过）</p><hr><h2 id="调试日志文件"><a href="#调试日志文件" class="headerlink" title="调试日志文件"></a>调试日志文件</h2><blockquote><p>TL;DR debug.log 文件与 wallet.dat 文件位于同一 Qtum 目录中，是记录基本钱包操作和错误情况的文本日志。每行日志都带有 UTC 时间戳，并显示每个同步到钱包区块链的新区块，发送动作，接收动作和错误情况。Qtum 虚拟机日志记录了钱包添加到区块链的合约交易，是代币交易问题很好的参考文件。</p></blockquote><p>每次你更新钱包时，你只要重命名 debug.log 文件为当前日期，比如“debug-2018-03-13.log”，就能保留旧的调试日志，以供参考（或者不保留删掉）。重启新版本钱包就可以写入一个新的 debug.log 文件了。对于 qtumd，使用默认设置的话，debug.log 文件每周保存大约4 MB。</p><p>在与 wallet.dat 文件相同的目录下找 debug.log 文件。 debug.log 文件是纯文本文件，可以使用任何文本编辑器或 QT 钱包打开。</p><p>每条日志都以 UTC 时间戳开头（不是你当地的时间，不用担心夏令时转换）</p><p><img src="https://cdn-images-1.medium.com/max/1280/1*XhNa5oRvsK7zVEI5jQ4ePA.jpeg" alt=""></p><p>这行日志表示在 3 月 7 日 14:27:34 UTC，钱包处理了一个区块并接受了这个区块。</p><p><img src="https://cdn-images-1.medium.com/max/960/1*abPTNvRmGr6OUvKrEwEssQ.jpeg" alt=""></p><p>我一般在钱包运行时获取 debug.log 文件的副本。我不确定这在技术上是否正确，但也没有弄坏钱包。QT 钱包中点击帮助 - 调试窗口 - 信息，屏幕的右下角提供了一个按钮，用于打开 debug.log 文件。</p><h2 id="非常自然，非常健康"><a href="#非常自然，非常健康" class="headerlink" title="非常自然，非常健康"></a>非常自然，非常健康</h2><p>我们将从调试日志显示的正常钱包操作开始，包括钱包启动，正常同步以及发送和接收操作。</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>启动时，钱包在初始化节点和读取多个文件方面做了很多工作，也许最重要的是 wallet.dat 文件，它包含钱包私钥。初始化后，钱包开始与其他节点建立连接，加载区块，同步区块链。Qtum Core 钱包是一个全节点，需要完整的区块链副本。调试日志显示追赶块写入很快，每秒几个。钱包验证每个区块并将其写入本地的区块链副本。下面例子中，整个启动流程记录了 148 行。这里有摘录的一些要点，为了清晰起见缩短了一些行，黄色高亮是我标出的：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*uDH9_zohmqSH33LZHwd7fg.jpeg" alt=""></p><p>钱包初始化后，在 18:01:26 处它比当前区块链高度落后大约半天（350个区块），并开始从其他对等点快速下载它没有的区块。直到 18:09:27，区块同步更新完毕，继续正常同步新区块。</p><p>下面我会举一个钱包日志文件的例子，它无法连接到对等点来同步区块链，so sad。</p><h2 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h2><p>接受到交易后，日志会显示一个带有交易 ID 的 “AddToWallet” 交易：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*uabvv0iMVwHkjTM0Lg6_Ig.jpeg" alt=""></p><p>交易可以是支付区块奖励或其他接收交易。金额没有列出来，但可以使用交易 ID 在你喜欢的资源管理器中找到详细信息。</p><h2 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h2><p>发送日志稍微复杂一些。现在我发送 0.2 QTUM; 你可以看到金额和交易ID：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*84rRR0jDRu7OEiv9QZuJOQ.jpeg" alt=""></p><p>发送的简单解释是 Qtum（née bitcoin）未花费交易输出（UTXO）模型。钱包选择先前整个未花费交易，在本例子中，未花费交易是 1.00000000 QTUM （在日志中没显示，但你可以在资源管理器中查看详细信息）。钱包必须发送整个 1.00000000 交易，对应指令将 0.20000000 提供给新地址并将 0.79909600 返回到钱包控制的零钱地址。发送的  1.00000000，接收地址的 0.20000000 和零钱地址的 0.79909600 之间的差值是 0.00090400：</p><p><img src="https://cdn-images-1.medium.com/max/1280/1*jhiasALQmf2D1XLp11-LuQ.jpeg" alt=""></p><p>这个差值是块奖励获奖钱包保留作为发布交易的“小费”，称为交易费用。</p><h2 id="其他调试模式"><a href="#其他调试模式" class="headerlink" title="其他调试模式"></a>其他调试模式</h2><p>如果你想研究内存池如何管理未确认交易，你可以在启动钱包时使用“-mempool”来记录有关 mempool 的调试记录详细信息。其他调试选项包括：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*moSoRYu3G7FIzFBCAZwmyQ.jpeg" alt=""></p><p>探索这些选项能产生什么有趣日志行留作练习，“miner”选项就看起来特别好玩。</p><hr><h2 id="坏事发生在好钱包"><a href="#坏事发生在好钱包" class="headerlink" title="坏事发生在好钱包"></a>坏事发生在好钱包</h2><p>如果你的钱包有问题，那你可能需要从 debug.log 文件中的错误报告中获得排除故障的提示，因为<em>调试文件是你的好朋友</em>。</p><h3 id="1-网络连接断开"><a href="#1-网络连接断开" class="headerlink" title="1. 网络连接断开"></a>1. 网络连接断开</h3><p>Testnet 钱包将新区块同步到＃99,479，这时钱包突然断开以太网，因为有人 “意外” 失去互联网连接。从 20:46:46 开始强行关闭8个对等连接（听起来很痛苦）（为清晰起见，缩短了几行）：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*pLKhietmDJdxROIeMQfDXg.jpeg" alt=""></p><p>19分钟后，互联网连接在 21:03:09 恢复，但当前的区块是＃99,485（钱包落后6个区块），钱包开始迅速同步区块 99480,99481,99482,99483等。如果你看到 debug.log 文件中的这些“强制关闭”，你绝对应该与你的Internet服务提供商沟通。</p><h3 id="2-时钟设置不正确"><a href="#2-时钟设置不正确" class="headerlink" title="2. 时钟设置不正确"></a>2. 时钟设置不正确</h3><p><img src="https://cdn-images-1.medium.com/max/960/1*35zGj9pklLSWSIf5Cgcrzg.jpeg" alt=""></p><p>我一直强调人们在社交媒体上要把时钟设置正确，但现在我认为这对钱包来说更是个问题。钱包的参考时间是相当宽容的，钱包从它连接的所有对等点收集参考时间，并与当地时间交叉验证。Qtum 中的参考时间（继承自比特币）非常灵活，如果你在糟糕的时间启动它（Qtumd 不太确定），QT钱包会抱怨。 如果你的计算机时区和时钟设置正确，你可以执行“getinfo”命令，可以看到“timeoffset”接近零。</p><p>如果你正在运行 qtumd 服务器钱包 - 它可以与许多对等点连接，那肯定会发现一些有错误时间戳的区块，记录有 “block timestamp too far in the future”。 成功挖到新区块但是搞错参考时间的钱包运气不太好。 debug.log 会显示 10 到 20 个或更多由其他对等点中继的相同坏区块。下面是来自 4 个节点的相同坏区块（为清楚起见，缩短了几行日志）：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*2e5XbG-WJXDUVwMRgcxW3g.jpeg" alt=""></p><p>qtumd 记录了网络所有或好或坏的行为。你可以把你的钱包想象成在吵闹聊天室里的一个公平而无情的管理员（向 Tony Sydney 大喊大叫），它必须拒绝，删除和禁止用户提供不适当的消息。钱包必须禁掉节点，断开不活动的节点，并拒绝具有错误请求头的区块。你的钱包和其他钱包都是被称为 Qtum Mainnet Ignition 网络节点的“聊天室”中的 24/7（7天24小时） 管理员。</p><h3 id="3-钱包不同步区块"><a href="#3-钱包不同步区块" class="headerlink" title="3. 钱包不同步区块"></a>3. 钱包不同步区块</h3><p>老实说，很难通过防火墙阻止我的钱包连接到网络;钱包总是不停地穿过防火墙。 最后，我弄坏了钱包中的网络，因此它无法连接到其他对等点来获取本次启动的调试日志文件。钱包记录了 77 行，调试日志在“dnsseed thread exit”之后停止，没有同步区块。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*r-x-uCZVbPYX_tjhleMrbA.jpeg" alt=""></p><hr><h2 id="特别奖主题：虚拟机日志"><a href="#特别奖主题：虚拟机日志" class="headerlink" title="特别奖主题：虚拟机日志"></a>特别奖主题：虚拟机日志</h2><p>每个节点都将每个合约交易保存到区块链的本地副本上。当节点验证包含了合约交易的新区块时，它会将区块链索引到存储合约的区块，再处理这些合约交易。节点将这些合约交易的结果记录到虚拟机日志 vm.log 中。</p><p>你可以在 Qtum 文件夹中找到 vm.log 文件，以及 wallet.dat 和 debug.log。 vm.log 文件很简洁。 它列出了 UTC 交易时间和合约地址。如果发生错误，合约交易失败，它会将原因和时间、地址记录在一起。</p><h2 id="好交易"><a href="#好交易" class="headerlink" title="好交易"></a>好交易</h2><p>这里有一些很好的合约交易，vm.log 中记录的：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*8xU8iJK0LApxD5N7XF7GYw.jpeg" alt=""></p><p>如何阅读：日志行通常比资源管理器时间戳晚几秒钟，而资源管理器每 16 秒显示一次。在 24 小时制 UTC 时间 12:49:54 显示有 <a href="https://explorer.qtum.org/block/528fd5c961ab9eae7c91d78b3a51ecd2fdec0982721c6e78863ae2cc8b34b7e9" target="_blank" rel="noopener">112,818</a> 块，这时资源管理器时间戳为 UTC 时间 12:49:52。合约地址 57931faffdec114056a49adfcaa1caac159a1a25 是区块链里的 <a href="https://explorer.qtum.org/token/57931faffdec114056a49adfcaa1caac159a1a25" target="_blank" rel="noopener">SpaceCash（SpaceChain）智能合约</a>，因此我们知道钱包处理了 SPC 代币交易，我们可以查看区块 112,818，可以看到有人交易了 3,960 个 SPC 代币：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*alHQQjPR1BBT5kZLEVWweA.jpeg" alt=""></p><hr><p>你的博主坚信在资源管理器上浏览加密交易，较小的测试量是最好的开始。 如何才能进行代币交易？</p><p>假设你是最近空投的接收者。你已将 QRC20 代币添加到钱包，现在你已准备好发送代币交易。你从之前的博客中了解到，所有代币交易都是通过将交易发送到智能合约来实现的，你可以观察所有智能合约交易的执行，包括你的交易。</p><p>当你从钱包发送一些代币时，你可以查看<a href="https://explorer.qtum.org/token/6b8bf98ff497c064e8f0bde13e0c4f5ed5bf8ce7" target="_blank" rel="noopener">合约交易页面</a>并观察你测试的小交易。在确认交易进入智能合约后，无需更改钱包的其他内容，就可以放心发送剩余代币的交易。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*Td6nS76BGJbCoXEJ19spzQ.jpeg" alt=""></p><p>但是要是好的钱包发生了坏事 – 你的测试交易没有执行呢？</p><h2 id="不太好"><a href="#不太好" class="headerlink" title="不太好"></a>不太好</h2><p>以下是 vm.log 中记录的一些有问题的交易：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*Fd2RoS8HkIcgF56FJ7gteA.jpeg" alt=""></p><p>如何阅读：在 06:30:16 的第一笔交易中，智能合约在执行交易前耗尽了gas。 有人将 gas 设置得太低，所以他们失去了那部分 gas，但有机会重试。</p><p>在 10:05:39 的第二个例子中，合约报告有一个错误指令。我没有分析过这类错误，但是我认为如果你试图在 ICO 售罄后进行购买，它们可能会产生。</p><p>对于失败的合约调用，资源管理器将显示该交易为空白（没有代币名称，没有交易金额），但据我所知，vm.log 是找出合约交易失败原因的唯一方法。 如果你在代币交易方面遇到问题，那虚拟机日志也是你的好朋友。</p><hr><p>我们今天在罗马这个永恒的城市写完博客。《总统杀局》(Ides of March)是在两天后的 3 月 15 日放映，但我不想等到那个时候才发布这个博客。根据 Nodemap，意大利有 6 个Qtum节点，其中一个在罗马。Qtum 真的是世界级的（甚至至少有一颗低地球轨道卫星） - 为什么不庆祝一下罗马的历史，大都会文化和 Qtum 节点呢？</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*OBYeHUd4YNI3b9-kqRWrLA.jpeg" alt=""></p><p>这里希望你所有的交易都顺利进行，如果不的话，调试日志和虚拟机日志就是你的好朋友。</p><p>保重，保持在线安全。</p><p>Jackson</p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><p>研究调试日志时听的音乐：<a href="http://streema.com/radios/Easy_and_Italy" target="_blank" rel="noopener">Radio Easy＆Italy</a> - Rome </p></li><li><p><a href="https://youtu.be/B4GvcCWzZZg" target="_blank" rel="noopener">无人机在古罗马斗兽场</a>，Yuneec Q500无人机，4k观看.</p></li><li><p>通过以下主题查看我过去的报告</p></li></ol><p><a href="https://medium.com/@jb395official/qtum-capped-supply-the-halving-b650b7fb955e" target="_blank" rel="noopener">QTUM 的有限供应量</a> - 减半 - 2018年3月4日</p><p>如何减半，以及为什么永远不会超过 107,822,406.25 QTUM</p><p><a href="https://medium.com/@jb395official/qrc20-token-report-february-25-2018-ff397a1ac070" target="_blank" rel="noopener">QRC20 代币报告</a> - 2018年2月25日</p><p>QRC20 代币如何工作，最近的空投为例。 （阿姆斯特丹）</p><p><a href="https://medium.com/@jb395official/testnet-and-qtum-mainnet-performance-january-1-8-e7af03a5d430" target="_blank" rel="noopener">Testnet 和 Qtum Mainnet 性能 - 1月1日至8日</a></p><p>Qtum 测试网络（testnet）。 （巴西里约热内卢）</p><p>发布于2018年1月7日</p><p><a href="https://medium.com/@jb395official/qtum-mainnet-results-december-25-31-891680ee5a52" target="_blank" rel="noopener">Qtum Mainnet 成果 – 12月25日至31日</a></p><p>使用虚拟专用网络（VPN）进行 staking。（首尔）</p><p>发布于2017年12月31日</p><p><a href="https://medium.com/@jb395official/qtum-mainnet-results-december-18-24-8e43e51aca3b" target="_blank" rel="noopener">Qtum Mainnet 成果 – 12月18日至24日</a></p><p>交易费用。</p><p>发表于2017年12月24日</p><p><a href="https://medium.com/@jb395official/qtum-mainnet-results-dec-11-17-d5548947fa1f" target="_blank" rel="noopener">Qtum Mainnet 成果 – 12月11日-17日</a></p><p>Passphrases，一个密码短语猜测脚本。（日内瓦，瑞士）</p><p>发布于2017年12月17日</p><p><a href="https://medium.com/@jb395official/qtum-mainnet-results-dec-4-10-2d4bc438062d" target="_blank" rel="noopener">Qtum Mainnet 成果 – 12月4日至10日</a></p><p>内存池（mempool）和未确认交易处理。 （悉尼）</p><p>发布于2017年12月10日</p><p><a href="https://medium.com/@jb395official/qtum-mainnet-results-nov-27-dec-3-327c1e9bc59c" target="_blank" rel="noopener">Qtum Mainnet 成果 – 11月27日 - 12月3日</a></p><p>孤儿块（香港 - 大屿山）</p><p>发布于2017年12月3日</p><p><a href="https://medium.com/@jb395official/qtum-mainnet-results-november-20-26-ebde2cd0139" target="_blank" rel="noopener">Qtum Mainnet 成果 – 11 月 20 日至 26 日</a></p><p>QTUM.explorer.io 合约页面（柏林）</p><p>发布于2017年11月26日</p><p><a href="https://medium.com/@jb395official/qtum-mainnet-results-november-13-19-bfbf45d0c153" target="_blank" rel="noopener">Qtum Mainnet 成果 – 11月13日至19日</a></p><p>一个非常简单的 SHA-256 哈希算法示例（柏林 - 弗里德里希斯海因）</p><p>发布于2017年11月20日</p><p><a href="https://medium.com/@jb395official/qtum-mainnet-results-november-6-12-f59dd373ff3" target="_blank" rel="noopener">Qtum Mainnet 成果 – 11月6日至12日</a></p><p>分发钱包获得区块奖励 ，五大网络权重(Big Five Network Weight )（北京）</p><p>发布于2017年11月12日</p><p><a href="https://medium.com/@jb395official/qtum-mainnet-results-october-30-november-5-d58164b811db" target="_blank" rel="noopener">Qtum Mainnet 成果 – 10月30日 - 11月5日</a></p><p>SHA-256哈希算法，目标和难度（首尔）</p><p>发布于2017年11月5日</p><p><a href="https://medium.com/@jb395official/an-introduction-to-qtum-proof-of-stake-mining-a-racing-story-f11a3f48009f" target="_blank" rel="noopener">Qtum 权益证明挖矿 - 一个赛跑故事</a></p><p>关于 PoS 采矿的故事（柏林马拉松）</p><p>发布于2017年10月29日</p><p><a href="https://medium.com/@jb395official/qtum-mainnet-results-october-23-29-527cd4ab887a" target="_blank" rel="noopener">Qtum Mainnet 成果 – 10月23日至29日</a></p><p>基金会钱包的离开（柏林）</p><p>发布于2017年10月29日</p><p><a href="https://medium.com/@jb395official/qtum-mainnet-results-october-1-8-f413231c689a" target="_blank" rel="noopener">Qtum Mainnet 成果 – 10月1 - 8日</a></p><p>非正式的 staking 常见问题。</p><p>发布于2017年10月26日</p><p><a href="https://medium.com/@jb395official/qtum-mainnet-results-october-16-22-9202990b8e8d" target="_blank" rel="noopener">Qtum Mainnet 成果 – 10月16 - 22日</a></p><p>网络权重，奖励统计时间和节点图（2017年悉尼）</p><p>发布于2017年10月22日</p><p><a href="https://medium.com/@jb395official/simulating-proof-of-stake-mining-for-qtum-57401c08590a" target="_blank" rel="noopener">模拟 Qtum 的权益证明挖矿</a></p><p>为 PoS挖矿模拟选择正确的UTXO大小</p><p>发布于2017年10月21日</p><p><a href="https://medium.com/@jb395official/qtum-proof-of-stake-mining-439d2b82802d" target="_blank" rel="noopener">Qtum 权益证明挖矿</a></p><p>我的 1.0 版 PoS 挖矿模拟器</p><p>发布于2017年10月16日</p><p><a href="https://medium.com/@jb395official/qtum-mainnet-ignition-results-october-9-15-1efe30eb2658" target="_blank" rel="noopener">Qtum Mainnet 点火结果 – 10月9 - 15日</a></p><p>Mainnet 图表介绍（新加坡）</p><p>发布于2017年10月15日</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;https://medium.com/@jb395official/the-debug-log-the-virtual-machine-log-march-13-2018-76ddbe568f2&quot; target=&quot;_blank&quot; rel=&quot;noope
      
    
    </summary>
    
      <category term="区块链" scheme="http://xichen.pub/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://xichen.pub/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Qtum" scheme="http://xichen.pub/tags/Qtum/"/>
    
      <category term="翻译" scheme="http://xichen.pub/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】 测试网和 Qtum 主网性能</title>
    <link href="http://xichen.pub/2018/08/06/2018-08-06-%E7%BF%BB%E8%AF%91-%E6%B5%8B%E8%AF%95%E7%BD%91%E5%92%8CQtum%E4%B8%BB%E7%BD%91%E6%80%A7%E8%83%BD/"/>
    <id>http://xichen.pub/2018/08/06/2018-08-06-翻译-测试网和Qtum主网性能/</id>
    <published>2018-08-06T06:11:00.000Z</published>
    <updated>2019-04-01T15:18:44.236Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://medium.com/@jb395official/testnet-and-qtum-mainnet-performance-january-1-8-e7af03a5d430" target="_blank" rel="noopener">https://medium.com/@jb395official/testnet-and-qtum-mainnet-performance-january-1-8-e7af03a5d430</a><br>译者：中山大学数学学院（珠海）林学渊<br>大二时给量子做的翻译，转载注明出处，谢谢</p><h1 id="测试网和-Qtum-主网性能-1-月-1-日至-8-日"><a href="#测试网和-Qtum-主网性能-1-月-1-日至-8-日" class="headerlink" title="测试网和 Qtum 主网性能 1 月 1 日至 8 日"></a>测试网和 Qtum 主网性能 1 月 1 日至 8 日</h1><p><img src="https://cdn-images-1.medium.com/max/1600/1*NBzVZMM_MBTcQfbx0EKqig.jpeg" alt=""></p><p>以下是每周的 Qtum 主网性能的图表评估，包括常用的图和表，以及有关 Qtum 测试网（testnet）的教程。用已有的钱包你就能使用测试网来探索交易，区块奖励等等。测试网是很好的资源，不管是对新手还是对区块链开发者来说都是。那这个报告里，我们就玩一下测试网。</p><p>我是社区成员之一，也是独立研究者，还没加入量子团队，但非常欣赏他们的技术指导和社区中的高谈阔论。</p><hr><h2 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h2><p>Qtum Mainnet 性能评估的数据来自 <a href="https://explorer.qtum.org/" target="_blank" rel="noopener">Qtum Explorer</a>，区块链(从 qtumd 服务器应用程序登录)以及来自 <a href="https://goo.gl/maps/qrhNumMaiRQ2" target="_blank" rel="noopener">Ipanema Beach.</a> 的加密电报消息。</p><h3 id="独立奖励地址数"><a href="#独立奖励地址数" class="headerlink" title="独立奖励地址数"></a>独立奖励地址数</h3><p>这一周，每日独立奖励地址数最高于 1 月 5 日达 292 个。一整周里有 1,094 个独立地址，上一周是 964 个。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*Ga9v-FC6GxNSfUv60BsAAg.jpeg" alt=""></p><p>赢得多个区块的钱包数与上周基本持平。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*gqd_k6UM4MIQaH1cZIytkg.jpeg" alt=""></p><h3 id="每日活跃交易数"><a href="#每日活跃交易数" class="headerlink" title="每日活跃交易数"></a>每日活跃交易数</h3><p>1 月 5 日，每日交易数创下历史新高 17,043。这个高峰出现在周四，我们刚刚看到周五也有一个高峰。以太坊周四和周五的交易数最近都达到了峰值。比特币没有太明显的每周周期性，也没有智能合约。活跃交易为每个块提供的交易数高于保底交易数 2。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*VCF0YsLo1IN3XHzSfC_2yA.jpeg" alt=""></p><p>你还可以在 <a href="https://qtumexplorer.io/" target="_blank" rel="noopener">QTUM Explorer.io</a> 和 <a href="https://explorer.qtum.org/" target="_blank" rel="noopener">Qtum Explorer</a> 主页底部查看交易图表。</p><h3 id="块间​​距变化"><a href="#块间​​距变化" class="headerlink" title="块间​​距变化"></a>块间​​距变化</h3><p>从 1 月 1 日到 1 月 7 日，有 2 个区块有大于20 分钟的块间距，上个星期是 3 个。最大块间距是块 75,404，达 30 分 26 秒。平均块间距在 144 秒左右保持稳定。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*2eBQJ6QBvAb_J_xRioYZGg.jpeg" alt=""></p><h3 id="网络权重"><a href="#网络权重" class="headerlink" title="网络权重"></a>网络权重</h3><p>如下所示，每日“新网络权重”是基于计算每日获奖块的 10 天指数移动平均值和已知大钱包的余额：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*Qkq7MyiA5Wv--fWHjc6ATg.jpeg" alt=""></p><p>目前的网络权重为 2030 万，年回报率为4.3％。</p><hr><h2 id="测试网"><a href="#测试网" class="headerlink" title="测试网"></a>测试网</h2><p>健康的区块链生态系统不断发展和升级的，具有更多新的功能，随着主网（主生产网络，mainnet）的发展，它们一般并行运行一个或多个测试网。这些测试网是给开发者和其他有兴趣的人来探索、测试、开发的。有多个测试网可用于各种加密。Qtum 的公共测试网称为 “testnet”。</p><p><img src="https://cdn-images-1.medium.com/max/960/1*j3tmRvu8U_QNRgpuXarMyw.jpeg" alt=""></p><p>除非你正在测试新软件，否则你可以使用在 mainnet 上相同钱包应用程序（qtumd 服务器应用程序和 qtum-qt 桌面 GUI 钱包）连接到 testnet。 要在 testnet 上启动桌面 GUI 钱包 qtum-qt，只需打开开始菜单，点击它。</p><p>要启动服务器应用程序 qtumd 和命令行界面 qtumd-cli，请使用 “-testnet” 开关：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./qtumd –testnet</span><br><span class="line">./qtum-cli –testnet getstakinginfo</span><br></pre></td></tr></table></figure><p>Python 中可以这样写：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*xr2n3_tsXvdmW00nGPsotQ.jpeg" alt=""></p><h2 id="Testnet-问答"><a href="#Testnet-问答" class="headerlink" title="Testnet 问答"></a>Testnet 问答</h2><p>切换到问答模式。</p><p>问：testnet 与 mainnet 有什么不同？<br>答：Testnet 是一个独立的主网区块链。它有不同的块，不同的交易和不同的代币，但操作，协议和规格与主网相同（除非你正在测试新软件）。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*YvVgxUHRanWmn2x_F0lqQw.jpeg" alt=""></p><p>问：区块链在哪里？<br>答：在节点（钱包）的磁盘存储器中，在所有其他节点中具有相同的副本。</p><p>问：我的代币在哪里（测试网或主网）？<br>答：在钱包里，在区块里，以及在所有其他节点中这些相同区块的副本里。每个拥有区块链资源管理器或节点的人都可以看到你的代币，但只有你使用 wallet.dat 文件中的私钥才能发送或丢弃这些代币。即使你的计算机无法同步区块链，或者你的计算机爆炸，或者你删除了区块链文件，你的代币仍然在区块链里。你可以在将新钱包与 wallet.dat 文件的备份同步后检索。如果你丢失了 wallet.dat 文件（以及你对 wallet.dat 文件所做的所有备份），那么你的代币仍然会在区块链中永久可见，只是无法将它们发送出去。</p><p>问：testnet 和 mainnet 的钱包应用程序是否相同？<br>答：是的，testnet 和 mainnet 使用相同的钱包应用程序，可以在启动时切换到在 testnet 上运行。 注意 testnet 钱包 GUI 和徽标上有漂亮的紫色。 testnet 的另一个显着特征是地址，所有地址都以小写 “q” 开头，而主网地址则以大写 “Q” 开头。</p><p><img src="https://cdn-images-1.medium.com/max/1280/1*4yl3-n3lEz-UE0qIlUJsBw.jpeg" alt=""></p><p>问：区块链是否相同？<br>答：不。测试网和主网是两条不同的区块链。这在上面的图里可以看得出来。 Mainnet 比 testnet 早大约三周，因此主网块高度比 testnet 高大约 13400 个块。如果在同一台计算机上运行 mainnet 和 testnet，则钱包（节点）会将区块链同步到计算机的磁盘存储器中。 testnet 区块链将加载到文件夹 “testnet3” - 表示这是继承比特币代码的第 3 个 testnet 引用。 mainnet 区块链占用更多内存，因为它比 testnet 更高并且拥有更多的交易。 在2018年1月7日，主网区块链为 404 MB，而testnet区块链为 131 MB。</p><p>问：wallet.dat文件是否相同？<br>答：不，testnet 和 mainnet 分别有各自的 wallet.dat 文件。 testnet 的 wallet.dat 文件在 testnet3 文件夹里。</p><p>问：testnet 上的活动节点是否相同？<br>答：不，节点要么在主网上，要么在测试网上。目前处于活动状态的节点主网上大约有 2,000 个， 测试网上大约有 40 个。 在这些节点中，大约 30 个是大钱包，为测试网提供基线容量，它们的数量和大小与去年夏天的天网（Skynet）相似，当时主网还只是帕特里克眼中闪烁的光芒。天网是 mainnet 推出之前的公共测试网络。  Qtum 团队可能会运行这 30 个节点来为 testnet 提供基本的基础架构。</p><p>问：测试网和主网上的 QTUM 代币是否相同？我可以将一些免费的测试网代币转移到我的主网钱包吗？<br>答：不，它们是不同的代币。回到图上，在每个主网和测试网的创世块中铸造了100,000,000个代币：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*oMsTR8ocJizv0zc0tDjhwA.jpeg" alt=""></p><p>虽然代币的工作方式相同（它们是双胞胎，在出生时分开 - 相隔三周），但是不可能将测试网代币移到主网上。 在每个区块链中，你只能在创世区块的区块链上发送代币。<br>主网地址以大写“Q”开头，例如“Qa93nb …”，而测试网地址以小写“q”开头，例如“qto45H …”在钱包中输错 Q 或 q 地址将导致错误。</p><p>问：是否有针对测试网的区块链资源管理器？<br>答：是的，在<a href="https://testnet.qtum.org/" target="_blank" rel="noopener">testnet.qtum.org</a>。除了Nodemap之外，它还有所有可用的 testnet 信息。你可以看到人们正在测试的内容，例如块59,159，它有许多合约调用，包括一个 2.0 币交易费。 好事是测试网代币是免费的。</p><p>问：测试网有水龙头(Faucet)吗？<br>答：是的。水龙头是一个免费提供代币的网站。你可以将其视为按需空投。 testnet水龙头是 <a href="http://testnet-faucet.qtum.info/" target="_blank" rel="noopener">testnet-faucet.qtum.info</a>，你可以每24小时取一次测试代币。 输入你的测试网钱包地址就可以使用水龙头，在下一个区块中可以收到多达100个测试代币。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*IsncAR16SggSeysw__jT6A.jpeg" alt=""></p><p>另外，我想分享一些有关主网水龙头的消息：向智能合约地址发送 10 个 QTUM：QdonTFalLfoR$uchaNObvioUSscam， 然后你可以从这个水龙头中获得高达 5000 mQTUM。 仅限今晚午夜UTC。</p><p>问：我可以练习将测试代币发送到其他显示在水龙头上的地址吗？<br>答：当然，为什么不呢？ 我一直在天网（Skynet）上这样做，也许没有烦到其他人。</p><p>问：这是否意味着我可以了解更改地址，向许多人发送诈骗信息，在另一台计算机上备份和恢复加密钱包等等，而且使用测试网代币没有风险？我可以上 testnet 蹦跶，尝试一些新类型的交易，确保我完全理解它，然后在 mainnet 上运行相同的交易吗？<br>答：是的。</p><p>问：我可以在testnet上获得块奖励吗？<br>答：是的，这非常简单，因为网络权重如此之低，目前还不到400万。如果你每天从水龙头获得测试代币持续一周，你将有足够的资金每周赢得奖励。</p><p><img src="https://cdn-images-1.medium.com/max/960/1*pP-oIz-nSmIEJzxF5x_Htw.jpeg" alt=""></p><p>问：我可以在同一台计算机上运行 mainnet 和 testnet 的钱包吗？<br>答：是的。应用程序使用单独的区块链独立运行，所以这没有问题。它们可以同时运行，但我不推荐。</p><p>问：你能展示测试网性能的图表吗？<br>答：我以为你永远不会问。</p><hr><h2 id="图表-–-测试网络版"><a href="#图表-–-测试网络版" class="headerlink" title="图表 – 测试网络版"></a>图表 – 测试网络版</h2><p>测试网分析的数据源来自<a href="https://testnet.qtum.org/" target="_blank" rel="noopener">测试网块资源管理器</a>，测试网区块链(从testnet qtumd 登录)，以及来自Copacabana Beach的有关testnet的加密电报消息。</p><h3 id="独立奖励地址"><a href="#独立奖励地址" class="headerlink" title="独立奖励地址"></a>独立奖励地址</h3><p>测试网有 30 个核心钱包，并根据正在进行的测试动态地加入一些额外的节点。对于 12 月份的每日地址数，12 月 28 日达最高为 36，并且之前有很多天只有最低的 30 个独立地址：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*QLWqdqtrC8ILqnVr4jkhjg.jpeg" alt=""></p><h3 id="每日活跃交易数-1"><a href="#每日活跃交易数-1" class="headerlink" title="每日活跃交易数"></a>每日活跃交易数</h3><p>测试网上的交易很少。活跃交易是指每个块保底的两笔交易（coinbase和coinstake交易）之外的代币或合约的交易。例如，如果一天有 600 个块，就算没有人发送一个代币或合约交易，那么还是会有 1,200 个交易。活跃交易提供超过 1,200 保底的交易数。 这些交易适合使用水龙头，测试合约等的人。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*9VfnjjdmNC20wkT77q1gNg.jpeg" alt=""></p><p>你还可以在测试网块资源管理器主页的底部看到一个 14 天的交易图表。</p><h3 id="块间​​距变化-1"><a href="#块间​​距变化-1" class="headerlink" title="块间​​距变化"></a>块间​​距变化</h3><p>12 月平均块间距稳定在 145 秒左右：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*D_ibeistgR6gEXmXcVrFqg.jpeg" alt=""></p><p>对于 52,000 至 56,000（约一周）的区块，有 3 个区块间隔超过 20 分钟，区块 54,053 的块间距最大，为26分08秒。 这组测试网的块间距分布和主网差不多：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*pw3XLEuFEcb-WZPG4sOhig.jpeg" alt=""></p><h3 id="网络权重-1"><a href="#网络权重-1" class="headerlink" title="网络权重"></a>网络权重</h3><p>钱包网络权重的计算（随难度而变的平均值）显示测试网是随机变化的，类似于主网。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*FLVzg0mX_QLQfljVnhx8Ig.jpeg" alt=""></p><h3 id="年回报率"><a href="#年回报率" class="headerlink" title="年回报率"></a>年回报率</h3><p>网络权重为 394 万，测试网代币的年回报率为 22.2％。这是一些简单的 staking：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*q1EUeL4gqxk8PnB-3J4n-Q.jpeg" alt=""></p><hr><p>来吧！来测试网玩xue耍xi！它为你而生！</p><p><img src="https://cdn-images-1.medium.com/max/960/1*3B_vbb8AD2Pf9dlCNfNu6A.jpeg" alt=""></p><p>我们本周在里约写完报告。你可能想要去一个温暖，友好的地方，如巴西的里约热内卢（3 个节点的家），完败北半球的冬天。 海滩很漂亮，人们很友善（只是不要把你华丽的加密珠宝带到海滩）。在海滩上有一个新鲜的椰子，它们几乎和那些块奖励一样美味！</p><p>Obrigado，愿你的区块奖励像 <a href="https://goo.gl/maps/ixCp3L7xLTy" target="_blank" rel="noopener">Sugarloaf 山</a>（PãodeAçucar）的Copacabana海滩升起的太阳！</p><p>JB395</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*qHqzeqKkmojdrObKOMT4DA.jpeg" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><p><a href="https://medium.com/@bodhitoken/bodhi-prediction-market-alpha-is-live-on-qtum-testnet-da60dc31fe1f" target="_blank" rel="noopener">Bodhi Prediction Market Alpha</a> 现已上线 Qtum Testnet！ 在这里查看 Bodhi 的测试合约。</p></li><li><p><a href="https://live.blockcypher.com/btc-testnet/" target="_blank" rel="noopener">测试网块浏览器</a>，支持比特币和以太坊Ropsten。</p></li><li><p>如果你只关注此报告中的一个链接，那一定是<a href="http://www.ethviewer.live/" target="_blank" rel="noopener">以太坊区块链可视化</a>，来自澳大利亚堪培拉的联邦科学与工业资源组织（CISRO，Commonwealth Scientific and Industrial Resource Organization）。这是一个令人惊叹的网站，可以实时显示以太坊区块链。未确认交易在云（mempool）中浮动，然后随着区块链的增长弹入块中。对于交易，你可以查看单个发送，合约调用和合约创建（单击这些浮动图标可以转到区块链资源管理器）。 叔块（以太坊独有）显示为红色，你可以看到主链与绿色标题和绿色链接一起增长。你参加加密派对的话，可以在电视大屏幕上显示这个网站。</p></li></ol><p><img src="https://cdn-images-1.medium.com/max/1600/1*dAF7_KizBemD6UJ0mOL5tQ.jpeg" alt=""></p><p><img src="https://cdn-images-1.medium.com/max/960/1*48e1QKE1gXbpAorWcw_6ug.jpeg" alt=""></p><ol><li><p>推荐一段关于隐秘(cryptic)和加密(crypto)的关系的音乐，来自挪威/英国 EDM 制作人 Alan Walker，用在现场表演的视频<a href="https://youtu.be/Tfaq4UTH7P0?t=1m43s" target="_blank" rel="noopener">YouTube Space NY</a>里，由 Alan，Noah Cyrus 和 Juliander 创作（歌词不宜在办公室浏览，nsfw，Not Safe For Work），以及对持有者的一些话：“当它全部倒下时，那么随你。”</p></li><li><p>有关里约热内卢<a href="https://youtu.be/_1uEy-n4IsU" target="_blank" rel="noopener">伊帕内玛海滩</a>的悲伤歌曲，创作于智能合约和空投之前的一段时间。</p></li></ol><hr><h2 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h2><p>来自 <a href="https://medium.com/@mahmoudalkarim?source=post_header_lockup" target="_blank" rel="noopener">Mahmoud Al-Karim</a> 的问题，2018年7月23日：</p><p>问：需要为 qrc token 准备测试网 qt 钱包。</p><p>答：</p><p>这个博客“QTUM 102：建立自己的QRC20 token ”会有帮助吗？<a href="https://medium.com/@IAMEIdentity/qtum-102-build-your-own-qrc20-token-59547654b518" target="_blank" rel="noopener">https://medium.com/@IAMEIdentity/qtum-102-build-your-own-qrc20-token-59547654b518</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;https://medium.com/@jb395official/testnet-and-qtum-mainnet-performance-january-1-8-e7af03a5d430&quot; target=&quot;_blank&quot; rel=&quot;noopene
      
    
    </summary>
    
      <category term="区块链" scheme="http://xichen.pub/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://xichen.pub/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Qtum" scheme="http://xichen.pub/tags/Qtum/"/>
    
      <category term="翻译" scheme="http://xichen.pub/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】 Qtum Mainnet 成果</title>
    <link href="http://xichen.pub/2018/07/30/2018-07-30-%E7%BF%BB%E8%AF%91-QtumMainnet%E6%88%90%E6%9E%9C/"/>
    <id>http://xichen.pub/2018/07/30/2018-07-30-翻译-QtumMainnet成果/</id>
    <published>2018-07-30T06:11:00.000Z</published>
    <updated>2019-04-01T15:18:44.234Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://medium.com/@jb395official/newbie-wallets-april-1-2018-26ea7a06489c" target="_blank" rel="noopener">https://medium.com/@jb395official/newbie-wallets-april-1-2018-26ea7a06489c</a><br>译者：中山大学数学学院（珠海）林学渊<br>大二时给量子做的翻译，转载注明出处，谢谢</p><h1 id="Qtum-Mainnet-成果-12-月-25-日至-31-日"><a href="#Qtum-Mainnet-成果-12-月-25-日至-31-日" class="headerlink" title="Qtum Mainnet 成果 12 月 25 日至 31 日"></a>Qtum Mainnet 成果 12 月 25 日至 31 日</h1><p><img src="https://cdn-images-1.medium.com/max/2000/1*W8WwxhZCKQyshSbOSala2w.jpeg" alt=""></p><p>以下是每周的 Qtum Mainnet 性能的图表评估，包括常用的图和表，以及使用虚拟专用网络（VPN）和 Qtum staking rig 的教程。有一万个理由你应该使用 VPN 上网，甚至你应该使用 VPN 挖加密货币。这个星期我们就着眼于 VPN 以及 Qtum 节点如何（以及在​​何处）通过 VPN 连接吧。</p><p><img src="https://cdn-images-1.medium.com/max/960/1*hz1WsRESrjaRUX4fYmK0EA.jpeg" alt=""></p><p>我是社区成员之一，也是独立研究者，还没加入量子团队，但非常欣赏他们的技术指导和社区中的高谈阔论，以及这些酷酷的贴纸。</p><hr><h2 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h2><p>Qtum Mainnet 性能评估的数据源来自 <a href="https://explorer.qtum.org/" target="_blank" rel="noopener">Qtum Explorer</a>，区块链(从 qtumd 服务器应用程序登录)以及来自 <a href="https://kojects.com/2015/08/03/pangyo-techno-valley-visit/" target="_blank" rel="noopener">Pangyo</a> 的加密电报消息。</p><h3 id="独立奖励地址"><a href="#独立奖励地址" class="headerlink" title="独立奖励地址"></a>独立奖励地址</h3><p>这一周，每日独立地址数最高在 12 月 28 日达 294 个。整个星期里有 964 个独立地址，上周是 946 个，表示中小钱包正常参与。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*4x59pN_0p2aov4MTUpIJPQ.jpeg" alt=""></p><p>赢得多个区块的钱包数与上周基本持平。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*Epqt09iTodvvOgciSiJiUQ.jpeg" alt=""></p><h3 id="每日活跃交易数"><a href="#每日活跃交易数" class="headerlink" title="每日活跃交易数"></a>每日活跃交易数</h3><p>每日交易数从上周开始下滑，可能是因为放假。活跃交易为每个块提供的交易数高于保底交易数2。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*IsGgm3sTegVcqirPIxLfYg.jpeg" alt=""></p><p>你还可以在 <a href="https://qtumexplorer.io/" target="_blank" rel="noopener">QTUM Explorer.io</a> 和 <a href="https://explorer.qtum.org/" target="_blank" rel="noopener">Qtum Explorer</a> 主页底部查看交易图表。</p><h3 id="块间​​距变化"><a href="#块间​​距变化" class="headerlink" title="块间​​距变化"></a>块间​​距变化</h3><p>从 12 月 25 日到 12 月 31 日，有 3 个区块有大于20 分钟的块间距，上个星期是 6 个。最大块间距是块 71,003，达 24 分 34 秒。平均块间距在 144 秒左右保持稳定。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*ZP9yuGqgFdXUVByHF7NyoA.jpeg" alt=""></p><h3 id="新网络权重"><a href="#新网络权重" class="headerlink" title="新网络权重"></a>新网络权重</h3><p>如下所示，每日“新网络权重”是基于计算随每日获奖块的 10 天指数而变的平均值和已知大钱包的余额的：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*Pf4mIN4oZxQgD3lDlDH4iA.jpeg" alt=""></p><p>如年度回报率表所示，网络权重为 1,990 万，年回报率为 4.4％：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*h3m0WfiO939826ltmotV7A.jpeg" alt=""></p><hr><h3 id="更多关于交易费用的信息"><a href="#更多关于交易费用的信息" class="headerlink" title="更多关于交易费用的信息"></a>更多关于交易费用的信息</h3><p>这是上周关于交易费用报告的后续。我做了一些额外分析，发现了从硬件钱包发送的低费用交易 - 其中有47个。 现在这些交易都在区块链上，所以有一个快乐的结局。 <a href="https://medium.com/@jb395official/qtum-mainnet-results-december-18-24-8e43e51aca3b" target="_blank" rel="noopener">上周的报告</a>已经用这个信息更新了。</p><h2 id="VPN-你能看见我嘛？"><a href="#VPN-你能看见我嘛？" class="headerlink" title="VPN - 你能看见我嘛？"></a>VPN - 你能看见我嘛？</h2><p>这周的教程我们研究虚拟专用网络（VPN），以及它们如何与 Qtum staking 钱包一起使用。</p><p><img src="https://cdn-images-1.medium.com/max/960/1*kABDmEvHuU7qtlhXteDPhw.jpeg" alt=""></p><p>你可能需要考虑使用 VPN 的安全和隐私功能进行加密货币挖矿活动。有 VPN 的话你的网络对以下是不可见的 1) 你的Internet服务提供商（ISP）2）<a href="https://torrentfreak.com/vpn-server-seized-to-investigate-russian-ambassadors-assassination-1171219/" target="_blank" rel="noopener">老大哥(big brother)</a> 3）黑客（但是你可能获得恶意软件）。VPN提供商提供在你的计算机上运行的应用程序，以便与其远程服务器建立加密连接，从而将你的流量解密并上传到网络上。</p><blockquote><p>译者注：2）老大哥的梗是 Big Brother is Watching You（老大哥在看着你），是出自英国著名政治小说《一九八四》的金句。</p></blockquote><p>你的 ISP 无法解析 VPN 加密流量来看你正在浏览的网站（等等，我的 ISP 怎么知道我正在搜索<a href="https://youtu.be/-M0PJ_mTtRU" target="_blank" rel="noopener">可食用的内衣</a>？），你的 IP 地址也被隐藏，通过你的VPN服务转换为提供的远程服务器的 IP 地址。你还可以使用 VPN 绕过地理限制。</p><p>可能加密矿工也担心因为带宽使用情况的签名，将他们识别为持有比特币（Qtum）的矿工，这可能使他们成为黑客的目标。此外，有些应用程序可以监视节点对等 IP 地址并与区块链交易（发送）相关联，确定哪些 IP 地址赢得了块奖励。如果你通过 VPN 连接到网络，则不必担心任何这类问题，因为你的节点 IP 地址来自 VPN 服务器，而不是你的真实网络连接地址。</p><p>你能玩些使用 VPN 通过国际服务器连接到你的 staking 设备的游戏。比如，定位在Qtum Nodemap上未显示的国家/地区，突然有个节点出现在 Casablanca 等等。开启 VPN 后，你的节点应该在大约一周内从 Nodemap 删除。</p><p>我不会详细介绍如何选择VPN，但是在隐私和安全方面，有些服务比其他服务更好（在<a href="https://www.pcmag.com/article2/0,2817,2403388,00.asp" target="_blank" rel="noopener">这里</a>或<a href="https://www.cnet.com/best-vpn-services-directory/" target="_blank" rel="noopener">这里</a>阅读）。</p><p><img src="https://cdn-images-1.medium.com/max/960/1*IStUSWYZxsg5JBvwR942fw.jpeg" alt=""></p><p>如果你确实安装了一个VPN，那你应该选择附近的服务器以减少与 Internet 连接的延迟。不要连接到首尔的服务器（除非你的是 ROC 中的 600 多个节点之一）。我不得不微调 VPN 设置来让它稳定一点：为特定城市选择“最佳服务器”，并设置为“自动重新连接”。 此外，我建议你在激活 VPN 之前有一个稳定的 staking 设置，因为故障排除更难，比如，通过 VPN <a href="http://canyouseeme.org/" target="_blank" rel="noopener">CanYouSeeMe.org</a> 无法检查端口 3888 是否打开。</p><p>我注意到的另一件事是打开 VPN 后，IPv6 连接都断了。你可能会担心甚至开着 VPN ，你的 IP 地址还是泄漏了。如果你返回到你的 ISP DNS（域名服务器）查找IP地址的话，则会发生这种情况，因此好的 VPN 应该提供自己的 DNS。另一个问题似乎是 IPv6 地址并不总是通过 VPN 路由，因此 VPN 可以将其切断。</p><p>监控节点也可以连接到其他许多个节点（你在 Qtum 网络里可以轻易做到这个 - 我在看着你，Nodemap），以及寻找第一个中继新块的节点并记录该节点的 IP 地址。<a href="https://blockchain.info/blocks" target="_blank" rel="noopener">Blockchain.info</a> 做的事类似，通过“Relayed By”信息，它们能够识别大型比特币挖矿池。下面的“addrlocal”字段显示节点的 IP 地址，即显示启用 VPN 的对等点的 VPN 出口服务器地址。注意，这些块不携带任何IP地址，但可以监视网络上的节点，将节点 IP 地址与 Qtum 钱包地址相关联。</p><h3 id="Ping-时间"><a href="#Ping-时间" class="headerlink" title="Ping 时间"></a>Ping 时间</h3><p>你知道，Qtum 权益证明（PoS）挖矿以 16 秒的增量慢慢运行，所以启用 VPN 的几毫秒延迟应该问题不大。我想通过查看 ping 时间来验证这一点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">qtum-cli getpeerinfo</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        "id": 1,</span><br><span class="line">        "addr": "42.33.140.123:3888",</span><br><span class="line">        "addrlocal": "135.23.65.157:23569",</span><br><span class="line">        "services": "000000000000000d",</span><br><span class="line">        "relaytxes": true,</span><br><span class="line">        "lastsend": 1563586912,</span><br><span class="line">        "lastrecv": 1563586910,</span><br><span class="line">        "bytessent": 204216,</span><br><span class="line">        "bytesrecv": 138312,</span><br><span class="line">        "conntime": 1563583815,</span><br><span class="line">        "timeoffset": 0,</span><br><span class="line">        "pingtime": 0.0781,</span><br><span class="line">        "minping": 0.068727,</span><br><span class="line">        "version": 70016,</span><br><span class="line">        "subver": "/Satoshi:0.14.8/",</span><br><span class="line">        "inbound": false,</span><br><span class="line">        "addnode": false,</span><br><span class="line">        "startingheight": 8607,</span><br><span class="line">        "banscore": 0,</span><br><span class="line">        "synced_headers": 75092,</span><br><span class="line">        "synced_blocks": 75092,</span><br><span class="line">        "inflight": [</span><br><span class="line">        ],</span><br></pre></td></tr></table></figure><p>Ping 表示 Packet Internet Groper，它表示你的计算机可以与 Internet 上另一个节点通信的速度，例如，上面的对等点信息显示的 ping 时间是 78.1 毫秒。 我在网上看到的其他 Qtum 节点上最快的 ping 大约是 15 毫秒，如果节点位于世界的另一端，ping可以延长到几百毫秒。你知道接下来我会写什么：我爬了一堆数据，在Excel中处理它，并可视化出一些图表。</p><p>我从使用 getpeerinfo 的对等连接列表开始，并在激活 VPN 之前获得了 ping 时间。对于这个节点，有 123 个连接，平均 ping 时间为 170 毫秒：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*l2L2jeAF7BPeUKvZuPm3gQ.jpeg" alt=""></p><p>启用 VPN（但不重新启动节点），连接计数降了一两个小时，然后平均 ping 时间为187毫秒。在 VPN 启用后，大约一半的对等点连接成功转移。但所有 IPv6 对等点连接都断了。</p><p>为了研究 ping 时间和网络的影响，我选择了韩国首尔的 VPN 出口服务器，根据Nodemap，这个服务器托管着 270 个节点。难道用 VPN 可以更快 ping 到首尔的所有节点么？有 123 个连接，平均 ping 时间为 204 毫秒（在下图中，最长两个 755 和 797 毫秒的 ping 被切断）：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*YBYJlAwNkNos-vNCepR4sA.jpeg" alt=""></p><p>再来看看对等点在首尔 VPN 的出口位置。节点应该参与区域网络图的形成。记住，节点是通过在它们之间中继未经确认的交易和新块来工作。</p><p>首先，这是今天早些时候 Nodemap 中前 10 个国家的分布：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*ZF_hafRnF0Q70Fuvx0U4Sg.jpeg" alt=""></p><p>韩国和美国领先。这两者谁第一几乎每天都在变化，现在中国（ROC，应该是Republic of China 中华民国）已经落后了。对于在首尔使用 VPN 服务器的节点，分布不会发生太大变化：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*_RN4G5AQE5bCMIy_21xByw.jpeg" alt=""></p><p>“其他”组里，这些国家都有一个节点：印度，印度尼西亚，伊朗，日本，马耳他，荷兰，挪威，波兰，俄罗斯，新加坡和瑞典。在你的家庭办公室或云托管服务提供商中运行节点，可以在全球范围内与全球各地的 Qtum 节点进行全球通信。</p><p>下一周：你是这个邻域的新手，技术上很好奇，那么你在量子链上应该怎样玩耍？一步步安装钱包，练习备份和恢复钱包，甚至免费获得测试代币？下周：所有关于<a href="https://testnet.qtum.org/" target="_blank" rel="noopener">测试网</a>的那些事。<br><img src="https://cdn-images-1.medium.com/max/960/1*AOwG3MFc5Cx0M-zEvN_OaA.jpeg" alt=""></p><p>我们在首尔与我们的 VPN 服务器一起写完报告，并祝大家健康快乐，享受有区块奖励的新年。干杯，2018 年！</p><p>새해 복 많이받으세요（新年快乐）</p><p>JB395</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*iX-Wrcjua3QlFp149HBoqQ.jpeg" alt=""></p><hr><p>参考：</p><p>“窃听”攻击可以曝光多达 60％ 的比特币用户，<a href="https://www.coindesk.com/eavesdropping-attack-can-unmask-60-bitcoin-clients/" target="_blank" rel="noopener">Coindesk</a>，2014年6月</p><p>如何查看比特币交易的IP地址？ <a href="https://bitcoin.stackexchange.com/questions/193/how-do-i-see-the-ip-address-of-a-bitcoin-transaction?" target="_blank" rel="noopener">StackExchange</a>，2012</p><p>韩国无人机4K - 早晨平静的土地（釜山，巨济，首尔），<a href="https://youtu.be/9Vo68cjwOgA" target="_blank" rel="noopener">YouTube</a>，2017年11月<br><img src="https://cdn-images-1.medium.com/max/1280/1*Cy0XVKeezr-d7_SIzx1ABw.jpeg" alt=""></p><p>请参阅我之前放在 <a href="https://medium.com/@jb395official/latest" target="_blank" rel="noopener">Medium</a> 上的报告。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;https://medium.com/@jb395official/newbie-wallets-april-1-2018-26ea7a06489c&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://medium.com
      
    
    </summary>
    
      <category term="区块链" scheme="http://xichen.pub/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://xichen.pub/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Qtum" scheme="http://xichen.pub/tags/Qtum/"/>
    
      <category term="翻译" scheme="http://xichen.pub/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】 QRC20 token 报告</title>
    <link href="http://xichen.pub/2018/07/24/2018-07-24-%E7%BF%BB%E8%AF%91-QRC20token%E6%8A%A5%E5%91%8A/"/>
    <id>http://xichen.pub/2018/07/24/2018-07-24-翻译-QRC20token报告/</id>
    <published>2018-07-24T06:11:00.000Z</published>
    <updated>2019-04-01T15:18:44.233Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://medium.com/@jb395official/qrc20-token-report-february-25-2018-ff397a1ac070" target="_blank" rel="noopener">https://medium.com/@jb395official/qrc20-token-report-february-25-2018-ff397a1ac070</a><br>译者：中山大学数学学院（珠海）林学渊<br>大二时给量子做的翻译，转载注明出处，谢谢</p><h1 id="QRC20-token-报告-2018年2月25日"><a href="#QRC20-token-报告-2018年2月25日" class="headerlink" title="QRC20  token 报告 - 2018年2月25日"></a>QRC20  token 报告 - 2018年2月25日</h1><p><img src="https://cdn-images-1.medium.com/max/1600/1*JGGMMQFeumk3QOj8412xgQ.jpeg" alt=""></p><p>为了表达我对社区的感谢，这里有一个关于 Qtum QRC20  token 的教程：它们是什么，它们在哪里，如何与它们交互，如何查看它们以及如何创建和销毁它们，用最近的 token 空投为 Qtum 持有者解释 token 生命周期中的这些细节。</p><p>我是一名独立研究员，偶尔写博客和主持社交媒体，十分中意Qtum的技术指导以及社区讨论。如果你对本文有想法或批评，请在社交软件上发给我或在下面评论。</p><hr><h2 id="主网性能"><a href="#主网性能" class="headerlink" title="主网性能"></a>主网性能</h2><p>首先，简要回顾最近的 Qtum 主网性能。</p><h3 id="独立奖励地址"><a href="#独立奖励地址" class="headerlink" title="独立奖励地址"></a>独立奖励地址</h3><p>过去 7 天里，每日独立地址数最高于2月25日达 306 个，平均值是 291 个每天。这意味着每天 600 个区块的区块奖励中，几乎一半是小钱包赢得的。一周的独立地址数是 1,107。这些数字表示，与 10 天前相比，独立奖励地址数有略微增加，也暗示部署的小钱包更多了，这在我的<a href="https://medium.com/@jb395official/happy-new-year-qtum-mainnet-performance-february-9-15-a696e8e8396e" target="_blank" rel="noopener">新年报告</a>中有提到。</p><h3 id="节点数"><a href="#节点数" class="headerlink" title="节点数"></a>节点数</h3><p><img src="https://cdn-images-1.medium.com/max/960/1*TmK1vTY41-kiWn6hcU_sIQ.jpeg" alt=""></p><p><a href="https://qtum.org/en/nodemap" target="_blank" rel="noopener">节点地图(Nodemap)</a>显示，节点数在3,250左右，其中大约1,260个在中国。我想如果节点地图能跟上即将到来的节点数的数量级增加，其他区块链节点地图也能处理很多节点就好了，那么让我们祝愿节点地图更加健壮，足以应对这些增加的工作量吧！</p><h3 id="交易费用"><a href="#交易费用" class="headerlink" title="交易费用"></a>交易费用</h3><p>去年，交易费用只占每天区块奖励的百分之几。两个星期前，交易费用大约占区块奖励的一半。刚过去的一个星期里，<a href="https://explorer.qtum.org/stats" target="_blank" rel="noopener">资源管理器</a>显示有几个时间段是交易费用比区块奖励还多(每个时间段是24小时制)。如果资源管理器计算正确，这意味着网络内交易数有很大的增幅，尤其是智能合约调用( token 和DAPP)，这一般会带有 0.1 QTUM 费用。随着空投的部署，交易费用出现了一些大高峰。</p><h3 id="块间距"><a href="#块间距" class="headerlink" title="块间距"></a>块间距</h3><p>块间距稳定在 600 块每天附近。在2月11到2月24两个星期内，有14个区块，间隔超过20分钟，最长间隔是到区块 98,210 的 31 分 20 秒。</p><h3 id="网络权重"><a href="#网络权重" class="headerlink" title="网络权重"></a>网络权重</h3><p>我计算网络权重的方法依赖于具有已知余额的大钱包所获得的块奖励百分比。这种方法提供了比钱包计算估计的网络权重更稳定和准确的数字。在上周，这些总余额为 664 万的大型钱包获得了 26.4％ 的块奖励，网络权重为 2520 万。网络权重为2520万表示年度回报率为3.5％。</p><hr><h2 id="token-时间"><a href="#token-时间" class="headerlink" title="token 时间"></a>token 时间</h2><p>如果你只想要理解 QRC20  token ，下面是太长不看版：</p><p>QTUM QRC20  token 是标准化的数字资产，它们在 Qtum 智能合约中创建并活在这个智能合约中，永不离开合约。通过与合约交易可以将 token 分配给不同的所有者，合约存储 Qtum 地址列表和每个地址拥有的 token 。任何人都可以创建智能合约并创建 token ，而所有 token 的智能合约都存在于Qtum区块链中。 token 代表了区块链 2.0 平台的重要功能，性能和经济价值。</p><p>为了更深入地了解 token ，我们在发现之旅中的陪同者将是爱丽丝，一位 150 岁的文学角色，对加密货币有着天生的好奇心：</p><p>这时，爱丽丝跳了起来，她突然想到：从来没有见过穿着有口袋背心的兔子，更没有见到过兔子还能从口袋里拿出—块表来，她好奇地穿过田野，紧紧地追赶那只兔子，刚好看见兔子跳进了矮树下面的一个大洞。爱丽丝也紧跟着跳了进去，根本没考虑怎么再出来。爱丽丝梦游仙境，刘易斯卡罗尔，1865年。</p><p><img src="https://cdn-images-1.medium.com/max/960/1*WV0uHmsnntYONJqpu9uwRw.jpeg" alt="1923年之前在美国出版"></p><p>爱丽丝想向 <a href="https://en.wikipedia.org/wiki/Alice_and_Bob" target="_blank" rel="noopener">鲍勃</a> 发送10个 Wonderland（WON） token 。 但是，当爱丽丝试图用她的钱包中进行交易时，事情变得越来越怪。爱丽丝决定学习关于 QRC20  token 的所有内容，并跟随一只名叫 Satoshi 的白兔，她最终从兔子洞落到一个充满了 token 和智能合约的另一个宇宙中。</p><p><img src="https://cdn-images-1.medium.com/max/960/1*kAq8FdtMgY11yJVJTFMNAQ.jpeg" alt=""></p><p>如果你想加入爱丽丝并掉入兔子洞以了解关于 Qtum QRC20  token 的所有信息，请继续阅读，包括爱丽丝在吃完蘑菇后发现的两个秘密。</p><p><img src="https://cdn-images-1.medium.com/max/960/1*QJCUoHDb6wZ1JAQWhZZ1XA.jpeg" alt="一些命运多舛的物理 token "></p><p>让我们从一些基本的解释开始。 QRC20 token 是可编程数字资产，创建于 Qtum 区块链的智能合约。 Qtum 区块链及其 EVM（以太坊虚拟机，Ethereum Virtual Machine）提供可执行代码和存储数据的智能合约。 使用Qtum Core 钱包，Qtum 手机钱包和 Qtum Web 钱包可以轻松创建带有 token 的基础智能合约。目前，更复杂的智能合约可以用编程语言 solidity 编写并发布在区块链上。</p><p>Qtum 继承了当前的虚拟机，用于执行来自以太坊有 token 的智能合约。 在以太坊中，基础 token 被称为 <a href="https://theethereum.wiki/w/index.php/ERC20_Token_Standard" target="_blank" rel="noopener">ERC20</a>，以Ethereum Request for Comments 20命名。这是添加 token 功能的协议，于 2015 年发布。 Qtum  token 命名为 QRC20，因为它遵循与 ERC20  token 相同的协议和标准。</p><p>爱丽丝知道可视化区块链模型 - 智能合约 -  token 架构是可行的（并且在进行交易时更安全），这也有助于解释 token 和空投如何运作。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*wd_2Plln8SKI-P3XBZi71Q.jpeg" alt=""></p><p>智能合约在合约创建交易中发布到网络，该交易包含在特定区块中，在这个区块里智能合约将永久存在。上图显示了一个智能合约（测试网区块 34,546 中的 Bodhi 合约）管理 QRC20  token ，合约将有存储空间来跟踪余额信息并提供六个功能来创建 token ，在地址之间转移 token ，查看余额等等。</p><h3 id="合约创建"><a href="#合约创建" class="headerlink" title="合约创建"></a>合约创建</h3><p>当合约创建交易发布到区块链时，智能合约在 Qtum 区块链上开始生效。 要看一下这样的合约创建交易，我们可以查看测试网上的 <a href="https://testnet.qtum.org/address/f6177bc9812eeb531907621af6641a41133dea9e" target="_blank" rel="noopener">Bodhi合约</a>（我在主网上找不到 Bodhi 合约）。</p><p>开发人员使用测试网来评估和测试他们的软件，这正是Bodhi对这个智能合约做的。</p><p><img src="https://cdn-images-1.medium.com/max/960/1*bJ-89iOHGgtktwQlGJ2QQQ.jpeg" alt=""></p><p>Bodhi 测试智能合约开始生命周期于测试网块 35,456，2017年11月20.合约创建了 335,000 测试用的 BOT  token ，Bodhi 开发者能运行测试，确保代码准备好发布到主网了。</p><h3 id="交易所和钱包"><a href="#交易所和钱包" class="headerlink" title="交易所和钱包"></a>交易所和钱包</h3><p>下面，我们来看一个交易所和钱包的简化模型，这有利于了解空投如何运作。</p><p>注意，在下图中，为了清楚起见， Q 地址是有序的。实际上，块编号是有序的，但 Q地址是随机的。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*kqQq7jeQwAyhva8BwaQleg.jpeg" alt=""></p><p>如图所示，交易所客户可以自己买卖，不需要区块链交易。 交易所使用一个热钱包和一个冷钱包（可能是每个的倍数）保存余额。 对于这个例子，交易所具有6,000,000个币的余额，这些币作为交易存储在区块链中，但从不存储在交易所本身中。 后来，爱丽丝吃了蘑菇，并了解了这些币的秘密。</p><p>我们考虑两个交易。首先，一个账户从交易中提现 300 币到个人钱包。为了实现这个，客户输入钱包地址（这里是Q 12），交易热钱包（可能通过交易所的中间地址）发送 300 个币的交易。其次，对于存入交易所的存款，客户输入其交易账户的存款地址，并将交易（可能通过交易所的一些中间地址）发送到交易所热钱包。</p><p>现在让我们看看一些直接连接到区块链的钱包，而不是通过交易所。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*Ryt8vgqj5bNTK2QVI01Osg.jpeg" alt=""></p><p>前面我将钱包描述为区块链上可以管理货币的浏览器。作为早期的加密货币使用者，爱丽丝可以向我们提供钱包角色的更多细节：</p><ul><li>浏览区块链并根据过去的交易计算余额</li><li>持有私钥并签署交易</li><li>设置交易费用（将随时间变化）</li><li>对于某些钱包，发布智能合约和合约调用（ token 交易等）</li></ul><p>只有全节点（含有整个区块链）可以将交易发送到网络以写进区块链中，因此上面使用简化支付验证的钱包（手机钱包）和其他轻量级钱包都必须通过全节点与区块链交互。</p><p>爱丽丝想要指出钱包本身并没有持有任何货币或代币，因为货币或代币总是存放在区块链上。 我们将在下面看到（扰流警报）即使在区块链上， token 也永远不会离开创建它们的智能合约。 它们该有多么无聊！</p><p><img src="https://cdn-images-1.medium.com/max/960/1*YkNZt1jTzxJCh7cPhvz6yg.jpeg" alt=""></p><p>当我们沿着兔子洞向下走时，爱丽丝有一个关于货币分享的秘密。 她说 Qtum 区块链上没有真正的货币。钱包为地址计算未花费的交易额总和，因此“货币”更像是Excel电子表格SUM公式的结果。 另一方面，QRC20 token 值是单独的金额，如Excel中单个单元格中的值。</p><hr><h2 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h2><p><img src="https://cdn-images-1.medium.com/max/960/1*zq6vblhARhPm-SaJXJyisw.jpeg" alt=""></p><p>当我们跟着爱丽丝走下兔子洞时，我们决定采取自拍或者说快照。空投快照​​是特定时间，特定区块的区块链读数。对于Bodhi空投，快照是在 2013 年 2 月 2 日 23:40:16 UTC 的 <a href="https://explorer.qtum.org/block/b14805dbcf2652075b185ea46322416186a5319861e9a317b7f1671368868078" target="_blank" rel="noopener">93,333 块</a>。爱丽丝指出，数字 3 和 9 在中国被认为是幸运的，代表着生活，生命和永恒。</p><p>然后发生的（猜一猜……）是 Bodhi 取区块链中 0 到 93,333 块，解析所有交易，找到每个 Qtum 地址的余额。</p><h3 id="空投"><a href="#空投" class="headerlink" title="空投"></a>空投</h3><p>这一节爱丽丝告诉你谁领到了空投，答案是：所有人。真正的问题是你是否有通过钱包或交易所来访问 token 的方法。</p><p>Bodhi 报告称他们以 4：100 的比例为 Qtum 持有者空投了4,015,325.92 BOT 代币，这意味着他们空投了 100,383,148 QTUM（他们排除了少于 10 QTUM 的地址）。 根据流通图表中的QTUM，2月2日有 100,353,364 QTUM（到目前为止，创造了1亿+块奖励），这意味着几乎每个 Qtum 地址都收到了BOT</p><p>空投的简单公平的方法是给每个活动地址提供 token 。为了检查快照所看到的区块链历史记录有多长，爱丽丝使用时光机（Explorer）来查看最早的块奖励获奖者。 她找不到创世块（1-5000）中任何活跃的钱包地址，但是这个家伙 <a href="https://explorer.qtum.org/address/QaHAXr7eqXZMvUp5HUXDZh1Pk4GhNMCh5b" target="_blank" rel="noopener">…Ch5b</a> 在 2017 年 9 月 8 日赢得了 <a href="https://explorer.qtum.org/block/6dbc7316f94cebff1dc27e13d4e698b97675f9924989d57bbb92ef85976c3fde" target="_blank" rel="noopener">5,041 块</a>，这是一个真正的 <a href="https://www.urbandictionary.com/define.php?term=OG" target="_blank" rel="noopener">OG</a> 钱包，在 2017 年 10 月之前挖了点矿。…Ch5b 仍有余额并确实收到了 BOT 空投。在看到合约调用工作后，我们将在下面看到实际的空投交易。</p><p>我们可以从上面回到我们的图，看看空投如何填充各种区块链地址。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*4WY94A6c--VwqISR6ixeWA.jpeg" alt=""></p><p>现在我们可以在区块链的左侧看到 Bodhi 智能合约存储，其中 BOT 空投到所有的地址。例如，地址 Q2 的交易所冷钱包将有 200,000 个 BOT 空投。该图中有两个时序假设。1）如果 Q10 的存入发生在块 93,333 之后，那么该地址仍然有 10 个 BOT 来自空投。 2）如果 Q12 的提现发生在块 93,333 之前，那么它将收到空投。</p><p>让我们看一下钱包在空投中的行为。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*RYLM_ns6iOIUUG7zf6ssYQ.jpeg" alt=""></p><p>这与预期非常符合，因为 BOT 被空投到每个活动地址（大于10 QTUM）。如上所述，这个包罗万象的空投问题是钱包是否可以访问 token ，这意味着钱包必须有办法添加 token 合约地址，并能够创建和发送 token 合约调用，而不是上面所有的钱包都可以做到这一点。</p><h3 id="与智能合约交流"><a href="#与智能合约交流" class="headerlink" title="与智能合约交流"></a>与智能合约交流</h3><p>回到爱丽丝原来的问题，爱丽丝把我们带到了这个兔子洞，爱丽丝想要向鲍勃发送 10 个 WON  token 。 可以这样类似地想。如果爱丽丝想要向鲍勃发送 10 个 token ，她不能简单地将 10 个 token 从她的钱包发送到 Bob 的钱包，即他的 Q 地址。这种方法存在一些问题。首先，代币不在爱丽丝的钱包中，而是在智能合约中。其次， token 不会被发送到鲍勃的钱包，它们会被移到智能合约存储中的鲍勃的 Q 地址。</p><p>不用担心交叉，爱丽丝的钱包知道如何与智能合约交流，因为她添加了 token 并输入了她钱包里的智能合约地址。向鲍勃“发送” token 的交易实际上被发送到智能合约，并且鲍勃的 Q 地址以及要转移给鲍勃的 token 的数量都作为数据被包含在合约调用交易中。 我们等下将在合约调用中查看数据，这之前先修复另一个易混淆因素。</p><p>比特币地址和 Qtum Q 地址由人们显式输入为 Base58 编码的字母数字字符。你可能从未注意到它（爱丽丝从未这样做过）但比特币和Q地址从不包含数字零，大写字母O，大写字母 I 或小写字母 l。其他的数字和字母都还好，但是如果名叫 Satoshi 的白兔子发现未来的加密货币用户搞砸了，会完全输入 “0”“O”“I”“l”（这很难，是的），为了减少 Bithumb 和 Coinbase 痛苦的客户服务电话，当人们将他们的比特币发送到错误的地址的时候，他们只需忽略这些字符，这对于一只兔子来说是非常具有前瞻性的想法。 这是很复杂的因素。 人类可读的 Base58 地址被转换为更有效的十六进制地址，用于在合约调用交易中发送，以及在智能合约中存储。 要在Base58和十六进制之间进行转换，请使用此网页进行<a href="http://lenschulwitz.com/base58" target="_blank" rel="noopener">Base58编码，解码和验证</a>。</p><p>现在我们可以查看合约调用中的数据，这是一个典型的例子：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*5yaPFlbxtfjd_B4R1oMkhA.jpeg" alt=""></p><p>数据显示：</p><ul><li>a9059cbb 表示这是一个转移操作</li><li>e22843f9a4 …是要转给的地址，以十六进制表示</li><li>3956ed39 转移的数量，十六进制，satoshis</li></ul><p>你对实际完成的空投怎么看？Bodhi 基金会不得不发出这么多合约调用。一旦智能合约启动，它很高兴在区块链中坐等指令。对于空投，这些指令将 BOT 从 Bodhi 基金会地址转移给所有的空投接收者。 例如，你可以在 2 月 15 日早上看到这种空投，比如 <a href="https://explorer.qtum.org/block/1405ac26eb8107936299c3103bb47c5ccd2764b4987f2d28956c7265e246a8c0" target="_blank" rel="noopener">100,719</a> 这样的块，有这么多、大的合约调用，它收 20  QTUM 的交易费！ 这些块包含多个合约调用，每个调用最多 200 个交易，因为Bodhi 更新了合约存储来执行空投。 以下是一些 Q 地址的空投交易：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*pvkrR5sNL5UFERrlH3RAtA.jpeg" alt=""></p><p>所有这些更新 Bodhi 智能合约的交易都已发布到区块链的 100,719 块和其他区块，但区块链中的智能合约存储实际上是如何更新的？ 显然，块奖励获奖钱包在区块链的本地副本中处理这些智能合约调用，将更新填充到其本地存储适当的块中。</p><p>以下是爱丽丝想要分享的第二个秘密：所有的全节点验证新块，它们还在智能合约块的本地副本上处理智能合约交易。 爱丽丝的第二个秘密是 - 每个节点在发布块时执行每个合约调用。</p><p>我们可以看看这些数据如何存储在智能合约中（再次使用令人困惑的十六进制地址）：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*urwLCJ_jmRN_hIDdXDmhyg.jpeg" alt=""></p><p>你想要的话，你可以浏览这个存储，找到你的地址，以及你地址的 token 数。不过不要试这个，有一个更简单的方法来看你的 token 余额，爱丽丝将在下面向我们展示。不过你知道我无法看着这样一个丰富的数据表而不抓着它运行一些 Excel 分析。</p><p>在资源管理器的智能合约页面，点击“显示所有”按钮，然后等一杯咖啡的时间让你的浏览器加载 31,944 项。一些我看不懂的有趣数据：有许多地址有1或2个satoshis token （0.00000001或0.00000002 token ），在其他区块链上称为灰尘。忽略这些条目， token 分布是：</p><p><img src="https://cdn-images-1.medium.com/max/1280/1*Flc-zyUqsIzrDo_o5hvG0Q.jpeg" alt=""></p><p>10个最大的代币持有量如在下图所示。爱丽丝猜测，4000 万那个位置是 Bodhi 基金会，其余的是交易所。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*Pt-Y_YNWLmIrUzGrXAYEOg.jpeg" alt=""></p><h3 id="查看你的-token-余额很容易"><a href="#查看你的-token-余额很容易" class="headerlink" title="查看你的 token 余额很容易"></a>查看你的 token 余额很容易</h3><p>爱丽丝想要有一个超级简单的方式检查合约存储中的 token 余额。她说要导航到<a href="https://explorer.qtum.org/tokens/search" target="_blank" rel="noopener">代币</a> 页面</p><p><img src="https://cdn-images-1.medium.com/max/960/1*krUT59IAL2elF-47wX8R9g.jpeg" alt=""></p><p>我们找不到她的WON token ，所以在这个例子中会使用 BOT; 点击 “BOT - Bodhi Token” 这个名字</p><p><img src="https://cdn-images-1.medium.com/max/960/1*rgAnhE_efD0Nm6m2RZkl9g.jpeg" alt=""></p><p>选择“READ SMART CONTRACT”并将 Q 地址粘贴到 “BalanceOf” 字段中，然后选择“Query”。 将出现 satoshis 的余额。获取 token 中的余额，将小数点向左移动 8 位（仅这个 token ）。</p><p>如果你可以在资源管理器中查看 token ，也可以通过在资源管理器中单击地址的 token 收藏来获取此页面的快捷方式。</p><h3 id="资源管理器中的-token"><a href="#资源管理器中的-token" class="headerlink" title="资源管理器中的 token"></a>资源管理器中的 token</h3><p>空投后，爱丽丝感到很困惑，因为她无法在资源管理器中看到她的地址的代币，但有其他地址已经自豪地展示了他们的代币。</p><p>要理解为什么资源管理器感觉不到空投代币，请记住空投是如何工作的：快照，一些处理，然后空投合约调用智能合约，没有任何东西触及区块链上的 Q 地址。</p><p>资源管理器一直处于蒙蔽状态，直到你将 token 添加到钱包并使用你的 Q 地址进行 token 交易（无论多小）。或者重新加载你的钱包（爱丽丝必须与白兔核对这个），然后资源管理器才知道你拥有该 token ，查询智能合约并正确显示 token 余额。</p><p>以太坊资源管理器内置了最受欢迎的 ERC20  token ，因此你可以查看给定地址的 token 。 也许 Qtum 资源管理器未来的版本中会也有这个功能。</p><h3 id="烧币（Burning-Tokens）"><a href="#烧币（Burning-Tokens）" class="headerlink" title="烧币（Burning Tokens）"></a>烧币（Burning Tokens）</h3><p>现在我们已经到了爱丽丝兔子洞的底部，是时候讨论在它们的使用寿命结束时如何销毁或“烧毁” token 。例如，在 Qtum Mainnet Ignition 启动之前，Qtum  token 以Ethereum ERC20  token 的形式存在。 2017年10月初，各种交易所允许 Qtum 代币持有人提交他们的 Qtum ERC20 代币换成 QTUM Mainnet 代币，换掉的 Qtum ERC20 代币随后被烧毁。</p><p><img src="https://cdn-images-1.medium.com/max/960/1*G-o_Li8O9erWSCtL4vN2Bw.jpeg" alt=""></p><p>为什么有人想要收购好的 token ？也许 token 会升级为新的代币或代币，就像 Qtum 的情况一样。此外，组织可以回收一些代币库存以减少供应，支持价格，类似于公司回购自己股票。</p><p>烧毁 token 你需要把他们发送给一个不存在的地址，将它们永久留在那里。例如，我们造个以太坊地址 0x1111111111111…，一个没有人拥有私钥的合法地址。我们告诉智能合约把 token 转移到那个地址，然后它们就被永久销毁了。我们可以在以太坊 Qtum ERC-20  token 页面查看这些可怜的 token ，并通过累计所有烧毁地址的百分比，看到 97.05％ 的旧 Qtum ERC20  token 已被烧毁：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*PYIvcJLrmpFiiOBumwdD9Q.jpeg" alt=""></p><p>如果你持有 Qtum ERC20 代币，那么建议在代币变得毫无价值之前，将这些 ERC20 代币转换为 Qtum Mainnet 代币。查一下社交媒体，看看是否还有可以完成这种交易的交易所。请快点，因为 Qtum ERC20  token 将永久埋葬在加密墓地，并且这些 token 将变成纪念品，因为不能再换成主网币。</p><hr><p>我不确定 Patrick 最近在哪儿环球旅行，但我认为 Earlz 最近参加完柏林的聚会，回到了阿姆斯特丹。我有几篇报告有柏林的照片，所以让我们在阿姆斯特丹完成。</p><p>阿姆斯特丹是一座历史悠久的城市，拥有美丽的运河，提供“咖啡”的咖啡馆，以及全年提供特殊照明的红灯区。</p><p><img src="https://cdn-images-1.medium.com/max/960/1*m49FhTcFoPWjQ3F7ITB90g.jpeg" alt="高买高卖"></p><p>阿姆斯特丹是郁金香泡沫的家园（1637年内爆），有些人将其与所谓的加密货币泡沫相提并论。 但是，如果你做自己的研究（DYOR），你可以类比区块链2.0平台，如 Qtum（成立于2017年）类比荷兰东印度公司（成立于1602年），这是第一家具有重要新商业范例的全球性公司（第一家） ，在股票市场公开交易），在当时是世界上最有价值的公司。</p><p>我们不要在风车上谈论泡沫。在阿姆斯特丹附近看一些精美的风车吧。今天，这些风车是优雅的历史宝石，但在它们的荣耀中，它们是锯木材，磨面粉和提取亚麻籽油的工业机器。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*NjSFeijRaqW18QJ1efVEQA.jpeg" alt=""></p><p>我很高兴地报告说，爱丽丝确实爬出了兔子洞，如果你看到她和白兔说话，不要担心，他们可能只是讨论区块链治理和扩展。</p><p>我希望你和爱丽丝一起享受这段旅程，了解 token 以及你的代币将非常有用和有利可图。</p><p>Jackson (JB395)</p><hr><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol><li><p>官方 Qtum Core 和 QRC20 Token 指南：<a href="https://blog.qtum.org/qtum-core-qrc-20-tokens-1c2734d6290c" target="_blank" rel="noopener">Medium</a></p></li><li><p>来自社区的一些出色的QRC20 token 资源：</p></li></ol><ul><li>Silverminer, 如何评价 Bodhi  token 。<a href="https://steemit.com/qtum/@silverminer/how-to-claim-bodhi-tokens" target="_blank" rel="noopener">Steemit</a></li><li>Sam Suh，使用 QBao 钱包的 QTUM 钱包教程 - 用于 Bodhi（BOT）代币或其他 QRC20 代币。<a href="https://medium.com/@samsuh_33856/qtum-wallet-tutorial-for-bodhi-bot-tokens-qrc20-tokens-using-qbao-ac14f9445dc8" target="_blank" rel="noopener">Medium</a></li></ul><ol><li><p><a href="https://bodhiproject.github.io/wiki/" target="_blank" rel="noopener">优秀参考资料</a>，关于移动端，QBao，qtum-qt 和qtumd / qtum-cli 等钱包从 Bodhi 基金会添加代币和代币交易。</p></li><li><p><a href="https://github.com/bodhiproject/bodhi-core/tree/master/contracts/tokens" target="_blank" rel="noopener">Github</a> 上的 Bodhi  token 合约。</p></li><li><p>我最喜欢的以太坊ERC20 token ，<a href="https://uetoken.com/" target="_blank" rel="noopener">UET</a>。 对不起，我忘记这个 ICO 了。</p></li><li><p>爱丽丝梦游仙境，<a href="http://www.alice-in-wonderland.net/resources/chapters-script/alices-adventures-in-wonderland/" target="_blank" rel="noopener">全文</a>。<br> <img src="https://cdn-images-1.medium.com/max/960/1*OqydpnY8pNUqdn8_1poDCQ.jpeg" alt=""></p></li><li><p>区块链研究时听的音乐：Be In The Moment with Amsterdam DJ Armin Van Buren 和他的每周视频博客<a href="https://www.youtube.com/channel/UCu5jfQcpRLm9xhmlSd5S8xw" target="_blank" rel="noopener">A State of Trance</a><br> 东南亚的<a href="https://youtu.be/fMLmtl6cUaA" target="_blank" rel="noopener">Armin</a><br> <img src="https://cdn-images-1.medium.com/max/960/1*NFYaY4LPjvsXUraQmB-fwQ.jpeg" alt=""></p></li><li><p>阿姆斯特丹的<a href="https://youtu.be/6Y6uPhquJbI" target="_blank" rel="noopener">无人机镜头</a>（DJI Mavic Pro），以4k观看</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;https://medium.com/@jb395official/qrc20-token-report-february-25-2018-ff397a1ac070&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://me
      
    
    </summary>
    
      <category term="区块链" scheme="http://xichen.pub/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://xichen.pub/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Qtum" scheme="http://xichen.pub/tags/Qtum/"/>
    
      <category term="翻译" scheme="http://xichen.pub/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】 新手钱包</title>
    <link href="http://xichen.pub/2018/07/18/2018-07-18-%E7%BF%BB%E8%AF%91-%E6%96%B0%E6%89%8B%E9%92%B1%E5%8C%85/"/>
    <id>http://xichen.pub/2018/07/18/2018-07-18-翻译-新手钱包/</id>
    <published>2018-07-18T06:11:00.000Z</published>
    <updated>2019-04-01T15:18:44.232Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://medium.com/@jb395official/newbie-wallets-april-1-2018-26ea7a06489c" target="_blank" rel="noopener">https://medium.com/@jb395official/newbie-wallets-april-1-2018-26ea7a06489c</a><br>译者：中山大学数学学院（珠海）林学渊<br>大二时给量子做的翻译，转载注明出处，谢谢</p><h1 id="新手钱包-–-2018年4月1日"><a href="#新手钱包-–-2018年4月1日" class="headerlink" title="新手钱包 – 2018年4月1日"></a>新手钱包 – 2018年4月1日</h1><p><img src="https://cdn-images-1.medium.com/max/1600/1*CoZWPEKSdUvkruolCf5urg.jpeg" alt=""></p><p><img src="https://cdn-images-1.medium.com/max/960/1*KFZfenJ-o8iR3x-il9r1qg.jpeg" alt=""></p><p>在本报告中，我们分析区块链，了解自今年年初以来新钱包对节点数增长的贡献。我们的区块链浏览器是<a href="https://qtum.info/" target="_blank" rel="noopener">qtum.info</a>，它本周增加了一个 <a href="https://qtum.info/misc/stake-calculator" target="_blank" rel="noopener">staking 奖励计算器</a>，需要输入地址或输入 stake 金额。这个新的资源管理器给我留下了深刻的印象，它具有明亮的背景，能够快速显示一个地址直到“出生日期”的所有交易。</p><p>TL;DR 1月下旬，大约有2000个 staking 钱包，每个有 500 个代币，这可能与宣布给中国的 50,000 个节点的视频流平台有关。</p><p>我是一名独立研究员，偶尔是博主，社交版主，并中意 Qtum 团队的技术指导和社区的高谈阔论。如果你对本文有任何意见或更正，请联系社交媒体。本博客假设你对Qtum 权益证明（Proof of Stake）和区块奖励机制有一些基本的了解，新的社区成员可以阅读我在以下参考文献中以前博客的链接来了解有关这些主题的更多信息。</p><hr><h2 id="网络权重（在家试试）"><a href="#网络权重（在家试试）" class="headerlink" title="网络权重（在家试试）"></a>网络权重（在家试试）</h2><p>经常看我博客的人知道我通过爬取资源管理器块奖励地址来计算网络权重的替代方法，识别具有稳定余额的大钱包，并使用这些大钱包赢得的总奖励和块奖励百分比来计算网络权重。在过去两周内，这个方法算的网络权重为 3340 万。</p><p>使用新的资源管理器，你可以用这些步骤在家里玩玩网络权重。将你喜欢的浏览器导航到新的资源管理器<a href="https://qtum.info/misc/biggest-miners" target="_blank" rel="noopener">Biggest Miners</a>页面：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*zMnbWpMRBMjx4EzlOsIlaw.jpeg" alt=""></p><p>爬取数据并保存到文本文件。然后恰好一周后，再次爬取数据。对那些在两次爬取之间具有大致相同余额的大钱包（考虑到增加的块奖励），计算总余额和本周开采的块。</p><p>网络权重 = 总余额 /（本周开采的块/每周4200块）。 如果你本周进行计算，你的应该接近我上面计算的网络权重（除非有人添加节点😊）</p><hr><h2 id="节点地图-Nodemap"><a href="#节点地图-Nodemap" class="headerlink" title="节点地图 Nodemap"></a>节点地图 Nodemap</h2><p>Nodemap 本周更新了，可以显示网络上超过 7,000 个节点。这里大事是 Qtum 节点在中国的增长，我不相信其他情况下所谓的“剧情反转”：目前 Qtum 在中国的节点数超过 4,400，是比特币或以太坊的中国节点的两倍多。下一步将是 Qtum 超过比特币的全球节点数，给它两个月。</p><p>去年，在韩国退出之前，节点数第一在韩国和美国之间来回切换。 2017年10月21日，你可以在此屏幕截图中看到，staking 大城市是加州山景城（Google Cloud的主页）和首尔。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*1S-VsFdLmsyBZS_mLyRxjg.jpeg" alt=""></p><p>截至2017年底，网络权重为 2000 万，节点数约为 1,200。但从那时起，节点部署和网络权重增加的速度有所加快。</p><p><img src="https://cdn-images-1.medium.com/max/960/1*DkgJumuKWajuIYQSFEg_Jg.jpeg" alt=""></p><p>目前，中国有11个城市拥有 100 个以上节点，其中包括南京的1000个节点。看看今天这个屏幕截图，酷！南京是江苏省的省会，拥有 3000 万人口，感觉就像你走动的时候不可能不撞到 Qtum 节点，这可能就是正在发生的事情。这些新节点非常有趣，因此我有一个<a href="https://www.urbandictionary.com/define.php?term=scientific-wild-ass%20guess" target="_blank" rel="noopener">大胆的想法(SWAG，Scientific wild-ass guess)</a>，关于其目的的：位于便利店的终端/信息亭，允许人们在不使用银行或信用卡的情况下为视频流服务支付现金。但这是一个完整的猜测，如果实际情况和我想的不一样，这些句子将被神奇地编辑掉。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*8okLn8l_ptzc-YF1_8Gs3Q.jpeg" alt=""></p><p>下表显示，从2月中旬到本周末的节点数变化。每个国家的都有增长，韩国节点数今天刚刚达到四位数字，中国节点数的增长目前占总节点数的63％。</p><p><img src="https://cdn-images-1.medium.com/max/1280/1*44a9XH-0tvlaG66U2Pn8bw.jpeg" alt=""></p><p>下面的饼图显示了节点位置百分比。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*4fl6MLjRDI7ajAi8sKqh1w.jpeg" alt=""></p><hr><h2 id="新手钱包"><a href="#新手钱包" class="headerlink" title="新手钱包"></a>新手钱包</h2><p>我们回到 Excel 表格分析，看看七天内块奖励获奖者。以下是它的工作原理：从资源管理器中删除块奖励获胜者的地址，在 Excel 中对独立地址排序，用宏记录程序将每个地址粘贴回资源管理器并爬取对应钱包余额和交易数。</p><p>staking 地址的交易数很有意思，它提供了有关钱包年龄的线索，因为每个区块奖励的支付时间在 10 次交易内。 如果你看到一个包含 50 到 5,000 笔交易的 staking 钱包地址，则那个钱包已经存在了一段时间。 但如果你看到一个钱包赢得区块奖励时少于 10 次交易，那么这正是它的第一次区块奖励体验（第一次是最好的时间！）</p><p>让我们进一步分析区块奖励获奖者。有趣的是一些新手钱包有500 QTUM，还有一些有400 QTUM。 人们喜欢整数，过去的研究显示，经常有 365,500,1000,2000 和 10000 QTUM 的钱包。但是现在有很多这种 500 QTUM 大小的新钱包。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*-A2lIHByL3PCkwSOBFuerw.jpeg" alt=""></p><p>上面的例子展示了<a href="https://qtum.info/address/QTkkpuhAdNddGEMp99v2BMdS3Qmo63TMm4" target="_blank" rel="noopener">这种钱包</a>中的一个，它有 500 QTUM，当时是 2018 年 1 月 30 日。你能看见转入 84, 854 QTUM 的交易和转出 84,354 QTUM 的交易。你能假定它下一次交易就是用这 84,354 QTUM 发送 500 QTUM 给<a href="https://qtum.info/address/Qjai23hm2YibnNL8JQWWbpUpAQMC24ARZ7/" target="_blank" rel="noopener">另一个钱包</a>，如此继续下去，造另外的 168 个钱包。</p><p><img src="https://cdn-images-1.medium.com/max/960/1*vB2iPZEmh-OouhbBXxyUIQ.jpeg" alt=""></p><p>我保证这些 staker 喜欢这 168 份交易费用，对此我只想用一个词来形容，“盲目发送(sendmanywithdupes)”。这本来只需一笔交易费即可为多个地址转入代币。在这次分析里，我看到了很多 sendmanywithdupes 交易的例子，包括去年发送 365 个 QTUM 到多个地址的那个著名系列，后来用来挖矿。注意，将 QTUM 拆分为单独的挖矿地址并没有改变赢得区块奖励的可能性，因为钱包软件保证了在有 27,375 个代币的单个钱包地址和分别有365个代币（共27,375个代币）的 75 个地址之间，赢得区块奖励的概率都是一样的。</p><p>中国的节点增长源自哪里？一种可能是中国视频流媒体公司宣布他们将在商业网络中部署 50,000 个节点。 我们可以折腾区块链，看看是否可以发现有关新节点的什么模式或细节。我们截取 3 月 24 日至 3 月 30 日的获得区块奖励的钱包，其中对同时满足 QTUM 少于 600 且 2018 年 1 月 1 日之后有过代币交易的钱包进一步过滤：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*-Mi-J1oN2KhPHpIRoD7l1A.jpeg" alt=""></p><p>直方图显示的是在不同日期转入（创建）500 QTUM 的块奖励获奖钱包数。因为块奖励与钱包重量成正比（还有一些随机影响），我们可以反过来处理块奖励计算，并回答这个问题：如果网络权重为 3340 万，一周内赢得 129 块奖励所需的钱包大小是多少？ [参考1] 答案是大约100万枚代币。如果你按 500 QTUM 部署 100万个，那么你将有 2000 个钱包，这肯定在中国的增长范围内，甚至可能有点低。在任何情况下，概率论表明如果你有一个有着 100 万个代币的钱包，或者每个有 500 个代币的 2000 个钱包，都能在一周内赢得 129 个块奖励。</p><hr><p>我希望你能享受这次关于区块链操作的讨论，并学到点东西。4月1日是复活节星期天，如果你关注复活节，那我希望你复活节快乐。</p><p>今天是复活节，我们在梵蒂冈写完博客。这里是基督教(Catholic Christianity)，圣彼得大教堂(St. Peter’s Basilica)和西斯廷教堂(the Sistine Chapel)之家。在西斯廷教堂，文艺复兴时期的艺术天才米开朗基罗花了10年（1502-1512）亲自画天花板和墙壁。 创世纪的标志性形象 – 创造亚当（所以亚当必须是人类的“<a href="https://qtum.info/block/1" target="_blank" rel="noopener">第1块(block 1)</a>”？）并给出了加密货币创世块的名称。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*i9tS3hJOpurRxNIvv1eEjQ.jpeg" alt=""></p><p>注意在线安全，我会在社交媒体上看到你</p><p>Jackson</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*F4j_asy0MBUS2hb-Y5ByBw.jpeg" alt=""></p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>在一周内获得 129 份块奖励，每天 600 块，也就是 4,200 块。钱包重量为：</li></ol><p><img src="https://cdn-images-1.medium.com/max/1280/1*DVu4tRWb7_ivXfJgGOEkew.jpeg" alt=""></p><ol><li>看我之前写在<a href="https://medium.com/@jb395official" target="_blank" rel="noopener">Medium</a>上的博客</li></ol><p><img src="https://cdn-images-1.medium.com/max/960/1*kuYpVPZtss0PO5Y2TbqyCw.jpeg" alt=""></p><ol><li>不是从无人机拍摄，而是一些<a href="https://www.youtube.com/watch?v=eMGL1_nSjIk" target="_blank" rel="noopener">不错的视频</a>,关于圣彼得广场和圣彼得大教堂的，1080P。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;https://medium.com/@jb395official/newbie-wallets-april-1-2018-26ea7a06489c&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://medium.com
      
    
    </summary>
    
      <category term="区块链" scheme="http://xichen.pub/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://xichen.pub/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Qtum" scheme="http://xichen.pub/tags/Qtum/"/>
    
      <category term="翻译" scheme="http://xichen.pub/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】 钱包和密钥</title>
    <link href="http://xichen.pub/2018/07/12/2018-07-12-%E7%BF%BB%E8%AF%91-%E9%92%B1%E5%8C%85%E5%92%8C%E5%AF%86%E9%92%A5/"/>
    <id>http://xichen.pub/2018/07/12/2018-07-12-翻译-钱包和密钥/</id>
    <published>2018-07-12T06:11:00.000Z</published>
    <updated>2019-04-01T15:18:44.231Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://medium.com/@jb395official/wallets-and-keys-july-23-2018-92abf2a2d2bf" target="_blank" rel="noopener">https://medium.com/@jb395official/wallets-and-keys-july-23-2018-92abf2a2d2bf</a><br>译者：中山大学数学学院（珠海）林学渊<br>大二时给量子做的翻译，转载注明出处，谢谢</p><p>Wallets and Keys — July 25, 2018</p><h1 id="钱包和密钥-2018年7月25日"><a href="#钱包和密钥-2018年7月25日" class="headerlink" title="钱包和密钥-2018年7月25日"></a>钱包和密钥-2018年7月25日</h1><p>本文考虑钱包和密钥。先简要介绍，再上例子。大多数例子基于浏览器上的 <a href="https://qtumwallet.org/" target="_blank" rel="noopener">Qtum Web 钱包</a>，类似于以太坊钱包 MyEtherWallet和MyCrypto。 Qtum Web 钱包运行在浏览器上，并不需要下载区块链，而是通过专用全节点连接到区块链。</p><p><img src="https://cdn-images-1.medium.com/max/960/1*sxyzaMzH1k1QMIM4WOmawA.jpeg" alt="变色龙示威，[Yathin S Krishnappa](https://commons.wikimedia.org/wiki/User:Yathin_sk)摄，裁剪过"></p><p>Web 钱包是一个强大的变色龙，提供了很多恢复其他类型Qtum钱包的方式。没有 Web 钱包恢复不了的钱包（如果你用本博客的技术的话）。注意Web钱包具有完整QRC20令牌功能。</p><p>注意事项：本博客和钱包恢复步骤包括处理私钥和种子词。在你尝试这些步骤前，确保你完全理解流程且电脑没有恶意软件和病毒。简单地发送QTUM或代币到一个新钱包比乱动私钥更安全，但有时无法发送代币，比如，你的手机钱包掉马桶或被忘在浴缸里一整夜。永远不要把你的私钥或种子词给别人因为他们能拿走你的币。</p><p><img src="https://cdn-images-1.medium.com/max/960/1*2co82T2PlBqiWtajX0A4uA.jpeg" alt=""></p><p>我是一名独立研究员，偶尔写博客和主持社交媒体，十分中意Qtum的技术指导。如果你对本文有想法或批评，请在社交软件上发给我或在下面评论。</p><hr><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><blockquote><p>TL;DR Qtum 钱包的安装使用了随机生成的私钥或种子词。通过导出私钥或种子词，你能在各种钱包之间转移你的 Qtum 地址。重要的是保证私钥和种子词安全–保持你的私人私密！</p></blockquote><p>你知道钱包在区块链建立它们的身份时使用了一个 Qtum地址 “Q…”。 这个地址生成自公钥，而公钥生成自私钥。</p><p>Satoshi 给比特币取了错误的名字 “钱包”， 因为钱包实际上不存任何币或代币，它们存在区块链里。“钱包”的正确名字应该是“密钥库”因为钱包的主要工作是保存和管理私钥，通过私钥来支持交易。</p><h1 id="私钥和种子词"><a href="#私钥和种子词" class="headerlink" title="私钥和种子词"></a>私钥和种子词</h1><p><img src="https://cdn-images-1.medium.com/max/960/1*zQsSpuPYc66g-_peB2qwDA.jpeg" alt=""></p><p>一个私钥是一个简陋的字符串，但它是通往王国的关键。私钥（不用密码）允许存储在由私钥生成的地址中的QTUM访问。你需要十分小心地使用私钥，因为如果任何一个人（黑客、恶意软件、甜言蜜语的热心人）拿了你的私钥，他们就可以拿了你的钱。</p><p><img src="https://cdn-images-1.medium.com/max/960/1*r8NdMNvHsshagpqlV-agtg.jpeg" alt=""></p><p>私钥也能用种子词生成。典型的是，钱包使用的种子词有两种，桌面钱包使用 bip-039 种子词，手机钱包使用“字典”种子词。这两种不相容，这个差别由 Web 钱包管理，它两种都能接受，是 bip-039 种子词则使用 “从助记符中恢复” ，是“字典”种子词则使用“从手机钱包恢复”。</p><p>比特币改进协议（Bitcoin Improvement Protocol 39 （bip-039)）给出了规则，生成私钥要使用从 2,048 个单词列表中导出的 12 个种子词[参考文献1]。手机钱包使用的“字典”单词一列是 4,216个类似bip-039的单词[参考文献2]。</p><p>输入种子词来恢复钱包有风险，因为私钥是从种子词里精确地生成而来，多一个符号或一个空格都会生成一个完全不同的私钥和完全不同的 Qtum 地址。如果你错输了种子词，你会创建给钱包创建一个你不期望的 Qtum 地址。如果你发币给那个地址，你很有可能永远无法再输入那个错字恢复钱包地址，这就意味着你的币永久丢失了。</p><p>下图显示了用于创建钱包或恢复钱包的所有 Web 钱包选项： </p><ol><li><p>生成新钱包 – 创建一个随机地址，下载一个密钥文件</p></li><li><p>用助记符创建 – 创建 12 个种子词生成的一个随机地址</p></li><li><p>从助记符恢复 – 使用 12 个 bip-039 种子词从另一个钱包恢复一个地址</p></li><li><p>从 WIF 恢复 – 从一个密钥中恢复一个地址</p></li><li><p>从手机钱包恢复 – 使用 12 个 “字典” 种子词从一个 Qtum 手机钱包中恢复一个地址</p></li><li><p>从密钥文件恢复 – 从 Web 钱包创建的密钥文件中恢复一个地址</p></li><li><p>从 Ledger 恢复 - 允许使用安全存储在 Ledger 硬件钱包中的私钥进行交易</p></li></ol><p><img src="https://cdn-images-1.medium.com/max/1600/1*jbZEYQ8-jqb70LjZTJ8ZuQ.jpeg" alt=""></p><p>让我们逐个详细地介绍这些选项。</p><ol><li>生成新钱包</li></ol><p>生成新钱包会创建一个随机地址并下载一个密钥文件，其名称由 unix 纪元时间（以毫秒为单位）给出，例如 “1532053935952.txt”，其中包含由密码加密的文本，例如：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;“<span class="keyword">version</span>”:”<span class="number">0.1</span><span class="comment">",”content”:”tFz3ctzaITRniFjD6lDm1m8Zyu7LeNjNm/j2ao/hxoIhYAwqlC9iZYZ9TCermbrxF2ljd/wTXnRq/Ca6nYPYZNJ4GC0=”&#125;</span></span><br></pre></td></tr></table></figure><p>将密钥文件保存在计算机上，并备份到多个USB设备。重新启动 / 恢复用“生成新钱包”选项创建的钱包的唯一方法是通过加载密钥文件并输入密码来“从密钥文件恢复”（请参阅​​下面的步骤6）。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*wIaJRnmbnL0uMZ0ceN1uUw.jpeg" alt=""></p><p>使用又长又强的密码，而不是像“12345”这样的简单密码。</p><ol><li>用助记符创建</li></ol><p>“用助记符创建” 创建 12 个种子词生成的一个随机地址。你必须重新输入那 12 个种子词，确保你以及保存好种子词了。</p><p>用这个选项你只要下面的 3 步就能从助记符（种子词）中恢复钱包。你也能（必须能）通过“转储为密钥文件”创建一个密钥文件来备份钱包。现在你有 2 种方式恢复钱包，使用种子词和密钥文件。这很有效地使你恢复钱包的能力翻倍，但也意味着你现在需要安全地存储三样东西（密码，种子词和密钥文件）。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*kVzIe1b-8C_WO3GPruXO7w.jpeg" alt=""></p><p>注意，助记符不同于 Core 钱包密码短语（这是一种自由格式的文本密码短语并且不是种子词）</p><ol><li>从助记符恢复</li></ol><p>“从助记符恢复”使用 12 个 bip-039 种子词从另一个钱包恢复一个地址。输入种子词时，他们必须和原种子词字字匹配。这意味着全部小写（永远没有大写字母）因为这是种子词生成的形式。任何差异或额外单词都会为钱包创建一个不同的随机的地址，也就是它会显示 0 零钱，这很危险，如果你发送 QTUM 给这个新地址的话。确保你检查过地址并确认那就是你要的地址。安全一点的是从助记符恢复以保存密钥文件，并使用密钥文件恢复钱包以打开钱包。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*3xqlhNWHTzGOt5X1U40CrQ.jpeg" alt=""></p><ol><li>从 WIF 恢复</li></ol><p>WIF 电子钱包导入格式（Wallet Import Format） 是私钥一种纠错和缩短的格式[参考文献3]。你遇到的大多数私钥都使用WIF，通常长度为52个字符，而本地私钥使用 64 个十六进制字符。 Web钱包和Core钱包提供私钥作为WIF，此选项将允许从WIF私钥恢复钱包地址。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*Pr47C0oYLqIihq1LjbJxiQ.jpeg" alt=""></p><ol><li>从手机钱包恢复</li></ol><p>“从手机钱包恢复”使用 12 个 “字典” 种子词从一个 Qtum 手机钱包中恢复一个地址。要让这种恢复正常工作，必须为每个字符正确输入手机钱包种子词（现在这听起来熟悉吗？）。单词总是小写，永远不会有大写字符。 此外，请勿在任何单词后面输入尾随空格，否则生成一个非常危险的新随机地址。 请确认这个选项创建的地址与你手机钱包中的地址相匹配（否则你输入的种子词不正确）。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*hdW_vYwAWFOqlo_TMtSrfQ.jpeg" alt=""></p><p>选择 CONFIRM 后，选择要恢复的地址：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*-72KpXo1e-I1CAzME0bYaQ.jpeg" alt=""></p><ol><li>从密钥文件恢复</li></ol><p>“从密钥文件恢复”从 Web 钱包创建的密钥文件中恢复一个地址。从电脑加载密钥文件并输入密码来恢复钱包地址。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*NviSnaTLVTYbDunYyVGXhA.jpeg" alt=""></p><ol><li>从 Ledger 恢复</li></ol><p>这个选项与其他选项的工作方式不同。“从 Ledger 恢复”允许使用安全存储在 Ledger 硬件钱包中的私钥进行交易。对于这个选项来说，私钥不会离开硬件钱包，而是 Ledger 签署交易（允许手动验证）和批准交易。</p><p>要使用 Ledger 硬件钱包，请在 Web 钱包上选择“从 Ledger 恢复”，连接你的 Ledger，登录并启动 Qtum 应用程序，然后选择CONNECT 来让 Web 钱包连接到 Ledger。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*4t8J2AThaRn_wiRKSY7ddw.jpeg" alt=""></p><p>选择默认路径 m/44’/88’/0’/0 并单击绿色挂锁按钮：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*RtixVkMflh7ai-Z3O5ghFw.jpeg" alt=""></p><p>在屏幕上默认路径 m/44’/88’/0’/0 选择所需的地址，然后单击绿色挂锁按钮：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*dyuJxEWOqPHcsVwzUHe9yA.jpeg" alt=""></p><p>这仅仅会启动标准 Web 钱包页面，因为私钥仍然锁定在Ledger中，没有可用的私钥，并且“转储到密钥文件” 按钮不可用。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*0F1OkKnfXaNqlTOp1dMh-w.jpeg" alt=""></p><hr><h1 id="测试网例子"><a href="#测试网例子" class="headerlink" title="测试网例子"></a>测试网例子</h1><p><img src="https://cdn-images-1.medium.com/max/960/1*KrwCpKAiDIp_cWbzep2dEQ.jpeg" alt="测试网资源管理器"></p><p>接下来是在各种 Qtum 钱包之间转移私钥或种子词来恢复钱包的一些真实示例。在本练习中，我使用Qtum Testnet，如果你需要在 Testnet 上进行复习，请参阅<a href="https://medium.com/@jb395official/testnet-and-qtum-mainnet-performance-january-1-8-e7af03a5d430" target="_blank" rel="noopener">这个博客</a>。</p><p><img src="https://cdn-images-1.medium.com/max/960/1*3v9Agworepo_g-Paz5bAtQ.jpeg" alt=""></p><p>让我说我对 Testnet QTUM 的价格发展感到非常失望。似乎 <a href="https://testnet.qtum.info/misc/rich-list" target="_blank" rel="noopener">Testnet QTUM 大佬</a> 正在操纵这种币抑制价格，这对于 Testnet QTUM 持有者来说是很伤心。 没有价格升值，而且这种币似乎永远停留在 0 satoshis。 Testnet QTUM 在任何主要交易所，任何小型交易所或任何交易所都没有交易对。 它基本上是一个毫无价值的币，我们唯一可以做的就是在 Qtum Testnet 上进行测试，所以我们就这样做。</p><h2 id="A-手机到-Web-钱包"><a href="#A-手机到-Web-钱包" class="headerlink" title="A. 手机到 Web 钱包"></a>A. 手机到 Web 钱包</h2><p>要在网络钱包上恢复 Qtum 手机钱包，请在移动设备上转到个人资料 - 电子钱包备份并输入你的个人识别码以查看种子词（你之前也应保存它们）。 在 Web 钱包上，选择“从手机钱包恢复”，准确输入种子词，然后选择确认。 从 Qtum 地址列表中（除非你在移动设备上选择了其他地址，否则应该是最重要的地址）找到所需的 Qtum 地址并选择 CHOOSE。检查恢复的地址是否与你的移动钱包地址相同（如果没有，请重新输入种子词并仔细检查所有字符）。使用“转储作为密钥文件”成功还原后，你可能要备份密钥文件。</p><h2 id="B-Core-到-Web-钱包"><a href="#B-Core-到-Web-钱包" class="headerlink" title="B. Core 到 Web 钱包"></a>B. Core 到 Web 钱包</h2><p>在 Qtum Core 钱包（显示 qtum-qt）上，选择 “帮助” - “调试窗口” - “命令”，并输入 dumpprivkey 命令需要的所有地址（有关多个地址的信息，请参阅参考资料4）。 复制 WIF 私钥，这里是 “cPuz…”。 在 Web 钱包上选择“从 WIF 恢复”，粘贴私钥，然后单击确认。 使用“转储为密钥文件”成功还原后，你可能要备份密钥文件。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*ujFP9icgoj1eEZ0-Fr2rVA.jpeg" alt=""></p><p>C. Web 到 Core 钱包</p><p>这与上面的 B 正好相反。 在 Web 钱包上选择“查看钱包信息”，查看私钥并复制私钥。 在 qtum-qt Core 钱包上选择“帮助” - “调试窗口” - “控制台”并输入命令 importprivkey 并粘贴私钥：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*0Rc6meMnP-lpORRXl8fyFg.jpeg" alt=""></p><p>Core 钱包将扫描区块链一两分钟，调试窗口标题将显示（Not Responding），Console 响应为“null”，你应该看到新地址加了 QTUM 余额。 你应该对 wallet.dat 文件重新备份，因为它包含一个新的私钥。 </p><p>D. 手机到 Core 钱包</p><p>显然，做 A - 手机到 Web 钱包再做 C - Web 到 Core 钱包。</p><p>E. Qbao 到 Web 钱包</p><p>在Qbao上转到“我” - “助记符导出” - 输入你的 PIN（密码）并复制助记符（12个种子词 - 你之前应该保存这些）。 在 Web 钱包上，选择“从手机钱包恢复”，并仔细输入12个种子字（无额外空格）并选择确认。 通过选择 CHOOSE 从“从手机钱包恢复”列表中选择所需的地址。 你可能要使用“转储为密钥文件”来保存密钥文件。</p><p>F. Electrum 到 Web 钱包</p><p>要使用种子词将地址从 Electrum 钱包转移到 Web 钱包，你需要在初始安装中将 Electrum 设置为与 Qtum 手机种子词兼容（然后使用手机钱包种子词来恢复 Electrum 上的手机钱包 ）。这个设置的 Electrum 配置截屏为：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*3pODwbYSz0uYGPaesLpgaQ.jpeg" alt=""></p><p>在这个截图之后，你输入手机钱包种子词（这些单词也与“从手机钱包中恢复”的 Web 钱包选项兼容）。</p><p>如果你尚未将 Electrum 钱包设置为与手机钱包兼容，则可以使用私钥恢复 Web 钱包上的 Electrum 钱包。 在 Electrum 钱包上选择“钱包” - “私钥” - “导出”，你将导出文件 qtum-electrum-private-keys.csv 或只复制一个私钥。 在 Web 钱包上选择“从 WIF 恢复”，粘贴私钥并选择确认。 检查钱包地址是否正确。 你可能需要使用“转储为密钥文件”来保存密钥文件。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*4q46uLQwpBZ-X4u2t6OX9w.jpeg" alt=""></p><p>F. Core 到 Core</p><p>见下面的参考文献4。</p><hr><p>我希望这个关于私钥和种子词的解释有助于你理解钱包。请记住，钱包不会存储硬币或代币。 硬币和代币总是存储在区块链中，但钱包存储私钥并使用私钥管理交易。 直接使用私钥和种子词时请务必小心。 确保你的计算机不含病毒和恶意软件，并且永远不要使用在线存储来存储私钥，种子词或密码</p><p>保持在线安全。</p><p>Jackson</p><hr><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol><li><p><a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki" target="_blank" rel="noopener">bip-039 参数</a>。 <a href="https://github.com/bitcoin/bips/blob/master/bip-0039/english.txt" target="_blank" rel="noopener">bip-039种子词 英语单词表</a>。 如果你的 bip-039 种子词不在这个表中，那么你写错了！</p></li><li><p><a href="https://github.com/qtumproject/qtum-android/blob/5a14b25a82fe04d9436147d776d1482e7f7ad242/app/src/main/java/org/qtum/wallet/utils/DictionaryWords.java" target="_blank" rel="noopener">“字典”种子词列表</a>。 如果你的种子词不在这个列表中，你就错了！</p></li><li><p>钱包导入格式（Wallet Import Format），比特币的一个<a href="https://en.bitcoin.it/wiki/Wallet_import_format" target="_blank" rel="noopener">例子</a>。</p></li><li><p>转移私钥 - Core 到 Core 钱包（显示为 qtum-qt Desktop GUI Core 钱包）</p></li></ol><p>在导出私钥之前，最好更新防病毒软件并运行完整的防病毒扫描。 永远不要把私钥给任何人，他们可以拿走你的 QTUM。</p><ol><li>如果你有加密钱包，请解锁钱包（而不是仅用于 staking）</li></ol><ul><li>转到“设置” - “解锁钱包”，取消选中“仅限 staking”，输入你的密码并按“确定” </li><li>你应该看到小挂锁符号搭扣打开了 </li></ul><p><img src="https://cdn-images-1.medium.com/max/1280/1*AIswxXEdSuAIpFnoPEfjAg.png" alt=""></p><ol><li>选择要导出私钥的 Qtum 地址</li></ol><ul><li><p>转到“文件” - “接收地址…”，然后复制 Qtum 地址以导出私钥</p></li><li><p>选择地址并按 COPY，关闭该窗口 </p></li><li><p>如果你的钱包有多个持有 QTUM 的接收地址，你可以找到哪些地址持有 QTUM，请转到“文件” - “调试窗口” - “控制台”并输入命令 listaddressgroupings 。</p><p><img src="https://cdn-images-1.medium.com/max/1280/1*vTy9q9TrXS5QHJEt9KknMQ.png" alt=""></p><p>滚动列表并复制保存 QTUM 的地址以导出这些私钥</p></li></ul><ol><li>打开控制台并输入命令以导出私钥</li></ol><ul><li><p>转到“文件” - “调试窗口” - “控制台”</p></li><li><p>在控制台底部，开始输入命令dumpprivkey</p></li><li><p>然后粘贴你刚刚复制的地址。 这个命令看起来像这样：</p><p><code>dumpprivkey QskjfhGF28374Daskfjh238742837482374</code><br><img src="https://cdn-images-1.medium.com/max/1280/1*DaZMckv-xWHur4FZNLFAtA.png" alt=""></p></li><li><p>输入命令</p></li></ul><ol><li>私钥将作为包含 52 个字符的文本字符串显示在控制台上</li></ol><ul><li>将私钥复制到文本文件中并保证其安全。这是一个未加密的私钥，任何拥有这个私钥的人都可以使用你的 QTUM。 切勿将私钥交给任何人。</li></ul><ol><li><p>要在第二个 Qtum Core 钱包上导入这个私钥，请启动该钱包并将其解锁（如果已加密）</p></li><li><p>在控制台中输入 importprivkey 命令</p></li></ol><ul><li><p>转到“文件” - “调试窗口” - “控制台”，并在底部开始输入命令importprivkey </p></li><li><p>复制并粘贴先前转储的私钥。 该命令看起来像这样：<br><code>importprivkey Siufy238746FGasj127356asjdhYTVss93845kajsfmyQTUM</code><br><img src="https://cdn-images-1.medium.com/max/1280/1*zQ60gUGNG0AGvu5X4wgUXw.png" alt=""></p></li><li><p>输入命令</p></li><li><p>钱包将重新扫描本地区块链大约两分钟，以查找此新地址的交易，在此期间，调试窗口标题将显示“无响应(Not Responding）”</p></li></ul><p><img src="https://cdn-images-1.medium.com/max/1280/1*Nx79UjkLWp6vezmBGlT-Qg.png" alt=""></p><ul><li>然后响应 “null”</li></ul><p><img src="https://cdn-images-1.medium.com/max/1280/1*jCEK9RvFGL9PWx6kc_pqjw.png" alt=""></p><ul><li>你应该看到新私钥的未花费的交易的值已添加到钱包的总余额中。</li></ul><p>你可能要将所有转移过的私钥（它将与你在步骤 2 中开始的地址）中的所有 QTUM 发送到另一个地址，因为私钥已导出并暴露在加密钱包之外（丢弃这个私钥）。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;https://medium.com/@jb395official/wallets-and-keys-july-23-2018-92abf2a2d2bf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://medium.c
      
    
    </summary>
    
      <category term="区块链" scheme="http://xichen.pub/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://xichen.pub/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Qtum" scheme="http://xichen.pub/tags/Qtum/"/>
    
      <category term="翻译" scheme="http://xichen.pub/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】 以太坊的挑战者：量子链（QTUM）</title>
    <link href="http://xichen.pub/2018/07/06/2018-07-06-%E7%BF%BB%E8%AF%91-%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%9A%84%E6%8C%91%E6%88%98%E8%80%85-%E9%87%8F%E5%AD%90%E9%93%BE(QTUM)/"/>
    <id>http://xichen.pub/2018/07/06/2018-07-06-翻译-以太坊的挑战者-量子链(QTUM)/</id>
    <published>2018-07-06T06:11:00.000Z</published>
    <updated>2019-04-01T15:18:44.229Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://strategiccoin.com/the-ethereum-challengers-qtum/" target="_blank" rel="noopener">https://strategiccoin.com/the-ethereum-challengers-qtum/</a><br>译者：中山大学数学学院（珠海）林学渊<br>大二时给量子做的翻译，转载注明出处，谢谢</p><h1 id="以太坊的挑战者：量子链（QTUM）"><a href="#以太坊的挑战者：量子链（QTUM）" class="headerlink" title="以太坊的挑战者：量子链（QTUM）"></a>以太坊的挑战者：量子链（QTUM）</h1><p>– Guest Contributor</p><p><a href="https://twitter.com/bitgenstein" target="_blank" rel="noopener">Peter Keay</a> 是 <a href="https://twitter.com/icoalert" target="_blank" rel="noopener">ICO Alert</a> 的全球化总监，也是 Bitgenstein’s Table加密哲学播客节目的主持人。他是“以太坊的挑战者”系列作者。 这篇文章最初发表在<a href="https://blog.icoalert.com/the-ethereum-challengers-ep-6-qtum-qtum-d3278493c61d" target="_blank" rel="noopener">这里</a>。 该系列涵盖的其他竞争对手包括 <a href="https://bitgenste.in/rsk" target="_blank" rel="noopener">RSK</a>，<a href="https://bitgenste.in/eos" target="_blank" rel="noopener">EOS</a>和<a href="https://bitgenste.in/ada" target="_blank" rel="noopener">Cardano</a>。</p><p>很多加密货币用户和投资者都十分支持比特币或以太坊，甚至达到了“极端主义者”的程度。</p><p>极端主义者们认为，他们喜欢的币将占据市场主导地位并广泛应用，而所有其他加密货币最终都会消亡 - 或者只是作为主导币的测试网络。</p><p><img src="https://cdn-images-1.medium.com/max/640/1*WFAo_yOnaJnRnQNweUymow.jpeg" alt="有些人只看到辩论的幽默。"></p><p>实际上，BTC和ETH货币是当今最重要的数字资产，而且在可预见的未来可能也是如此。 然而比特币和以太坊是完全不同的，它们的优点和缺点都不一样。</p><p>所以，在2016年，一个简单的想法诞生了：</p><p>如果加密货币同时拥有比特币和以太坊的优点会怎样？</p><p><img src="https://cdn-images-1.medium.com/max/800/1*SXhk8TmWZlFV805WmRVgmw.png" alt="以太坊经典和比特币现金的优势，个人看法。（The Cryptos漫画）"></p><h2 id="遇见-Qtum。发音为“Quantum”"><a href="#遇见-Qtum。发音为“Quantum”" class="headerlink" title="遇见 Qtum。发音为“Quantum”"></a>遇见 Qtum。发音为“Quantum”</h2><blockquote><p>译者注：发音和中文“狂腾”相近</p></blockquote><p>Qtum 结合了比特币技术和以太坊技术。</p><p>在“以太坊的挑战者”的系列中，我已经为大多数挑战者做了一些相关概念的总结。 例如，我们讨论了<a href="https://bitgenste.in/rsk" target="_blank" rel="noopener">图灵完整性和侧链与RSK</a>，<a href="https://bitgenste.in/eos" target="_blank" rel="noopener">PoS和DPoS与EOS</a>，以及<a href="https://bitgenste.in/ada" target="_blank" rel="noopener">用Cardano的形式验证</a>。</p><p>自从 Qtum（请记住：在你的心里请读作“Quantum”）将其平台作为比特币和以太坊的结合来推广时，让我们来谈谈两个主要的区块链交易模型。 然后，我们将讨论 Qtum 的其他功能，包括一些近期的公告，并看看它如何处理我们的七大问题。</p><p>所以，首先是交易模型。比特币使用 UTXO 模型。 以太坊使用帐户模型。 Qtum 想两者都要。</p><h2 id="UTXO-模型（BTC）vs-账户模型"><a href="#UTXO-模型（BTC）vs-账户模型" class="headerlink" title="UTXO 模型（BTC）vs. 账户模型"></a>UTXO 模型（BTC）vs. 账户模型</h2><p>你是否曾把 BTC 从一个地址发送到另一个地址，结果在块浏览器中看到你的帐户实际发送了更多的BTC？</p><p>这是 UTXO 模型的工作原理决定的，但对于习惯帐户模型的人来说，这并不直观。 事实上，看你的地址，显然发送的 BTC 比告诉你的要多得多，这十分可怕。</p><p><img src="https://cdn-images-1.medium.com/max/640/1*-SBxQwqWIf1V5G94Uz1uCw.gif" alt="我把它交给了美联储。"></p><p>你习惯帐户模型，在那里你的帐户有余额。</p><p>例如，你的以太坊地址也是你的以太坊帐户。 你可以从余额中支出并接收余额付款。</p><p>虽然建议仅使用一次地址 - 出于隐私和安全的原因 - 实际上帐户模型会激励用户重复使用地址，因为这是最简单的用钱方式。</p><blockquote><p>以太坊账户类型：以太坊有两种账户：由私钥控制的账户 - 如果你使用ETH，则为你所有 - 以及由合约代码控制的账户。<br>私钥帐户制作并签署要发送给其他帐户的信息，而合约帐户会在收到信息时激活其代码以执行各种交易（包括发送其他信息，签订合约以及读取或写入自己的存储）。请注意，区块链中的“信息”包括交易。</p></blockquote><p>帐户模型使用类似于银行帐户的余额管理系统。</p><p>但是像比特币这样的 UTXO（Unspent Transaction Output，未花费的交易输出）模型是不同的。</p><p>用 UTXO 模型的感觉类似于你只用支票付款，一直持有直到你需要用掉它。</p><p><img src="https://cdn-images-1.medium.com/max/640/1*xY4xGhypSmxWvPgpdhwCPA.png" alt="比特币是你最卑微的仆人。 并且把财富作为支票的内容。"></p><p>正如你不能在银行只兑现支票的某一部分，而是必须兑现全部。在比特币里，一个地址收到一定钱后又只想只花掉其中一点，这样不行，它必须花掉所有的钱。</p><p>当你发送 BTC 时，你会花费 “vins” 并生成新的 “vouts”. UTXO 无法重复使用，所以通过花费 vins 并生成 vouts 后 UTXO 就被销毁了。</p><p>因此，如果你收到一个声称有 3.152 BTC 的 UTXO vin，然后发送 2.1 BTC，你实际上必须发送整个 3.152 BTC - 在这种情况下，作为两个 vouts：〜2.1给你的收件人和~1.052给你自己。 （小的采矿费会略微降低实际数量。）你收到的 3.152 BTC的 UTXO 已完成使命且无法重复使用，但 BTC 仍然存在于新的 UTXO 中。</p><p>在后台，你创建的 vout 脚本（发送）需要vin脚本的许可。 换句话说，为了花钱，你必须有一张有效的支票或多张支票，证明你过去收到过这笔钱（或者更多），并且支票一定不能撕掉。</p><p>因此，在帐户模型中，你的余额会被检查并借记和贷记，这不是比特币的工作方式。</p><p>如果你将BTC从Ledger钱包发送给其他人并在一个块代理商上检查交易，你可能已经注意到了这一点。</p><p>看似任意数量的BTC会被发送出去。 但你发送的实际金额将发送给收件人，剩余部分将转到一个你能控制的新地址。 你没有发送给收件人的BTC仍然是你的，但会被发送到新地址。</p><p>这是 UTXO 的工作原理决定的。 同样，如果你收到了两个分别为 1.1 BTC 和 0.8 BTC 的 UTXO，并且你想花费 1.3 BTC，那么两个 UTXO 都将 “被花费”，其余的将作为新的 UTXO 发送给你 - 在这种情况下，有 0.6 BTC，减去交易费用。</p><p>为什么这可能比简单的账户余额系统更好？</p><p>UTXO 模型激励用户限制他们对地址的重复使用，因为每次花费时 BTC 都会自动发送到新地址。</p><p>这样更安全，即使是对于<a href="https://bitgenste.in/quantum" target="_blank" rel="noopener">量子计算（quantum computing）</a>这样的进步也是如此，因为在你的地址开始使用之前，你的公钥不会泄露。 你的公共地址是公钥的哈希，而不是你的公钥本身，即使很多人错误地使用这些术语。 公钥和地址是相关但不同的东西。</p><p><img src="https://cdn-images-1.medium.com/max/640/1*9HAqy2m1Y0WHtSx2UQPvvw.png" alt="仅仅因为有人知道你的地址并不意味着他们有你的公钥。 除非你透露了它。"></p><p>但是，一旦地址开始花钱，该地址的公钥就会发布到区块链，因此理论上容易受到攻击，立刻就暴露了。 但是，如果地址的余额为空，即使成功攻击你的公钥也毫无价值 - 它发送到了你控制的新地址，并带有未公开的公钥 - 因此当BTC将“零钱”发送到新地址时，你将重新获得未知公钥安全上的好处。</p><p>一次性地址也具有隐私优势。 这种从地址到地址发送 BTC 的行为使得跟踪个人变得更加困难。 BTC 本身仍然可以很容易被跟踪，但在许多情况下，很难确定所涉及的大量地址的所有权。</p><p>其他代币以其他方式实现了类似或更高级别的隐私优势和安全性，不仅拥有这些优点，同时还保留了重复使用地址的便利性。 然而，这些代币在测试时间上没有比特币长，或者程度上没有比特币剧烈，并且他们的解决方案可能存在无法预料的复杂情况。</p><p>如果像以太坊这样的帐户模型加密货币的用户遵循仅使用每个地址一次的推荐做法，他们享有与UTXO提供的相同的安全和隐私权益。 但在比特币中，用户更有可能遵循这一最佳实践，因为它是默认行为。</p><blockquote><p>附注：这些优点不适用于不再受欢迎的单地址钱包。 单地址钱包将UTXO的“零钱”发送回同一地址。<br>它们适用于其他两种主要类型：<br>1）随机生成新地址的钱包，现在也不常见。 当发送BTC时，用过的UTXO的“零钱”被发送到新的随机地址。 这是有风险的，因为如果钱包丢失，自上次备份以来生成的随机地址也将丢失。</p></blockquote><p><img src="https://cdn-images-1.medium.com/max/640/1*aRc8XGDo6I7T_P0xmjMftw.jpeg" alt="而且，在至少一种情况下，密钥实际上不是随机生成的而是后来被盗。"></p><blockquote><p>2）能生成确定地址的钱包。 你今天用BTC的钱包可能会确定性地创建地址。 例如，硬件钱包和Electrum桌面钱包都是确定性的。 它们包含几乎无限的数学生成地址池。 无论何时发送BTC，这些钱包都会将用过的UTXO发送的“零钱”发送到新生成的地址。 确定性地址生成优于随机地址生成，因为一个种子可以重新生成所有相同的地址，从而提供更好的备份和恢复功能。</p></blockquote><h2 id="比特币的简单支付验证"><a href="#比特币的简单支付验证" class="headerlink" title="比特币的简单支付验证"></a>比特币的简单支付验证</h2><p>UTXO模型的一个优点是 SPV，(Simplified Payment Verification，简单支付验证），允许客户端验证一个交易是否包含在一个块中，而无需下载和验证整个区块链。</p><p>简而言之，希望下载的数据更少，因为任何人一旦把钱用出去，UTXO输出就会被遗忘。</p><p>块标题足以进行验证，因为它们可以提供 <a href="https://hackernoon.com/merkle-trees-181cb4bc30b4" target="_blank" rel="noopener">Merkle branchas</a> “包含证明（proof of inclusion）”在 Satoshi 的<a href="https://bitcoin.org/bitcoin.pdf" target="_blank" rel="noopener">原白皮书</a>中描述了 SPV 背后的想法，尽管不是所有的功能。</p><p>这种轻量级验证方法确实存在一些风险，但是 <a href="https://bitcoin.org/en/developer-guide#application-of-bloom-filters" target="_blank" rel="noopener">Bloom 过滤器</a>和连接到多个节点而不是一个节点的各种措施用于缓解此方法带来的安全问题。否则，轻型比特币客户端联系的完整节点可能会有<br>1) 通过假装不存在的交易欺骗用户或<br>2）获得所需的数据轻松跟踪比特币用户。</p><h2 id="结合两种模型：Qtum"><a href="#结合两种模型：Qtum" class="headerlink" title="结合两种模型：Qtum"></a>结合两种模型：Qtum</h2><p>Qtum 以 UTXO 模型及其 SPV 功能为基础运行，但增加了以太坊虚拟机 - 并且还支持其他虚拟机，我们稍后会介绍。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*xRqWbdSxhH6PKQOk4BLd5g.png" alt=""></p><p>此外，尽管 UTXO 模型（BTC，BCH，LTC和DGB都是UTXO代币的例子）不支持退款，但 Qtum 可以通过创建新输出来退款。 在以太坊设置 “gas 限制” 并获得所有未使用的有作用的 gas 退款，因为以太坊没有运行在 UTXO 模型上。 但Qtum已成功启用此退款功能，即使它基于比特币的交易模式。</p><p>使用比特币运行，Qtum 可以轻松采用比特币开发，如 SegWit 和闪电网络（Lightning Network），以及之后的<a href="https://github.com/bitcoin/bips" target="_blank" rel="noopener">比特币改进建议</a>。</p><p>使用以太坊的虚拟机运行，允许 Qtum 支持 Turing 完整的智能合约，这是比特币无法支持的。</p><h2 id="为什么比特币脚本不够用"><a href="#为什么比特币脚本不够用" class="headerlink" title="为什么比特币脚本不够用"></a>为什么比特币脚本不够用</h2><p>比特币的智能合约能力非常有限 - 尽管 RSK 和 CounterParty 正致力于以不同的方式在比特币区块链上实现智能合约。</p><p>特别是，比特币的脚本语言没有循环功能。 根据给定的变量，代码不能执行多次。 这一点或其他因素使比特币语言只能完成最简单的任务。</p><p>因此，Qtum 通过在比特币代码之上允许以太币虚拟机，在比特币代码库上实现图灵完备脚本 - 尽管不在实际比特币区块链上。</p><p>为了做到这一点，它中间需要多一层。</p><h2 id="Qtum-帐户抽象层"><a href="#Qtum-帐户抽象层" class="headerlink" title="Qtum 帐户抽象层"></a>Qtum 帐户抽象层</h2><p>为了使智能合约虚拟机及帐户模型适用于比特币的无帐户UTXO模型，Qtum包含了一个“帐户抽象层”。正如你可能想象的那样，让基于帐户的系统在无帐户底层上运行需要在 AAL（Account Abstract Layer，用户抽象层） 做一些复杂工作。</p><p>最终结果是为用户提供了 UTXO 和开发人员优势的图灵完备的以太坊虚拟机的优势。</p><p><img src="https://cdn-images-1.medium.com/max/640/1*VxxBCg15Nx_u7YLmPn06vg.png" alt="和区块链一样，它并不那么简单，但你 get 到了要点。"></p><h2 id="新操作码"><a href="#新操作码" class="headerlink" title="新操作码"></a>新操作码</h2><blockquote><p>操作码：代码行的一部分，用于标识将要执行的操作。 有关其他示例，请查看比特币的可用操作码。 这些操作码是比特币脚本语言的所有功能。</p></blockquote><p>寻求为比特币添加智能合约功能的解决方案，例如 RSK，通常需要一些新的操作码，且需要比特币来升级其代码。</p><p>Qtum 不需要比特币分支来添加新的操作码，因为它已经将比特币的代码分配到一个新项目中，因此能够简单地添加新的操作码。</p><blockquote><p>技术说明：Qtum仍然使用比特币脚本语言，但是三个新的操作码使虚拟机能够在此基础上运行</p><ul><li>OP_EXEC：执行特定的以太坊虚拟机字节码。</li><li>OP_EXEC_ASSIGN：与上述相同，可以包含合约地址和合约数据。它可选择将资金转移到智能合约上。</li><li>OP_TXHASH：推送当前执行的交易的ID哈希。<br>Qtum 必须允许智能合约在添加到区块链时立即执行，因此前两个操作码将以特殊优先级进行处理。</li></ul></blockquote><p>通过添加这些操作码及帐户抽象层，Qtum 成功允许比特币代码库支持以太坊虚拟机。</p><p>现在，任何以太坊应用程序都可以在Qtum上运行，并享受UTXO基础带来的好处。</p><p>但是等等……还有更多。</p><h2 id="权益证明，模板和向后兼容性"><a href="#权益证明，模板和向后兼容性" class="headerlink" title="权益证明，模板和向后兼容性"></a>权益证明，模板和向后兼容性</h2><p>Qtum对以太坊虚拟机的实现并不意味着它包含了以太坊的局限性。</p><p>像比特币一样，以太坊是建立在工作量证明之上的。节点消耗大量能量，首先解决非常困难的难题，并声称采矿奖励。我们在<a href="https://bitgenste.in/eos" target="_blank" rel="noopener">EOS第2章中</a>里讨论了的共识模型，包括工作量证明。</p><p>Qtum取而代之的是建立在 Peercoin（PPC）之上的 Proof of Stake 模型，这是第一个使用赌注模型生效的加密货币。</p><p><img src="https://cdn-images-1.medium.com/max/640/1*RyqgUQ-pGjYU47LX7LasHw.png" alt="Qtum延续了用权益证明征服强大神仙的悠久传统。"></p><p>Stof of Stake共识模型允许Qtum在没有高计算能力需求和每秒更多交易数的情况下运行。</p><p>如果您想详细阅读有关权益证明的信息，特别是与工作量证明相比较，我推荐以太坊团队成员撰写的<a href="https://github.com/ethereum/wiki/wiki/Proof-of-Stake-FAQ" target="_blank" rel="noopener">文章</a>。 不可否认，许多其他货币已经转移到了权益证明，以太坊计划在某些时候部分或全部这样做。</p><p>Qtum 还在实施模板以简化 dApp 开发 - 这是 NEM 等备选方案的重点，也是通过Crowd Machine 等项目引入以太坊的。</p><p>Qtum确实提供了一项功能，与 PoS 和模板不同，以太坊很可能永远不具备：向后兼容性。 Qtum 节点即使没有完全更新到最新版本的 Qtum，也可以参与共识。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*137VSsgkWHEwgn6lxK0tNA.png" alt=""></p><h2 id="Qtum-X86-虚拟机"><a href="#Qtum-X86-虚拟机" class="headerlink" title="Qtum X86 虚拟机"></a>Qtum X86 虚拟机</h2><p>Qtum AAL最着名的是允许使用以太坊虚拟机，但它也允许用其他虚拟机。</p><p>在5月23号，即本文发布的几个星期前，Qtum在<a href="https://blog.qtum.org/qtum-x86-virtual-machine-qtum-enterprise-version-progress-update-2ff249968e2b" target="_blank" rel="noopener">韩国 Qtum X86 虚拟机会议</a>上做了一个演讲。X86 VM 允许开发人员使用许多不同的编程语言。提到的C和C++已经支持了，其他像Rust, Python 和 Go 正在路上。</p><p>目前的Qtum路线图将 X86 集成放在 2018 年末。</p><h2 id="Qtum-Enterprise（Qtum-X）"><a href="#Qtum-Enterprise（Qtum-X）" class="headerlink" title="Qtum Enterprise（Qtum X）"></a>Qtum Enterprise（Qtum X）</h2><p>Qtum Enterprise（Qtum X）也在同一个5月23日的会议中描述，是一项旨在吸引企业的新举措。 Qtum X 将是一个权威证明（Proof of Authority）系统，允许每秒更多的交易。</p><p>Qtum X 和 Qtum 是独立的产品，至少目前是这样。 我还没有找到关于这两种产品是否可以互通的任何信息，即它们是否将共享相同的货币。</p><p>宣布之后可能还需要很长时间才能获得许多细节，特别是英语版，所以如果有读者有更多信息，我会十分感谢分享。</p><h2 id="连接到世界"><a href="#连接到世界" class="headerlink" title="连接到世界"></a>连接到世界</h2><p>除了Qtum X和X86虚拟机之外，Qtum还有许多其他项目正在开发中，旨在吸引开发人员和企业加入Qtum生态系统。</p><p>API。 模板。 功能齐全的SDK。 原子交换。 Qtum 卫星。</p><p>原子交换：将一种加密货币交易给另一种货币而不涉及任何第三方。 在典型的原子交换中，在一个区块链上启动时间锁定的智能合约。 如果另一方未在规定时间内交付所交易的货币，则该交易将被取消。</p><p>是的，我不是在开玩笑说卫星。 与Nexus一样，Qtum计划与SpaceChain合作发射卫星。 看来，与前者相比，Qtum在审查阻力之后，主要是在现阶段拉动宣传噱头 - 正如他们所说的那样，“无可争议地证明了我们决心成为世界领先的加密货币和区块链平台。”</p><p>好吧，让我们把话题带回地球。</p><h2 id="Qtum如何回答我们的七大问题？"><a href="#Qtum如何回答我们的七大问题？" class="headerlink" title="Qtum如何回答我们的七大问题？"></a>Qtum如何回答我们的七大问题？</h2><p><img src="https://cdn-images-1.medium.com/max/800/1*u1FBYguBW9JqCVrAL6l1JQ.png" alt=""></p><p>1.可扩展性</p><p>由于它是从比特币和以太坊构建的，因此Qtum每秒没有大量的交易。 权益证明（Proof of Stake）有助于实现 SegWit，将 TPS 提升至 60 左右。截至我看到的最新信息，Qtum 未来的可扩展性开发可能包括脱链渠道抑或类似于以太坊提议的分片的功能。 Qtum Enterprise（Qtum X）将使用授权证书来实现更高的交易吞吐量。 目前尚不清楚Qtum X和Qtum将如何或是否将在此时集成，但由于其可扩展性优势，企业可能对Qtum X感兴趣。</p><p><img src="https://cdn-images-1.medium.com/max/480/0*-sNt1eVMIsXAVRif" alt=""></p><p>2.治理</p><p>Qtum的股权证明，最初建立在PeerCoin开创性的PoS代码之上。Qtum确实有一个分散治理协议（DGP）。 Qtum X 将在权威证明上运行。</p><p>Qtum区块链基金会指导DGP范围之外的决策。</p><p>3.开发复杂性</p><p>虽然Qtum可以使用以太坊的EVM和Solidity，但新的Qtum X86虚拟机还是会允许 C 和 C++ 和之后其他语言比如 Ruby, Go, Python. 与以太坊不同，Qtum的EVM始终向后兼容。</p><p>eSML是Qtum的计划语言，具有正式的验证能力。我们在<a href="https://bitgenste.in/ada" target="_blank" rel="noopener">episode #3 (Cardano)</a>讨论了正式验证。正式验证是 Cardano 的主要关注点。 公平地说，一些第三方解决方案以及可能即将推出的 Casper 也将为以太坊引进正式验证。</p><p>4.时间轴</p><p>Qtum 很活跃，新的 X86 虚拟机将在今年晚些时候集成。 Qtum X（Qtum Enterprise）项目时间表在撰写本文时尚不清楚。</p><p>5.广义特征</p><p>如上所述，模板计划为应用程序开发人员提供通用功能，减少重复性工作和错误倾向。 除此之外，尚未出现广义特征。 随着X86虚拟机的集成，我不会惊讶于看到许多有趣的功能。</p><p>6.可采纳性</p><p>几个基本的 Qtum 可采用性功能已经到位，例如 Ledger 钱包集成，但由于以业务为中心的 Qtum X 仍处于早期开发阶段，我怀疑我们不会知道最终的 Qtum dApp 生态系统以及后来的游戏有多么对用户友好。</p><p>Qtum 确实有交易费用，但是像以太坊的费用一样，它们可能最终会被企业从用户那里抽象出来。 我没有找到有关 Qtum 上人类可读的地址计划的信息。</p><p>7.市场地位</p><p>据我所知，Qtum没有像我们迄今为止讨论过的大多数解决方案那样大的开发者社区。 然而，在Qtum上运行了一些dApp和ICO。 如果Qtum区块链基金会能够在加强Qtum营销的同时快速实现计划中的X86 VM，Qtum X和更多功能，那么它可能会使它们成为强大的以太坊挑战者。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*YbD8z2mQTGnDUvETLRg_WA.png" alt=""></p><p>当然，随着我们通过市值进一步向下移动，我们应该期待看到处于早期阶段的项目。 他们根本没有顶级项目那么多的嗡嗡声 - 也没有多少钱。</p><p>Qtum带来了其他智能合约平台的许多优势，以及它自己的一些重点。 因此，尽管我大声地认为Qtum确实需要一个新的标识，但我很高兴看到该项目的去向。</p><p>毕竟，在<a href="https://bitgenste.in/neo" target="_blank" rel="noopener">NEO的第4集</a>中，我们讨论了中国项目在中国的表现如何比外国项目更好。 事实上，好多了。 中国的强大优势可能会使Qtum成为以太坊的严峻挑战者。</p><p><img src="https://cdn-images-1.medium.com/max/640/1*8-ezmr50c9Frcnkc0ppQOg.gif" alt=""></p><p>与本系列中的所有平台一样，我将密切关注 Qtum 及 X86 VM 和 Qtum X 的发布。</p><p><a href="https://twitter.com/bitgenstein" target="_blank" rel="noopener">让我知道你对Twitter上Qtum的看法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;https://strategiccoin.com/the-ethereum-challengers-qtum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://strategiccoin.com/the-ethere
      
    
    </summary>
    
      <category term="区块链" scheme="http://xichen.pub/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://xichen.pub/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Qtum" scheme="http://xichen.pub/tags/Qtum/"/>
    
      <category term="翻译" scheme="http://xichen.pub/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】 深入理解以太坊虚拟机 - 如何解释一个智能合约的方法调用</title>
    <link href="http://xichen.pub/2018/06/30/2018-06-30-%E7%BF%BB%E8%AF%91-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%99%9A%E6%8B%9F%E6%9C%BA-EVM%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E7%AE%80%E4%BB%8B/"/>
    <id>http://xichen.pub/2018/06/30/2018-06-30-翻译-深入理解以太坊虚拟机-EVM汇编代码简介/</id>
    <published>2018-06-30T06:11:00.000Z</published>
    <updated>2019-04-01T15:18:44.228Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://medium.com/@hayeah/how-to-decipher-a-smart-contract-method-call-8ee980311603" target="_blank" rel="noopener">https://medium.com/@hayeah/how-to-decipher-a-smart-contract-method-call-8ee980311603</a><br>译者：中山大学数学学院（珠海）林学渊<br>大二时给量子做的翻译，转载注明出处，谢谢</p><h1 id="如何解释一个智能合约的方法调用"><a href="#如何解释一个智能合约的方法调用" class="headerlink" title="如何解释一个智能合约的方法调用"></a>如何解释一个智能合约的方法调用</h1><hr><p>在本系列的前几篇文章中，我们已经看到了 Solidity 如何在 EVM 存储中表示复杂的数据结构。但是如果没有办法与数据交互，数据就毫无用处。智能合约是数据与外部世界交互的中介。</p><p>在本文中，我们将看到 Solidity 和 EVM 如何使外部程序能够调用合约的方法并使其状态发生变化。</p><p>“外部程序” 不限于 DApp / JavaScript。 任何可以使用 HTTP RPC 与以太坊节点进行通信的程序都可以通过创建交易来与部署在区块链上的任何合约进行交互。</p><p>创建一个交易就像创建一个 HTTP 请求。 Web 服务器可以接受你的 HTTP 请求并更改数据库。同理，网络将接受一个交易，然后底层区块链扩展以包括状态的改变。</p><p>交易对于智能合约来说就像是 HTTP 请求对于 Web 服务。</p><p>如果对 EVM 汇编和 Solidity 的数据表示不熟悉，请参阅本系列以前的文章以了解更多信息：</p><ul><li><a href="https://medium.com/@hayeah/diving-into-the-ethereum-vm-6e8d5d2f3c30" target="_blank" rel="noopener">EVM汇编代码简介</a></li><li><a href="https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-2-storage-layout-bc5349cb11b7" target="_blank" rel="noopener">如何表示固定长度的数据类型</a></li><li><a href="https://medium.com/@hayeah/diving-into-the-ethereum-vm-the-hidden-costs-of-arrays-28e119f04a9b" target="_blank" rel="noopener">如何表示动态数据类型</a></li></ul><h1 id="合约交易"><a href="#合约交易" class="headerlink" title="合约交易"></a>合约交易</h1><p>我们来看一个将状态变量设置为 <code>0x1</code> 的交易。与之交互的合约有变量 <code>a</code> 的一个 setter 和一个 getter：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">  uint256 a;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setA</span><span class="params">(uint256 _a)</span> </span>&#123;</span><br><span class="line">    a = _a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getA</span><span class="params">()</span> <span class="title">returns</span><span class="params">(uint256)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该合约部署在测试网络Rinkeby上。可以使用 Etherscan 查看地址<a href="https://rinkeby.etherscan.io/address/0x62650ae5c5777d1660cc17fcd4f48f6a66b9a4c2#code" target="_blank" rel="noopener">0x62650ae5….</a></p><p>我创建了一个可以调用 <code>setA(1)</code> 的交易。可以在地址<a href="https://rinkeby.etherscan.io/tx/0x7db471e5792bbf38dc784a5b983ee6a7bbe3f1db85dd4daede9ee88ed88057a5" target="_blank" rel="noopener">0x7db471e5….</a>处查看此交易</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*IkWyWsud_E7DD6QfpPoKHQ.jpeg" alt=""></p><p>交易的输入数据是：<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>xee919d5000000000000000000000000000000000000000000000000000000<span class="number">00000000001</span></span><br></pre></td></tr></table></figure></p><p>对 EVM 来说，这仅仅是 36 个字节的原始数据。将它作为 <code>calldata</code> 传给未经处理的智能合约。如果智能合约是一个 Solidity 程序，那么它将这些输入字节解释为一个方法调用，并为 <code>setA(1)</code> 执行相应的汇编代码。</p><p>输入数据可以分解为两个子部分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法选择器 (4 bytes)</span></span><br><span class="line"><span class="number">0xee919d5</span></span><br><span class="line"><span class="comment"># 第一个参数 (32 bytes)</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000001</span></span><br></pre></td></tr></table></figure><p>前四个字节是方法选择器，其余部分是 32 字节块的方法参数。在这个例子里只有 1 个参数，值 <code>0x1</code>。</p><p>方法选择器是方法签名的 kecccak256 哈希。在这个例子里，方法签名是 <code>setA(uint256)</code> ，它是方法的名称和参数的类型。</p><p>我们用 Python 来计算一下方法选择器。首先，散列方法签名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 pyethereum https://github.com/ethereum/pyethereum/#installation</span></span><br><span class="line">&gt; <span class="keyword">from</span> ethereum.utils <span class="keyword">import</span> sha3</span><br><span class="line">&gt; sha3(<span class="string">"setA(uint256)"</span>).hex()</span><br><span class="line"><span class="string">'ee919d50445cd9f463621849366a537968fe1ce096894b0d0c001528383d4769'</span></span><br></pre></td></tr></table></figure><p>然后获取哈希的前4个字节：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; sha3(<span class="string">"setA(uint256)"</span>)[<span class="number">0</span>:<span class="number">4</span>].hex()</span><br><span class="line"><span class="string">'ee919d50'</span></span><br></pre></td></tr></table></figure><h1 id="应用程序二进制接口（ABI）"><a href="#应用程序二进制接口（ABI）" class="headerlink" title="应用程序二进制接口（ABI）"></a>应用程序二进制接口（ABI）</h1><p>就 EVM 而言，交易的输入数据（<code>calldata</code>）只是一个字节序列。EVM 没有内置的方法调用的支持。</p><p>智能合约可以选择通过结构化方式来处理输入数据以模拟方法调用，如前一节所述。</p><p>如果 EVM 上的语言对输入数据的解释达成一致，那么它们可以很容易地进行交互。<a href="https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI#formal-specification-of-the-encoding" target="_blank" rel="noopener">合约应用程序二进制接口</a>（ABI）指定了一种通用的编码方案。</p><p>我们已经知道 ABI 如何编码一个简单的方法调用，如 <code>setA(1)</code>。在后面的章节中，我们将看到有更复杂参数的方法调用是如何编码的。</p><h1 id="调用-Getter"><a href="#调用-Getter" class="headerlink" title="调用 Getter"></a>调用 Getter</h1><p>如果调用的方法改变了状态，那么整个网络都必须同意。这将需要一笔交易，并且会耗费 gas。</p><p>像 <code>getA()</code> 这样的 getter 方法不会改变任何东西。我们可以将方法调用发送到本地以太坊节点，而不是要求整个网络进行计算。 <code>eth_call</code> RPC 请求允许在本地模拟交易。这对只读方法或 gas 的使用评估非常有用。</p><p><code>eth_call</code> 就像缓存的 HTTP GET请求。</p><ul><li>它不会改变全局共识状态。</li><li>本地区块链（“cache”）可能有点过时。</li></ul><p>让我们发起一个 <code>eth_call</code> 调用 <code>getA</code> 方法，返回状态 <code>a</code>。</p><p>首先，计算出方法选择器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sha3(<span class="string">"getA()"</span>)[<span class="number">0</span>:<span class="number">4</span>].hex()</span><br><span class="line"><span class="string">'d46300fd'</span></span><br></pre></td></tr></table></figure><p>由于没有参数，输入数据本身就是方法选择器。 我们可以向任意一个以太坊节点发送 <code>eth_call</code> 请求。 在这个例子中，我们会将请求发送到由 infura.io 托管的公共以太坊节点：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -X POST \</span></span><br><span class="line">-H "Content-Type: application/json" \</span><br><span class="line">"https://rinkeby.infura.io/YOUR_INFURA_TOKEN" \</span><br><span class="line">--data '</span><br><span class="line">&#123;</span><br><span class="line">  "jsonrpc": "2.0",</span><br><span class="line">  "id": 1,</span><br><span class="line">  "method": "eth_call",</span><br><span class="line">  "params": [</span><br><span class="line">    &#123;</span><br><span class="line">      "to": "0x62650ae5c5777d1660cc17fcd4f48f6a66b9a4c2",</span><br><span class="line">      "data": "0xd46300fd"</span><br><span class="line">    &#125;,</span><br><span class="line">    "latest"</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">'</span><br></pre></td></tr></table></figure></p><p>EVM 执行计算并返回原始字节：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"jsonrpc"</span>:<span class="string">"2.0"</span>,</span><br><span class="line">  <span class="attr">"id"</span>:<span class="number">1</span>,</span><br><span class="line">  <span class="attr">"result"</span>:<span class="string">"0x0000000000000000000000000000000000000000000000000000000000000001"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 ABI，这些字节应该被解释为值 <code>0x1</code>。</p><h1 id="用于外部方法调用的汇编代码"><a href="#用于外部方法调用的汇编代码" class="headerlink" title="用于外部方法调用的汇编代码"></a>用于外部方法调用的汇编代码</h1><p>现在我们来看编译后的合约如何处理原始输入数据来进行方法调用的。 考虑定义了 <code>setA(uint256)</code> 的合约：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">  uint256 a;</span><br><span class="line">  <span class="comment">// 注意: `payable` 让汇编代码简单一点</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setA</span><span class="params">(uint256 _a)</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">    a = _a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">solc</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">bin</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">asm</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">optimize</span> <span class="comment">call</span><span class="string">.</span><span class="comment">sol</span></span><br></pre></td></tr></table></figure><p>被调用方法的汇编代码位于 <code>sub_0</code> 下的合约主体中：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">sub_0:</span> <span class="class">assembly </span>&#123;</span><br><span class="line">    mstore(<span class="number">0x40</span>, <span class="number">0x60</span>)</span><br><span class="line">    and(div(calldataload(<span class="number">0x0</span>), <span class="number">0x100000000000000000000000000000000000000000000000000000000</span>), <span class="number">0xffffffff</span>)</span><br><span class="line">    <span class="number">0xee919d50</span></span><br><span class="line">    dup2</span><br><span class="line">    eq</span><br><span class="line">    tag_2</span><br><span class="line">    jumpi</span><br><span class="line"><span class="symbol">  tag_1:</span></span><br><span class="line">    <span class="number">0x0</span></span><br><span class="line">    dup1</span><br><span class="line">    revert</span><br><span class="line"><span class="symbol">  tag_2:</span></span><br><span class="line">    tag_3</span><br><span class="line">    calldataload(<span class="number">0x4</span>)</span><br><span class="line">    jump(tag_4)</span><br><span class="line"><span class="symbol">  tag_3:</span></span><br><span class="line">    stop</span><br><span class="line"><span class="symbol">  tag_4:</span></span><br><span class="line">      <span class="comment">/* "call.sol":95:96  a */</span></span><br><span class="line">    <span class="number">0x0</span></span><br><span class="line">      <span class="comment">/* "call.sol":95:101  a = _a */</span></span><br><span class="line">    dup2</span><br><span class="line">    swap1</span><br><span class="line">    sstore</span><br><span class="line"><span class="symbol">  tag_5:</span></span><br><span class="line">    pop</span><br><span class="line">    jump <span class="comment">// out</span></span><br><span class="line"><span class="symbol">auxdata:</span> <span class="number">0xa165627a7a7230582016353b5ec133c89560dea787de20e25e96284d67a632e9df74dd981cc4db7a0a0029</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有两段与本次讨论无关的样板代码:</p><ul><li><code>mstore(0x40，0x60)</code> 位于顶部，用于保存内存中 sha3 哈希的前 64 个字节。无论合同是否需要，它总是存在的。</li><li><code>auxdata</code> 位于最底部，用于验证发布的源代码与部署的字节码是否相同。 这是可选的，但可以编译到编译器中。</li></ul><p>让我们将剩余的汇编代码分成两部分以便于分析：</p><ol><li>匹配选择器并跳转到方法。</li><li>加载参数，执行方法和从方法返回。</li></ol><p>首先，用于匹配选择器的汇编代码如下（带注释）：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载前 4 个字节作为方法选择器</span></span><br><span class="line"><span class="keyword">and</span>(<span class="built-in">div</span>(calldataload(<span class="number">0x0</span>), <span class="number">0x100000000000000000000000000000000000000000000000000000000</span>), <span class="number">0xffffffff</span>)</span><br><span class="line"><span class="comment">// 如果选择器匹配到 `0xee919d50`, 跳转到 setA</span></span><br><span class="line"><span class="number">0xee919d50</span></span><br><span class="line">dup2</span><br><span class="line"><span class="keyword">eq</span></span><br><span class="line">tag_2</span><br><span class="line">jumpi</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有匹配到的方法. 失败 &amp; 返回.</span></span><br><span class="line">tag_1:</span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">  dup1</span><br><span class="line">  revert</span><br><span class="line"><span class="comment">//  setA 方法的主体</span></span><br><span class="line">tag_2:</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>很直接，除了在开始从调用数据里加载 4 个字节的位交换。</p><p>为了清楚起见，低层次伪代码中的汇编逻辑如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">methodSelector = calldata[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line"><span class="keyword">if</span> methodSelector == <span class="string">"0xee919d50"</span>:</span><br><span class="line">  <span class="keyword">goto</span> tag_2 <span class="comment">// 跳转到 setA</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="comment">// 没有匹配到的方法. 失败 &amp; 返回.</span></span><br><span class="line">  revert</span><br></pre></td></tr></table></figure><p>实际方法调用的汇编代码（带注释）：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setA</span></span><br><span class="line"><span class="symbol">tag_2:</span></span><br><span class="line">  <span class="comment">// 方法调用后返回的位置</span></span><br><span class="line">  tag_3</span><br><span class="line">  <span class="comment">// 加载参数 (参数值为 0x1，0x4是地址，0x0~0x3是方法选择器).</span></span><br><span class="line">  calldataload(<span class="number">0x4</span>)</span><br><span class="line">  <span class="comment">// 执行</span></span><br><span class="line">  jump(tag_4)</span><br><span class="line"><span class="symbol">tag_4:</span></span><br><span class="line">  <span class="comment">// sstore(0x0, 0x1)</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">  dup2</span><br><span class="line">  swap1</span><br><span class="line">  sstore</span><br><span class="line"><span class="symbol">tag_5:</span></span><br><span class="line">  pop</span><br><span class="line">  <span class="comment">// 程序结束, 跳转到 tag_3 停止</span></span><br><span class="line">  jump</span><br><span class="line"><span class="symbol">tag_3:</span></span><br><span class="line">  <span class="comment">// 程序结束</span></span><br><span class="line">  stop</span><br></pre></td></tr></table></figure></p><p>在进入方法主体之前，汇编代码做了两件事：</p><ol><li>保存方法调用后返回的位置。</li><li>将来自调用数据的参数加载到堆栈上。</li></ol><p>低层次的伪代码：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存方法调用后返回的位置.</span></span><br><span class="line"><span class="variable">@returnTo</span> = tag_3</span><br><span class="line"><span class="attribute">tag_2</span>: <span class="comment">// setA</span></span><br><span class="line">  <span class="comment">// 将调用数据的参数加载到堆栈中.</span></span><br><span class="line">  <span class="variable">@arg1</span> = calldata[<span class="number">4</span>:<span class="number">4</span>+<span class="number">32</span>]</span><br><span class="line"><span class="attribute">tag_4</span>: <span class="comment">// a = _a</span></span><br><span class="line">  sstore(<span class="number">0</span>x0, <span class="variable">@arg1</span>)</span><br><span class="line">tag_5 <span class="comment">// return</span></span><br><span class="line">  jump(<span class="variable">@returnTo</span>)</span><br><span class="line"><span class="attribute">tag_3</span>:</span><br><span class="line">  stop</span><br></pre></td></tr></table></figure><p>将两部分组合在一起：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">methodSelector = calldata[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line"><span class="keyword">if</span> methodSelector == <span class="string">"0xee919d50"</span>:</span><br><span class="line">  goto tag_2 <span class="comment">// 跳转到 setA</span></span><br><span class="line"><span class="string">else:</span></span><br><span class="line">  <span class="comment">// 没有匹配的方法. 失败.</span></span><br><span class="line">  revert</span><br><span class="line"><span class="meta">@returnTo</span> = tag_3</span><br><span class="line"><span class="string">tag_2:</span> <span class="comment">// setA(uint256 _a)</span></span><br><span class="line">  <span class="meta">@arg</span>1 = calldata[<span class="number">4</span>:<span class="number">36</span>]</span><br><span class="line"><span class="string">tag_4:</span> <span class="comment">// a = _a</span></span><br><span class="line">  sstore(<span class="number">0x0</span>, <span class="meta">@arg</span>1)</span><br><span class="line">tag_5 <span class="comment">// return</span></span><br><span class="line">  jump(<span class="meta">@returnTo</span>)</span><br><span class="line"><span class="string">tag_3:</span></span><br><span class="line">  stop</span><br></pre></td></tr></table></figure></p><blockquote><p>有趣的花絮:返回的操作码是 <code>fd</code>。 但是你在黄皮书里找不到它的规范，或者在代码中实现。 实际上，<code>fd</code> 并不存在！ 这是一个无效的操作。 当 EVM 遇到无效操作时，它会因为副作用而放弃并恢复状态。</p></blockquote><h1 id="处理多个方法"><a href="#处理多个方法" class="headerlink" title="处理多个方法"></a>处理多个方法</h1><p>Solidity 编译器如何为具有多个方法的合同生成汇编代码？</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">pragma</span> solidity<span class="regexp"> ^0.4.11</span>;</span><br><span class="line"><span class="attribute">contract</span> C &#123;</span><br><span class="line">    <span class="attribute">uint256</span> a;</span><br><span class="line">    <span class="attribute">uint256</span> b;</span><br><span class="line">    <span class="attribute">function</span> setA(uint256 _a) &#123;</span><br><span class="line">      <span class="attribute">a</span> = _a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">function</span> setB(uint256 _b) &#123;</span><br><span class="line">      <span class="attribute">b</span> = _b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单。只是更多的 <code>if-else</code> 分支一个一个接上去：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// methodSelector = calldata[0:4]</span></span><br><span class="line">and(div(calldataload(<span class="number">0x0</span>), <span class="number">0x100000000000000000000000000000000000000000000000000000000</span>), <span class="number">0xffffffff</span>)</span><br><span class="line"><span class="comment">// if methodSelector == 0x9cdcf9b</span></span><br><span class="line"><span class="number">0x9cdcf9b</span></span><br><span class="line">dup2</span><br><span class="line">eq</span><br><span class="line">tag_2 <span class="comment">// SetB</span></span><br><span class="line">jumpi</span><br><span class="line"><span class="comment">// elsif methodSelector == 0xee919d50</span></span><br><span class="line">dup1</span><br><span class="line"><span class="number">0xee919d50</span></span><br><span class="line">eq</span><br><span class="line">tag_3 <span class="comment">// SetA</span></span><br><span class="line">jumpi</span><br></pre></td></tr></table></figure><p>伪代码：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">methodSelector = calldata[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line"><span class="keyword">if</span> methodSelector == <span class="string">"0x9cdcf9b"</span>:</span><br><span class="line">  <span class="keyword">goto</span> tag_2</span><br><span class="line"><span class="keyword">elsif</span> methodSelector == <span class="string">"0xee919d50"</span>:</span><br><span class="line">  <span class="keyword">goto</span> tag_3</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  // 没有匹配的方法. 失败.</span><br><span class="line">  revert</span><br></pre></td></tr></table></figure><h1 id="用于复杂方法调用的-ABI-编码"><a href="#用于复杂方法调用的-ABI-编码" class="headerlink" title="用于复杂方法调用的 ABI 编码"></a>用于复杂方法调用的 ABI 编码</h1><p><img src="https://cdn-images-1.medium.com/max/1600/1*EtXrxIQWOtodr4kw3TyJFA.jpeg" alt="别担心零。没事的。"></p><p>对于方法调用，交易的输入数据前四个字节总是方法选择器。 然后方法参数以 32 个字节的块为单位。 <a href="https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI" target="_blank" rel="noopener">ABI编码规范</a>详细说明了复杂类型参数是如何编码的，但读取会非常痛苦。</p><p>学习 ABI 编码的另一个策略是使用 <a href="https://github.com/ethereum/pyethereum/blob/4e945e2a24554ec04eccb160cff689a82eed7e0d/ethereum/abi.py" target="_blank" rel="noopener">pyethereum 的 ABI 编码函数</a>来研究如何对不同数据类型进行编码。 我们将从简单的案例开始，并构建更复杂的类型。</p><p>首先，导入 <code>encode_abi</code> 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ethereum.abi <span class="keyword">import</span> encode_abi</span><br></pre></td></tr></table></figure><p>对于有三个 uint256 参数的方法（例如 <code>foo(uint256 a，uint256 b，uint256 c)</code>），编码的参数就是一个接一个的 uint256 数字:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一个数组列出参数类型</span></span><br><span class="line"><span class="comment"># 第二个数组列出参数值</span></span><br><span class="line">&gt; encode_abi([<span class="string">"uint256"</span>, <span class="string">"uint256"</span>, <span class="string">"uint256"</span>],[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).hex()</span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000001</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000002</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br></pre></td></tr></table></figure><p>小于 32 个字节的数据类型填充为32个字节：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; encode_abi([<span class="string">"int8"</span>, <span class="string">"uint32"</span>, <span class="string">"uint64"</span>],[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).hex()</span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000001</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000002</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br></pre></td></tr></table></figure><p>对于定长数组，元素也是 32 字节的块（如果需要，填充 0 ），依次排列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; encode_abi(</span><br><span class="line">   [<span class="string">"int8[3]"</span>, <span class="string">"int256[3]"</span>],</span><br><span class="line">   [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line">).hex()</span><br><span class="line">// int8[<span class="number">3</span>]. 用 <span class="number">0</span> 填充到 <span class="number">32</span> bytes.</span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000001</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000002</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line">// int256[<span class="number">3</span>].</span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000004</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000005</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000006</span></span><br></pre></td></tr></table></figure><h1 id="动态数组的-ABI-编码"><a href="#动态数组的-ABI-编码" class="headerlink" title="动态数组的 ABI 编码"></a>动态数组的 ABI 编码</h1><p>ABI 引入了一个间接层来对动态数组进行编码，遵循称为<a href="https://github.com/ethereum/pyethereum/blob/4e945e2a24554ec04eccb160cff689a82eed7e0d/ethereum/abi.py#L735-L741" target="_blank" rel="noopener">头尾编码</a>的方案。</p><p>这个想法是，动态数组的元素封装在交易的 calldata 的尾部。 参数（“头部”）是对数组元素所在的 calldata 的引用。</p><p>如果我们调用一个含 3 个动态数组的方法，则参数会像这样编码（为了清晰起见添加了注释和换行符）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&gt; encode_abi(</span><br><span class="line">  [<span class="string">"uint256[]"</span>, <span class="string">"uint256[]"</span>, <span class="string">"uint256[]"</span>],</span><br><span class="line">  [[<span class="number">0xa1</span>, <span class="number">0xa2</span>, <span class="number">0xa3</span>], [<span class="number">0xb1</span>, <span class="number">0xb2</span>, <span class="number">0xb3</span>], [<span class="number">0xc1</span>, <span class="number">0xc2</span>, <span class="number">0xc3</span>]]</span><br><span class="line">).hex()</span><br><span class="line">/************* 头部 (<span class="number">32</span>*<span class="number">3</span> bytes) *************/</span><br><span class="line">// arg1: 查看位置 <span class="number">0x60</span> 寻找数组数据</span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000060</span></span><br><span class="line">// arg2: 查看位置 <span class="number">0xe0</span> 寻找数组数据</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000e0</span></span><br><span class="line">// arg3: 查看位置 <span class="number">0x160</span> 寻找数组数据</span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000160</span></span><br><span class="line">/************* 尾部 (<span class="number">128</span>**<span class="number">3</span> bytes) *************/</span><br><span class="line">// 位置 <span class="number">0x60</span>. arg1 的数据.</span><br><span class="line">// 长度后跟元素</span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>a1</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>a2</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>a3</span><br><span class="line">// 位置 <span class="number">0xe0</span>. arg2 的数据.</span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b1</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b2</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b3</span><br><span class="line">// 位置 <span class="number">0x160</span>. arg3 的数据.</span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>c1</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>c2</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>c3</span><br></pre></td></tr></table></figure><p>所以头部有三个 32 字节的参数，指向尾部的位置，它包含三个动态数组的实际数据。</p><p>例如，第一个参数是 <code>0x60</code>，指向 calldata 的第96个（<code>0x60</code>）字节。 如果你看第 96 个字节，它是一个数组的开始。 前 32 个字节是长度，后面是三个元素。</p><p>可以混合动态和静态参数。 这里有一个 <code>(静态, 动态, 静态)</code> 参数的例子。 静态参数按原样编码，而第二个动态数组的数据放置在尾部：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; encode_abi(</span><br><span class="line">  [<span class="string">"uint256"</span>, <span class="string">"uint256[]"</span>, <span class="string">"uint256"</span>],</span><br><span class="line">  [<span class="number">0xaaaa</span>, [<span class="number">0xb1</span>, <span class="number">0xb2</span>, <span class="number">0xb3</span>], <span class="number">0xbbbb</span>]</span><br><span class="line">).hex()</span><br><span class="line">/************* 头部 (<span class="number">32</span>*<span class="number">3</span> bytes) *************/</span><br><span class="line">// arg1: <span class="number">0xaaaa</span></span><br><span class="line"><span class="number">000000000000000000000000000000000000000000000000000000000000</span>aaaa</span><br><span class="line">// arg2: 查看数组数据的位置 <span class="number">0x60</span> </span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000060</span></span><br><span class="line">// arg3: <span class="number">0xbbbb</span></span><br><span class="line"><span class="number">000000000000000000000000000000000000000000000000000000000000</span>bbbb</span><br><span class="line">/************* 尾部 (<span class="number">128</span> bytes) *************/</span><br><span class="line">// 位置 <span class="number">0x60</span>. arg2 的数据.</span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b1</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b2</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b3</span><br></pre></td></tr></table></figure><p>很多零，但没关系。</p><h1 id="编码字节"><a href="#编码字节" class="headerlink" title="编码字节"></a>编码字节</h1><p>字符串和字节数组也用头尾编码。唯一的区别是这些字节以 32 字节的块形式紧密打包，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; encode_abi(</span><br><span class="line">  [<span class="string">"string"</span>, <span class="string">"string"</span>, <span class="string">"string"</span>],</span><br><span class="line">  [<span class="string">"aaaa"</span>, <span class="string">"bbbb"</span>, <span class="string">"cccc"</span>]</span><br><span class="line">).hex()</span><br><span class="line">// arg1: 查看位置 <span class="number">0x60</span> 寻找字符串数据</span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000060</span></span><br><span class="line">// arg2: 查看位置 <span class="number">0xa0</span> 寻找字符串数据</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>a0</span><br><span class="line">// arg3: 查看位置 <span class="number">0xe0</span> 寻找字符串数据</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000e0</span></span><br><span class="line">// <span class="number">0x60</span> (<span class="number">96</span>). arg1 的数据</span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000004</span></span><br><span class="line"><span class="number">6161616100000000000000000000000000000000000000000000000000000000</span></span><br><span class="line">// <span class="number">0xa0</span> (<span class="number">160</span>). arg2 的数据</span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000004</span></span><br><span class="line"><span class="number">6262626200000000000000000000000000000000000000000000000000000000</span></span><br><span class="line">// <span class="number">0xe0</span> (<span class="number">224</span>). arg3 的数据</span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000004</span></span><br><span class="line"><span class="number">6363636300000000000000000000000000000000000000000000000000000000</span></span><br></pre></td></tr></table></figure><p>对于每个字符串/字节数组，它前 32 个字节对​​长度进行编码，后跟字节。</p><p>如果字符串大于 32 字节，则使用多个 32 字节的块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// encode <span class="number">48</span> bytes of string data</span><br><span class="line">ethereum.abi.encode_abi(</span><br><span class="line">  [<span class="string">"string"</span>],</span><br><span class="line">  [<span class="string">"a"</span> * (<span class="number">32</span>+<span class="number">16</span>)]</span><br><span class="line">).hex()</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000020</span></span><br><span class="line">// 字符串长度是 <span class="number">0x30</span> (<span class="number">48</span>)</span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000030</span></span><br><span class="line"><span class="number">6161616161616161616161616161616161616161616161616161616161616161</span></span><br><span class="line"><span class="number">6161616161616161616161616161616100000000000000000000000000000000</span></span><br></pre></td></tr></table></figure><h1 id="嵌套数组"><a href="#嵌套数组" class="headerlink" title="嵌套数组"></a>嵌套数组</h1><p>嵌套数组，每个嵌套有一个间接寻址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt; encode_abi(</span><br><span class="line">  [<span class="string">"uint256[][]"</span>],</span><br><span class="line">  [[[<span class="number">0xa1</span>, <span class="number">0xa2</span>, <span class="number">0xa3</span>], [<span class="number">0xb1</span>, <span class="number">0xb2</span>, <span class="number">0xb3</span>], [<span class="number">0xc1</span>, <span class="number">0xc2</span>, <span class="number">0xc3</span>]]]</span><br><span class="line">).hex()</span><br><span class="line">// arg1: 外层数组位于 <span class="number">0x20</span>.</span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000020</span></span><br><span class="line">// <span class="number">0x20</span>. 每个元素都是一个内部数组的位置。</span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000060</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000e0</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000160</span></span><br><span class="line">// array[<span class="number">0</span>] at <span class="number">0x60</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>a1</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>a2</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>a3</span><br><span class="line">// array[<span class="number">1</span>] at <span class="number">0xe0</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b1</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b2</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b3</span><br><span class="line">// array[<span class="number">2</span>] at <span class="number">0x160</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>c1</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>c2</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>c3</span><br></pre></td></tr></table></figure><p>呀，很多零。</p><h1 id="gas-成本-amp-ABI-编码设计"><a href="#gas-成本-amp-ABI-编码设计" class="headerlink" title="gas 成本 &amp; ABI 编码设计"></a>gas 成本 &amp; ABI 编码设计</h1><p>为什么 ABI 将方法选择器截断为只有 4 个字节？ 如果不用 sha256 的全部 32 个字节，那么对于不同的方法是否会出现碰撞？ 如果截断是为了节省成本，为什么还要在方法选择器中节省 28 字节却让它浪费更多的零填充字节？</p><p>这两个设计选择似乎是矛盾的……直到我们考虑交易的 gas 成本。</p><ul><li>21000 支付给每笔交易</li><li>4 支付给交易的每个 0 字节数据或代码</li><li>68 支付给交易的每个非零数据或代码</li></ul><p>啊哈！ 零字节便宜17倍，所以零填充不是那么糟糕。</p><p>方法选择器是一个加密哈希，它是伪随机的。一个随机字符串往往会有大部分非零字节，因为每个字节只有 0.3％（1/255）的可能性为 0。</p><ul><li><p><code>0x1</code> 填充为 32 字节，成本 192 gas</p><p>4 * 31 (零字节) + 68 (1个非零字节)</p></li><li><p>sha256 很可能有 32 个非零字节，成本约为 2176 gas</p><p>32 * 68</p></li><li><p>sha256 截断为 4 个字节，成本约为 272 gas </p><p>32 * 4</p></li></ul><p>ABI 展示了另一个由 gas 成本结构激励的低级设计的例子。</p><h1 id="负整数…"><a href="#负整数…" class="headerlink" title="负整数…"></a>负整数…</h1><p>负整数通常使用称为<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%A3%9C%E6%95%B8" target="_blank" rel="noopener">补码</a>的方案来表示。int8 的 <code>-1</code> 编码全是1 <code>1111 1111</code>。</p><p>ABI 使用 1 来填充负整数，所以 -1 会填充为：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 16进制表示</span></span><br><span class="line">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span><br></pre></td></tr></table></figure><p>小负数主要是 1，因此耗费大量 gas。</p><p><code>¯\_(ツ)_/¯</code></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>要与智能合约交互，需要向其发送原始字节。它执行一些计算，可能会改变它自己的状态，然后返回原始字节。方法调用实际上不存在。 这是 ABI 创造的集体幻想。</p><p>ABI被指定为低级格式，但在功能上它更像是跨语言 RPC 框架的序列化格式。</p><p>我们可以在 DApp 和 Web App 的架构层之间进行类比：</p><ul><li>区块链就像支持数据库。</li><li>合约就像一个 web 服务。</li><li>交易就像一个请求。</li><li>ABI 是数据交换格式，如<a href="https://en.wikipedia.org/wiki/Protocol_Buffers" target="_blank" rel="noopener">协议缓冲区</a>。</li></ul><p>如果你喜欢这篇文章，你应该在Twitter @hayeah上关注我。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;https://medium.com/@hayeah/how-to-decipher-a-smart-contract-method-call-8ee980311603&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://
      
    
    </summary>
    
      <category term="区块链" scheme="http://xichen.pub/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://xichen.pub/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Qtum" scheme="http://xichen.pub/tags/Qtum/"/>
    
      <category term="翻译" scheme="http://xichen.pub/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】 深入理解以太坊虚拟机 - 如何表示动态数据类型</title>
    <link href="http://xichen.pub/2018/06/24/2018-06-24-%E7%BF%BB%E8%AF%91-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%A6%82%E4%BD%95%E8%A1%A8%E7%A4%BA%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://xichen.pub/2018/06/24/2018-06-24-翻译-深入理解以太坊虚拟机-如何表示动态数据类型/</id>
    <published>2018-06-24T06:11:00.000Z</published>
    <updated>2019-04-01T15:18:44.226Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://medium.com/@hayeah/diving-into-the-ethereum-vm-the-hidden-costs-of-arrays-28e119f04a9b" target="_blank" rel="noopener">https://medium.com/@hayeah/diving-into-the-ethereum-vm-the-hidden-costs-of-arrays-28e119f04a9b</a><br>译者：中山大学数学学院（珠海）林学渊<br>大二时给量子做的翻译，转载注明出处，谢谢</p><h1 id="如何表示动态数据类型"><a href="#如何表示动态数据类型" class="headerlink" title="如何表示动态数据类型"></a>如何表示动态数据类型</h1><p>数组的隐性成本</p><hr><p>Solidity 提供了我们熟悉的数据结构。除了简单的如数字和结构体，也有其他数据类型，它们能随着数据的添加而动态变化。3个主要的动态类型是：</p><ul><li>映射：<code>mapping(bytes32 =&gt; uint256)</code>，<code>mapping(address =&gt; string)</code>，等等。</li><li>数组：<code>[]uint256</code>，<code>[]byte</code>，等等。</li><li>字节数组：只有两种，字符串和字节。</li></ul><p>在本系列第二篇文章中，我们已经看到固定长度的简单类型在存储中是如何表示的。</p><ul><li>基础类型：<code>uint256</code>，<code>byte</code>，等等。</li><li>定长数组：<code>[10]uint8</code>，<code>[32]byte</code>，<code>bytes32</code>。</li><li>结构体：用以上两种类型组装而成。</li></ul><p>固定长度的存储变量在存储中一个接一个存储，尽可能轻量地打包成32字节的块。</p><blockquote><p>如果对这个不熟，我建议看: <a href="https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-2-storage-layout-bc5349cb11b7" target="_blank" rel="noopener">Diving Into The Ethereum VM Part II — Storage Cost</a></p></blockquote><p>在这篇文章中，我们深入理解 Solidity 是如何支持更多复杂的数据结构的。 Solidity 中的数组和映射可能看起来很熟悉，但它们的实现方式使它们具有本质的不同。</p><p>我们从映射开始，这是三者中最简单的一种。 事实证明，数组和字节数组只是有更多的功能的映射。</p><h1 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h1><p>在 <code>uint256 =&gt; uint256</code> 映射中存储一个值：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    mapping(<span class="function"><span class="params">uint256</span> =&gt;</span> uint256) items;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      items[<span class="number">0xC0FEFE</span>] = <span class="number">0x42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译:<br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">solc</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">bin</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">asm</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">optimize</span> <span class="comment">c</span><span class="literal">-</span><span class="comment">mapping</span><span class="string">.</span><span class="comment">sol</span></span><br></pre></td></tr></table></figure></p><p>汇编代码:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">  <span class="comment">// 什么也没干. 可以优化.</span></span><br><span class="line">  <span class="number">0xc0fef</span>e</span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">  swap1</span><br><span class="line">  dup2</span><br><span class="line">  mstore</span><br><span class="line">  <span class="number">0x20</span></span><br><span class="line">  mstore</span><br><span class="line">  <span class="comment">// 存储 0x42 到地址 0x798...187c</span></span><br><span class="line">  <span class="number">0x42</span></span><br><span class="line">  <span class="number">0x79826054ee948a209ff4a6c9064d7398508d2c1909a392f899d301c6d</span>232187c</span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure></p><p>我们可以将 EVM 存储视为键值对数据库，每个键限制为 32 个字节。不是直接使用键 <code>0xC0FEFE</code> ，而是将键散列为 <code>0x798...187c</code>，并将值 <code>0x42</code> 存储在那里。使用的哈希函数是 <code>keccak256（SHA256）</code>。</p><p>在这个例子里，我们没有看到 <code>keccak256</code> 指令，因为优化器已经预先计算结果并将其内联到字节码里了。可以从这些没用的 <code>mstore</code> 指令中看到这种计算的痕迹。</p><h1 id="计算地址"><a href="#计算地址" class="headerlink" title="计算地址"></a>计算地址</h1><p>让我们用一些 Python 代码来将 <code>0xC0FEFE</code> 散列为 <code>0x798...187c</code>。如果你想跟着做，你需要 Python 3.6，或者安装 <a href="https://pypi.python.org/pypi/pysha3" target="_blank" rel="noopener">pysha3</a> 来获得 <code>keccak_256</code> 哈希函数。</p><p>定义两个辅助函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> sha3</span><br><span class="line"><span class="comment"># 把一个数转化为 32 字节的数组</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bytes32</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> binascii.unhexlify(<span class="string">'%064x'</span> % i)</span><br><span class="line"><span class="comment"># 计算 32 字节数组的 keccak256 哈希</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">keccak256</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sha3.keccak_256(x).hexdigest()</span><br></pre></td></tr></table></figure><p>把一个数转化为 32 字节的数组:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; bytes32(1)</span></span><br><span class="line">b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01'</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; bytes32(0xC0FEFE)</span></span><br><span class="line">b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc0\xfe\xfe'</span><br></pre></td></tr></table></figure></p><p>用 <code>+</code> 运算把两个字节数组接在一起：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; bytes32(1) + bytes32(2)</span></span><br><span class="line">b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02'</span><br></pre></td></tr></table></figure></p><p>计算字节数组的 keccak256 哈希<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; keccak256(bytes(1))</span></span><br><span class="line">'bc36789e7a1e281436464229828f817d6612f7b477d66591ff96a9e064bcc98a'</span><br></pre></td></tr></table></figure></p><p>现在我们可以计算 <code>0x798...187c</code>了。</p><p>存储变量 <code>items</code> 的位置是 <code>0x0</code>（因为它是第一个存储变量）。要获取地址，将键 <code>0xc0fefe</code> 与 <code>items</code> 的位置接在一起：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># key = 0xC0FEFE, position = 0</span></span><br><span class="line">&gt;&gt;&gt; keccak256(bytes32(<span class="number">0</span>xC0FEFE) + bytes32(<span class="number">0</span>))</span><br><span class="line">'<span class="number">79826054</span>ee948a209ff4a6c<span class="number">9064</span>d<span class="number">739850</span>8d2c<span class="number">1909</span>a392f899d301c6d<span class="number">232187</span>c'</span><br></pre></td></tr></table></figure></p><p>计算一个键的存储地址的公式为：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keccak256(<span class="name">bytes32</span>(<span class="name">key</span>) + bytes32(<span class="name">position</span>))</span><br></pre></td></tr></table></figure></p><h1 id="2-个映射"><a href="#2-个映射" class="headerlink" title="2 个映射"></a>2 个映射</h1><p>让我们用公式来计算值会存储到哪个位置！假设我们有2个映射：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line">contract C &#123;</span><br><span class="line">    mapping(uint256 =&gt; uint256) itemsA;</span><br><span class="line">    mapping(uint256 =&gt; uint256) itemsB;</span><br><span class="line">    function C() &#123;</span><br><span class="line">      itemsA[0xAAAA] = 0xAAAA;</span><br><span class="line">      itemsB[0xBBBB] = 0xBBBB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>itemsA</code> 的位置为 <code>0</code>, 键为 <code>0xAAAA</code>:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> key = 0xAAAA, position = 0</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; keccak256(bytes32(0xAAAA) + bytes32(0))</span></span><br><span class="line">'839613f731613c3a2f728362760f939c8004b5d9066154aab51d6dadf74733f3'</span><br></pre></td></tr></table></figure></p><p><code>itemsB</code> 的位置为 <code>1</code>, 键为 <code>0xBBBB</code>:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> key = 0xBBBB, position = 1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; keccak256(bytes32(0xBBBB) + bytes32(1))</span></span><br><span class="line">'34cb23340a4263c995af18b23d9f53b67ff379ccaa3a91b75007b010c489d395'</span><br></pre></td></tr></table></figure></p><p>我们用编译器证明我们的计算：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> solc --bin --asm --optimize  c-mapping-2.sol</span></span><br></pre></td></tr></table></figure></p><p>汇编代码:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">tag_2:</span></span><br><span class="line">  // ... 忽略内存优化，可以优化掉</span><br><span class="line">  <span class="number">0xaaaa</span></span><br><span class="line">  <span class="number">0x839613f731613c3a2f728362760f939c8004b5d9066154aab51d6dadf74733f3</span></span><br><span class="line">  sstore</span><br><span class="line">  <span class="number">0xbbbb</span></span><br><span class="line">  <span class="number">0x34cb23340a4263c995af18b23d9f53b67ff379ccaa3a91b75007b010c489d395</span></span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure></p><p>和我们想的一样。</p><h1 id="汇编里的-KECCAK256"><a href="#汇编里的-KECCAK256" class="headerlink" title="汇编里的 KECCAK256"></a>汇编里的 KECCAK256</h1><p>编译器能预先计算一个键的地址，因为涉及的键是常量。如果键是一个变量，那么散列需要用汇编代码完成。现在我们要禁用这个优化，以便看到哈希如何在汇编中完成。</p><p>事实证明，通过引入一个额外变量 <code>i</code> 可以简化优化器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line">contract C &#123;</span><br><span class="line">    mapping(uint256 =&gt; uint256) items;</span><br><span class="line">    // 这个变量使常值优化失败</span><br><span class="line">    uint256 i = 0xC0FEFE;</span><br><span class="line">    function C() &#123;</span><br><span class="line">      items[i] = 0x42;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量位置还是 <code>0x0</code>, 所以我们认为地址和前面一样。</p><p>编译，但这次没有哈希预计算：<br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">$</span> <span class="comment">solc</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">bin</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">asm</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">optimize</span>  <span class="comment">c</span><span class="literal">-</span><span class="comment">mapping</span><span class="literal">-</span><span class="literal">-</span><span class="comment">no</span><span class="literal">-</span><span class="comment">constant</span><span class="literal">-</span><span class="comment">folding</span><span class="string">.</span><span class="comment">sol</span></span><br></pre></td></tr></table></figure></p><p>汇编代码:<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">  <span class="comment">// `i` 入栈</span></span><br><span class="line">  sload(<span class="number">0x1</span>)</span><br><span class="line">    [<span class="meta">0xC0FEFE</span>]</span><br><span class="line">  <span class="comment">// 存储键 `0xC0FEFE` 到内存 0x0, 准备哈希.</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">    [<span class="meta">0x0 0xC0FEFE</span>]</span><br><span class="line">  swap1</span><br><span class="line">    [<span class="meta">0xC0FEFE 0x0</span>]</span><br><span class="line">  dup2</span><br><span class="line">    [<span class="meta">0x0 0xC0FEFE 0x0</span>]</span><br><span class="line">  mstore</span><br><span class="line">    [<span class="meta">0x0</span>]</span><br><span class="line">    memory: &#123;</span><br><span class="line">      <span class="number">0x00</span> =&gt; <span class="number">0xC0FEFE</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 保持位置 `0x0` 到内存 0x20 (32), 准备哈希.</span></span><br><span class="line">  <span class="number">0x20</span> <span class="comment">// 32</span></span><br><span class="line">    [<span class="meta">0x20 0x0</span>]</span><br><span class="line">  dup2</span><br><span class="line">    [<span class="meta">0x0 0x20 0x0</span>]</span><br><span class="line">  swap1</span><br><span class="line">    [<span class="meta">0x20 0x0 0x0</span>]</span><br><span class="line">  mstore</span><br><span class="line">    [<span class="meta">0x0</span>]</span><br><span class="line">    memory: &#123;</span><br><span class="line">      <span class="number">0x00</span> =&gt; <span class="number">0xC0FEFE</span></span><br><span class="line">      <span class="number">0x20</span> =&gt; <span class="number">0x0</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 从第 0 个字节开始，依次哈希内存中接下来的 0x40 (64) 字节</span></span><br><span class="line">  <span class="number">0x40</span> <span class="comment">// 64</span></span><br><span class="line">    [<span class="meta">0x40 0x0</span>]</span><br><span class="line">  swap1</span><br><span class="line">    [<span class="meta">0x0 0x40</span>]</span><br><span class="line">  keccak256</span><br><span class="line">    [<span class="meta">0x798...187c</span>]</span><br><span class="line">  <span class="comment">// 保存 0x42 到计算地址</span></span><br><span class="line">  <span class="number">0x42</span></span><br><span class="line">    [<span class="meta">0x42 0x798...187c</span>]</span><br><span class="line">  swap1</span><br><span class="line">    [<span class="meta">0x798...187c 0x42</span>]</span><br><span class="line">  sstore</span><br><span class="line">    store: &#123;</span><br><span class="line">      <span class="number">0x798</span>..<span class="number">.187</span>c =&gt; <span class="number">0x42</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><code>mstore</code> 指令在内存中写入 32 个字节。 内存要便宜得多，只需要 3 gas 来读写。汇编代码前半部分通过将键和位置加载到相邻的内存块中来“连接”键和位置：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 0                   31  32                 63</span><br><span class="line">[<span class="string">    key (32 bytes)    </span>][<span class="symbol"> position (32 bytes) </span>]</span><br></pre></td></tr></table></figure></p><p>然后，<code>keccak256</code> 指令散列该内存区域中的数据。成本取决于有多少数据被散列：</p><ul><li>30 付给每个SHA3操作。</li><li>6 付给每个32字节的字。</li></ul><p>对于 <code>uint256</code> 键，gas 成本是 42（<code>30 + 6 * 2</code>）。</p><h1 id="映射大数值"><a href="#映射大数值" class="headerlink" title="映射大数值"></a>映射大数值</h1><p>每个存储单元只能存储 32 个字节。如果试图存储更大的结构会发生什么？</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0</span>.<span class="number">4</span>.<span class="number">11</span><span class="comment">;</span></span><br><span class="line">contract C &#123;</span><br><span class="line">    mapping(uint256 =&gt; Tuple) tuples<span class="comment">;</span></span><br><span class="line">    struct Tuple &#123;</span><br><span class="line">      uint256 a<span class="comment">;</span></span><br><span class="line">      uint256 <span class="keyword">b;</span></span><br><span class="line"><span class="keyword"> </span>     uint256 c<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    function C() &#123;</span><br><span class="line">      tuples[<span class="number">0x1</span>].a = <span class="number">0x1A</span><span class="comment">;</span></span><br><span class="line">      tuples[<span class="number">0x1</span>].<span class="keyword">b </span>= <span class="number">0x1B</span><span class="comment">;</span></span><br><span class="line">      tuples[<span class="number">0x1</span>].c = <span class="number">0x1C</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译，你可以看到 3 个 sstore 指令：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">tag_2:</span></span><br><span class="line">  // ...忽略未优化代码</span><br><span class="line">  <span class="number">0x1a</span></span><br><span class="line">  <span class="number">0xada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7d</span></span><br><span class="line">  sstore</span><br><span class="line">  <span class="number">0x1b</span></span><br><span class="line">  <span class="number">0xada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7e</span></span><br><span class="line">  sstore</span><br><span class="line">  <span class="number">0x1c</span></span><br><span class="line">  <span class="number">0xada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7f</span></span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure></p><p>注意，除了最后一位数字，计算出的地址都是相同的。<code>Tuple</code> 结构的字段一个接一个地排列（.7d，.7e，.7f）。</p><h2 id="映射不打包"><a href="#映射不打包" class="headerlink" title="映射不打包"></a>映射不打包</h2><p>由于映射的设计方式，即使只存储 1 个字节，每一项的最小存储量也是 32 个字节：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    mapping(uint256 =&gt; uint8) items;</span><br><span class="line">    function C() &#123;</span><br><span class="line">      items[<span class="number">0xA</span>] = <span class="number">0xAA</span>;</span><br><span class="line">      items[<span class="number">0xB</span>] = <span class="number">0xBB</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果值大于 32 字节，则以 32 字节为单位支付存储费用。</p><h1 id="动态数组是-Mappings"><a href="#动态数组是-Mappings" class="headerlink" title="动态数组是 Mappings++"></a>动态数组是 Mappings++</h1><p>（译者注：C和C++的梗）</p><p>在经典程序语言中，数组只是一个在内存中连续排列数据项的列表。假设你有一个含 100 个 <code>uint8</code> 元素的数组，那么它将占用 100 个字节的内存。在此方案中，将整个阵列批量加载到 CPU 缓存中并循环遍历项目很便宜。</p><p>对于大多数语言而言，数组比映射便宜。不过，对于 Solidity 而言，数组是一种更昂贵的映射。数组的数据项按顺序放置在存储中，如：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>x290d...e563</span><br><span class="line"><span class="number">0</span>x290d...e564</span><br><span class="line"><span class="number">0</span>x290d...e565</span><br><span class="line"><span class="number">0</span>x290d...e566</span><br></pre></td></tr></table></figure></p><p>但记住，每次对这些存储单元的访问实际上都是数据库中的键值查找。访问数组元素与访问映射元素没有区别。</p><p>考虑类型 <code>[] uint256</code>，它与映射（<code>uint256 =&gt; uint256</code>）基本相同，并增加了使其“类似数组”的功能：</p><ul><li><code>length</code> 表示有多少数据项。</li><li>绑定检查。读取或写入超出长度的索引时会引发错误。</li><li>比映射更复杂的存储打包行为。</li><li>数组缩小时自动释放未使用的存储单元。</li><li>对 <code>bytes</code> 和 <code>string</code> 进行特殊优化，使短数组（小于31字节）的存储效率更高。</li></ul><h1 id="简单数组"><a href="#简单数组" class="headerlink" title="简单数组"></a>简单数组</h1><p>我们来看看存储三个数据项的数组：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c-darray.sol</span></span><br><span class="line"><span class="selector-tag">pragma</span> <span class="selector-tag">solidity</span> ^<span class="selector-tag">0</span><span class="selector-class">.4</span><span class="selector-class">.11</span>;</span><br><span class="line"><span class="selector-tag">contract</span> <span class="selector-tag">C</span> &#123;</span><br><span class="line">    <span class="selector-tag">uint256</span><span class="selector-attr">[]</span> <span class="selector-tag">chunks</span>;</span><br><span class="line">    <span class="selector-tag">function</span> <span class="selector-tag">C</span>() &#123;</span><br><span class="line">      <span class="selector-tag">chunks</span><span class="selector-class">.push</span>(<span class="number">0</span>xAA);</span><br><span class="line">      <span class="selector-tag">chunks</span><span class="selector-class">.push</span>(<span class="number">0</span>xBB);</span><br><span class="line">      <span class="selector-tag">chunks</span><span class="selector-class">.push</span>(<span class="number">0</span>xCC);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>数组访问的汇编代码太复杂，无法跟踪。我们用 Remix 调试器来运行合约：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*9l0i7RLrlH0yq9BTb_oM-w.jpeg" alt=""></p><p>可以看到使用了 4 个存储单元：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">key:</span> <span class="number">0x0000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="symbol">value:</span> <span class="number">0x0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="symbol">key:</span> <span class="number">0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563</span></span><br><span class="line"><span class="symbol">value:</span> <span class="number">0x00000000000000000000000000000000000000000000000000000000000000aa</span></span><br><span class="line"><span class="symbol">key:</span> <span class="number">0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e564</span></span><br><span class="line"><span class="symbol">value:</span> <span class="number">0x00000000000000000000000000000000000000000000000000000000000000bb</span></span><br><span class="line"><span class="symbol">key:</span> <span class="number">0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e565</span></span><br><span class="line"><span class="symbol">value:</span> <span class="number">0x00000000000000000000000000000000000000000000000000000000000000cc</span></span><br></pre></td></tr></table></figure></p><p>一个块的位置是 <code>0x0</code>，它用于存储数组的长度（<code>0x3</code>）。散列变量的位置以查找数组数据项的地址：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> position = 0</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; keccak256(bytes32(0))</span></span><br><span class="line">'290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563'</span><br></pre></td></tr></table></figure></p><p>数组中的每个数据项都从该地址（<code>0x29..63</code>，<code>0x29..64</code>，<code>0x29..65</code>）开始顺序布局。</p><h1 id="动态数组打包"><a href="#动态数组打包" class="headerlink" title="动态数组打包"></a>动态数组打包</h1><p>你怎么看这些所有重要的打包行为？基于映射的数组的一个优点是打包。 四个数据项的 <code>uint128 []</code> 数组恰好填满两个存储单元（加 1 用于存储长度）。</p><p>考虑：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint128[] s;</span><br><span class="line">    function C() &#123;</span><br><span class="line">        s.length = <span class="number">4</span>;</span><br><span class="line">        s[<span class="number">0</span>] = <span class="number">0xAA</span>;</span><br><span class="line">        s[<span class="number">1</span>] = <span class="number">0xBB</span>;</span><br><span class="line">        s[<span class="number">2</span>] = <span class="number">0xCC</span>;</span><br><span class="line">        s[<span class="number">3</span>] = <span class="number">0xDD</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 Remix 上运行, 最终存储的状态是：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">key:</span> <span class="number">0x0000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="symbol">value:</span> <span class="number">0x0000000000000000000000000000000000000000000000000000000000000004</span></span><br><span class="line"><span class="symbol">key:</span> <span class="number">0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563</span></span><br><span class="line"><span class="symbol">value:</span> <span class="number">0x000000000000000000000000000000bb000000000000000000000000000000aa</span></span><br><span class="line"><span class="symbol">key:</span> <span class="number">0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e564</span></span><br><span class="line"><span class="symbol">value:</span> <span class="number">0x000000000000000000000000000000dd000000000000000000000000000000cc</span></span><br></pre></td></tr></table></figure></p><p>和我们想的一样，只用了 3 个存储单元。长度存储在 <code>0x0</code> 处，即存储变量的位置。四个数据项打包在两个独立的存储单元中。该数组的起始地址是变量位置的哈希值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> position = 0</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; keccak256(bytes32(0))</span></span><br><span class="line">'290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563'</span><br></pre></td></tr></table></figure><p>现在每增加两个数组元素，地址才会增加一次。看起来ok！</p><p>但汇编代码本身并没有得到很好的优化。由于只使用两个存储单元，因此我们希望优化器也只使用两个 <code>sstore</code> 进行分配。然而，在引入边界检查（以及其他）情况下，不可能优化 <code>sstore</code> 指令。</p><p>四个 <code>sstore</code> 指令用于分配：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* <span class="string">"c-bytes--sstore-optimize-fail.sol"</span>:<span class="number">105</span>:<span class="number">116</span>  s<span class="string">[0]</span> = 0xAA */</span><br><span class="line">sstore</span><br><span class="line">/* <span class="string">"c-bytes--sstore-optimize-fail.sol"</span>:<span class="number">126</span>:<span class="number">137</span>  s<span class="string">[1]</span> = 0xBB */</span><br><span class="line">sstore</span><br><span class="line">/* <span class="string">"c-bytes--sstore-optimize-fail.sol"</span>:<span class="number">147</span>:<span class="number">158</span>  s<span class="string">[2]</span> = 0xCC */</span><br><span class="line">sstore</span><br><span class="line">/* <span class="string">"c-bytes--sstore-optimize-fail.sol"</span>:<span class="number">168</span>:<span class="number">179</span>  s<span class="string">[3]</span> = 0xDD */</span><br><span class="line">sstore</span><br></pre></td></tr></table></figure><h1 id="字节数组-amp-字符串"><a href="#字节数组-amp-字符串" class="headerlink" title="字节数组 &amp; 字符串"></a>字节数组 &amp; 字符串</h1><p><code>bytes</code> 和 <code>string</code> 是分别针对字节和字符进行优化的特殊数组类型。如果数组的长度小于 31 个字节，则只用一个存储单元来存储整个数组。较长的字节数组与正常数组的表示方式大致相同。</p><p>我们来看一个实际使用的短字节数组：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// c-<span class="keyword">bytes--long.sol</span></span><br><span class="line"><span class="keyword">pragma </span>solidity ^<span class="number">0</span>.<span class="number">4</span>.<span class="number">11</span><span class="comment">;</span></span><br><span class="line"><span class="symbol">contract</span> C &#123;</span><br><span class="line">    <span class="keyword">bytes </span>s<span class="comment">;</span></span><br><span class="line">    <span class="meta">function</span> C() &#123;</span><br><span class="line">        s.<span class="keyword">push(0xAA);</span></span><br><span class="line"><span class="keyword"> </span>       s.<span class="keyword">push(0xBB);</span></span><br><span class="line"><span class="keyword"> </span>       s.<span class="keyword">push(0xCC);</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于数组只有 3 个字节（小于 31 个字节），因此它只占用一个存储单元。在 Remix 中运行，存储状态为：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">key:</span> <span class="number">0x0000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="symbol">value:</span> <span class="number">0xaabbcc0000000000000000000000000000000000000000000000000000000006</span></span><br></pre></td></tr></table></figure></p><p>数据 <code>0xaabbcc...</code> 从左到右存储。后面的 0 是空数据。最后一个字节 <code>0x06</code> 是数组的编码长度。 公式为 <code>encodedLength / 2 = length</code>。这种情况下，实际长度是 <code>6/2 = 3</code>。</p><p>字符串的工作方式和这个完全相同。</p><h1 id="长字节数组"><a href="#长字节数组" class="headerlink" title="长字节数组"></a>长字节数组</h1><p>如果数据量大于 31 字节，则字节数组就像 <code>[]byte</code>。让我们看看长度为 128 字节的字节数组：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c-bytes--long.sol</span></span><br><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    bytes s;</span><br><span class="line">    function C() &#123;</span><br><span class="line">        s.length = <span class="number">32</span> * <span class="number">4</span>;</span><br><span class="line">        s[<span class="number">31</span>] = <span class="number">0x1</span>;</span><br><span class="line">        s[<span class="number">63</span>] = <span class="number">0x2</span>;</span><br><span class="line">        s[<span class="number">95</span>] = <span class="number">0x3</span>;</span><br><span class="line">        s[<span class="number">127</span>] = <span class="number">0x4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 Remix 运行，可以看到存储里使用了 4 个存储单元：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0000</span>..<span class="number">.0000</span></span><br><span class="line"><span class="number">0x0000</span>..<span class="number">.0101</span></span><br><span class="line"><span class="number">0x290d</span>...e563</span><br><span class="line"><span class="number">0x0000</span>..<span class="number">.0001</span></span><br><span class="line"><span class="number">0x290d</span>...e564</span><br><span class="line"><span class="number">0x0000</span>..<span class="number">.0002</span></span><br><span class="line"><span class="number">0x290d</span>...e565</span><br><span class="line"><span class="number">0x0000</span>..<span class="number">.0003</span></span><br><span class="line"><span class="number">0x290d</span>...e566</span><br><span class="line"><span class="number">0x0000</span>..<span class="number">.0004</span></span><br></pre></td></tr></table></figure></p><p>存储单元 <code>0x0</code> 不再用于存储数据。整个存储单元现在存储编码后的数组长度。为了得到实际的长度，做 <code>length =（encodedLength - 1）/ 2</code>。在这种情况下，长度为 <code>128 =（0x101 - 1）/ 2</code>。实际字节存储在 <code>0x290d...e563</code> 中，以及按顺序排列的存储单元中。</p><p>字节数组的汇编代码非常大。除了正常的边界检查和调整数组大小的东西，它还要编码/解码长度，以及在长和短字节数组之间进行转换。</p><blockquote><p>为什么要对长度进行编码？因为这种方式有一个简单的方法来检测一个字节数组是短还是长。注意，长数组的编码长度总是奇数，短数组的编码长度总是偶数。汇编只需要查看最后一位，看它是零（偶/短）还是非零（奇/长）。</p></blockquote><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>查看 Solidity 编译器的内部工作，我们发现熟悉的数据结构（如映射和数组）与传统的编程语言的完全不同。</p><p>回顾一下：</p><ul><li>数组就像映射，效率不高。</li><li>比映射更复杂的汇编代码。</li><li>比较小类型（字节，uint8，字符串）映射更好的存储效率。</li></ul><p>汇编代码没有很好地优化。即使打包过了，还是每个分配要一个 <code>sstore</code> 。<br>EVM 存储是一个键值对数据库，非常像 git。如果你改变了任何东西，那么根节点的校验和就会改变。如果两个根节点具有相同的校验和，则存储的数据相同。</p><p>要了解 Solidity 和 EVM 的独特之处，可以想象数组中的每个元素都是一个文件在 git 存储库中。当你改变一个数组元素的值时，你实际上正在创建一个 git commit。在遍历数组时，无法一次加载整个数组，您必须查看存储库并分别查找每个文件。</p><p>不仅如此，每个文件被限制为 32 个字节！因为我们需要将数据结构分割成32个字节的块，所以 Solidity 的编译器由于各种逻辑和优化技巧而复杂化，所有这些都是在汇编中完成的。</p><p>然而，32 字节的限制完全是任意的。备份键值存储可以使用键存储任意数量的字节。也许在将来我们可以添加一个新的 EVM 指令来存储任意字节和一个关键字。</p><p>目前，EVM 存储是一个预先假定为32字节数组的键值对数据库。</p><p>请参阅 <a href="https://github.com/ethereum/solidity/blob/3b07c4d38e40c52ee8a4d16e56e2afa1a0f27905/libsolidity/codegen/ArrayUtils.cpp#L624" target="_blank" rel="noopener">ArrayUtils::resizeDynamicArray</a>，了解编译器在调整数组大小时的作用。通常情况下，数据结构将作为标准库的一部分在语言中完成，但在 Solidity 中，它会被烧录入编译器。</p><p>如果你喜欢这篇文章，你应该在 Twitter <a href="https://twitter.com/hayeah" target="_blank" rel="noopener">@hayeah</a> 上关注我。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;https://medium.com/@hayeah/diving-into-the-ethereum-vm-the-hidden-costs-of-arrays-28e119f04a9b&quot; target=&quot;_blank&quot; rel=&quot;noopener
      
    
    </summary>
    
      <category term="区块链" scheme="http://xichen.pub/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://xichen.pub/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Qtum" scheme="http://xichen.pub/tags/Qtum/"/>
    
      <category term="翻译" scheme="http://xichen.pub/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】 深入理解以太坊虚拟机 - 如何表示固定长度的数据类型</title>
    <link href="http://xichen.pub/2018/06/18/2018-06-18-%E7%BF%BB%E8%AF%91-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%A6%82%E4%BD%95%E8%A1%A8%E7%A4%BA%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://xichen.pub/2018/06/18/2018-06-18-翻译-深入理解以太坊虚拟机-如何表示固定长度的数据类型/</id>
    <published>2018-06-18T06:11:00.000Z</published>
    <updated>2019-04-01T15:18:44.225Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-2-storage-layout-bc5349cb11b7" target="_blank" rel="noopener">https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-2-storage-layout-bc5349cb11b7</a><br>译者：中山大学数学学院（珠海）林学渊<br>大二时给量子做的翻译，转载注明出处，谢谢</p><h1 id="如何表示固定长度的数据类型"><a href="#如何表示固定长度的数据类型" class="headerlink" title="如何表示固定长度的数据类型"></a>如何表示固定长度的数据类型</h1><p>我是怎样学会了担忧以及计算存储成本</p><hr><p>在本系列文章的第一篇中，我们看了一个简单 Solidity 合约的汇编代码：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">contract</span> C &#123;</span><br><span class="line">    <span class="attribute">uint256</span> a;</span><br><span class="line">    <span class="attribute">function</span> C() &#123;</span><br><span class="line">      <span class="attribute">a</span> = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该合约实际上是调用了 <code>sstore</code> 指令：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="function"><span class="title">sstore</span><span class="params">(<span class="number">0</span>x0, <span class="number">0</span>x1)</span></span></span><br></pre></td></tr></table></figure></p><ul><li>EVM 把值 0x1 保存在存储位置 0x0.</li><li>每个存储位置实际上能存 32 字节 (或者 256 比特).<blockquote><p>如果对这个不熟，我建议看: <a href="https://blog.qtum.org/diving-into-the-ethereum-vm-6e8d5d2f3c30" target="_blank" rel="noopener">Diving Into The Ethereum VM Part 1 — Assembly &amp; Bytecode</a></p></blockquote></li></ul><p>在本篇文章中，我们关注 Solidity 如何使用32字节的块来表示更多复杂的数据类型，比如结构体和数组。我们也能看到如何优化存储，及怎样可能优化失败。<br>在典型的程序语言中，理解数据类型在底层如何表示不是特别有用。但在 Solidity (或任何 EVM 语言) 这种知识至关重要，因为存储访问太贵了。</p><ul><li><code>sstore</code> 花费 20000 gas, 或者比基础算术指令贵约 5000倍.</li><li><code>sload</code> 花费 200 gas, 或者比基础算术指令贵约 100倍.</li></ul><p>对于“花费”，我们这里谈的是真钱，不仅仅是性能上的多少毫秒。运行和使用合约的花费中，<code>sstore</code> 和 <code>sload</code> 占主导地位！</p><h1 id="磁带解析"><a href="#磁带解析" class="headerlink" title="磁带解析"></a>磁带解析</h1><p><img src="https://cdn-images-1.medium.com/max/1600/1*BfkvMOBrd2aJQ46p9DeDtg.jpeg" alt="图灵机. Source: http://raganwald.com/"></p><p>构建通用计算机的两个基本要素：</p><ol><li>一种循环方式，无论是跳转还是递归。</li><li>无限内存</li></ol><p>EVM 汇编代码提供跳转，EVM 存储提供无限内存。这些对一切都够用了，包括模拟一个运行以太坊的世界，其以太坊又模拟了一个运行以太坊的世界…</p><p><img src="https://cdn-images-1.medium.com/max/1600/0*WmSMw86hQrhFLhCo.gif" alt="Diving Into The Microverse Battery"></p><p>EVM 存储一个合约像是一条没有尽头的磁带，磁带的每个单元有32字节，像这样：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">32 字节</span>][<span class="symbol">32 字节</span>][<span class="string">32 字节</span>]...</span><br></pre></td></tr></table></figure></p><p>我们会看到数据如何在无尽的磁带上变得生动起来的。</p><blockquote><p>磁带长度为 2²⁵⁶, 或者每个合约有大约10⁷⁷个单元。宇宙的可观测的粒子数是10⁸⁰。大约1000个合约就足以容纳所有质子，中子和电子。不要相信营销炒作，因为它比无限更短。</p></blockquote><h1 id="空白磁带"><a href="#空白磁带" class="headerlink" title="空白磁带"></a>空白磁带</h1><p>存储最初是空白的，默认为 0 。拥有无限磁带并不需要花费任何东西。</p><p>我们来看一个简单的合约来说明零价值行为：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">pragma</span> solidity<span class="regexp"> ^0.4.11</span>;</span><br><span class="line"><span class="attribute">contract</span> C &#123;</span><br><span class="line">    <span class="attribute">uint256</span> a;</span><br><span class="line">    <span class="attribute">uint256</span> b;</span><br><span class="line">    <span class="attribute">uint256</span> c;</span><br><span class="line">    <span class="attribute">uint256</span> d;</span><br><span class="line">    <span class="attribute">uint256</span> e;</span><br><span class="line">    <span class="attribute">uint256</span> f;</span><br><span class="line">    <span class="attribute">function</span> C() &#123;</span><br><span class="line">      <span class="attribute">f</span> = 0xc0fefe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>存储中的布局很简单。</p><ul><li>变量 <code>a</code> 位于位置 <code>0x0</code></li><li>变量 <code>b</code> 位于位置 <code>0x1</code></li><li>如此下去…<br>关键问题: 如果我们只用 <code>f</code>, 我们给 <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>, <code>e</code>花多少?<br>编译看一下：<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">$</span> <span class="comment">solc</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">bin</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">asm</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">optimize</span> <span class="comment">c</span><span class="literal">-</span><span class="comment">many</span><span class="literal">-</span><span class="comment">variables</span><span class="string">.</span><span class="comment">sol</span></span><br></pre></td></tr></table></figure></li></ul><p>汇编:<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sstore(0x5, 0xc0fefe)</span></span><br><span class="line"><span class="symbol">tag_2:</span></span><br><span class="line">  <span class="number">0xc0fefe</span></span><br><span class="line">  <span class="number">0x5</span></span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure></p><p>因此，存储变量的声明不需要任何费用，因为没有初始化。 Solidity 为该变量保留一个位置，并且只有当你存储某些内容时才支付 gas 。</p><p>在这种情况下，我们只为存储到 <code>0x5</code> 花钱。</p><p>如果我们手工编写汇编，我们可以任意选择存储位置而不必“扩展”存储：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入任意位置</span></span><br><span class="line"><span class="function"><span class="title">sstore</span><span class="params">(<span class="number">0</span>xc0fefe, <span class="number">0</span>x42)</span></span></span><br></pre></td></tr></table></figure><h1 id="读取-0"><a href="#读取-0" class="headerlink" title="读取 0"></a>读取 0</h1><p>你不仅可以在存储的任何位置写入，还可以立即从任何位置读取。读取未初始化的位置仅返回 <code>0x0</code> 。</p><p>让我们看一个读取未初始化位置的合约：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">pragma</span> solidity<span class="regexp"> ^0.4.11</span>;</span><br><span class="line"><span class="attribute">contract</span> C &#123;</span><br><span class="line">    <span class="attribute">uint256</span> a;</span><br><span class="line">    <span class="attribute">function</span> C() &#123;</span><br><span class="line">      <span class="attribute">a</span> = a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译:<br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">$</span> <span class="comment">solc</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">bin</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">asm</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">optimize</span> <span class="comment">c</span><span class="literal">-</span><span class="comment">zero</span><span class="literal">-</span><span class="comment">value</span><span class="string">.</span><span class="comment">sol</span></span><br></pre></td></tr></table></figure></p><p>汇编代码:<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">  <span class="comment">// sload(0x0) returning 0x0</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">  dup1</span><br><span class="line">  sload</span><br><span class="line">  <span class="comment">// a + 1; where a == 0</span></span><br><span class="line">  <span class="number">0x1</span></span><br><span class="line">  <span class="keyword">add</span></span><br><span class="line">  <span class="comment">// sstore(0x0, a + 1)</span></span><br><span class="line">  swap1</span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure></p><p>注意：生成从未初始化位置加载数据的代码是有效的。</p><p>然而，我们可以比 Solidity 编译器更聪明。由于我们知道<code>tag_2</code>是构造函数，并且从未写入过，所以我们可以用<code>0x0</code>替换<code>sload</code>序列。这可以省 5,000 gas。</p><h1 id="结构体的表示"><a href="#结构体的表示" class="headerlink" title="结构体的表示"></a>结构体的表示</h1><p>我们来看第一个复杂数据类型，一个有 6 个字段的结构体：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0</span>.<span class="number">4</span>.<span class="number">11</span><span class="comment">;</span></span><br><span class="line">contract C &#123;</span><br><span class="line">    struct Tuple &#123;</span><br><span class="line">      uint256 a<span class="comment">;</span></span><br><span class="line">      uint256 <span class="keyword">b;</span></span><br><span class="line"><span class="keyword"> </span>     uint256 c<span class="comment">;</span></span><br><span class="line">      uint256 d<span class="comment">;</span></span><br><span class="line">      uint256 e<span class="comment">;</span></span><br><span class="line">      uint256 f<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    Tuple t<span class="comment">;</span></span><br><span class="line">    function C() &#123;</span><br><span class="line">      t.f = <span class="number">0xC0FEFE</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>存储中的布局和状态变量一样。</p><ul><li>变量 <code>t.a</code> 位于位置 <code>0x0</code></li><li>变量 <code>t.b</code> 位于位置 <code>0x1</code></li><li>如此下去…</li></ul><p>和之前类似，我们可以直接向 <code>t.f</code> 写入而不用给初始化花钱。</p><p>编译：<br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">$</span> <span class="comment">solc</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">bin</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">asm</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">optimize</span> <span class="comment">c</span><span class="literal">-</span><span class="comment">struct</span><span class="literal">-</span><span class="comment">fields</span><span class="string">.</span><span class="comment">sol</span></span><br></pre></td></tr></table></figure></p><p>我们看到了一样的汇编代码：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">tag_2:</span></span><br><span class="line">  <span class="number">0xc0fefe</span></span><br><span class="line">  <span class="number">0x5</span></span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure></p><h1 id="定长数组"><a href="#定长数组" class="headerlink" title="定长数组"></a>定长数组</h1><p>声明一个定长数组：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint256[<span class="number">6</span>] numbers;</span><br><span class="line">    function C() &#123;</span><br><span class="line">      numbers[<span class="number">5</span>] = <span class="number">0xC0FEFE</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于编译器确切地知道有多少个 <code>uint256</code> （ 32 个字节），因此它可以简单地将数组元素放在存储器中，就像存储变量和结构体一样。</p><p>在这份合约中，我们再次存储到位置 <code>0x5</code> 。</p><p>编译：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ solc --bin --<span class="keyword">asm</span> --optimize c-<span class="keyword">static</span>-<span class="built_in">array</span>.sol</span><br></pre></td></tr></table></figure></p><p>汇编代码：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">tag_2:</span></span><br><span class="line">  <span class="number">0xc0fefe</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">  <span class="number">0x5</span></span><br><span class="line"><span class="symbol">tag_4:</span></span><br><span class="line">  <span class="keyword">add</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line"><span class="symbol">tag_5:</span></span><br><span class="line">  <span class="keyword">pop</span></span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure></p><p>它稍微长一些，但如果你稍微眯起一点，你会发现它实际上是一样的。我们手动进一步优化：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">tag_2:</span></span><br><span class="line">  <span class="number">0xc0fefe</span></span><br><span class="line">  // <span class="number">0</span>+<span class="number">5.</span> 用 <span class="number">0x5</span> 代替</span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">  <span class="number">0x5</span></span><br><span class="line">  <span class="keyword">add</span></span><br><span class="line">  // <span class="keyword">Push</span> then <span class="keyword">pop</span> immediately. Useless, just remove.</span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">  <span class="keyword">pop</span></span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure></p><p>除去标签和伪指令，我们再次得到相同的字节码序列：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">tag_2:</span></span><br><span class="line">  <span class="number">0xc0fefe</span></span><br><span class="line">  <span class="number">0x5</span></span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure></p><h1 id="数组边界检测"><a href="#数组边界检测" class="headerlink" title="数组边界检测"></a>数组边界检测</h1><p>我们已经看到，定长数组与结构体或状态变量两者具有相同的存储布局，但生成的汇编代码是不同的。原因是 Solidity 为数组访问生成了边界检查。</p><p>让我们再次编译数组合约，这次先关闭优化：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ solc --bin --<span class="keyword">asm</span> c-<span class="keyword">static</span>-<span class="built_in">array</span>.sol</span><br></pre></td></tr></table></figure></p><p>注释一下，在每条指令后打印机器状态：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">  <span class="number">0xc0fef</span>e</span><br><span class="line">    [<span class="number">0xc0fef</span>e]</span><br><span class="line">  <span class="number">0x5</span></span><br><span class="line">    [<span class="number">0x5</span> <span class="number">0xc0fef</span>e]</span><br><span class="line">  dup1</span><br><span class="line">  <span class="comment">/* 数组边界检测代码 */</span></span><br><span class="line">  <span class="comment">// 5 &lt; 6</span></span><br><span class="line">  <span class="number">0x6</span></span><br><span class="line">    [<span class="number">0x6</span> <span class="number">0x5</span> <span class="number">0xc0fef</span>e]</span><br><span class="line">  dup2</span><br><span class="line">    [<span class="number">0x5</span> <span class="number">0x6</span> <span class="number">0x5</span> <span class="number">0xc0fef</span>e]</span><br><span class="line">  lt</span><br><span class="line">    [<span class="number">0x1</span> <span class="number">0x5</span> <span class="number">0xc0fef</span>e]</span><br><span class="line">  <span class="comment">// bound_check_ok = 1 (TRUE)</span></span><br><span class="line">  <span class="comment">// if(bound_check_ok) &#123; goto tag5 &#125; else &#123; invalid &#125;</span></span><br><span class="line">  tag_5</span><br><span class="line">    [tag_5 <span class="number">0x1</span> <span class="number">0x5</span> <span class="number">0xc0fef</span>e]</span><br><span class="line">  jumpi</span><br><span class="line">    <span class="comment">// 测试情形是对的. 将跳转到 tag_5.</span></span><br><span class="line">    <span class="comment">// 并且 `jumpi` 消费了栈中 2 个元素.</span></span><br><span class="line">    [<span class="number">0x5</span> <span class="number">0xc0fef</span>e]</span><br><span class="line">  invalid</span><br><span class="line"><span class="comment">// 数组访问合法，继续</span></span><br><span class="line"><span class="comment">// stack: [0x5 0xc0fefe]</span></span><br><span class="line">tag_5:</span><br><span class="line">  sstore</span><br><span class="line">    []</span><br><span class="line">    storage: &#123; <span class="number">0x5</span> =&gt; <span class="number">0xc0fef</span>e &#125;</span><br></pre></td></tr></table></figure><p>现在可以看到边界检测代码了。编译器能够优化这些东西，但并不完美。</p><p>在本文的后面，我们将看到数组边界检测如何干扰编译器的优化，使得定长数组比存储变量或结构的效率低得多。</p><h1 id="打包行为"><a href="#打包行为" class="headerlink" title="打包行为"></a>打包行为</h1><p>存储很贵（啊啊啊我已经说一百万次了）。一个关键的优化是尽可能多地将数据打包到一个 32 字节的单元中。</p><p>考虑有四个存储变量（每个 64 比特）的合约，总共可以累加到 256 比特（ 32 字节）：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">pragma</span> solidity<span class="regexp"> ^0.4.11</span>;</span><br><span class="line"><span class="attribute">contract</span> C &#123;</span><br><span class="line">    <span class="attribute">uint64</span> a;</span><br><span class="line">    <span class="attribute">uint64</span> b;</span><br><span class="line">    <span class="attribute">uint64</span> c;</span><br><span class="line">    <span class="attribute">uint64</span> d;</span><br><span class="line">    <span class="attribute">function</span> C() &#123;</span><br><span class="line">      <span class="attribute">a</span> = 0xaaaa;</span><br><span class="line">      <span class="attribute">b</span> = 0xbbbb;</span><br><span class="line">      <span class="attribute">c</span> = 0xcccc;</span><br><span class="line">      <span class="attribute">d</span> = 0xdddd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们希望编译器只用一个 <code>sstore</code> ，所以将它们放在同一个存储单元中。</p><p>编译：<br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">$</span> <span class="comment">solc</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">bin</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">asm</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">optimize</span> <span class="comment">c</span><span class="literal">-</span><span class="comment">many</span><span class="literal">-</span><span class="comment">variables</span><span class="literal">-</span><span class="literal">-</span><span class="comment">packing</span><span class="string">.</span><span class="comment">sol</span></span><br></pre></td></tr></table></figure></p><p>汇编代码：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">tag_2:</span></span><br><span class="line">    /* <span class="string">"c-many-variables--packing.sol"</span>:<span class="number">121</span>:<span class="number">122</span>  a */</span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">    /* <span class="string">"c-many-variables--packing.sol"</span>:<span class="number">121</span>:<span class="number">131</span>  a = <span class="number">0xaaaa</span> */</span><br><span class="line">  dup1</span><br><span class="line">  sload</span><br><span class="line">    /* <span class="string">"c-many-variables--packing.sol"</span>:<span class="number">125</span>:<span class="number">131</span>  <span class="number">0xaaaa</span> */</span><br><span class="line">  <span class="number">0xaaaa</span></span><br><span class="line">  <span class="keyword">not</span>(<span class="number">0xffffffffffffffff</span>)</span><br><span class="line">    /* <span class="string">"c-many-variables--packing.sol"</span>:<span class="number">121</span>:<span class="number">131</span>  a = <span class="number">0xaaaa</span> */</span><br><span class="line">  swap1</span><br><span class="line">  swap2</span><br><span class="line">  <span class="keyword">and</span></span><br><span class="line">  <span class="keyword">or</span></span><br><span class="line">  <span class="keyword">not</span>(<span class="keyword">sub</span>(exp(<span class="number">0x2</span>, <span class="number">0x80</span>), exp(<span class="number">0x2</span>, <span class="number">0x40</span>)))</span><br><span class="line">    /* <span class="string">"c-many-variables--packing.sol"</span>:<span class="number">139</span>:<span class="number">149</span>  b = <span class="number">0xbbbb</span> */</span><br><span class="line">  <span class="keyword">and</span></span><br><span class="line">  <span class="number">0xbbbb0000000000000000</span></span><br><span class="line">  <span class="keyword">or</span></span><br><span class="line">  <span class="keyword">not</span>(<span class="keyword">sub</span>(exp(<span class="number">0x2</span>, <span class="number">0xc0</span>), exp(<span class="number">0x2</span>, <span class="number">0x80</span>)))</span><br><span class="line">    /* <span class="string">"c-many-variables--packing.sol"</span>:<span class="number">157</span>:<span class="number">167</span>  c = <span class="number">0xcccc</span> */</span><br><span class="line">  <span class="keyword">and</span></span><br><span class="line">  <span class="number">0xcccc00000000000000000000000000000000</span></span><br><span class="line">  <span class="keyword">or</span></span><br><span class="line">  <span class="keyword">sub</span>(exp(<span class="number">0x2</span>, <span class="number">0xc0</span>), <span class="number">0x1</span>)</span><br><span class="line">    /* <span class="string">"c-many-variables--packing.sol"</span>:<span class="number">175</span>:<span class="number">185</span>  d = <span class="number">0xdddd</span> */</span><br><span class="line">  <span class="keyword">and</span></span><br><span class="line">  <span class="number">0xdddd000000000000000000000000000000000000000000000000</span></span><br><span class="line">  <span class="keyword">or</span></span><br><span class="line">  swap1</span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure></p><p>有很多我无法破译的位交换，但不用在意这些细节。关键要注意的是，只用了一个 <code>sstore</code>。</p><p>优化成功！</p><h1 id="打破优化"><a href="#打破优化" class="headerlink" title="打破优化"></a>打破优化</h1><p>要是优化器可以一直完美工作就好了。让我们打破它。我们唯一的改变是我们使用帮助函数来设置存储变量：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0</span>.<span class="number">4</span>.<span class="number">11</span><span class="comment">;</span></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint64 a<span class="comment">;</span></span><br><span class="line">    uint64 <span class="keyword">b;</span></span><br><span class="line"><span class="keyword"> </span>   uint64 c<span class="comment">;</span></span><br><span class="line">    uint64 d<span class="comment">;</span></span><br><span class="line">    function C() &#123;</span><br><span class="line">      setAB()<span class="comment">;</span></span><br><span class="line">      setCD()<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    function setAB() internal &#123;</span><br><span class="line">      a = <span class="number">0xaaaa</span><span class="comment">;</span></span><br><span class="line">      <span class="keyword">b </span>= <span class="number">0xbbbb</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    function setCD() internal &#123;</span><br><span class="line">      c = <span class="number">0xcccc</span><span class="comment">;</span></span><br><span class="line">      d = <span class="number">0xdddd</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译<br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">$</span> <span class="comment">solc</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">bin</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">asm</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">optimize</span> <span class="comment">c</span><span class="literal">-</span><span class="comment">many</span><span class="literal">-</span><span class="comment">variables</span><span class="literal">-</span><span class="literal">-</span><span class="comment">packing</span><span class="literal">-</span><span class="comment">helpers</span><span class="string">.</span><span class="comment">sol</span></span><br></pre></td></tr></table></figure></p><p>汇编输出太多了。我们将忽略大部分细节并关注结构：<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span> 构造函数</span><br><span class="line">tag_2:</span><br><span class="line">  <span class="string">//</span> <span class="string">...</span></span><br><span class="line">  <span class="string">//</span> 跳转到 tag_5，调用 <span class="keyword">set</span>AB<span class="params">()</span> </span><br><span class="line">  jump</span><br><span class="line">tag_4:</span><br><span class="line">  <span class="string">//</span> <span class="string">...</span></span><br><span class="line">  <span class="string">//</span> 跳转到 tag_7，调用 <span class="keyword">set</span>CD<span class="params">()</span></span><br><span class="line">  jump</span><br><span class="line"><span class="string">//</span> 函数 <span class="keyword">set</span>AB<span class="params">()</span></span><br><span class="line">tag_5:</span><br><span class="line">  <span class="string">//</span> 位交换，设置 a, b</span><br><span class="line">  <span class="string">//</span> <span class="string">...</span></span><br><span class="line">  sstore</span><br><span class="line">tag_9:</span><br><span class="line">  jump  <span class="string">//</span> 返回 <span class="keyword">set</span>AB<span class="params">()</span> 的调用者</span><br><span class="line"><span class="string">//</span> 函数 <span class="keyword">set</span>CD<span class="params">()</span></span><br><span class="line">tag_7:</span><br><span class="line">  <span class="string">//</span> 位交换，设置 c, d</span><br><span class="line">  <span class="string">//</span> <span class="string">...</span></span><br><span class="line">  sstore</span><br><span class="line">tag_10:</span><br><span class="line">  jump  <span class="string">//</span> 返回 <span class="keyword">set</span>CD<span class="params">()</span> 的调用者</span><br></pre></td></tr></table></figure></p><p>现在有两个 <code>sstore</code> ，而不是一个。 Solidity 编译器可以在标签内进行优化，但不能跨标签进行优化。</p><blockquote><p>调用函数可能会花费更多，而不是太多，不仅因为函数调用很贵（它们只是跳转指令），而且因为 <code>sstore</code> 优化可能会失败。</p></blockquote><p>为了解决这个问题， Solidity 编译器需要学习如何内联函数，使得本质上得到的代码与不调用函数的相同：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">a</span> = <span class="number">0</span>xaaaa<span class="comment">;</span></span><br><span class="line"><span class="attribute">b</span> = <span class="number">0</span>xbbbb<span class="comment">;</span></span><br><span class="line"><span class="attribute">c</span> = <span class="number">0</span>xcccc<span class="comment">;</span></span><br><span class="line"><span class="attribute">d</span> = <span class="number">0</span>xdddd<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>如果我们仔细阅读完整的汇编输出，我们会看到函数 setAB（）和 setCD（）的汇编代码被包含了两次，使代码臃肿，还花费额外 gas 部署合约。我们稍后在了解合约生命周期时再讨论这一点。</p><h1 id="为什么优化器坏了"><a href="#为什么优化器坏了" class="headerlink" title="为什么优化器坏了"></a>为什么优化器坏了</h1><p>优化器不会跨标签进行优化。考虑 “1 + 1” ，如果在同一标签下，它可以优化为 <code>0x2</code> ：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 优化成功!</span><br><span class="line"><span class="symbol">tag_0:</span></span><br><span class="line">  <span class="number">0x1</span></span><br><span class="line">  <span class="number">0x1</span></span><br><span class="line">  <span class="keyword">add</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></p><p>但会优化失败，如果指令被标签分开了的话：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 优化失败!</span><br><span class="line"><span class="symbol">tag_0:</span></span><br><span class="line">  <span class="number">0x1</span></span><br><span class="line">  <span class="number">0x1</span></span><br><span class="line"><span class="symbol">tag_1:</span></span><br><span class="line">  <span class="keyword">add</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></p><p>这个行为在 0.4.13 版时是真的。以后可能会变。</p><h1 id="再次打破优化"><a href="#再次打破优化" class="headerlink" title="再次打破优化"></a>再次打破优化</h1><p>让我们看看优化失败的另一种方式。打包是否适用于定长数组？考虑：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint64[<span class="number">4</span>] numbers;</span><br><span class="line">    function C() &#123;</span><br><span class="line">      numbers[<span class="number">0</span>] = <span class="number">0x0</span>;</span><br><span class="line">      numbers[<span class="number">1</span>] = <span class="number">0x1111</span>;</span><br><span class="line">      numbers[<span class="number">2</span>] = <span class="number">0x2222</span>;</span><br><span class="line">      numbers[<span class="number">3</span>] = <span class="number">0x3333</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同样，我们希望只用一个 <code>sstore</code> 指令将 4 个 64 比特的数字打包到一个 32 字节的存储单元中。</p><p>编译后的汇编代码太长了。作为替代，计算 <code>sstore</code> 和 <code>sload</code> 指令的数量：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ solc --bin --<span class="keyword">asm</span> --optimize c-<span class="keyword">static</span>-<span class="keyword">array</span>--packing.sol | grep -E <span class="string">'(sstore|sload)'</span></span><br><span class="line">  sload</span><br><span class="line">  sstore</span><br><span class="line">  sload</span><br><span class="line">  sstore</span><br><span class="line">  sload</span><br><span class="line">  sstore</span><br><span class="line">  sload</span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure></p><p>嗷！不！！即使这个定长数组的存储布局与等效的结构体或存储变量完全相同，优化也会失败。它现在需要四对 <code>sload</code> 和 <code>sstore</code> 。</p><p>快速浏览汇编代码可以发现，每个数组访问都有边界检测代码，并在不同的标签下进行组织。但标签边界打破了优化。</p><p>然而有一点小小的安慰的是，3 个额外的 <code>sstore</code> 指令比第一个便宜：</p><ul><li><code>sstore</code> 花费 20,000 gas用于第一次写入新位置。</li><li><code>sstore</code> 花费 5,000 gas用于后续写入现有位置。</li></ul><p>所以这个特定优化的失败花费我们 35k 而不是 20k ，多了 75％ 。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>如果 Solidity 编译器能够计算出存储变量的大小，它只须简单地将它们放在一个接一个的存储空间中。如果可能的话，编译器将数据紧密地打包成32字节的块。</p><p>总结我们目前为止看到的打包行为：</p><ul><li>存储变量：有。</li><li>结构字段：有。</li><li>定长数组：无。理论上，有。</li></ul><p>由于存储访问成本非常高，因此应该将存储变量视为数据库架构。在编写合约时，可能会很有用的是做小型实验，并检查汇编代码以确定编译器是否正在优化。</p><p>可以肯定， Solidity 编译器将来会有所改进。不幸的是，现在我们还不能盲目信任它的优化器。</p><p>理解存储变量要花钱，字面意思，花钱。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-2-storage-layout-bc5349cb11b7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;htt
      
    
    </summary>
    
      <category term="区块链" scheme="http://xichen.pub/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://xichen.pub/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Qtum" scheme="http://xichen.pub/tags/Qtum/"/>
    
      <category term="翻译" scheme="http://xichen.pub/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】 深入理解以太坊虚拟机 - EVM汇编代码简介</title>
    <link href="http://xichen.pub/2018/06/12/2018-06-12-%E7%BF%BB%E8%AF%91-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%99%9A%E6%8B%9F%E6%9C%BA-EVM%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E7%AE%80%E4%BB%8B/"/>
    <id>http://xichen.pub/2018/06/12/2018-06-12-翻译-深入理解以太坊虚拟机-EVM汇编代码简介/</id>
    <published>2018-06-12T06:11:00.000Z</published>
    <updated>2019-04-01T15:18:44.223Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://blog.qtum.org/diving-into-the-ethereum-vm-6e8d5d2f3c30" target="_blank" rel="noopener">https://blog.qtum.org/diving-into-the-ethereum-vm-6e8d5d2f3c30</a><br>译者：中山大学数学学院（珠海）林学渊<br>大二时给量子做的翻译，转载注明出处，谢谢</p><h1 id="EVM汇编代码简介"><a href="#EVM汇编代码简介" class="headerlink" title="EVM汇编代码简介"></a>EVM汇编代码简介</h1><hr><p>Solidity 提供了很多高级语言抽象，但这些功能很难让我理解程序运行时到底发生了什么。阅读 Solidity 的文档仍然使我对一些基础的东西感到疑惑。</p><p>string, bytes32, byte[], bytes 有什么区别?</p><ul><li>什么时候应该用哪个？</li><li>把 string 转为 bytes 发生了什么？转为 byte[] 呢？</li><li>这些需要多少 gas ？</li></ul><p>mapping 在以太坊虚拟机里是怎么存的？</p><ul><li>为什么不能把 mapping 删了？</li><li>能构建 maping 到 maping 的数据结构吗？(当然可以，但这是怎么实现的？)</li><li>为什么有存储 mapping ，但是没有内存 mapping ?</li></ul><p>编译后的合约在以太坊虚拟机里长什么样？</p><ul><li>合约如何创建？</li><li>构造方法是什么？真的吗？</li><li>回退函数是什么？</li></ul><p>我想，学习一门在以太坊虚拟机( EVM )上运行的高级语言如 Solidity 会是一个好的自我投资。有以下原因。</p><ol><li>Solidity 不是最后一门语言。更好的 EVM 语言正在到来。(漂亮，对不对？)</li><li>EVM是个数据库引擎。理解用任意一种 EVM 语言写的智能合约前，必须理解数据是如何被组织、存储和操控的。</li><li>了解如何成为一个贡献者。以太坊工具链刚刚起步，深入理解EVM会帮助你给你自己或其他人造出惊艳的工具。</li><li>智力挑战。EVM使得你能在密码学、数据结构和程序语言设计的交汇处获得最佳实践。</li></ol><p>在本系列文章中，我会解构一些简单的 Solidity 智能合约，以便理解它们作为 EVM 字节码时如何工作。</p><p>我希望学习和写作的要点：</p><ul><li>EVM 字节码的基础</li><li>不同数据类型( mapping, array )的表现形式</li><li>合约创建时发生了什么</li><li>一个方法调用时发生了什么</li><li>ABI 桥如何区别了 EVM 语言</li></ul><p>我的终极目标是能够完全理解一个编译后的 Solidity 合约。先从一些基础的 EVM 字节码开始阅读吧！</p><p>一个有用的引用：<a href="https://gist.github.com/hayeah/bd37a123c02fecffbe629bf98a8391df" target="_blank" rel="noopener">EVM 指令集</a></p><h1 id="一个简单的智能合约"><a href="#一个简单的智能合约" class="headerlink" title="一个简单的智能合约"></a>一个简单的智能合约</h1><p>我们的第一个合约有构造函数和一个常量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// c1.sol</span><br><span class="line">pragma solidity ^0.4.11;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint256 a;</span><br><span class="line">    function C() &#123;</span><br><span class="line">      a = 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用 <code>solc</code> 命令编译：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">$ solc --<span class="keyword">bin </span>--asm <span class="built_in">c1</span>.sol</span><br><span class="line">======= <span class="built_in">c1</span>.sol:C =======</span><br><span class="line"><span class="symbol">EVM</span> assembly:</span><br><span class="line">    <span class="comment">/* "c1.sol":26:94  contract C &#123;... */</span></span><br><span class="line">  mstore(<span class="number">0x40</span>, <span class="number">0x60</span>)</span><br><span class="line">    <span class="comment">/* "c1.sol":59:92  function C() &#123;... */</span></span><br><span class="line">  jumpi(tag_1, iszero(callvalue))</span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">  dup1</span><br><span class="line">  <span class="keyword">revert</span></span><br><span class="line"><span class="keyword">tag_1:</span></span><br><span class="line"><span class="keyword">tag_2:</span></span><br><span class="line"><span class="keyword"> </span>   <span class="comment">/* "c1.sol":84:85  1 */</span></span><br><span class="line">  <span class="number">0x1</span></span><br><span class="line">    <span class="comment">/* "c1.sol":80:81  a */</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">    <span class="comment">/* "c1.sol":80:85  a = 1 */</span></span><br><span class="line">  dup2</span><br><span class="line">  swap1</span><br><span class="line">  sstore</span><br><span class="line">  <span class="keyword">pop</span></span><br><span class="line"><span class="keyword"> </span>   <span class="comment">/* "c1.sol":59:92  function C() &#123;... */</span></span><br><span class="line"><span class="symbol">tag_3</span>:</span><br><span class="line">    <span class="comment">/* "c1.sol":26:94  contract C &#123;... */</span></span><br><span class="line"><span class="symbol">tag_4</span>:</span><br><span class="line">  dataSize(<span class="keyword">sub_0)</span></span><br><span class="line"><span class="keyword"> </span> dup1</span><br><span class="line">  dataOffset(<span class="keyword">sub_0)</span></span><br><span class="line"><span class="keyword"> </span> <span class="number">0x0</span></span><br><span class="line">  codecopy</span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">  return</span><br><span class="line"><span class="symbol">stop</span></span><br><span class="line"><span class="keyword">sub_0: </span>assembly &#123;</span><br><span class="line">        <span class="comment">/* "c1.sol":26:94  contract C &#123;... */</span></span><br><span class="line">      mstore(<span class="number">0x40</span>, <span class="number">0x60</span>)</span><br><span class="line"><span class="symbol">    tag_1:</span></span><br><span class="line">      <span class="number">0x0</span></span><br><span class="line">      dup1</span><br><span class="line">      <span class="keyword">revert</span></span><br><span class="line"><span class="keyword">auxdata: </span><span class="number">0xa165627a7a72305820af3193f6fd31031a0e0d2de1ad2c27352b1ce081b4f3c92b5650ca4dd542bb770029</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">Binary:</span></span><br><span class="line"><span class="keyword">60606040523415600e57600080fd5b5b60016000819055505b5b60368060266000396000f30060606040525b600080fd00a165627a7a72305820af3193f6fd31031a0e0d2de1ad2c27352b1ce081b4f3c92b5650ca4dd542bb770029</span></span><br></pre></td></tr></table></figure><p>数字 <code>6060604052...</code> 是 EVM 真正运行的字节码。</p><h1 id="蹒跚学步"><a href="#蹒跚学步" class="headerlink" title="蹒跚学步"></a>蹒跚学步</h1><p>一半的汇编是模板，以至于在大多数 Solidity 程序中都一样。我们等下再来看这些。现在，我们来实验我们合约独特的一部分，存储变量的声明：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">a</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>这个声明的字节码表示是 <code>6001600081905550</code> 。根据指令换行：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">60 </span><span class="number">01</span></span><br><span class="line"><span class="symbol">60 </span><span class="number">00</span></span><br><span class="line"><span class="number">81</span></span><br><span class="line"><span class="number">90</span></span><br><span class="line"><span class="number">55</span></span><br><span class="line"><span class="number">50</span></span><br></pre></td></tr></table></figure></p><p>EVM 底层循环是从上到下运行每一条指令。<br>我们注释一下汇编代码(以 <code>tag_2</code> 开头)以便阅读：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">tag_2:</span></span><br><span class="line">  <span class="comment">// 60 01</span></span><br><span class="line">  <span class="number">0x1</span></span><br><span class="line">  <span class="comment">// 60 00</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">  <span class="comment">// 81</span></span><br><span class="line">  dup2</span><br><span class="line">  <span class="comment">// 90</span></span><br><span class="line">  swap1</span><br><span class="line">  <span class="comment">// 55</span></span><br><span class="line">  sstore</span><br><span class="line">  <span class="comment">// 50</span></span><br><span class="line">  pop</span><br></pre></td></tr></table></figure></p><p>注意汇编中的 <code>0x1</code> 实际上是 <code>push(0x1)</code> 的缩写。这条指令表示吧数字 <code>1</code> 入栈。</p><p>如果只盯着这个看，很难捕获到发生了什么。不要担心，模仿 EVM 一行一行地走，很简单的。</p><h1 id="模仿-EVM"><a href="#模仿-EVM" class="headerlink" title="模仿 EVM"></a>模仿 EVM</h1><p>EVM 是堆栈机器。指令可以使用栈中的值作为参数，也可以把某一些值入栈作为结果。举个例子， <code>add</code> 指令。</p><p>假设栈中有 2 个值：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure></p><p>当 EVM 看到 <code>add</code> 时，它把栈顶的 2 项出栈相加，然后把结果入栈回去，操作后：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">3</span>]</span><br></pre></td></tr></table></figure></p><p>以后我们仍然用 <code>[]</code> 这个符号来表示栈：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空栈</span></span><br><span class="line"><span class="built_in">stack</span>: []</span><br><span class="line"><span class="comment">// 有3个元素的栈. 栈顶元素是 3. 栈底元素是 1.</span></span><br><span class="line"><span class="built_in">stack</span>: [<span class="number">3</span> <span class="number">2</span> <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p><p>用 <code>{}</code> 来表示合约存储:<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空存储</span></span><br><span class="line"><span class="symbol">store:</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 值 0x1 存储在地址 0x0.</span></span><br><span class="line"><span class="symbol">store:</span> &#123; <span class="number">0x0</span> =&gt; <span class="number">0x1</span> &#125;</span><br></pre></td></tr></table></figure></p><p>现在我们来看一些实际的字节码。我们将模仿EVM运行字节序列 <code>6001600081905550</code> ，同时写出每一条指令运行后的机器状态：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 60 01: 将1入栈</span></span><br><span class="line"><span class="number">0x1</span></span><br><span class="line"><span class="symbol">  stack:</span> [<span class="number">0x1</span>]</span><br><span class="line"><span class="comment">// 60 00: 将0入栈</span></span><br><span class="line"><span class="number">0x0</span></span><br><span class="line"><span class="symbol">  stack:</span> [<span class="number">0x0</span> <span class="number">0x1</span>]</span><br><span class="line"><span class="comment">// 81: 复制栈中的第二个元素，入栈</span></span><br><span class="line">dup2</span><br><span class="line"><span class="symbol">  stack:</span> [<span class="number">0x1</span> <span class="number">0x0</span> <span class="number">0x1</span>]</span><br><span class="line"><span class="comment">// 90: 交换栈顶2个元素</span></span><br><span class="line">swap1</span><br><span class="line"><span class="symbol">  stack:</span> [<span class="number">0x0</span> <span class="number">0x1</span> <span class="number">0x1</span>]</span><br><span class="line"><span class="comment">// 55: 把值 0x1 存储到地址 0x0</span></span><br><span class="line"><span class="comment">// 这条指令使用了栈顶的两个元素</span></span><br><span class="line">sstore</span><br><span class="line"><span class="symbol">  stack:</span> [<span class="number">0x1</span>]</span><br><span class="line"><span class="symbol">  store:</span> &#123; <span class="number">0x0</span> =&gt; <span class="number">0x1</span> &#125;</span><br><span class="line"><span class="comment">// 50: 出栈，即丢掉栈顶一个元素</span></span><br><span class="line">pop</span><br><span class="line"><span class="symbol">  stack:</span> []</span><br><span class="line"><span class="symbol">  store:</span> &#123; <span class="number">0x0</span> =&gt; <span class="number">0x1</span> &#125;</span><br></pre></td></tr></table></figure><p>运行完了。栈空了，同时有一个元素存储到了存储器里。</p><p>值得注意的是 Solidity 决定把状态变量 <code>uint256 a</code> 存储到地址 <code>0x0</code> 。很可能其他语言会把状态变量存到其他地方。</p><p>写出伪代码， EVM 运行 <code>6001600081905550</code> 就像是这样：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="function"><span class="title">sstore</span><span class="params">(<span class="number">0</span>x0, <span class="number">0</span>x1)</span></span></span><br></pre></td></tr></table></figure><p>看仔细一点，会发现 <code>dup2</code>, <code>swap1</code>, <code>pop</code> 是多余的。汇编代码可以更简单：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x1</span></span><br><span class="line"><span class="number">0x0</span></span><br><span class="line">sstore</span><br></pre></td></tr></table></figure><p>你可以试着模拟运行上面的<code>3</code>条指令，肯定会惊喜地发现它们结束时的机器状态是一样的：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">stack:</span> []</span><br><span class="line"><span class="symbol">store:</span> &#123; <span class="number">0x0</span> =&gt; <span class="number">0x1</span> &#125;</span><br></pre></td></tr></table></figure><h1 id="2-个存储变量"><a href="#2-个存储变量" class="headerlink" title="2 个存储变量"></a>2 个存储变量</h1><p>添加另一个相同数据类型的存储变量：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c2.sol</span></span><br><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint256 a;</span><br><span class="line">    uint256 b;</span><br><span class="line">    function C() &#123;</span><br><span class="line">      a = <span class="number">1</span>;</span><br><span class="line">      b = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译，注意 <code>tag_2</code>:<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ solc --bin --asm c2.sol</span><br><span class="line"><span class="comment">// ... more stuff omitted</span></span><br><span class="line">tag_2:</span><br><span class="line">    <span class="comment">/* "c2.sol":99:100  1 */</span></span><br><span class="line">  <span class="number">0x1</span></span><br><span class="line">    <span class="comment">/* "c2.sol":95:96  a */</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">    <span class="comment">/* "c2.sol":95:100  a = 1 */</span></span><br><span class="line">  dup2</span><br><span class="line">  swap1</span><br><span class="line">  sstore</span><br><span class="line">  <span class="keyword">pop</span></span><br><span class="line">    <span class="comment">/* "c2.sol":112:113  2 */</span></span><br><span class="line">  <span class="number">0x2</span></span><br><span class="line">    <span class="comment">/* "c2.sol":108:109  b */</span></span><br><span class="line">  <span class="number">0x1</span></span><br><span class="line">    <span class="comment">/* "c2.sol":108:113  b = 2 */</span></span><br><span class="line">  dup2</span><br><span class="line">  swap1</span><br><span class="line">  sstore</span><br><span class="line">  <span class="keyword">pop</span></span><br></pre></td></tr></table></figure></p><p>汇编伪代码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="function"><span class="title">sstore</span><span class="params">(<span class="number">0</span>x0, <span class="number">0</span>x1)</span></span></span><br><span class="line"><span class="comment">// b = 2</span></span><br><span class="line"><span class="function"><span class="title">sstore</span><span class="params">(<span class="number">0</span>x1, <span class="number">0</span>x2)</span></span></span><br></pre></td></tr></table></figure><p>现在我们知道这两个存储变量是依次存储的，<code>a</code> 存储在地址 <code>0x0</code>，<code>b</code> 存储在地址 <code>0x1</code>。</p><h1 id="打包存储"><a href="#打包存储" class="headerlink" title="打包存储"></a>打包存储</h1><p>每个存储单元能存 32 字节。如果全部使用 32 字节的话，如果一个变量只要 16 字节，那就很浪费了。 Solidity 通过把 2 个短的数据类型打包成 1 个来提高存储效率。</p><p>把 <code>a</code> 和 <code>b</code> 改成每个 16 字节：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">pragma</span> solidity<span class="regexp"> ^0.4.11</span>;</span><br><span class="line"><span class="attribute">contract</span> C &#123;</span><br><span class="line">    <span class="attribute">uint128</span> a;</span><br><span class="line">    <span class="attribute">uint128</span> b;</span><br><span class="line">    <span class="attribute">function</span> C() &#123;</span><br><span class="line">      <span class="attribute">a</span> = <span class="number">1</span>;</span><br><span class="line">      <span class="attribute">b</span> = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译合约：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ solc --<span class="keyword">bin </span>--asm <span class="built_in">c3</span>.sol</span><br></pre></td></tr></table></figure><p>生成的汇编代码更复杂了：<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">  // a = 1</span><br><span class="line">  0x1</span><br><span class="line">  0x0</span><br><span class="line">  dup1</span><br><span class="line">  0x100</span><br><span class="line">  exp</span><br><span class="line">  dup2</span><br><span class="line">  sload</span><br><span class="line">  dup2</span><br><span class="line">  0xffffffffffffffffffffffffffffffff</span><br><span class="line">  mul</span><br><span class="line">  not</span><br><span class="line">  and</span><br><span class="line">  swap1</span><br><span class="line">  dup4</span><br><span class="line">  0xffffffffffffffffffffffffffffffff</span><br><span class="line">  and</span><br><span class="line">  mul</span><br><span class="line">  or</span><br><span class="line">  swap1</span><br><span class="line">  sstore</span><br><span class="line">  pop</span><br><span class="line">  // b = 2</span><br><span class="line">  0x2</span><br><span class="line">  0x0</span><br><span class="line">  0x10</span><br><span class="line">  0x100</span><br><span class="line">  exp</span><br><span class="line">  dup2</span><br><span class="line">  sload</span><br><span class="line">  dup2</span><br><span class="line">  0xffffffffffffffffffffffffffffffff</span><br><span class="line">  mul</span><br><span class="line">  not</span><br><span class="line">  and</span><br><span class="line">  swap1</span><br><span class="line">  dup4</span><br><span class="line">  0xffffffffffffffffffffffffffffffff</span><br><span class="line">  and</span><br><span class="line">  mul</span><br><span class="line">  or</span><br><span class="line">  swap1</span><br><span class="line">  sstore</span><br><span class="line">  pop</span><br></pre></td></tr></table></figure></p><p>上面的汇编代码把 2 个变量打包到1个存储地址( <code>0x0</code> )，像这样：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">         b         </span>][<span class="symbol">         a         </span>]</span><br><span class="line">[<span class="string">16 bytes / 128 bits</span>][<span class="symbol">16 bytes / 128 bits</span>]</span><br></pre></td></tr></table></figure><p>打包的原因是目前最贵的操作就是存储空间的使用：</p><ul><li><code>sstore</code> 花费 20,000 gas 来第一次写入一个新地址</li><li><code>sstore</code> 花费 5,000 gas 来随后写入一个已存在的地址</li><li><code>sload</code> 花费 500 gas</li><li>大多数指令只花费 3~10 gas</li></ul><p>通过使用相同的地址， Solidity 为第二个变量存储只支付 5,000 而不是 20,000，省了 15,000 gas。</p><h1 id="更多优化"><a href="#更多优化" class="headerlink" title="更多优化"></a>更多优化</h1><p>不分别同 2 个 <code>sstore</code> 指令来保存 <code>a</code> 和 <code>b</code> ，而把2个128比特的数字打包到内存里再使用1个 <code>sstore</code> ，从而节省 5,000 gas。</p><p>你可以通过 <code>optimize</code> 标志来让Solidity做这个操作：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">$</span> <span class="comment">solc</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">bin</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">asm</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">optimize</span> <span class="comment">c3</span><span class="string">.</span><span class="comment">sol</span></span><br></pre></td></tr></table></figure><p>这个方式生成的汇编代码只使用1个 <code>sload</code> 和1个 <code>sstore</code> :<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">tag_2:</span></span><br><span class="line">    <span class="comment">/* "c3.sol":95:96  a */</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">    <span class="comment">/* "c3.sol":95:100  a = 1 */</span></span><br><span class="line">  dup1</span><br><span class="line">  sload</span><br><span class="line">    <span class="comment">/* "c3.sol":108:113  b = 2 */</span></span><br><span class="line">  <span class="number">0x200000000000000000000000000000000</span></span><br><span class="line">  not(<span class="keyword">sub(exp(0x2, </span><span class="number">0x80</span>), <span class="number">0x1</span>))</span><br><span class="line">    <span class="comment">/* "c3.sol":95:100  a = 1 */</span></span><br><span class="line">  <span class="keyword">swap1</span></span><br><span class="line"><span class="keyword"> </span> <span class="keyword">swap2</span></span><br><span class="line"><span class="keyword"> </span> <span class="keyword">and</span></span><br><span class="line"><span class="keyword"> </span>   <span class="comment">/* "c3.sol":99:100  1 */</span></span><br><span class="line">  <span class="number">0x1</span></span><br><span class="line">    <span class="comment">/* "c3.sol":95:100  a = 1 */</span></span><br><span class="line">  <span class="keyword">or</span></span><br><span class="line"><span class="keyword"> </span> <span class="keyword">sub(exp(0x2, </span><span class="number">0x80</span>), <span class="number">0x1</span>)</span><br><span class="line">    <span class="comment">/* "c3.sol":108:113  b = 2 */</span></span><br><span class="line">  <span class="keyword">and</span></span><br><span class="line"><span class="keyword"> </span> <span class="keyword">or</span></span><br><span class="line"><span class="keyword"> </span> <span class="keyword">swap1</span></span><br><span class="line"><span class="keyword"> </span> sstore</span><br></pre></td></tr></table></figure></p><p>字节码是<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">600080547002000000000000000000000000000000006001608060020</span>a03199091166001176001608060020a<span class="number">0316179055</span></span><br></pre></td></tr></table></figure></p><p>格式化字节码成一行一条指令的形式：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// push 0x0</span></span><br><span class="line"><span class="number">60</span> <span class="number">00</span></span><br><span class="line"><span class="comment">// dup1</span></span><br><span class="line"><span class="number">80</span></span><br><span class="line"><span class="comment">// sload</span></span><br><span class="line"><span class="number">54</span></span><br><span class="line"><span class="comment">// push17 作为 32 字节的数字，把接下来的 17 字节入栈</span></span><br><span class="line"><span class="number">70</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="comment">/* not(sub(exp(0x2, 0x80), 0x1)) */</span></span><br><span class="line"><span class="comment">// push 0x1</span></span><br><span class="line"><span class="number">60</span> <span class="number">01</span></span><br><span class="line"><span class="comment">// push 0x80 (32)</span></span><br><span class="line"><span class="number">60</span> <span class="number">80</span></span><br><span class="line"><span class="comment">// push 0x80 (2)</span></span><br><span class="line"><span class="number">60</span> <span class="number">02</span></span><br><span class="line"><span class="comment">// exp</span></span><br><span class="line"><span class="number">0</span>a</span><br><span class="line"><span class="comment">// sub</span></span><br><span class="line"><span class="number">03</span></span><br><span class="line"><span class="comment">// not</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="comment">// swap1</span></span><br><span class="line"><span class="number">90</span></span><br><span class="line"><span class="comment">// swap2</span></span><br><span class="line"><span class="number">91</span></span><br><span class="line"><span class="comment">// and</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="comment">// push 0x1</span></span><br><span class="line"><span class="number">60</span> <span class="number">01</span></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="comment">/* sub(exp(0x2, 0x80), 0x1) */</span></span><br><span class="line"><span class="comment">// push 0x1</span></span><br><span class="line"><span class="number">60</span> <span class="number">01</span></span><br><span class="line"><span class="comment">// push 0x80</span></span><br><span class="line"><span class="number">60</span> <span class="number">80</span></span><br><span class="line"><span class="comment">// push 0x02</span></span><br><span class="line"><span class="number">60</span> <span class="number">02</span></span><br><span class="line"><span class="comment">// exp</span></span><br><span class="line"><span class="number">0</span>a</span><br><span class="line"><span class="comment">// sub</span></span><br><span class="line"><span class="number">03</span></span><br><span class="line"><span class="comment">// and</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="comment">// swap1</span></span><br><span class="line"><span class="number">90</span></span><br><span class="line"><span class="comment">// sstore</span></span><br><span class="line"><span class="number">55</span></span><br></pre></td></tr></table></figure></p><p>在汇编代码里有4个魔法变量：</p><ul><li><p>0x1 (16 字节), 使用低 16 位字节</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 字节码表示 <span class="number">0</span>x01</span><br><span class="line"><span class="number">16</span>:<span class="number">32</span> <span class="number">0</span>x000000000000000000000<span class="number">00000000000</span></span><br><span class="line"><span class="number">00</span>:<span class="number">16</span> <span class="number">0</span>x000000000000000000000<span class="number">00000000001</span></span><br></pre></td></tr></table></figure></li><li><p>0x2 (16 字节), 使用高 16 位字节</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//字节码表示 <span class="number">0</span>x2000000000000000000000<span class="number">00000000000</span></span><br><span class="line"><span class="number">16</span>:<span class="number">32</span> <span class="number">0</span>x000000000000000000000<span class="number">00000000002</span></span><br><span class="line"><span class="number">00</span>:<span class="number">16</span> <span class="number">0</span>x000000000000000000000<span class="number">00000000000</span></span><br></pre></td></tr></table></figure></li><li><p><code>not(sub(exp(0x2, 0x80), 0x1))</code></p></li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高 16 字节的二进制掩码</span></span><br><span class="line"><span class="attribute">16</span>:<span class="number">32</span> <span class="number">0</span>xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</span><br><span class="line"><span class="number">00</span>:<span class="number">16</span> <span class="number">0</span>x00000000000000000000000000000000</span><br></pre></td></tr></table></figure><ul><li><code>sub(exp(0x2, 0x80), 0x1)</code></li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 低 16 字节的二进制掩码</span></span><br><span class="line"><span class="attribute">16</span>:<span class="number">32</span> <span class="number">0</span>x00000000000000000000000000000000 </span><br><span class="line"><span class="number">00</span>:<span class="number">16</span> <span class="number">0</span>xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</span><br></pre></td></tr></table></figure><p>代码对这些值做了位交换以获得需要的结果：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">16<span class="selector-pseudo">:32</span> 0<span class="selector-tag">x00000000000000000000000000000002</span> </span><br><span class="line">00<span class="selector-pseudo">:16</span> 0<span class="selector-tag">x00000000000000000000000000000001</span></span><br></pre></td></tr></table></figure></p><p>最后，这个 32 字节的值存储在地址 0x0。</p><h2 id="gas-的使用"><a href="#gas-的使用" class="headerlink" title="gas 的使用"></a>gas 的使用</h2><blockquote><p>60008054700<strong>200000000000000000000000000000000</strong>6001608060020a03199091166001176001608060020a0316179055</p></blockquote><p>注意 <code>0x200000000000000000000000000000000</code> 嵌在字节码里了。但编译器也可能选择用指令 <code>exp(0x2, 0x81)</code> 计算值，这将生成更短的字节码序列。</p><p>结果好像是 <code>0x200000000000000000000000000000000</code> 比 <code>exp(0x2, 0x81)</code> 更便宜。我们看一下分别需要花费的 gas：</p><ul><li>4 gas  花在一笔交易中的每一个为 0 的数据或代码</li><li>68 gas 花在一笔交易中的每一个非 0 的数据或代码</li></ul><p>比较一下总的gas花费：</p><ul><li><p>字节码 <code>0x200000000000000000000000000000000</code>. 它有很多 0 ，更便宜<br>(1 <em> 68) + (16 </em> 4) = 196.</p></li><li><p>字节码 <code>608160020a</code>. 更短，但没有0.<br>5 * 68 = 340.</p></li></ul><p>更长但有更多 0 的序列实际上更便宜！</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>EVM 编译器实际上没有优化字节码大小或速度抑或内存效率。取而代之的是，它优化了 gas 的使用，这是一个间接的层面，可以激励以太坊区块链进行高效计算。</p><p>我们已经看到了 EVM 一些诡异的方面：</p><ul><li>EVM 是 256 比特机器。以 32 字节为块来操作数据最自然。</li><li>持久化存储很贵。</li><li>Solidity 编译器为了最小化 gas 的使用采取了有趣的做法。</li></ul><p>gas 成本的设定是任意的，以后可能会变。随着成本的变化，编译器会做出不同的选择。</p><hr><p>在本系列文章中，关于 EVM 我会写：</p><ul><li>EVM 汇编代码的介绍</li><li>定长数据类型如何表示</li><li>动态数据类型如何表示</li><li>ABI编码的外部函数如何调用</li><li>一个新合约创建时发生了什么</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;https://blog.qtum.org/diving-into-the-ethereum-vm-6e8d5d2f3c30&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.qtum.org/diving-i
      
    
    </summary>
    
      <category term="区块链" scheme="http://xichen.pub/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://xichen.pub/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Qtum" scheme="http://xichen.pub/tags/Qtum/"/>
    
      <category term="翻译" scheme="http://xichen.pub/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
</feed>
