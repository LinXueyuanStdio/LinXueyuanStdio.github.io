<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XiChen</title>
  
  <subtitle>XiChen&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xichen.pub/"/>
  <updated>2018-12-11T04:17:48.541Z</updated>
  <id>http://xichen.pub/</id>
  
  <author>
    <name>Lin Xueyuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Android TimeCat】 解决魅族无法彻底卸载 app 问题</title>
    <link href="http://xichen.pub/2018/10/29/2018-10-29-Android-TimeCat-%E8%A7%A3%E5%86%B3%E9%AD%85%E6%97%8FFlyme6%E6%97%A0%E6%B3%95%E5%BD%BB%E5%BA%95%E5%8D%B8%E8%BD%BDapp%E9%97%AE%E9%A2%98/"/>
    <id>http://xichen.pub/2018/10/29/2018-10-29-Android-TimeCat-解决魅族Flyme6无法彻底卸载app问题/</id>
    <published>2018-10-29T05:11:00.000Z</published>
    <updated>2018-12-11T04:17:48.541Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>卸载重装老是提示不能重复安装。<br>卸载了某些软件（例如通过开发者模式调试安装的应用）后，实际这个应用还残留在系统，当用低版本或者其他签名的apk覆盖安装的时候会提示“安装失败”，要求卸载后重新安装。但是就是不提示安装在哪里，反正已安装列表里已经不见了。无论从应用列表寻找还是清理垃圾，都根本找不到这个应用。<br>现在介绍的这个方法不需要ROOT，不需要任何第三方软件。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><h2 id="1-进入手机的“设置”-“安全”-（指纹和安全）"><a href="#1-进入手机的“设置”-“安全”-（指纹和安全）" class="headerlink" title="1.进入手机的“设置”-“安全” （指纹和安全）"></a>1.进入手机的“设置”-“安全” （指纹和安全）</h2><div class="image-package"><br><img src="/assets/blog/img/2018-10-29/0.webp" width="700"><br><br><br><div class="image-caption"><br>1<br></div><br></div><h2 id="2-选择进入访客默认"><a href="#2-选择进入访客默认" class="headerlink" title="2.选择进入访客默认"></a>2.选择进入访客默认</h2><div class="image-package"><br><img src="/assets/blog/img/2018-10-29/1.webp" width="700"><br><br><br><div class="image-caption"><br>2<br></div><br></div><h2 id="3-打开访客模式，记住密码"><a href="#3-打开访客模式，记住密码" class="headerlink" title="3. 打开访客模式，记住密码"></a>3. 打开访客模式，记住密码</h2><p>默认密码一般是1234。如果你的密码是1234，那访客模式的密码是4321。</p><div class="image-package"><br><img src="/assets/blog/img/2018-10-29/2.webp" width="700"><br><br><br><div class="image-caption"><br>3<br></div><br></div><h2 id="4-锁屏，用刚刚的“访客密码”进入系统，记住是访客密码，不是你平时的密码"><a href="#4-锁屏，用刚刚的“访客密码”进入系统，记住是访客密码，不是你平时的密码" class="headerlink" title="4.锁屏，用刚刚的“访客密码”进入系统，记住是访客密码，不是你平时的密码"></a>4.锁屏，用刚刚的“访客密码”进入系统，记住是访客密码，不是你平时的密码</h2><div class="image-package"><br><img src="/assets/blog/img/2018-10-29/3.webp" width="700"><br><br><br><div class="image-caption"><br>4<br></div><br></div><h2 id="5-你会在访客模式中看到你要卸载的app，这里我们简称“幽灵App”，只要把对应的幽灵App删除，然后进入正常的模式就可以安装新的app了。"><a href="#5-你会在访客模式中看到你要卸载的app，这里我们简称“幽灵App”，只要把对应的幽灵App删除，然后进入正常的模式就可以安装新的app了。" class="headerlink" title="5.你会在访客模式中看到你要卸载的app，这里我们简称“幽灵App”，只要把对应的幽灵App删除，然后进入正常的模式就可以安装新的app了。"></a>5.你会在访客模式中看到你要卸载的app，这里我们简称“幽灵App”，只要把对应的幽灵App删除，然后进入正常的模式就可以安装新的app了。</h2><p>访客模式的桌面是使用了开源项目 <a href="https://github.com/LawnchairLauncher/Lawnchair" target="_blank" rel="noopener">LawnchairLauncher/Lawnchair</a>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/7717fb3df4e8" target="_blank" rel="noopener">解决魅族Flyme6无法彻底卸载app问题</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;卸载重装老是提示不能重复安装。&lt;br&gt;卸载了某些软件（例如通过开发者模式调试安装的应用）后，实际这个应用还残留在系统，当用低版本或者其他签名
      
    
    </summary>
    
      <category term="Android" scheme="http://xichen.pub/categories/Android/"/>
    
    
      <category term="Android" scheme="http://xichen.pub/tags/Android/"/>
    
      <category term="Keyboard" scheme="http://xichen.pub/tags/Keyboard/"/>
    
  </entry>
  
  <entry>
    <title>【Android TimeCat】 解决 context.startforegroundservice() did not then call service.startforeground()</title>
    <link href="http://xichen.pub/2018/10/25/2018-10-25-Android-TimeCat-context.startforegroundservice()didnotthencallservice.startforeground()/"/>
    <id>http://xichen.pub/2018/10/25/2018-10-25-Android-TimeCat-context.startforegroundservice()didnotthencallservice.startforeground()/</id>
    <published>2018-10-25T04:11:00.000Z</published>
    <updated>2018-10-25T10:23:14.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>因为这个适配没做好，被用户干了。。。</p><p>Android 8.0 有一项复杂功能；系统不允许后台应用创建后台服务。 因此，Android 8.0 引入了一种全新的方法，即 Context.startForegroundService()，以在前台启动新服务。<br>在系统创建服务后，应用有5秒的时间来调用该服务的 startForeground() 方法以显示新服务的用户可见通知。如果应用在此时间限制内未调用 startForeground()，则系统将停止服务并声明此应用为 ANR。</p><p>但是目前在调用：context.startForegroundService(intent)时报如下ANR，startForegroundService()文档说明在service启动后要调用startForeground()。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">android</span><span class="selector-class">.app</span><span class="selector-class">.RemoteServiceException</span>: <span class="selector-tag">Context</span><span class="selector-class">.startForegroundService</span>() <span class="selector-tag">did</span> <span class="selector-tag">not</span> <span class="selector-tag">then</span> <span class="selector-tag">call</span> <span class="selector-tag">Service</span><span class="selector-class">.startForeground</span>()</span><br></pre></td></tr></table></figure></p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><h2 id="第一步：使用Context-startForegroundService-启动服务后，在service的onCreate方法中调用startForeground-。"><a href="#第一步：使用Context-startForegroundService-启动服务后，在service的onCreate方法中调用startForeground-。" class="headerlink" title="第一步：使用Context.startForegroundService()启动服务后，在service的onCreate方法中调用startForeground()。"></a>第一步：使用<code>Context.startForegroundService()</code>启动服务后，在<code>service</code>的<code>onCreate</code>方法中调用<code>startForeground()</code>。</h2><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NotificationChannel</span> channel = <span class="function"><span class="keyword">new</span> <span class="title">NotificationChannel</span>(<span class="type">CHANNEL_ID</span>,<span class="type">CHANNEL_NAME</span>,</span></span><br><span class="line"><span class="function">                <span class="type">NotificationManager</span>.<span class="type">IMPORTANCE_HIGH</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">NotificationManager</span> <span class="title">manager</span> = (<span class="type">NotificationManager</span>) <span class="title">getSystemService</span>(<span class="type">Context</span>.<span class="type">NOTIFICATION_SERVICE</span>);</span></span><br><span class="line"><span class="function"><span class="title">manager</span>.<span class="title">createNotificationChannel</span>(channel);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Notification</span> <span class="title">notification</span> = <span class="title">new</span> <span class="title">Notification</span>.<span class="title">Builder</span>(getApplicationContext(),<span class="title">CHANNEL_ID</span>).<span class="title">build</span>();</span></span><br><span class="line"><span class="function"><span class="title">startForeground</span>(<span class="number">1</span>, notification);</span></span><br></pre></td></tr></table></figure><h2 id="第二步：在onStart里再次调用startForeground"><a href="#第二步：在onStart里再次调用startForeground" class="headerlink" title="第二步：在onStart里再次调用startForeground()"></a>第二步：在<code>onStart</code>里再次调用<code>startForeground()</code></h2><h2 id="Why？"><a href="#Why？" class="headerlink" title="Why？"></a>Why？</h2><ol><li>Android 8.0 系统不允许后台应用创建后台服务，故只能使用<code>Context.startForegroundService()</code>启动服务</li><li>创建服务后，应用必须在5秒内调用该服务的 <code>startForeground()</code> 显示一条可见通知，声明有服务在挂着，不然系统会停止服务 + ANR 套餐送上。</li><li>Notification 要加 Channel，系统的要求</li><li>为什么要在<code>onStart</code>里再次调用<code>startForeground()</code>？答：这一条主要是针对后台保活的服务，如果在服务<code>A</code>运行期间，保活机制又<code>startForegroundService</code>启动了一次服务<code>A</code>，那么这样不会调用服务<code>A</code>的<code>onCreate</code>方法，只会调用<code>onStart</code>方法。如果不在<code>onStart</code>方法里再挂个通知的话，系统会认为你使用了 <code>startForegroundService</code> 却不在 5 秒内给通知，很傻地就停止服务 + ANR 套餐送上了。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/lylddingHFFW/article/details/78219327" target="_blank" rel="noopener">lyldding-HFFW 在Android O上启动Service遇到问题记录</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;因为这个适配没做好，被用户干了。。。&lt;/p&gt;
&lt;p&gt;Android 8.0 有一项复杂功能；系统不允许后台应用创建后台服务。 因此，Andr
      
    
    </summary>
    
      <category term="Android" scheme="http://xichen.pub/categories/Android/"/>
    
    
      <category term="Android" scheme="http://xichen.pub/tags/Android/"/>
    
      <category term="Keyboard" scheme="http://xichen.pub/tags/Keyboard/"/>
    
  </entry>
  
  <entry>
    <title>nodejs 中同步异步多种写法</title>
    <link href="http://xichen.pub/2018/09/04/2018-09-04-js-async-await/"/>
    <id>http://xichen.pub/2018/09/04/2018-09-04-js-async-await/</id>
    <published>2018-09-03T20:11:00.000Z</published>
    <updated>2018-09-04T08:37:25.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>nodejs 的同步异步写起来真爽，特别是结合 typescript，简直上天！感觉可以取代 go 的异步呢，哈哈。</p><h2 id="同步循环"><a href="#同步循环" class="headerlink" title="同步循环"></a>同步循环</h2><p>传统 for 循环：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> item = array[i]</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进阶 forEach：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="异步循环"><a href="#异步循环" class="headerlink" title="异步循环"></a>异步循环</h2><h3 id="全部异步，不关心结果"><a href="#全部异步，不关心结果" class="headerlink" title="全部异步，不关心结果"></a>全部异步，不关心结果</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doArray</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  array.forEach(<span class="keyword">async</span>(item) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> doItem(item)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'loop done! But each item is sitll doing'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="依次同步"><a href="#依次同步" class="headerlink" title="依次同步"></a>依次同步</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doArray</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> array) &#123;</span><br><span class="line">    <span class="keyword">await</span> doItem(item)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'every item done!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步执行，同步等结果"><a href="#异步执行，同步等结果" class="headerlink" title="异步执行，同步等结果"></a>异步执行，同步等结果</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doArray</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> promises = array.map(<span class="function"><span class="params">item</span> =&gt;</span> doItem(item))</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.all(promises)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'every item done!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;nodejs 的同步异步写起来真爽，特别是结合 typescript，简直上天！感觉可以取代 go 的异步呢，哈哈。&lt;/p&gt;
&lt;h2 id=
      
    
    </summary>
    
      <category term="区块链" scheme="http://xichen.pub/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="异步" scheme="http://xichen.pub/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="nodejs" scheme="http://xichen.pub/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】 QTUM 的有限供应量 - 减半</title>
    <link href="http://xichen.pub/2018/08/13/2018-08-13-%E7%BF%BB%E8%AF%91-QTUM%E7%9A%84%E6%9C%89%E9%99%90%E4%BE%9B%E5%BA%94%E9%87%8F-%E5%87%8F%E5%8D%8A/"/>
    <id>http://xichen.pub/2018/08/13/2018-08-13-翻译-QTUM的有限供应量-减半/</id>
    <published>2018-08-13T06:11:00.000Z</published>
    <updated>2018-09-01T09:52:41.290Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://medium.com/@jb395official/qtum-capped-supply-the-halving-b650b7fb955e" target="_blank" rel="noopener">https://medium.com/@jb395official/qtum-capped-supply-the-halving-b650b7fb955e</a><br>译者：中山大学数学学院（珠海）林学渊<br>大二时给量子做的翻译，转载注明出处，谢谢</p><h1 id="QTUM-的有限供应量-减半"><a href="#QTUM-的有限供应量-减半" class="headerlink" title="QTUM 的有限供应量 - 减半"></a>QTUM 的有限供应量 - 减半</h1><p>QTUM Capped Supply — The Halving</p><p>这是社区中常问的一个问题：QTUM 的供应量是否有限？有多少？</p><p>本报告回答了这个问题 - 是的，供应量是有限的 - 并给出了最大供应量。</p><p>TL;DR QTUM 的供应量上限为 107,822,406.25，约 31 年发完。</p><p>我是一名独立研究员，偶尔是博主，社交版主，并中意 Qtum 团队的技术指导和社区的高谈阔论。如果你对本文有任何意见或更正，请在社交媒体上联系我。</p><hr><h2 id="新资源管理器"><a href="#新资源管理器" class="headerlink" title="新资源管理器"></a>新资源管理器</h2><p>首先，让我安利一个新资源管理器：<a href="http://qtum.info" target="_blank" rel="noopener">qtum.info</a>.</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*Jjcubf7UuFyVtC2f2jMGKQ.jpeg" alt=""></p><p>这个功能强大的资源管理器有干净的布局，可以轻松导航到地址的第一个交易，还有一个覆盖 98,345 个地址（有些不那么富有）的“富豪榜(Rich List)”。</p><h2 id="网络权重"><a href="#网络权重" class="headerlink" title="网络权重"></a>网络权重</h2><p>在 2018 年 2 月 26 日至 3 月 4 日期间，已知余额为 600 万以上的大钱包共赢得 712 块奖励，总计 4,185，即 17.01％，网络权重为 3520 万，年回报率为 2.49％。</p><hr><h2 id="有限供应量"><a href="#有限供应量" class="headerlink" title="有限供应量"></a>有限供应量</h2><p>一对情侣相距 50 米对视。作为大学数学系的学生，他们决定相互靠近一半，一直到25米，然后再一半接近12.5米，然后又一半，再接近一半，等等。作为数学家，他们知道每次他们减少一半的距离，但永远不会真正接触到彼此，但作为现实主义者，他们知道他们会<em>为了所有实际目的而足够接近</em>。</p><p>在研究之前，我认为 QTUM 没有上限，但事实证明 QTUM 的上限类似于比特币的上限。很多人都知道比特币的最大数量是 21,000,000。那 QTUM 的最大数量是多少？</p><h2 id="减半"><a href="#减半" class="headerlink" title="减半"></a>减半</h2><p>要计算出 QTUM 的最大数量，我们需要考虑减半（取一半）。我使用比特币作为参考，因为到目前为止它已经减半，所以每个人都知道这个数字是 2100 万。许多人都知道比特币的块奖励每 4 年下降一半（“减半”）。比特币开始时有 50 个代币用于区块奖励，减半到 25，到目前区块奖励是 12.5 个代币。</p><p>Qtum 遵循类似的减半模式，由钱包中的代码设置减半时间：</p><p><img src="https://cdn-images-1.medium.com/max/1280/1*50l2ob3FhEsR5Pc973TpyQ.jpeg" alt=""></p><p>该代码表示​​减半间隔是 985,500 块，对当前块间距来说约为 4 年半。Qtum 的第一次减半将在块 990,501，大约在 2022 年 3 月 9 日，在 UTC 时间 07:48:48（在你的日历标记一下！）[2]。</p><p>我们在情侣中看到了“为了所有实际目的”的问题，在计算 Qtum 块奖励的源代码中也有一个硬限制（hard limit）。 在下面列出的参考文献[1]中计算比特币的上限（考虑一些不同的因素）。 要获得 QTUM 的最大数量，下表显示了块奖励如何连续减半以及未来 31 年总 QTUM 如何累积：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*IC-PtTp4JhDGBch9RsJO0g.jpeg" alt=""></p><p>这张表有一些解释。</p><p>创世块 <a href="http://qtum.info/block/1" target="_blank" rel="noopener">1</a>-5,000 创造了原始的 100,000,000 QTUM，每个块创造了 20,000 QTUM（像比特币那样的 coinbase 块奖励，而不是像 Qtum 那样的 coinstake 块奖励）。从块 5,001 开始，块奖励是 4.0 QTUM，并持续 985,500 块到块 990,500，这将增加 3,942,000 个新 QTUM。从块 990,501 开始，块奖励将减半至 2.0 QTUM，之后每隔 4 年块奖励将减半。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*0ZrZ5oRyysMGg1TrlUSr5g.jpeg" alt=""></p><hr><p>有关暗网的报道称，Satoshi 团队（Team Satoshi）的左侧臀部有 21,000,000 的数字纹身。我既不能证实也不否认 Qtum 团队的任何人也自豪地在他们的皮肤上 <a href="https://goo.gl/maps/PyjfAUDVq2Q2" target="_blank" rel="noopener">签上</a>数字 107,822,406.25 [4]。我希望现在每个人都能记住 107,822,406.25 这个数字，因为这是上限，永远不会有更多的 QTUM。</p><p>Jackson</p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] 比特币维基，<a href="https://en.bitcoin.it/wiki/Controlled_supply" target="_blank" rel="noopener">控制供应量</a></p><p>[2] 日期计算：Epoch 和 Unix 时间戳<a href="https://www.epochconverter.com/" target="_blank" rel="noopener">转换器</a> - 每块使用144秒。</p><p>[3] Qtum 的 validations.cpp 代码:</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*rFRg5IkHZkLTNBKWa9HY3w.jpeg" alt=""></p><p>解释</p><p>1375行：对于前 5,000 个区块（nLastPOWBlock），区块奖励为 20,000 QTUM。 这些是创世块。</p><p>1378行：halfvings =（当前块 - 5,001）/ 985,500 的整数（忽略小数部分）</p><p>1380行：如果减半大于或等于7，则将块奖励设置为0。从块 6,903,501 开始。</p><p>1382，1385 行：否则，块奖励为4.0 QTUM 除以 2 x 减半数。</p><p>[4] 这些句子是个玩笑，但 107,822,406.25 是真的！</p><p>[5] 如果你同样痴迷于创世块创造世界的故事，你可能会喜欢 <a href="http://qtum.info/block/0" target="_blank" rel="noopener">0 区块</a>，它早于 Mainnet 的发布，并且似乎拥有 50.0 QTUM 的未花费区块奖励。事实上，这个地址在最近的空投中收到了 BOT。 我没有将这 50 QTUM 包括在上面的上限计算中，但是你可以自己加进去算一遍。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;https://medium.com/@jb395official/qtum-capped-supply-the-halving-b650b7fb955e&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://medium.
      
    
    </summary>
    
      <category term="区块链" scheme="http://xichen.pub/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://xichen.pub/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Qtum" scheme="http://xichen.pub/tags/Qtum/"/>
    
      <category term="翻译" scheme="http://xichen.pub/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】 调试日志，虚拟机日志</title>
    <link href="http://xichen.pub/2018/08/13/2018-08-13-%E7%BF%BB%E8%AF%91-%E8%B0%83%E8%AF%95%E6%97%A5%E5%BF%97-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%97%A5%E5%BF%97/"/>
    <id>http://xichen.pub/2018/08/13/2018-08-13-翻译-调试日志-虚拟机日志/</id>
    <published>2018-08-12T20:11:00.000Z</published>
    <updated>2018-09-01T09:50:47.701Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://medium.com/@jb395official/the-debug-log-the-virtual-machine-log-march-13-2018-76ddbe568f2" target="_blank" rel="noopener">https://medium.com/@jb395official/the-debug-log-the-virtual-machine-log-march-13-2018-76ddbe568f2</a><br>译者：中山大学数学学院（珠海）林学渊<br>大二时给量子做的翻译，转载注明出处，谢谢</p><h1 id="调试日志，虚拟机日志，2018-年-3-月-13-日"><a href="#调试日志，虚拟机日志，2018-年-3-月-13-日" class="headerlink" title="调试日志，虚拟机日志，2018 年 3 月 13 日"></a>调试日志，虚拟机日志，2018 年 3 月 13 日</h1><p><img src="https://cdn-images-1.medium.com/max/2000/1*xcYyb6Iu9J6c-h1ZTVH9UQ.jpeg" alt=""></p><p>这个星期我们研究 debug.log。当你怀疑你的钱包有问题时（或者如果你只是对 Qtum 感到好奇的话），debug.log 就是你的好朋友。我们来看看如何找到调试日志（debug log），如何阅读它，以及如何从中发现问题。特别奖主题是虚拟机日志 vm.log。</p><p>我是一名独立研究员，偶尔是博主，社交版主，并中意 Qtum 团队的技术指导和社区的高谈阔论。如果你对本文有任何意见或更正，请在社交媒体上联系我。</p><hr><h2 id="网络权重，节点数"><a href="#网络权重，节点数" class="headerlink" title="网络权重，节点数"></a>网络权重，节点数</h2><p>从 3 月 4 日至 11 日，已知余额为 590.5 万的大钱包赢得了总 4,779 块奖励中的 709 块，或者说 14.84％，网络权重为 3980 万，年回报率为 2.20％。本计算用了大约 11 倍的数据点，并且用了比钱包计算网络权重更好的算法（IMHO），但这个数字是每周更新，而钱包计算的网络权重是每块更新。（编辑过）</p><hr><h2 id="调试日志文件"><a href="#调试日志文件" class="headerlink" title="调试日志文件"></a>调试日志文件</h2><blockquote><p>TL;DR debug.log 文件与 wallet.dat 文件位于同一 Qtum 目录中，是记录基本钱包操作和错误情况的文本日志。每行日志都带有 UTC 时间戳，并显示每个同步到钱包区块链的新区块，发送动作，接收动作和错误情况。Qtum 虚拟机日志记录了钱包添加到区块链的合约交易，是代币交易问题很好的参考文件。</p></blockquote><p>每次你更新钱包时，你只要重命名 debug.log 文件为当前日期，比如“debug-2018-03-13.log”，就能保留旧的调试日志，以供参考（或者不保留删掉）。重启新版本钱包就可以写入一个新的 debug.log 文件了。对于 qtumd，使用默认设置的话，debug.log 文件每周保存大约4 MB。</p><p>在与 wallet.dat 文件相同的目录下找 debug.log 文件。 debug.log 文件是纯文本文件，可以使用任何文本编辑器或 QT 钱包打开。</p><p>每条日志都以 UTC 时间戳开头（不是你当地的时间，不用担心夏令时转换）</p><p><img src="https://cdn-images-1.medium.com/max/1280/1*XhNa5oRvsK7zVEI5jQ4ePA.jpeg" alt=""></p><p>这行日志表示在 3 月 7 日 14:27:34 UTC，钱包处理了一个区块并接受了这个区块。</p><p><img src="https://cdn-images-1.medium.com/max/960/1*abPTNvRmGr6OUvKrEwEssQ.jpeg" alt=""></p><p>我一般在钱包运行时获取 debug.log 文件的副本。我不确定这在技术上是否正确，但也没有弄坏钱包。QT 钱包中点击帮助 - 调试窗口 - 信息，屏幕的右下角提供了一个按钮，用于打开 debug.log 文件。</p><h2 id="非常自然，非常健康"><a href="#非常自然，非常健康" class="headerlink" title="非常自然，非常健康"></a>非常自然，非常健康</h2><p>我们将从调试日志显示的正常钱包操作开始，包括钱包启动，正常同步以及发送和接收操作。</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>启动时，钱包在初始化节点和读取多个文件方面做了很多工作，也许最重要的是 wallet.dat 文件，它包含钱包私钥。初始化后，钱包开始与其他节点建立连接，加载区块，同步区块链。Qtum Core 钱包是一个全节点，需要完整的区块链副本。调试日志显示追赶块写入很快，每秒几个。钱包验证每个区块并将其写入本地的区块链副本。下面例子中，整个启动流程记录了 148 行。这里有摘录的一些要点，为了清晰起见缩短了一些行，黄色高亮是我标出的：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*uDH9_zohmqSH33LZHwd7fg.jpeg" alt=""></p><p>钱包初始化后，在 18:01:26 处它比当前区块链高度落后大约半天（350个区块），并开始从其他对等点快速下载它没有的区块。直到 18:09:27，区块同步更新完毕，继续正常同步新区块。</p><p>下面我会举一个钱包日志文件的例子，它无法连接到对等点来同步区块链，so sad。</p><h2 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h2><p>接受到交易后，日志会显示一个带有交易 ID 的 “AddToWallet” 交易：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*uabvv0iMVwHkjTM0Lg6_Ig.jpeg" alt=""></p><p>交易可以是支付区块奖励或其他接收交易。金额没有列出来，但可以使用交易 ID 在你喜欢的资源管理器中找到详细信息。</p><h2 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h2><p>发送日志稍微复杂一些。现在我发送 0.2 QTUM; 你可以看到金额和交易ID：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*84rRR0jDRu7OEiv9QZuJOQ.jpeg" alt=""></p><p>发送的简单解释是 Qtum（née bitcoin）未花费交易输出（UTXO）模型。钱包选择先前整个未花费交易，在本例子中，未花费交易是 1.00000000 QTUM （在日志中没显示，但你可以在资源管理器中查看详细信息）。钱包必须发送整个 1.00000000 交易，对应指令将 0.20000000 提供给新地址并将 0.79909600 返回到钱包控制的零钱地址。发送的  1.00000000，接收地址的 0.20000000 和零钱地址的 0.79909600 之间的差值是 0.00090400：</p><p><img src="https://cdn-images-1.medium.com/max/1280/1*jhiasALQmf2D1XLp11-LuQ.jpeg" alt=""></p><p>这个差值是块奖励获奖钱包保留作为发布交易的“小费”，称为交易费用。</p><h2 id="其他调试模式"><a href="#其他调试模式" class="headerlink" title="其他调试模式"></a>其他调试模式</h2><p>如果你想研究内存池如何管理未确认交易，你可以在启动钱包时使用“-mempool”来记录有关 mempool 的调试记录详细信息。其他调试选项包括：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*moSoRYu3G7FIzFBCAZwmyQ.jpeg" alt=""></p><p>探索这些选项能产生什么有趣日志行留作练习，“miner”选项就看起来特别好玩。</p><hr><h2 id="坏事发生在好钱包"><a href="#坏事发生在好钱包" class="headerlink" title="坏事发生在好钱包"></a>坏事发生在好钱包</h2><p>如果你的钱包有问题，那你可能需要从 debug.log 文件中的错误报告中获得排除故障的提示，因为<em>调试文件是你的好朋友</em>。</p><h3 id="1-网络连接断开"><a href="#1-网络连接断开" class="headerlink" title="1. 网络连接断开"></a>1. 网络连接断开</h3><p>Testnet 钱包将新区块同步到＃99,479，这时钱包突然断开以太网，因为有人 “意外” 失去互联网连接。从 20:46:46 开始强行关闭8个对等连接（听起来很痛苦）（为清晰起见，缩短了几行）：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*pLKhietmDJdxROIeMQfDXg.jpeg" alt=""></p><p>19分钟后，互联网连接在 21:03:09 恢复，但当前的区块是＃99,485（钱包落后6个区块），钱包开始迅速同步区块 99480,99481,99482,99483等。如果你看到 debug.log 文件中的这些“强制关闭”，你绝对应该与你的Internet服务提供商沟通。</p><h3 id="2-时钟设置不正确"><a href="#2-时钟设置不正确" class="headerlink" title="2. 时钟设置不正确"></a>2. 时钟设置不正确</h3><p><img src="https://cdn-images-1.medium.com/max/960/1*35zGj9pklLSWSIf5Cgcrzg.jpeg" alt=""></p><p>我一直强调人们在社交媒体上要把时钟设置正确，但现在我认为这对钱包来说更是个问题。钱包的参考时间是相当宽容的，钱包从它连接的所有对等点收集参考时间，并与当地时间交叉验证。Qtum 中的参考时间（继承自比特币）非常灵活，如果你在糟糕的时间启动它（Qtumd 不太确定），QT钱包会抱怨。 如果你的计算机时区和时钟设置正确，你可以执行“getinfo”命令，可以看到“timeoffset”接近零。</p><p>如果你正在运行 qtumd 服务器钱包 - 它可以与许多对等点连接，那肯定会发现一些有错误时间戳的区块，记录有 “block timestamp too far in the future”。 成功挖到新区块但是搞错参考时间的钱包运气不太好。 debug.log 会显示 10 到 20 个或更多由其他对等点中继的相同坏区块。下面是来自 4 个节点的相同坏区块（为清楚起见，缩短了几行日志）：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*2e5XbG-WJXDUVwMRgcxW3g.jpeg" alt=""></p><p>qtumd 记录了网络所有或好或坏的行为。你可以把你的钱包想象成在吵闹聊天室里的一个公平而无情的管理员（向 Tony Sydney 大喊大叫），它必须拒绝，删除和禁止用户提供不适当的消息。钱包必须禁掉节点，断开不活动的节点，并拒绝具有错误请求头的区块。你的钱包和其他钱包都是被称为 Qtum Mainnet Ignition 网络节点的“聊天室”中的 24/7（7天24小时） 管理员。</p><h3 id="3-钱包不同步区块"><a href="#3-钱包不同步区块" class="headerlink" title="3. 钱包不同步区块"></a>3. 钱包不同步区块</h3><p>老实说，很难通过防火墙阻止我的钱包连接到网络;钱包总是不停地穿过防火墙。 最后，我弄坏了钱包中的网络，因此它无法连接到其他对等点来获取本次启动的调试日志文件。钱包记录了 77 行，调试日志在“dnsseed thread exit”之后停止，没有同步区块。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*r-x-uCZVbPYX_tjhleMrbA.jpeg" alt=""></p><hr><h2 id="特别奖主题：虚拟机日志"><a href="#特别奖主题：虚拟机日志" class="headerlink" title="特别奖主题：虚拟机日志"></a>特别奖主题：虚拟机日志</h2><p>每个节点都将每个合约交易保存到区块链的本地副本上。当节点验证包含了合约交易的新区块时，它会将区块链索引到存储合约的区块，再处理这些合约交易。节点将这些合约交易的结果记录到虚拟机日志 vm.log 中。</p><p>你可以在 Qtum 文件夹中找到 vm.log 文件，以及 wallet.dat 和 debug.log。 vm.log 文件很简洁。 它列出了 UTC 交易时间和合约地址。如果发生错误，合约交易失败，它会将原因和时间、地址记录在一起。</p><h2 id="好交易"><a href="#好交易" class="headerlink" title="好交易"></a>好交易</h2><p>这里有一些很好的合约交易，vm.log 中记录的：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*8xU8iJK0LApxD5N7XF7GYw.jpeg" alt=""></p><p>如何阅读：日志行通常比资源管理器时间戳晚几秒钟，而资源管理器每 16 秒显示一次。在 24 小时制 UTC 时间 12:49:54 显示有 <a href="https://explorer.qtum.org/block/528fd5c961ab9eae7c91d78b3a51ecd2fdec0982721c6e78863ae2cc8b34b7e9" target="_blank" rel="noopener">112,818</a> 块，这时资源管理器时间戳为 UTC 时间 12:49:52。合约地址 57931faffdec114056a49adfcaa1caac159a1a25 是区块链里的 <a href="https://explorer.qtum.org/token/57931faffdec114056a49adfcaa1caac159a1a25" target="_blank" rel="noopener">SpaceCash（SpaceChain）智能合约</a>，因此我们知道钱包处理了 SPC 代币交易，我们可以查看区块 112,818，可以看到有人交易了 3,960 个 SPC 代币：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*alHQQjPR1BBT5kZLEVWweA.jpeg" alt=""></p><hr><p>你的博主坚信在资源管理器上浏览加密交易，较小的测试量是最好的开始。 如何才能进行代币交易？</p><p>假设你是最近空投的接收者。你已将 QRC20 代币添加到钱包，现在你已准备好发送代币交易。你从之前的博客中了解到，所有代币交易都是通过将交易发送到智能合约来实现的，你可以观察所有智能合约交易的执行，包括你的交易。</p><p>当你从钱包发送一些代币时，你可以查看<a href="https://explorer.qtum.org/token/6b8bf98ff497c064e8f0bde13e0c4f5ed5bf8ce7" target="_blank" rel="noopener">合约交易页面</a>并观察你测试的小交易。在确认交易进入智能合约后，无需更改钱包的其他内容，就可以放心发送剩余代币的交易。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*Td6nS76BGJbCoXEJ19spzQ.jpeg" alt=""></p><p>但是要是好的钱包发生了坏事 – 你的测试交易没有执行呢？</p><h2 id="不太好"><a href="#不太好" class="headerlink" title="不太好"></a>不太好</h2><p>以下是 vm.log 中记录的一些有问题的交易：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*Fd2RoS8HkIcgF56FJ7gteA.jpeg" alt=""></p><p>如何阅读：在 06:30:16 的第一笔交易中，智能合约在执行交易前耗尽了gas。 有人将 gas 设置得太低，所以他们失去了那部分 gas，但有机会重试。</p><p>在 10:05:39 的第二个例子中，合约报告有一个错误指令。我没有分析过这类错误，但是我认为如果你试图在 ICO 售罄后进行购买，它们可能会产生。</p><p>对于失败的合约调用，资源管理器将显示该交易为空白（没有代币名称，没有交易金额），但据我所知，vm.log 是找出合约交易失败原因的唯一方法。 如果你在代币交易方面遇到问题，那虚拟机日志也是你的好朋友。</p><hr><p>我们今天在罗马这个永恒的城市写完博客。《总统杀局》(Ides of March)是在两天后的 3 月 15 日放映，但我不想等到那个时候才发布这个博客。根据 Nodemap，意大利有 6 个Qtum节点，其中一个在罗马。Qtum 真的是世界级的（甚至至少有一颗低地球轨道卫星） - 为什么不庆祝一下罗马的历史，大都会文化和 Qtum 节点呢？</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*OBYeHUd4YNI3b9-kqRWrLA.jpeg" alt=""></p><p>这里希望你所有的交易都顺利进行，如果不的话，调试日志和虚拟机日志就是你的好朋友。</p><p>保重，保持在线安全。</p><p>Jackson</p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><p>研究调试日志时听的音乐：<a href="http://streema.com/radios/Easy_and_Italy" target="_blank" rel="noopener">Radio Easy＆Italy</a> - Rome </p></li><li><p><a href="https://youtu.be/B4GvcCWzZZg" target="_blank" rel="noopener">无人机在古罗马斗兽场</a>，Yuneec Q500无人机，4k观看.</p></li><li><p>通过以下主题查看我过去的报告</p></li></ol><p><a href="https://medium.com/@jb395official/qtum-capped-supply-the-halving-b650b7fb955e" target="_blank" rel="noopener">QTUM 的有限供应量</a> - 减半 - 2018年3月4日</p><p>如何减半，以及为什么永远不会超过 107,822,406.25 QTUM</p><p><a href="https://medium.com/@jb395official/qrc20-token-report-february-25-2018-ff397a1ac070" target="_blank" rel="noopener">QRC20 代币报告</a> - 2018年2月25日</p><p>QRC20 代币如何工作，最近的空投为例。 （阿姆斯特丹）</p><p><a href="https://medium.com/@jb395official/testnet-and-qtum-mainnet-performance-january-1-8-e7af03a5d430" target="_blank" rel="noopener">Testnet 和 Qtum Mainnet 性能 - 1月1日至8日</a></p><p>Qtum 测试网络（testnet）。 （巴西里约热内卢）</p><p>发布于2018年1月7日</p><p><a href="https://medium.com/@jb395official/qtum-mainnet-results-december-25-31-891680ee5a52" target="_blank" rel="noopener">Qtum Mainnet 成果 – 12月25日至31日</a></p><p>使用虚拟专用网络（VPN）进行 staking。（首尔）</p><p>发布于2017年12月31日</p><p><a href="https://medium.com/@jb395official/qtum-mainnet-results-december-18-24-8e43e51aca3b" target="_blank" rel="noopener">Qtum Mainnet 成果 – 12月18日至24日</a></p><p>交易费用。</p><p>发表于2017年12月24日</p><p><a href="https://medium.com/@jb395official/qtum-mainnet-results-dec-11-17-d5548947fa1f" target="_blank" rel="noopener">Qtum Mainnet 成果 – 12月11日-17日</a></p><p>Passphrases，一个密码短语猜测脚本。（日内瓦，瑞士）</p><p>发布于2017年12月17日</p><p><a href="https://medium.com/@jb395official/qtum-mainnet-results-dec-4-10-2d4bc438062d" target="_blank" rel="noopener">Qtum Mainnet 成果 – 12月4日至10日</a></p><p>内存池（mempool）和未确认交易处理。 （悉尼）</p><p>发布于2017年12月10日</p><p><a href="https://medium.com/@jb395official/qtum-mainnet-results-nov-27-dec-3-327c1e9bc59c" target="_blank" rel="noopener">Qtum Mainnet 成果 – 11月27日 - 12月3日</a></p><p>孤儿块（香港 - 大屿山）</p><p>发布于2017年12月3日</p><p><a href="https://medium.com/@jb395official/qtum-mainnet-results-november-20-26-ebde2cd0139" target="_blank" rel="noopener">Qtum Mainnet 成果 – 11 月 20 日至 26 日</a></p><p>QTUM.explorer.io 合约页面（柏林）</p><p>发布于2017年11月26日</p><p><a href="https://medium.com/@jb395official/qtum-mainnet-results-november-13-19-bfbf45d0c153" target="_blank" rel="noopener">Qtum Mainnet 成果 – 11月13日至19日</a></p><p>一个非常简单的 SHA-256 哈希算法示例（柏林 - 弗里德里希斯海因）</p><p>发布于2017年11月20日</p><p><a href="https://medium.com/@jb395official/qtum-mainnet-results-november-6-12-f59dd373ff3" target="_blank" rel="noopener">Qtum Mainnet 成果 – 11月6日至12日</a></p><p>分发钱包获得区块奖励 ，五大网络权重(Big Five Network Weight )（北京）</p><p>发布于2017年11月12日</p><p><a href="https://medium.com/@jb395official/qtum-mainnet-results-october-30-november-5-d58164b811db" target="_blank" rel="noopener">Qtum Mainnet 成果 – 10月30日 - 11月5日</a></p><p>SHA-256哈希算法，目标和难度（首尔）</p><p>发布于2017年11月5日</p><p><a href="https://medium.com/@jb395official/an-introduction-to-qtum-proof-of-stake-mining-a-racing-story-f11a3f48009f" target="_blank" rel="noopener">Qtum 权益证明挖矿 - 一个赛跑故事</a></p><p>关于 PoS 采矿的故事（柏林马拉松）</p><p>发布于2017年10月29日</p><p><a href="https://medium.com/@jb395official/qtum-mainnet-results-october-23-29-527cd4ab887a" target="_blank" rel="noopener">Qtum Mainnet 成果 – 10月23日至29日</a></p><p>基金会钱包的离开（柏林）</p><p>发布于2017年10月29日</p><p><a href="https://medium.com/@jb395official/qtum-mainnet-results-october-1-8-f413231c689a" target="_blank" rel="noopener">Qtum Mainnet 成果 – 10月1 - 8日</a></p><p>非正式的 staking 常见问题。</p><p>发布于2017年10月26日</p><p><a href="https://medium.com/@jb395official/qtum-mainnet-results-october-16-22-9202990b8e8d" target="_blank" rel="noopener">Qtum Mainnet 成果 – 10月16 - 22日</a></p><p>网络权重，奖励统计时间和节点图（2017年悉尼）</p><p>发布于2017年10月22日</p><p><a href="https://medium.com/@jb395official/simulating-proof-of-stake-mining-for-qtum-57401c08590a" target="_blank" rel="noopener">模拟 Qtum 的权益证明挖矿</a></p><p>为 PoS挖矿模拟选择正确的UTXO大小</p><p>发布于2017年10月21日</p><p><a href="https://medium.com/@jb395official/qtum-proof-of-stake-mining-439d2b82802d" target="_blank" rel="noopener">Qtum 权益证明挖矿</a></p><p>我的 1.0 版 PoS 挖矿模拟器</p><p>发布于2017年10月16日</p><p><a href="https://medium.com/@jb395official/qtum-mainnet-ignition-results-october-9-15-1efe30eb2658" target="_blank" rel="noopener">Qtum Mainnet 点火结果 – 10月9 - 15日</a></p><p>Mainnet 图表介绍（新加坡）</p><p>发布于2017年10月15日</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;https://medium.com/@jb395official/the-debug-log-the-virtual-machine-log-march-13-2018-76ddbe568f2&quot; target=&quot;_blank&quot; rel=&quot;noope
      
    
    </summary>
    
      <category term="区块链" scheme="http://xichen.pub/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://xichen.pub/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Qtum" scheme="http://xichen.pub/tags/Qtum/"/>
    
      <category term="翻译" scheme="http://xichen.pub/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】 测试网和 Qtum 主网性能</title>
    <link href="http://xichen.pub/2018/08/06/2018-08-06-%E7%BF%BB%E8%AF%91-%E6%B5%8B%E8%AF%95%E7%BD%91%E5%92%8CQtum%E4%B8%BB%E7%BD%91%E6%80%A7%E8%83%BD/"/>
    <id>http://xichen.pub/2018/08/06/2018-08-06-翻译-测试网和Qtum主网性能/</id>
    <published>2018-08-06T06:11:00.000Z</published>
    <updated>2018-09-01T09:45:38.715Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://medium.com/@jb395official/testnet-and-qtum-mainnet-performance-january-1-8-e7af03a5d430" target="_blank" rel="noopener">https://medium.com/@jb395official/testnet-and-qtum-mainnet-performance-january-1-8-e7af03a5d430</a><br>译者：中山大学数学学院（珠海）林学渊<br>大二时给量子做的翻译，转载注明出处，谢谢</p><h1 id="测试网和-Qtum-主网性能-1-月-1-日至-8-日"><a href="#测试网和-Qtum-主网性能-1-月-1-日至-8-日" class="headerlink" title="测试网和 Qtum 主网性能 1 月 1 日至 8 日"></a>测试网和 Qtum 主网性能 1 月 1 日至 8 日</h1><p><img src="https://cdn-images-1.medium.com/max/1600/1*NBzVZMM_MBTcQfbx0EKqig.jpeg" alt=""></p><p>以下是每周的 Qtum 主网性能的图表评估，包括常用的图和表，以及有关 Qtum 测试网（testnet）的教程。用已有的钱包你就能使用测试网来探索交易，区块奖励等等。测试网是很好的资源，不管是对新手还是对区块链开发者来说都是。那这个报告里，我们就玩一下测试网。</p><p>我是社区成员之一，也是独立研究者，还没加入量子团队，但非常欣赏他们的技术指导和社区中的高谈阔论。</p><hr><h2 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h2><p>Qtum Mainnet 性能评估的数据来自 <a href="https://explorer.qtum.org/" target="_blank" rel="noopener">Qtum Explorer</a>，区块链(从 qtumd 服务器应用程序登录)以及来自 <a href="https://goo.gl/maps/qrhNumMaiRQ2" target="_blank" rel="noopener">Ipanema Beach.</a> 的加密电报消息。</p><h3 id="独立奖励地址数"><a href="#独立奖励地址数" class="headerlink" title="独立奖励地址数"></a>独立奖励地址数</h3><p>这一周，每日独立奖励地址数最高于 1 月 5 日达 292 个。一整周里有 1,094 个独立地址，上一周是 964 个。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*Ga9v-FC6GxNSfUv60BsAAg.jpeg" alt=""></p><p>赢得多个区块的钱包数与上周基本持平。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*gqd_k6UM4MIQaH1cZIytkg.jpeg" alt=""></p><h3 id="每日活跃交易数"><a href="#每日活跃交易数" class="headerlink" title="每日活跃交易数"></a>每日活跃交易数</h3><p>1 月 5 日，每日交易数创下历史新高 17,043。这个高峰出现在周四，我们刚刚看到周五也有一个高峰。以太坊周四和周五的交易数最近都达到了峰值。比特币没有太明显的每周周期性，也没有智能合约。活跃交易为每个块提供的交易数高于保底交易数 2。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*VCF0YsLo1IN3XHzSfC_2yA.jpeg" alt=""></p><p>你还可以在 <a href="https://qtumexplorer.io/" target="_blank" rel="noopener">QTUM Explorer.io</a> 和 <a href="https://explorer.qtum.org/" target="_blank" rel="noopener">Qtum Explorer</a> 主页底部查看交易图表。</p><h3 id="块间​​距变化"><a href="#块间​​距变化" class="headerlink" title="块间​​距变化"></a>块间​​距变化</h3><p>从 1 月 1 日到 1 月 7 日，有 2 个区块有大于20 分钟的块间距，上个星期是 3 个。最大块间距是块 75,404，达 30 分 26 秒。平均块间距在 144 秒左右保持稳定。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*2eBQJ6QBvAb_J_xRioYZGg.jpeg" alt=""></p><h3 id="网络权重"><a href="#网络权重" class="headerlink" title="网络权重"></a>网络权重</h3><p>如下所示，每日“新网络权重”是基于计算每日获奖块的 10 天指数移动平均值和已知大钱包的余额：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*Qkq7MyiA5Wv--fWHjc6ATg.jpeg" alt=""></p><p>目前的网络权重为 2030 万，年回报率为4.3％。</p><hr><h2 id="测试网"><a href="#测试网" class="headerlink" title="测试网"></a>测试网</h2><p>健康的区块链生态系统不断发展和升级的，具有更多新的功能，随着主网（主生产网络，mainnet）的发展，它们一般并行运行一个或多个测试网。这些测试网是给开发者和其他有兴趣的人来探索、测试、开发的。有多个测试网可用于各种加密。Qtum 的公共测试网称为 “testnet”。</p><p><img src="https://cdn-images-1.medium.com/max/960/1*j3tmRvu8U_QNRgpuXarMyw.jpeg" alt=""></p><p>除非你正在测试新软件，否则你可以使用在 mainnet 上相同钱包应用程序（qtumd 服务器应用程序和 qtum-qt 桌面 GUI 钱包）连接到 testnet。 要在 testnet 上启动桌面 GUI 钱包 qtum-qt，只需打开开始菜单，点击它。</p><p>要启动服务器应用程序 qtumd 和命令行界面 qtumd-cli，请使用 “-testnet” 开关：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./qtumd –testnet</span><br><span class="line">./qtum-cli –testnet getstakinginfo</span><br></pre></td></tr></table></figure><p>Python 中可以这样写：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*xr2n3_tsXvdmW00nGPsotQ.jpeg" alt=""></p><h2 id="Testnet-问答"><a href="#Testnet-问答" class="headerlink" title="Testnet 问答"></a>Testnet 问答</h2><p>切换到问答模式。</p><p>问：testnet 与 mainnet 有什么不同？<br>答：Testnet 是一个独立的主网区块链。它有不同的块，不同的交易和不同的代币，但操作，协议和规格与主网相同（除非你正在测试新软件）。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*YvVgxUHRanWmn2x_F0lqQw.jpeg" alt=""></p><p>问：区块链在哪里？<br>答：在节点（钱包）的磁盘存储器中，在所有其他节点中具有相同的副本。</p><p>问：我的代币在哪里（测试网或主网）？<br>答：在钱包里，在区块里，以及在所有其他节点中这些相同区块的副本里。每个拥有区块链资源管理器或节点的人都可以看到你的代币，但只有你使用 wallet.dat 文件中的私钥才能发送或丢弃这些代币。即使你的计算机无法同步区块链，或者你的计算机爆炸，或者你删除了区块链文件，你的代币仍然在区块链里。你可以在将新钱包与 wallet.dat 文件的备份同步后检索。如果你丢失了 wallet.dat 文件（以及你对 wallet.dat 文件所做的所有备份），那么你的代币仍然会在区块链中永久可见，只是无法将它们发送出去。</p><p>问：testnet 和 mainnet 的钱包应用程序是否相同？<br>答：是的，testnet 和 mainnet 使用相同的钱包应用程序，可以在启动时切换到在 testnet 上运行。 注意 testnet 钱包 GUI 和徽标上有漂亮的紫色。 testnet 的另一个显着特征是地址，所有地址都以小写 “q” 开头，而主网地址则以大写 “Q” 开头。</p><p><img src="https://cdn-images-1.medium.com/max/1280/1*4yl3-n3lEz-UE0qIlUJsBw.jpeg" alt=""></p><p>问：区块链是否相同？<br>答：不。测试网和主网是两条不同的区块链。这在上面的图里可以看得出来。 Mainnet 比 testnet 早大约三周，因此主网块高度比 testnet 高大约 13400 个块。如果在同一台计算机上运行 mainnet 和 testnet，则钱包（节点）会将区块链同步到计算机的磁盘存储器中。 testnet 区块链将加载到文件夹 “testnet3” - 表示这是继承比特币代码的第 3 个 testnet 引用。 mainnet 区块链占用更多内存，因为它比 testnet 更高并且拥有更多的交易。 在2018年1月7日，主网区块链为 404 MB，而testnet区块链为 131 MB。</p><p>问：wallet.dat文件是否相同？<br>答：不，testnet 和 mainnet 分别有各自的 wallet.dat 文件。 testnet 的 wallet.dat 文件在 testnet3 文件夹里。</p><p>问：testnet 上的活动节点是否相同？<br>答：不，节点要么在主网上，要么在测试网上。目前处于活动状态的节点主网上大约有 2,000 个， 测试网上大约有 40 个。 在这些节点中，大约 30 个是大钱包，为测试网提供基线容量，它们的数量和大小与去年夏天的天网（Skynet）相似，当时主网还只是帕特里克眼中闪烁的光芒。天网是 mainnet 推出之前的公共测试网络。  Qtum 团队可能会运行这 30 个节点来为 testnet 提供基本的基础架构。</p><p>问：测试网和主网上的 QTUM 代币是否相同？我可以将一些免费的测试网代币转移到我的主网钱包吗？<br>答：不，它们是不同的代币。回到图上，在每个主网和测试网的创世块中铸造了100,000,000个代币：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*oMsTR8ocJizv0zc0tDjhwA.jpeg" alt=""></p><p>虽然代币的工作方式相同（它们是双胞胎，在出生时分开 - 相隔三周），但是不可能将测试网代币移到主网上。 在每个区块链中，你只能在创世区块的区块链上发送代币。<br>主网地址以大写“Q”开头，例如“Qa93nb …”，而测试网地址以小写“q”开头，例如“qto45H …”在钱包中输错 Q 或 q 地址将导致错误。</p><p>问：是否有针对测试网的区块链资源管理器？<br>答：是的，在<a href="https://testnet.qtum.org/" target="_blank" rel="noopener">testnet.qtum.org</a>。除了Nodemap之外，它还有所有可用的 testnet 信息。你可以看到人们正在测试的内容，例如块59,159，它有许多合约调用，包括一个 2.0 币交易费。 好事是测试网代币是免费的。</p><p>问：测试网有水龙头(Faucet)吗？<br>答：是的。水龙头是一个免费提供代币的网站。你可以将其视为按需空投。 testnet水龙头是 <a href="http://testnet-faucet.qtum.info/" target="_blank" rel="noopener">testnet-faucet.qtum.info</a>，你可以每24小时取一次测试代币。 输入你的测试网钱包地址就可以使用水龙头，在下一个区块中可以收到多达100个测试代币。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*IsncAR16SggSeysw__jT6A.jpeg" alt=""></p><p>另外，我想分享一些有关主网水龙头的消息：向智能合约地址发送 10 个 QTUM：QdonTFalLfoR$uchaNObvioUSscam， 然后你可以从这个水龙头中获得高达 5000 mQTUM。 仅限今晚午夜UTC。</p><p>问：我可以练习将测试代币发送到其他显示在水龙头上的地址吗？<br>答：当然，为什么不呢？ 我一直在天网（Skynet）上这样做，也许没有烦到其他人。</p><p>问：这是否意味着我可以了解更改地址，向许多人发送诈骗信息，在另一台计算机上备份和恢复加密钱包等等，而且使用测试网代币没有风险？我可以上 testnet 蹦跶，尝试一些新类型的交易，确保我完全理解它，然后在 mainnet 上运行相同的交易吗？<br>答：是的。</p><p>问：我可以在testnet上获得块奖励吗？<br>答：是的，这非常简单，因为网络权重如此之低，目前还不到400万。如果你每天从水龙头获得测试代币持续一周，你将有足够的资金每周赢得奖励。</p><p><img src="https://cdn-images-1.medium.com/max/960/1*pP-oIz-nSmIEJzxF5x_Htw.jpeg" alt=""></p><p>问：我可以在同一台计算机上运行 mainnet 和 testnet 的钱包吗？<br>答：是的。应用程序使用单独的区块链独立运行，所以这没有问题。它们可以同时运行，但我不推荐。</p><p>问：你能展示测试网性能的图表吗？<br>答：我以为你永远不会问。</p><hr><h2 id="图表-–-测试网络版"><a href="#图表-–-测试网络版" class="headerlink" title="图表 – 测试网络版"></a>图表 – 测试网络版</h2><p>测试网分析的数据源来自<a href="https://testnet.qtum.org/" target="_blank" rel="noopener">测试网块资源管理器</a>，测试网区块链(从testnet qtumd 登录)，以及来自Copacabana Beach的有关testnet的加密电报消息。</p><h3 id="独立奖励地址"><a href="#独立奖励地址" class="headerlink" title="独立奖励地址"></a>独立奖励地址</h3><p>测试网有 30 个核心钱包，并根据正在进行的测试动态地加入一些额外的节点。对于 12 月份的每日地址数，12 月 28 日达最高为 36，并且之前有很多天只有最低的 30 个独立地址：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*QLWqdqtrC8ILqnVr4jkhjg.jpeg" alt=""></p><h3 id="每日活跃交易数-1"><a href="#每日活跃交易数-1" class="headerlink" title="每日活跃交易数"></a>每日活跃交易数</h3><p>测试网上的交易很少。活跃交易是指每个块保底的两笔交易（coinbase和coinstake交易）之外的代币或合约的交易。例如，如果一天有 600 个块，就算没有人发送一个代币或合约交易，那么还是会有 1,200 个交易。活跃交易提供超过 1,200 保底的交易数。 这些交易适合使用水龙头，测试合约等的人。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*9VfnjjdmNC20wkT77q1gNg.jpeg" alt=""></p><p>你还可以在测试网块资源管理器主页的底部看到一个 14 天的交易图表。</p><h3 id="块间​​距变化-1"><a href="#块间​​距变化-1" class="headerlink" title="块间​​距变化"></a>块间​​距变化</h3><p>12 月平均块间距稳定在 145 秒左右：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*D_ibeistgR6gEXmXcVrFqg.jpeg" alt=""></p><p>对于 52,000 至 56,000（约一周）的区块，有 3 个区块间隔超过 20 分钟，区块 54,053 的块间距最大，为26分08秒。 这组测试网的块间距分布和主网差不多：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*pw3XLEuFEcb-WZPG4sOhig.jpeg" alt=""></p><h3 id="网络权重-1"><a href="#网络权重-1" class="headerlink" title="网络权重"></a>网络权重</h3><p>钱包网络权重的计算（随难度而变的平均值）显示测试网是随机变化的，类似于主网。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*FLVzg0mX_QLQfljVnhx8Ig.jpeg" alt=""></p><h3 id="年回报率"><a href="#年回报率" class="headerlink" title="年回报率"></a>年回报率</h3><p>网络权重为 394 万，测试网代币的年回报率为 22.2％。这是一些简单的 staking：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*q1EUeL4gqxk8PnB-3J4n-Q.jpeg" alt=""></p><hr><p>来吧！来测试网玩xue耍xi！它为你而生！</p><p><img src="https://cdn-images-1.medium.com/max/960/1*3B_vbb8AD2Pf9dlCNfNu6A.jpeg" alt=""></p><p>我们本周在里约写完报告。你可能想要去一个温暖，友好的地方，如巴西的里约热内卢（3 个节点的家），完败北半球的冬天。 海滩很漂亮，人们很友善（只是不要把你华丽的加密珠宝带到海滩）。在海滩上有一个新鲜的椰子，它们几乎和那些块奖励一样美味！</p><p>Obrigado，愿你的区块奖励像 <a href="https://goo.gl/maps/ixCp3L7xLTy" target="_blank" rel="noopener">Sugarloaf 山</a>（PãodeAçucar）的Copacabana海滩升起的太阳！</p><p>JB395</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*qHqzeqKkmojdrObKOMT4DA.jpeg" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><p><a href="https://medium.com/@bodhitoken/bodhi-prediction-market-alpha-is-live-on-qtum-testnet-da60dc31fe1f" target="_blank" rel="noopener">Bodhi Prediction Market Alpha</a> 现已上线 Qtum Testnet！ 在这里查看 Bodhi 的测试合约。</p></li><li><p><a href="https://live.blockcypher.com/btc-testnet/" target="_blank" rel="noopener">测试网块浏览器</a>，支持比特币和以太坊Ropsten。</p></li><li><p>如果你只关注此报告中的一个链接，那一定是<a href="http://www.ethviewer.live/" target="_blank" rel="noopener">以太坊区块链可视化</a>，来自澳大利亚堪培拉的联邦科学与工业资源组织（CISRO，Commonwealth Scientific and Industrial Resource Organization）。这是一个令人惊叹的网站，可以实时显示以太坊区块链。未确认交易在云（mempool）中浮动，然后随着区块链的增长弹入块中。对于交易，你可以查看单个发送，合约调用和合约创建（单击这些浮动图标可以转到区块链资源管理器）。 叔块（以太坊独有）显示为红色，你可以看到主链与绿色标题和绿色链接一起增长。你参加加密派对的话，可以在电视大屏幕上显示这个网站。</p></li></ol><p><img src="https://cdn-images-1.medium.com/max/1600/1*dAF7_KizBemD6UJ0mOL5tQ.jpeg" alt=""></p><p><img src="https://cdn-images-1.medium.com/max/960/1*48e1QKE1gXbpAorWcw_6ug.jpeg" alt=""></p><ol><li><p>推荐一段关于隐秘(cryptic)和加密(crypto)的关系的音乐，来自挪威/英国 EDM 制作人 Alan Walker，用在现场表演的视频<a href="https://youtu.be/Tfaq4UTH7P0?t=1m43s" target="_blank" rel="noopener">YouTube Space NY</a>里，由 Alan，Noah Cyrus 和 Juliander 创作（歌词不宜在办公室浏览，nsfw，Not Safe For Work），以及对持有者的一些话：“当它全部倒下时，那么随你。”</p></li><li><p>有关里约热内卢<a href="https://youtu.be/_1uEy-n4IsU" target="_blank" rel="noopener">伊帕内玛海滩</a>的悲伤歌曲，创作于智能合约和空投之前的一段时间。</p></li></ol><hr><h2 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h2><p>来自 <a href="https://medium.com/@mahmoudalkarim?source=post_header_lockup" target="_blank" rel="noopener">Mahmoud Al-Karim</a> 的问题，2018年7月23日：</p><p>问：需要为 qrc token 准备测试网 qt 钱包。</p><p>答：</p><p>这个博客“QTUM 102：建立自己的QRC20 token ”会有帮助吗？<a href="https://medium.com/@IAMEIdentity/qtum-102-build-your-own-qrc20-token-59547654b518" target="_blank" rel="noopener">https://medium.com/@IAMEIdentity/qtum-102-build-your-own-qrc20-token-59547654b518</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;https://medium.com/@jb395official/testnet-and-qtum-mainnet-performance-january-1-8-e7af03a5d430&quot; target=&quot;_blank&quot; rel=&quot;noopene
      
    
    </summary>
    
      <category term="区块链" scheme="http://xichen.pub/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://xichen.pub/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Qtum" scheme="http://xichen.pub/tags/Qtum/"/>
    
      <category term="翻译" scheme="http://xichen.pub/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】 Qtum Mainnet 成果</title>
    <link href="http://xichen.pub/2018/07/30/2018-07-30-%E7%BF%BB%E8%AF%91-QtumMainnet%E6%88%90%E6%9E%9C/"/>
    <id>http://xichen.pub/2018/07/30/2018-07-30-翻译-QtumMainnet成果/</id>
    <published>2018-07-30T06:11:00.000Z</published>
    <updated>2018-09-01T09:43:33.972Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://medium.com/@jb395official/newbie-wallets-april-1-2018-26ea7a06489c" target="_blank" rel="noopener">https://medium.com/@jb395official/newbie-wallets-april-1-2018-26ea7a06489c</a><br>译者：中山大学数学学院（珠海）林学渊<br>大二时给量子做的翻译，转载注明出处，谢谢</p><h1 id="Qtum-Mainnet-成果-12-月-25-日至-31-日"><a href="#Qtum-Mainnet-成果-12-月-25-日至-31-日" class="headerlink" title="Qtum Mainnet 成果 12 月 25 日至 31 日"></a>Qtum Mainnet 成果 12 月 25 日至 31 日</h1><p><img src="https://cdn-images-1.medium.com/max/2000/1*W8WwxhZCKQyshSbOSala2w.jpeg" alt=""></p><p>以下是每周的 Qtum Mainnet 性能的图表评估，包括常用的图和表，以及使用虚拟专用网络（VPN）和 Qtum staking rig 的教程。有一万个理由你应该使用 VPN 上网，甚至你应该使用 VPN 挖加密货币。这个星期我们就着眼于 VPN 以及 Qtum 节点如何（以及在​​何处）通过 VPN 连接吧。</p><p><img src="https://cdn-images-1.medium.com/max/960/1*hz1WsRESrjaRUX4fYmK0EA.jpeg" alt=""></p><p>我是社区成员之一，也是独立研究者，还没加入量子团队，但非常欣赏他们的技术指导和社区中的高谈阔论，以及这些酷酷的贴纸。</p><hr><h2 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h2><p>Qtum Mainnet 性能评估的数据源来自 <a href="https://explorer.qtum.org/" target="_blank" rel="noopener">Qtum Explorer</a>，区块链(从 qtumd 服务器应用程序登录)以及来自 <a href="https://kojects.com/2015/08/03/pangyo-techno-valley-visit/" target="_blank" rel="noopener">Pangyo</a> 的加密电报消息。</p><h3 id="独立奖励地址"><a href="#独立奖励地址" class="headerlink" title="独立奖励地址"></a>独立奖励地址</h3><p>这一周，每日独立地址数最高在 12 月 28 日达 294 个。整个星期里有 964 个独立地址，上周是 946 个，表示中小钱包正常参与。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*4x59pN_0p2aov4MTUpIJPQ.jpeg" alt=""></p><p>赢得多个区块的钱包数与上周基本持平。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*Epqt09iTodvvOgciSiJiUQ.jpeg" alt=""></p><h3 id="每日活跃交易数"><a href="#每日活跃交易数" class="headerlink" title="每日活跃交易数"></a>每日活跃交易数</h3><p>每日交易数从上周开始下滑，可能是因为放假。活跃交易为每个块提供的交易数高于保底交易数2。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*IsGgm3sTegVcqirPIxLfYg.jpeg" alt=""></p><p>你还可以在 <a href="https://qtumexplorer.io/" target="_blank" rel="noopener">QTUM Explorer.io</a> 和 <a href="https://explorer.qtum.org/" target="_blank" rel="noopener">Qtum Explorer</a> 主页底部查看交易图表。</p><h3 id="块间​​距变化"><a href="#块间​​距变化" class="headerlink" title="块间​​距变化"></a>块间​​距变化</h3><p>从 12 月 25 日到 12 月 31 日，有 3 个区块有大于20 分钟的块间距，上个星期是 6 个。最大块间距是块 71,003，达 24 分 34 秒。平均块间距在 144 秒左右保持稳定。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*ZP9yuGqgFdXUVByHF7NyoA.jpeg" alt=""></p><h3 id="新网络权重"><a href="#新网络权重" class="headerlink" title="新网络权重"></a>新网络权重</h3><p>如下所示，每日“新网络权重”是基于计算随每日获奖块的 10 天指数而变的平均值和已知大钱包的余额的：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*Pf4mIN4oZxQgD3lDlDH4iA.jpeg" alt=""></p><p>如年度回报率表所示，网络权重为 1,990 万，年回报率为 4.4％：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*h3m0WfiO939826ltmotV7A.jpeg" alt=""></p><hr><h3 id="更多关于交易费用的信息"><a href="#更多关于交易费用的信息" class="headerlink" title="更多关于交易费用的信息"></a>更多关于交易费用的信息</h3><p>这是上周关于交易费用报告的后续。我做了一些额外分析，发现了从硬件钱包发送的低费用交易 - 其中有47个。 现在这些交易都在区块链上，所以有一个快乐的结局。 <a href="https://medium.com/@jb395official/qtum-mainnet-results-december-18-24-8e43e51aca3b" target="_blank" rel="noopener">上周的报告</a>已经用这个信息更新了。</p><h2 id="VPN-你能看见我嘛？"><a href="#VPN-你能看见我嘛？" class="headerlink" title="VPN - 你能看见我嘛？"></a>VPN - 你能看见我嘛？</h2><p>这周的教程我们研究虚拟专用网络（VPN），以及它们如何与 Qtum staking 钱包一起使用。</p><p><img src="https://cdn-images-1.medium.com/max/960/1*kABDmEvHuU7qtlhXteDPhw.jpeg" alt=""></p><p>你可能需要考虑使用 VPN 的安全和隐私功能进行加密货币挖矿活动。有 VPN 的话你的网络对以下是不可见的 1) 你的Internet服务提供商（ISP）2）<a href="https://torrentfreak.com/vpn-server-seized-to-investigate-russian-ambassadors-assassination-1171219/" target="_blank" rel="noopener">老大哥(big brother)</a> 3）黑客（但是你可能获得恶意软件）。VPN提供商提供在你的计算机上运行的应用程序，以便与其远程服务器建立加密连接，从而将你的流量解密并上传到网络上。</p><blockquote><p>译者注：2）老大哥的梗是 Big Brother is Watching You（老大哥在看着你），是出自英国著名政治小说《一九八四》的金句。</p></blockquote><p>你的 ISP 无法解析 VPN 加密流量来看你正在浏览的网站（等等，我的 ISP 怎么知道我正在搜索<a href="https://youtu.be/-M0PJ_mTtRU" target="_blank" rel="noopener">可食用的内衣</a>？），你的 IP 地址也被隐藏，通过你的VPN服务转换为提供的远程服务器的 IP 地址。你还可以使用 VPN 绕过地理限制。</p><p>可能加密矿工也担心因为带宽使用情况的签名，将他们识别为持有比特币（Qtum）的矿工，这可能使他们成为黑客的目标。此外，有些应用程序可以监视节点对等 IP 地址并与区块链交易（发送）相关联，确定哪些 IP 地址赢得了块奖励。如果你通过 VPN 连接到网络，则不必担心任何这类问题，因为你的节点 IP 地址来自 VPN 服务器，而不是你的真实网络连接地址。</p><p>你能玩些使用 VPN 通过国际服务器连接到你的 staking 设备的游戏。比如，定位在Qtum Nodemap上未显示的国家/地区，突然有个节点出现在 Casablanca 等等。开启 VPN 后，你的节点应该在大约一周内从 Nodemap 删除。</p><p>我不会详细介绍如何选择VPN，但是在隐私和安全方面，有些服务比其他服务更好（在<a href="https://www.pcmag.com/article2/0,2817,2403388,00.asp" target="_blank" rel="noopener">这里</a>或<a href="https://www.cnet.com/best-vpn-services-directory/" target="_blank" rel="noopener">这里</a>阅读）。</p><p><img src="https://cdn-images-1.medium.com/max/960/1*IStUSWYZxsg5JBvwR942fw.jpeg" alt=""></p><p>如果你确实安装了一个VPN，那你应该选择附近的服务器以减少与 Internet 连接的延迟。不要连接到首尔的服务器（除非你的是 ROC 中的 600 多个节点之一）。我不得不微调 VPN 设置来让它稳定一点：为特定城市选择“最佳服务器”，并设置为“自动重新连接”。 此外，我建议你在激活 VPN 之前有一个稳定的 staking 设置，因为故障排除更难，比如，通过 VPN <a href="http://canyouseeme.org/" target="_blank" rel="noopener">CanYouSeeMe.org</a> 无法检查端口 3888 是否打开。</p><p>我注意到的另一件事是打开 VPN 后，IPv6 连接都断了。你可能会担心甚至开着 VPN ，你的 IP 地址还是泄漏了。如果你返回到你的 ISP DNS（域名服务器）查找IP地址的话，则会发生这种情况，因此好的 VPN 应该提供自己的 DNS。另一个问题似乎是 IPv6 地址并不总是通过 VPN 路由，因此 VPN 可以将其切断。</p><p>监控节点也可以连接到其他许多个节点（你在 Qtum 网络里可以轻易做到这个 - 我在看着你，Nodemap），以及寻找第一个中继新块的节点并记录该节点的 IP 地址。<a href="https://blockchain.info/blocks" target="_blank" rel="noopener">Blockchain.info</a> 做的事类似，通过“Relayed By”信息，它们能够识别大型比特币挖矿池。下面的“addrlocal”字段显示节点的 IP 地址，即显示启用 VPN 的对等点的 VPN 出口服务器地址。注意，这些块不携带任何IP地址，但可以监视网络上的节点，将节点 IP 地址与 Qtum 钱包地址相关联。</p><h3 id="Ping-时间"><a href="#Ping-时间" class="headerlink" title="Ping 时间"></a>Ping 时间</h3><p>你知道，Qtum 权益证明（PoS）挖矿以 16 秒的增量慢慢运行，所以启用 VPN 的几毫秒延迟应该问题不大。我想通过查看 ping 时间来验证这一点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">qtum-cli getpeerinfo</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        "id": 1,</span><br><span class="line">        "addr": "42.33.140.123:3888",</span><br><span class="line">        "addrlocal": "135.23.65.157:23569",</span><br><span class="line">        "services": "000000000000000d",</span><br><span class="line">        "relaytxes": true,</span><br><span class="line">        "lastsend": 1563586912,</span><br><span class="line">        "lastrecv": 1563586910,</span><br><span class="line">        "bytessent": 204216,</span><br><span class="line">        "bytesrecv": 138312,</span><br><span class="line">        "conntime": 1563583815,</span><br><span class="line">        "timeoffset": 0,</span><br><span class="line">        "pingtime": 0.0781,</span><br><span class="line">        "minping": 0.068727,</span><br><span class="line">        "version": 70016,</span><br><span class="line">        "subver": "/Satoshi:0.14.8/",</span><br><span class="line">        "inbound": false,</span><br><span class="line">        "addnode": false,</span><br><span class="line">        "startingheight": 8607,</span><br><span class="line">        "banscore": 0,</span><br><span class="line">        "synced_headers": 75092,</span><br><span class="line">        "synced_blocks": 75092,</span><br><span class="line">        "inflight": [</span><br><span class="line">        ],</span><br></pre></td></tr></table></figure><p>Ping 表示 Packet Internet Groper，它表示你的计算机可以与 Internet 上另一个节点通信的速度，例如，上面的对等点信息显示的 ping 时间是 78.1 毫秒。 我在网上看到的其他 Qtum 节点上最快的 ping 大约是 15 毫秒，如果节点位于世界的另一端，ping可以延长到几百毫秒。你知道接下来我会写什么：我爬了一堆数据，在Excel中处理它，并可视化出一些图表。</p><p>我从使用 getpeerinfo 的对等连接列表开始，并在激活 VPN 之前获得了 ping 时间。对于这个节点，有 123 个连接，平均 ping 时间为 170 毫秒：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*l2L2jeAF7BPeUKvZuPm3gQ.jpeg" alt=""></p><p>启用 VPN（但不重新启动节点），连接计数降了一两个小时，然后平均 ping 时间为187毫秒。在 VPN 启用后，大约一半的对等点连接成功转移。但所有 IPv6 对等点连接都断了。</p><p>为了研究 ping 时间和网络的影响，我选择了韩国首尔的 VPN 出口服务器，根据Nodemap，这个服务器托管着 270 个节点。难道用 VPN 可以更快 ping 到首尔的所有节点么？有 123 个连接，平均 ping 时间为 204 毫秒（在下图中，最长两个 755 和 797 毫秒的 ping 被切断）：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*YBYJlAwNkNos-vNCepR4sA.jpeg" alt=""></p><p>再来看看对等点在首尔 VPN 的出口位置。节点应该参与区域网络图的形成。记住，节点是通过在它们之间中继未经确认的交易和新块来工作。</p><p>首先，这是今天早些时候 Nodemap 中前 10 个国家的分布：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*ZF_hafRnF0Q70Fuvx0U4Sg.jpeg" alt=""></p><p>韩国和美国领先。这两者谁第一几乎每天都在变化，现在中国（ROC，应该是Republic of China 中华民国）已经落后了。对于在首尔使用 VPN 服务器的节点，分布不会发生太大变化：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*_RN4G5AQE5bCMIy_21xByw.jpeg" alt=""></p><p>“其他”组里，这些国家都有一个节点：印度，印度尼西亚，伊朗，日本，马耳他，荷兰，挪威，波兰，俄罗斯，新加坡和瑞典。在你的家庭办公室或云托管服务提供商中运行节点，可以在全球范围内与全球各地的 Qtum 节点进行全球通信。</p><p>下一周：你是这个邻域的新手，技术上很好奇，那么你在量子链上应该怎样玩耍？一步步安装钱包，练习备份和恢复钱包，甚至免费获得测试代币？下周：所有关于<a href="https://testnet.qtum.org/" target="_blank" rel="noopener">测试网</a>的那些事。<br><img src="https://cdn-images-1.medium.com/max/960/1*AOwG3MFc5Cx0M-zEvN_OaA.jpeg" alt=""></p><p>我们在首尔与我们的 VPN 服务器一起写完报告，并祝大家健康快乐，享受有区块奖励的新年。干杯，2018 年！</p><p>새해 복 많이받으세요（新年快乐）</p><p>JB395</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*iX-Wrcjua3QlFp149HBoqQ.jpeg" alt=""></p><hr><p>参考：</p><p>“窃听”攻击可以曝光多达 60％ 的比特币用户，<a href="https://www.coindesk.com/eavesdropping-attack-can-unmask-60-bitcoin-clients/" target="_blank" rel="noopener">Coindesk</a>，2014年6月</p><p>如何查看比特币交易的IP地址？ <a href="https://bitcoin.stackexchange.com/questions/193/how-do-i-see-the-ip-address-of-a-bitcoin-transaction?" target="_blank" rel="noopener">StackExchange</a>，2012</p><p>韩国无人机4K - 早晨平静的土地（釜山，巨济，首尔），<a href="https://youtu.be/9Vo68cjwOgA" target="_blank" rel="noopener">YouTube</a>，2017年11月<br><img src="https://cdn-images-1.medium.com/max/1280/1*Cy0XVKeezr-d7_SIzx1ABw.jpeg" alt=""></p><p>请参阅我之前放在 <a href="https://medium.com/@jb395official/latest" target="_blank" rel="noopener">Medium</a> 上的报告。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;https://medium.com/@jb395official/newbie-wallets-april-1-2018-26ea7a06489c&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://medium.com
      
    
    </summary>
    
      <category term="区块链" scheme="http://xichen.pub/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://xichen.pub/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Qtum" scheme="http://xichen.pub/tags/Qtum/"/>
    
      <category term="翻译" scheme="http://xichen.pub/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】 QRC20 token 报告</title>
    <link href="http://xichen.pub/2018/07/24/2018-07-24-%E7%BF%BB%E8%AF%91-QRC20token%E6%8A%A5%E5%91%8A/"/>
    <id>http://xichen.pub/2018/07/24/2018-07-24-翻译-QRC20token报告/</id>
    <published>2018-07-24T06:11:00.000Z</published>
    <updated>2018-09-01T09:42:36.338Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://medium.com/@jb395official/qrc20-token-report-february-25-2018-ff397a1ac070" target="_blank" rel="noopener">https://medium.com/@jb395official/qrc20-token-report-february-25-2018-ff397a1ac070</a><br>译者：中山大学数学学院（珠海）林学渊<br>大二时给量子做的翻译，转载注明出处，谢谢</p><h1 id="QRC20-token-报告-2018年2月25日"><a href="#QRC20-token-报告-2018年2月25日" class="headerlink" title="QRC20  token 报告 - 2018年2月25日"></a>QRC20  token 报告 - 2018年2月25日</h1><p><img src="https://cdn-images-1.medium.com/max/1600/1*JGGMMQFeumk3QOj8412xgQ.jpeg" alt=""></p><p>为了表达我对社区的感谢，这里有一个关于 Qtum QRC20  token 的教程：它们是什么，它们在哪里，如何与它们交互，如何查看它们以及如何创建和销毁它们，用最近的 token 空投为 Qtum 持有者解释 token 生命周期中的这些细节。</p><p>我是一名独立研究员，偶尔写博客和主持社交媒体，十分中意Qtum的技术指导以及社区讨论。如果你对本文有想法或批评，请在社交软件上发给我或在下面评论。</p><hr><h2 id="主网性能"><a href="#主网性能" class="headerlink" title="主网性能"></a>主网性能</h2><p>首先，简要回顾最近的 Qtum 主网性能。</p><h3 id="独立奖励地址"><a href="#独立奖励地址" class="headerlink" title="独立奖励地址"></a>独立奖励地址</h3><p>过去 7 天里，每日独立地址数最高于2月25日达 306 个，平均值是 291 个每天。这意味着每天 600 个区块的区块奖励中，几乎一半是小钱包赢得的。一周的独立地址数是 1,107。这些数字表示，与 10 天前相比，独立奖励地址数有略微增加，也暗示部署的小钱包更多了，这在我的<a href="https://medium.com/@jb395official/happy-new-year-qtum-mainnet-performance-february-9-15-a696e8e8396e" target="_blank" rel="noopener">新年报告</a>中有提到。</p><h3 id="节点数"><a href="#节点数" class="headerlink" title="节点数"></a>节点数</h3><p><img src="https://cdn-images-1.medium.com/max/960/1*TmK1vTY41-kiWn6hcU_sIQ.jpeg" alt=""></p><p><a href="https://qtum.org/en/nodemap" target="_blank" rel="noopener">节点地图(Nodemap)</a>显示，节点数在3,250左右，其中大约1,260个在中国。我想如果节点地图能跟上即将到来的节点数的数量级增加，其他区块链节点地图也能处理很多节点就好了，那么让我们祝愿节点地图更加健壮，足以应对这些增加的工作量吧！</p><h3 id="交易费用"><a href="#交易费用" class="headerlink" title="交易费用"></a>交易费用</h3><p>去年，交易费用只占每天区块奖励的百分之几。两个星期前，交易费用大约占区块奖励的一半。刚过去的一个星期里，<a href="https://explorer.qtum.org/stats" target="_blank" rel="noopener">资源管理器</a>显示有几个时间段是交易费用比区块奖励还多(每个时间段是24小时制)。如果资源管理器计算正确，这意味着网络内交易数有很大的增幅，尤其是智能合约调用( token 和DAPP)，这一般会带有 0.1 QTUM 费用。随着空投的部署，交易费用出现了一些大高峰。</p><h3 id="块间距"><a href="#块间距" class="headerlink" title="块间距"></a>块间距</h3><p>块间距稳定在 600 块每天附近。在2月11到2月24两个星期内，有14个区块，间隔超过20分钟，最长间隔是到区块 98,210 的 31 分 20 秒。</p><h3 id="网络权重"><a href="#网络权重" class="headerlink" title="网络权重"></a>网络权重</h3><p>我计算网络权重的方法依赖于具有已知余额的大钱包所获得的块奖励百分比。这种方法提供了比钱包计算估计的网络权重更稳定和准确的数字。在上周，这些总余额为 664 万的大型钱包获得了 26.4％ 的块奖励，网络权重为 2520 万。网络权重为2520万表示年度回报率为3.5％。</p><hr><h2 id="token-时间"><a href="#token-时间" class="headerlink" title="token 时间"></a>token 时间</h2><p>如果你只想要理解 QRC20  token ，下面是太长不看版：</p><p>QTUM QRC20  token 是标准化的数字资产，它们在 Qtum 智能合约中创建并活在这个智能合约中，永不离开合约。通过与合约交易可以将 token 分配给不同的所有者，合约存储 Qtum 地址列表和每个地址拥有的 token 。任何人都可以创建智能合约并创建 token ，而所有 token 的智能合约都存在于Qtum区块链中。 token 代表了区块链 2.0 平台的重要功能，性能和经济价值。</p><p>为了更深入地了解 token ，我们在发现之旅中的陪同者将是爱丽丝，一位 150 岁的文学角色，对加密货币有着天生的好奇心：</p><p>这时，爱丽丝跳了起来，她突然想到：从来没有见过穿着有口袋背心的兔子，更没有见到过兔子还能从口袋里拿出—块表来，她好奇地穿过田野，紧紧地追赶那只兔子，刚好看见兔子跳进了矮树下面的一个大洞。爱丽丝也紧跟着跳了进去，根本没考虑怎么再出来。爱丽丝梦游仙境，刘易斯卡罗尔，1865年。</p><p><img src="https://cdn-images-1.medium.com/max/960/1*WV0uHmsnntYONJqpu9uwRw.jpeg" alt="1923年之前在美国出版"></p><p>爱丽丝想向 <a href="https://en.wikipedia.org/wiki/Alice_and_Bob" target="_blank" rel="noopener">鲍勃</a> 发送10个 Wonderland（WON） token 。 但是，当爱丽丝试图用她的钱包中进行交易时，事情变得越来越怪。爱丽丝决定学习关于 QRC20  token 的所有内容，并跟随一只名叫 Satoshi 的白兔，她最终从兔子洞落到一个充满了 token 和智能合约的另一个宇宙中。</p><p><img src="https://cdn-images-1.medium.com/max/960/1*kAq8FdtMgY11yJVJTFMNAQ.jpeg" alt=""></p><p>如果你想加入爱丽丝并掉入兔子洞以了解关于 Qtum QRC20  token 的所有信息，请继续阅读，包括爱丽丝在吃完蘑菇后发现的两个秘密。</p><p><img src="https://cdn-images-1.medium.com/max/960/1*QJCUoHDb6wZ1JAQWhZZ1XA.jpeg" alt="一些命运多舛的物理 token "></p><p>让我们从一些基本的解释开始。 QRC20 token 是可编程数字资产，创建于 Qtum 区块链的智能合约。 Qtum 区块链及其 EVM（以太坊虚拟机，Ethereum Virtual Machine）提供可执行代码和存储数据的智能合约。 使用Qtum Core 钱包，Qtum 手机钱包和 Qtum Web 钱包可以轻松创建带有 token 的基础智能合约。目前，更复杂的智能合约可以用编程语言 solidity 编写并发布在区块链上。</p><p>Qtum 继承了当前的虚拟机，用于执行来自以太坊有 token 的智能合约。 在以太坊中，基础 token 被称为 <a href="https://theethereum.wiki/w/index.php/ERC20_Token_Standard" target="_blank" rel="noopener">ERC20</a>，以Ethereum Request for Comments 20命名。这是添加 token 功能的协议，于 2015 年发布。 Qtum  token 命名为 QRC20，因为它遵循与 ERC20  token 相同的协议和标准。</p><p>爱丽丝知道可视化区块链模型 - 智能合约 -  token 架构是可行的（并且在进行交易时更安全），这也有助于解释 token 和空投如何运作。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*wd_2Plln8SKI-P3XBZi71Q.jpeg" alt=""></p><p>智能合约在合约创建交易中发布到网络，该交易包含在特定区块中，在这个区块里智能合约将永久存在。上图显示了一个智能合约（测试网区块 34,546 中的 Bodhi 合约）管理 QRC20  token ，合约将有存储空间来跟踪余额信息并提供六个功能来创建 token ，在地址之间转移 token ，查看余额等等。</p><h3 id="合约创建"><a href="#合约创建" class="headerlink" title="合约创建"></a>合约创建</h3><p>当合约创建交易发布到区块链时，智能合约在 Qtum 区块链上开始生效。 要看一下这样的合约创建交易，我们可以查看测试网上的 <a href="https://testnet.qtum.org/address/f6177bc9812eeb531907621af6641a41133dea9e" target="_blank" rel="noopener">Bodhi合约</a>（我在主网上找不到 Bodhi 合约）。</p><p>开发人员使用测试网来评估和测试他们的软件，这正是Bodhi对这个智能合约做的。</p><p><img src="https://cdn-images-1.medium.com/max/960/1*bJ-89iOHGgtktwQlGJ2QQQ.jpeg" alt=""></p><p>Bodhi 测试智能合约开始生命周期于测试网块 35,456，2017年11月20.合约创建了 335,000 测试用的 BOT  token ，Bodhi 开发者能运行测试，确保代码准备好发布到主网了。</p><h3 id="交易所和钱包"><a href="#交易所和钱包" class="headerlink" title="交易所和钱包"></a>交易所和钱包</h3><p>下面，我们来看一个交易所和钱包的简化模型，这有利于了解空投如何运作。</p><p>注意，在下图中，为了清楚起见， Q 地址是有序的。实际上，块编号是有序的，但 Q地址是随机的。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*kqQq7jeQwAyhva8BwaQleg.jpeg" alt=""></p><p>如图所示，交易所客户可以自己买卖，不需要区块链交易。 交易所使用一个热钱包和一个冷钱包（可能是每个的倍数）保存余额。 对于这个例子，交易所具有6,000,000个币的余额，这些币作为交易存储在区块链中，但从不存储在交易所本身中。 后来，爱丽丝吃了蘑菇，并了解了这些币的秘密。</p><p>我们考虑两个交易。首先，一个账户从交易中提现 300 币到个人钱包。为了实现这个，客户输入钱包地址（这里是Q 12），交易热钱包（可能通过交易所的中间地址）发送 300 个币的交易。其次，对于存入交易所的存款，客户输入其交易账户的存款地址，并将交易（可能通过交易所的一些中间地址）发送到交易所热钱包。</p><p>现在让我们看看一些直接连接到区块链的钱包，而不是通过交易所。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*Ryt8vgqj5bNTK2QVI01Osg.jpeg" alt=""></p><p>前面我将钱包描述为区块链上可以管理货币的浏览器。作为早期的加密货币使用者，爱丽丝可以向我们提供钱包角色的更多细节：</p><ul><li>浏览区块链并根据过去的交易计算余额</li><li>持有私钥并签署交易</li><li>设置交易费用（将随时间变化）</li><li>对于某些钱包，发布智能合约和合约调用（ token 交易等）</li></ul><p>只有全节点（含有整个区块链）可以将交易发送到网络以写进区块链中，因此上面使用简化支付验证的钱包（手机钱包）和其他轻量级钱包都必须通过全节点与区块链交互。</p><p>爱丽丝想要指出钱包本身并没有持有任何货币或代币，因为货币或代币总是存放在区块链上。 我们将在下面看到（扰流警报）即使在区块链上， token 也永远不会离开创建它们的智能合约。 它们该有多么无聊！</p><p><img src="https://cdn-images-1.medium.com/max/960/1*YkNZt1jTzxJCh7cPhvz6yg.jpeg" alt=""></p><p>当我们沿着兔子洞向下走时，爱丽丝有一个关于货币分享的秘密。 她说 Qtum 区块链上没有真正的货币。钱包为地址计算未花费的交易额总和，因此“货币”更像是Excel电子表格SUM公式的结果。 另一方面，QRC20 token 值是单独的金额，如Excel中单个单元格中的值。</p><hr><h2 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h2><p><img src="https://cdn-images-1.medium.com/max/960/1*zq6vblhARhPm-SaJXJyisw.jpeg" alt=""></p><p>当我们跟着爱丽丝走下兔子洞时，我们决定采取自拍或者说快照。空投快照​​是特定时间，特定区块的区块链读数。对于Bodhi空投，快照是在 2013 年 2 月 2 日 23:40:16 UTC 的 <a href="https://explorer.qtum.org/block/b14805dbcf2652075b185ea46322416186a5319861e9a317b7f1671368868078" target="_blank" rel="noopener">93,333 块</a>。爱丽丝指出，数字 3 和 9 在中国被认为是幸运的，代表着生活，生命和永恒。</p><p>然后发生的（猜一猜……）是 Bodhi 取区块链中 0 到 93,333 块，解析所有交易，找到每个 Qtum 地址的余额。</p><h3 id="空投"><a href="#空投" class="headerlink" title="空投"></a>空投</h3><p>这一节爱丽丝告诉你谁领到了空投，答案是：所有人。真正的问题是你是否有通过钱包或交易所来访问 token 的方法。</p><p>Bodhi 报告称他们以 4：100 的比例为 Qtum 持有者空投了4,015,325.92 BOT 代币，这意味着他们空投了 100,383,148 QTUM（他们排除了少于 10 QTUM 的地址）。 根据流通图表中的QTUM，2月2日有 100,353,364 QTUM（到目前为止，创造了1亿+块奖励），这意味着几乎每个 Qtum 地址都收到了BOT</p><p>空投的简单公平的方法是给每个活动地址提供 token 。为了检查快照所看到的区块链历史记录有多长，爱丽丝使用时光机（Explorer）来查看最早的块奖励获奖者。 她找不到创世块（1-5000）中任何活跃的钱包地址，但是这个家伙 <a href="https://explorer.qtum.org/address/QaHAXr7eqXZMvUp5HUXDZh1Pk4GhNMCh5b" target="_blank" rel="noopener">…Ch5b</a> 在 2017 年 9 月 8 日赢得了 <a href="https://explorer.qtum.org/block/6dbc7316f94cebff1dc27e13d4e698b97675f9924989d57bbb92ef85976c3fde" target="_blank" rel="noopener">5,041 块</a>，这是一个真正的 <a href="https://www.urbandictionary.com/define.php?term=OG" target="_blank" rel="noopener">OG</a> 钱包，在 2017 年 10 月之前挖了点矿。…Ch5b 仍有余额并确实收到了 BOT 空投。在看到合约调用工作后，我们将在下面看到实际的空投交易。</p><p>我们可以从上面回到我们的图，看看空投如何填充各种区块链地址。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*4WY94A6c--VwqISR6ixeWA.jpeg" alt=""></p><p>现在我们可以在区块链的左侧看到 Bodhi 智能合约存储，其中 BOT 空投到所有的地址。例如，地址 Q2 的交易所冷钱包将有 200,000 个 BOT 空投。该图中有两个时序假设。1）如果 Q10 的存入发生在块 93,333 之后，那么该地址仍然有 10 个 BOT 来自空投。 2）如果 Q12 的提现发生在块 93,333 之前，那么它将收到空投。</p><p>让我们看一下钱包在空投中的行为。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*RYLM_ns6iOIUUG7zf6ssYQ.jpeg" alt=""></p><p>这与预期非常符合，因为 BOT 被空投到每个活动地址（大于10 QTUM）。如上所述，这个包罗万象的空投问题是钱包是否可以访问 token ，这意味着钱包必须有办法添加 token 合约地址，并能够创建和发送 token 合约调用，而不是上面所有的钱包都可以做到这一点。</p><h3 id="与智能合约交流"><a href="#与智能合约交流" class="headerlink" title="与智能合约交流"></a>与智能合约交流</h3><p>回到爱丽丝原来的问题，爱丽丝把我们带到了这个兔子洞，爱丽丝想要向鲍勃发送 10 个 WON  token 。 可以这样类似地想。如果爱丽丝想要向鲍勃发送 10 个 token ，她不能简单地将 10 个 token 从她的钱包发送到 Bob 的钱包，即他的 Q 地址。这种方法存在一些问题。首先，代币不在爱丽丝的钱包中，而是在智能合约中。其次， token 不会被发送到鲍勃的钱包，它们会被移到智能合约存储中的鲍勃的 Q 地址。</p><p>不用担心交叉，爱丽丝的钱包知道如何与智能合约交流，因为她添加了 token 并输入了她钱包里的智能合约地址。向鲍勃“发送” token 的交易实际上被发送到智能合约，并且鲍勃的 Q 地址以及要转移给鲍勃的 token 的数量都作为数据被包含在合约调用交易中。 我们等下将在合约调用中查看数据，这之前先修复另一个易混淆因素。</p><p>比特币地址和 Qtum Q 地址由人们显式输入为 Base58 编码的字母数字字符。你可能从未注意到它（爱丽丝从未这样做过）但比特币和Q地址从不包含数字零，大写字母O，大写字母 I 或小写字母 l。其他的数字和字母都还好，但是如果名叫 Satoshi 的白兔子发现未来的加密货币用户搞砸了，会完全输入 “0”“O”“I”“l”（这很难，是的），为了减少 Bithumb 和 Coinbase 痛苦的客户服务电话，当人们将他们的比特币发送到错误的地址的时候，他们只需忽略这些字符，这对于一只兔子来说是非常具有前瞻性的想法。 这是很复杂的因素。 人类可读的 Base58 地址被转换为更有效的十六进制地址，用于在合约调用交易中发送，以及在智能合约中存储。 要在Base58和十六进制之间进行转换，请使用此网页进行<a href="http://lenschulwitz.com/base58" target="_blank" rel="noopener">Base58编码，解码和验证</a>。</p><p>现在我们可以查看合约调用中的数据，这是一个典型的例子：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*5yaPFlbxtfjd_B4R1oMkhA.jpeg" alt=""></p><p>数据显示：</p><ul><li>a9059cbb 表示这是一个转移操作</li><li>e22843f9a4 …是要转给的地址，以十六进制表示</li><li>3956ed39 转移的数量，十六进制，satoshis</li></ul><p>你对实际完成的空投怎么看？Bodhi 基金会不得不发出这么多合约调用。一旦智能合约启动，它很高兴在区块链中坐等指令。对于空投，这些指令将 BOT 从 Bodhi 基金会地址转移给所有的空投接收者。 例如，你可以在 2 月 15 日早上看到这种空投，比如 <a href="https://explorer.qtum.org/block/1405ac26eb8107936299c3103bb47c5ccd2764b4987f2d28956c7265e246a8c0" target="_blank" rel="noopener">100,719</a> 这样的块，有这么多、大的合约调用，它收 20  QTUM 的交易费！ 这些块包含多个合约调用，每个调用最多 200 个交易，因为Bodhi 更新了合约存储来执行空投。 以下是一些 Q 地址的空投交易：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*pvkrR5sNL5UFERrlH3RAtA.jpeg" alt=""></p><p>所有这些更新 Bodhi 智能合约的交易都已发布到区块链的 100,719 块和其他区块，但区块链中的智能合约存储实际上是如何更新的？ 显然，块奖励获奖钱包在区块链的本地副本中处理这些智能合约调用，将更新填充到其本地存储适当的块中。</p><p>以下是爱丽丝想要分享的第二个秘密：所有的全节点验证新块，它们还在智能合约块的本地副本上处理智能合约交易。 爱丽丝的第二个秘密是 - 每个节点在发布块时执行每个合约调用。</p><p>我们可以看看这些数据如何存储在智能合约中（再次使用令人困惑的十六进制地址）：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*urwLCJ_jmRN_hIDdXDmhyg.jpeg" alt=""></p><p>你想要的话，你可以浏览这个存储，找到你的地址，以及你地址的 token 数。不过不要试这个，有一个更简单的方法来看你的 token 余额，爱丽丝将在下面向我们展示。不过你知道我无法看着这样一个丰富的数据表而不抓着它运行一些 Excel 分析。</p><p>在资源管理器的智能合约页面，点击“显示所有”按钮，然后等一杯咖啡的时间让你的浏览器加载 31,944 项。一些我看不懂的有趣数据：有许多地址有1或2个satoshis token （0.00000001或0.00000002 token ），在其他区块链上称为灰尘。忽略这些条目， token 分布是：</p><p><img src="https://cdn-images-1.medium.com/max/1280/1*Flc-zyUqsIzrDo_o5hvG0Q.jpeg" alt=""></p><p>10个最大的代币持有量如在下图所示。爱丽丝猜测，4000 万那个位置是 Bodhi 基金会，其余的是交易所。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*Pt-Y_YNWLmIrUzGrXAYEOg.jpeg" alt=""></p><h3 id="查看你的-token-余额很容易"><a href="#查看你的-token-余额很容易" class="headerlink" title="查看你的 token 余额很容易"></a>查看你的 token 余额很容易</h3><p>爱丽丝想要有一个超级简单的方式检查合约存储中的 token 余额。她说要导航到<a href="https://explorer.qtum.org/tokens/search" target="_blank" rel="noopener">代币</a> 页面</p><p><img src="https://cdn-images-1.medium.com/max/960/1*krUT59IAL2elF-47wX8R9g.jpeg" alt=""></p><p>我们找不到她的WON token ，所以在这个例子中会使用 BOT; 点击 “BOT - Bodhi Token” 这个名字</p><p><img src="https://cdn-images-1.medium.com/max/960/1*rgAnhE_efD0Nm6m2RZkl9g.jpeg" alt=""></p><p>选择“READ SMART CONTRACT”并将 Q 地址粘贴到 “BalanceOf” 字段中，然后选择“Query”。 将出现 satoshis 的余额。获取 token 中的余额，将小数点向左移动 8 位（仅这个 token ）。</p><p>如果你可以在资源管理器中查看 token ，也可以通过在资源管理器中单击地址的 token 收藏来获取此页面的快捷方式。</p><h3 id="资源管理器中的-token"><a href="#资源管理器中的-token" class="headerlink" title="资源管理器中的 token"></a>资源管理器中的 token</h3><p>空投后，爱丽丝感到很困惑，因为她无法在资源管理器中看到她的地址的代币，但有其他地址已经自豪地展示了他们的代币。</p><p>要理解为什么资源管理器感觉不到空投代币，请记住空投是如何工作的：快照，一些处理，然后空投合约调用智能合约，没有任何东西触及区块链上的 Q 地址。</p><p>资源管理器一直处于蒙蔽状态，直到你将 token 添加到钱包并使用你的 Q 地址进行 token 交易（无论多小）。或者重新加载你的钱包（爱丽丝必须与白兔核对这个），然后资源管理器才知道你拥有该 token ，查询智能合约并正确显示 token 余额。</p><p>以太坊资源管理器内置了最受欢迎的 ERC20  token ，因此你可以查看给定地址的 token 。 也许 Qtum 资源管理器未来的版本中会也有这个功能。</p><h3 id="烧币（Burning-Tokens）"><a href="#烧币（Burning-Tokens）" class="headerlink" title="烧币（Burning Tokens）"></a>烧币（Burning Tokens）</h3><p>现在我们已经到了爱丽丝兔子洞的底部，是时候讨论在它们的使用寿命结束时如何销毁或“烧毁” token 。例如，在 Qtum Mainnet Ignition 启动之前，Qtum  token 以Ethereum ERC20  token 的形式存在。 2017年10月初，各种交易所允许 Qtum 代币持有人提交他们的 Qtum ERC20 代币换成 QTUM Mainnet 代币，换掉的 Qtum ERC20 代币随后被烧毁。</p><p><img src="https://cdn-images-1.medium.com/max/960/1*G-o_Li8O9erWSCtL4vN2Bw.jpeg" alt=""></p><p>为什么有人想要收购好的 token ？也许 token 会升级为新的代币或代币，就像 Qtum 的情况一样。此外，组织可以回收一些代币库存以减少供应，支持价格，类似于公司回购自己股票。</p><p>烧毁 token 你需要把他们发送给一个不存在的地址，将它们永久留在那里。例如，我们造个以太坊地址 0x1111111111111…，一个没有人拥有私钥的合法地址。我们告诉智能合约把 token 转移到那个地址，然后它们就被永久销毁了。我们可以在以太坊 Qtum ERC-20  token 页面查看这些可怜的 token ，并通过累计所有烧毁地址的百分比，看到 97.05％ 的旧 Qtum ERC20  token 已被烧毁：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*PYIvcJLrmpFiiOBumwdD9Q.jpeg" alt=""></p><p>如果你持有 Qtum ERC20 代币，那么建议在代币变得毫无价值之前，将这些 ERC20 代币转换为 Qtum Mainnet 代币。查一下社交媒体，看看是否还有可以完成这种交易的交易所。请快点，因为 Qtum ERC20  token 将永久埋葬在加密墓地，并且这些 token 将变成纪念品，因为不能再换成主网币。</p><hr><p>我不确定 Patrick 最近在哪儿环球旅行，但我认为 Earlz 最近参加完柏林的聚会，回到了阿姆斯特丹。我有几篇报告有柏林的照片，所以让我们在阿姆斯特丹完成。</p><p>阿姆斯特丹是一座历史悠久的城市，拥有美丽的运河，提供“咖啡”的咖啡馆，以及全年提供特殊照明的红灯区。</p><p><img src="https://cdn-images-1.medium.com/max/960/1*m49FhTcFoPWjQ3F7ITB90g.jpeg" alt="高买高卖"></p><p>阿姆斯特丹是郁金香泡沫的家园（1637年内爆），有些人将其与所谓的加密货币泡沫相提并论。 但是，如果你做自己的研究（DYOR），你可以类比区块链2.0平台，如 Qtum（成立于2017年）类比荷兰东印度公司（成立于1602年），这是第一家具有重要新商业范例的全球性公司（第一家） ，在股票市场公开交易），在当时是世界上最有价值的公司。</p><p>我们不要在风车上谈论泡沫。在阿姆斯特丹附近看一些精美的风车吧。今天，这些风车是优雅的历史宝石，但在它们的荣耀中，它们是锯木材，磨面粉和提取亚麻籽油的工业机器。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*NjSFeijRaqW18QJ1efVEQA.jpeg" alt=""></p><p>我很高兴地报告说，爱丽丝确实爬出了兔子洞，如果你看到她和白兔说话，不要担心，他们可能只是讨论区块链治理和扩展。</p><p>我希望你和爱丽丝一起享受这段旅程，了解 token 以及你的代币将非常有用和有利可图。</p><p>Jackson (JB395)</p><hr><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol><li><p>官方 Qtum Core 和 QRC20 Token 指南：<a href="https://blog.qtum.org/qtum-core-qrc-20-tokens-1c2734d6290c" target="_blank" rel="noopener">Medium</a></p></li><li><p>来自社区的一些出色的QRC20 token 资源：</p></li></ol><ul><li>Silverminer, 如何评价 Bodhi  token 。<a href="https://steemit.com/qtum/@silverminer/how-to-claim-bodhi-tokens" target="_blank" rel="noopener">Steemit</a></li><li>Sam Suh，使用 QBao 钱包的 QTUM 钱包教程 - 用于 Bodhi（BOT）代币或其他 QRC20 代币。<a href="https://medium.com/@samsuh_33856/qtum-wallet-tutorial-for-bodhi-bot-tokens-qrc20-tokens-using-qbao-ac14f9445dc8" target="_blank" rel="noopener">Medium</a></li></ul><ol><li><p><a href="https://bodhiproject.github.io/wiki/" target="_blank" rel="noopener">优秀参考资料</a>，关于移动端，QBao，qtum-qt 和qtumd / qtum-cli 等钱包从 Bodhi 基金会添加代币和代币交易。</p></li><li><p><a href="https://github.com/bodhiproject/bodhi-core/tree/master/contracts/tokens" target="_blank" rel="noopener">Github</a> 上的 Bodhi  token 合约。</p></li><li><p>我最喜欢的以太坊ERC20 token ，<a href="https://uetoken.com/" target="_blank" rel="noopener">UET</a>。 对不起，我忘记这个 ICO 了。</p></li><li><p>爱丽丝梦游仙境，<a href="http://www.alice-in-wonderland.net/resources/chapters-script/alices-adventures-in-wonderland/" target="_blank" rel="noopener">全文</a>。<br> <img src="https://cdn-images-1.medium.com/max/960/1*OqydpnY8pNUqdn8_1poDCQ.jpeg" alt=""></p></li><li><p>区块链研究时听的音乐：Be In The Moment with Amsterdam DJ Armin Van Buren 和他的每周视频博客<a href="https://www.youtube.com/channel/UCu5jfQcpRLm9xhmlSd5S8xw" target="_blank" rel="noopener">A State of Trance</a><br> 东南亚的<a href="https://youtu.be/fMLmtl6cUaA" target="_blank" rel="noopener">Armin</a><br> <img src="https://cdn-images-1.medium.com/max/960/1*NFYaY4LPjvsXUraQmB-fwQ.jpeg" alt=""></p></li><li><p>阿姆斯特丹的<a href="https://youtu.be/6Y6uPhquJbI" target="_blank" rel="noopener">无人机镜头</a>（DJI Mavic Pro），以4k观看</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;https://medium.com/@jb395official/qrc20-token-report-february-25-2018-ff397a1ac070&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://me
      
    
    </summary>
    
      <category term="区块链" scheme="http://xichen.pub/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://xichen.pub/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Qtum" scheme="http://xichen.pub/tags/Qtum/"/>
    
      <category term="翻译" scheme="http://xichen.pub/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】 新手钱包</title>
    <link href="http://xichen.pub/2018/07/18/2018-07-18-%E7%BF%BB%E8%AF%91-%E6%96%B0%E6%89%8B%E9%92%B1%E5%8C%85/"/>
    <id>http://xichen.pub/2018/07/18/2018-07-18-翻译-新手钱包/</id>
    <published>2018-07-18T06:11:00.000Z</published>
    <updated>2018-09-01T09:40:32.627Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://medium.com/@jb395official/newbie-wallets-april-1-2018-26ea7a06489c" target="_blank" rel="noopener">https://medium.com/@jb395official/newbie-wallets-april-1-2018-26ea7a06489c</a><br>译者：中山大学数学学院（珠海）林学渊<br>大二时给量子做的翻译，转载注明出处，谢谢</p><h1 id="新手钱包-–-2018年4月1日"><a href="#新手钱包-–-2018年4月1日" class="headerlink" title="新手钱包 – 2018年4月1日"></a>新手钱包 – 2018年4月1日</h1><p><img src="https://cdn-images-1.medium.com/max/1600/1*CoZWPEKSdUvkruolCf5urg.jpeg" alt=""></p><p><img src="https://cdn-images-1.medium.com/max/960/1*KFZfenJ-o8iR3x-il9r1qg.jpeg" alt=""></p><p>在本报告中，我们分析区块链，了解自今年年初以来新钱包对节点数增长的贡献。我们的区块链浏览器是<a href="https://qtum.info/" target="_blank" rel="noopener">qtum.info</a>，它本周增加了一个 <a href="https://qtum.info/misc/stake-calculator" target="_blank" rel="noopener">staking 奖励计算器</a>，需要输入地址或输入 stake 金额。这个新的资源管理器给我留下了深刻的印象，它具有明亮的背景，能够快速显示一个地址直到“出生日期”的所有交易。</p><p>TL;DR 1月下旬，大约有2000个 staking 钱包，每个有 500 个代币，这可能与宣布给中国的 50,000 个节点的视频流平台有关。</p><p>我是一名独立研究员，偶尔是博主，社交版主，并中意 Qtum 团队的技术指导和社区的高谈阔论。如果你对本文有任何意见或更正，请联系社交媒体。本博客假设你对Qtum 权益证明（Proof of Stake）和区块奖励机制有一些基本的了解，新的社区成员可以阅读我在以下参考文献中以前博客的链接来了解有关这些主题的更多信息。</p><hr><h2 id="网络权重（在家试试）"><a href="#网络权重（在家试试）" class="headerlink" title="网络权重（在家试试）"></a>网络权重（在家试试）</h2><p>经常看我博客的人知道我通过爬取资源管理器块奖励地址来计算网络权重的替代方法，识别具有稳定余额的大钱包，并使用这些大钱包赢得的总奖励和块奖励百分比来计算网络权重。在过去两周内，这个方法算的网络权重为 3340 万。</p><p>使用新的资源管理器，你可以用这些步骤在家里玩玩网络权重。将你喜欢的浏览器导航到新的资源管理器<a href="https://qtum.info/misc/biggest-miners" target="_blank" rel="noopener">Biggest Miners</a>页面：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*zMnbWpMRBMjx4EzlOsIlaw.jpeg" alt=""></p><p>爬取数据并保存到文本文件。然后恰好一周后，再次爬取数据。对那些在两次爬取之间具有大致相同余额的大钱包（考虑到增加的块奖励），计算总余额和本周开采的块。</p><p>网络权重 = 总余额 /（本周开采的块/每周4200块）。 如果你本周进行计算，你的应该接近我上面计算的网络权重（除非有人添加节点😊）</p><hr><h2 id="节点地图-Nodemap"><a href="#节点地图-Nodemap" class="headerlink" title="节点地图 Nodemap"></a>节点地图 Nodemap</h2><p>Nodemap 本周更新了，可以显示网络上超过 7,000 个节点。这里大事是 Qtum 节点在中国的增长，我不相信其他情况下所谓的“剧情反转”：目前 Qtum 在中国的节点数超过 4,400，是比特币或以太坊的中国节点的两倍多。下一步将是 Qtum 超过比特币的全球节点数，给它两个月。</p><p>去年，在韩国退出之前，节点数第一在韩国和美国之间来回切换。 2017年10月21日，你可以在此屏幕截图中看到，staking 大城市是加州山景城（Google Cloud的主页）和首尔。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*1S-VsFdLmsyBZS_mLyRxjg.jpeg" alt=""></p><p>截至2017年底，网络权重为 2000 万，节点数约为 1,200。但从那时起，节点部署和网络权重增加的速度有所加快。</p><p><img src="https://cdn-images-1.medium.com/max/960/1*DkgJumuKWajuIYQSFEg_Jg.jpeg" alt=""></p><p>目前，中国有11个城市拥有 100 个以上节点，其中包括南京的1000个节点。看看今天这个屏幕截图，酷！南京是江苏省的省会，拥有 3000 万人口，感觉就像你走动的时候不可能不撞到 Qtum 节点，这可能就是正在发生的事情。这些新节点非常有趣，因此我有一个<a href="https://www.urbandictionary.com/define.php?term=scientific-wild-ass%20guess" target="_blank" rel="noopener">大胆的想法(SWAG，Scientific wild-ass guess)</a>，关于其目的的：位于便利店的终端/信息亭，允许人们在不使用银行或信用卡的情况下为视频流服务支付现金。但这是一个完整的猜测，如果实际情况和我想的不一样，这些句子将被神奇地编辑掉。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*8okLn8l_ptzc-YF1_8Gs3Q.jpeg" alt=""></p><p>下表显示，从2月中旬到本周末的节点数变化。每个国家的都有增长，韩国节点数今天刚刚达到四位数字，中国节点数的增长目前占总节点数的63％。</p><p><img src="https://cdn-images-1.medium.com/max/1280/1*44a9XH-0tvlaG66U2Pn8bw.jpeg" alt=""></p><p>下面的饼图显示了节点位置百分比。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*4fl6MLjRDI7ajAi8sKqh1w.jpeg" alt=""></p><hr><h2 id="新手钱包"><a href="#新手钱包" class="headerlink" title="新手钱包"></a>新手钱包</h2><p>我们回到 Excel 表格分析，看看七天内块奖励获奖者。以下是它的工作原理：从资源管理器中删除块奖励获胜者的地址，在 Excel 中对独立地址排序，用宏记录程序将每个地址粘贴回资源管理器并爬取对应钱包余额和交易数。</p><p>staking 地址的交易数很有意思，它提供了有关钱包年龄的线索，因为每个区块奖励的支付时间在 10 次交易内。 如果你看到一个包含 50 到 5,000 笔交易的 staking 钱包地址，则那个钱包已经存在了一段时间。 但如果你看到一个钱包赢得区块奖励时少于 10 次交易，那么这正是它的第一次区块奖励体验（第一次是最好的时间！）</p><p>让我们进一步分析区块奖励获奖者。有趣的是一些新手钱包有500 QTUM，还有一些有400 QTUM。 人们喜欢整数，过去的研究显示，经常有 365,500,1000,2000 和 10000 QTUM 的钱包。但是现在有很多这种 500 QTUM 大小的新钱包。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*-A2lIHByL3PCkwSOBFuerw.jpeg" alt=""></p><p>上面的例子展示了<a href="https://qtum.info/address/QTkkpuhAdNddGEMp99v2BMdS3Qmo63TMm4" target="_blank" rel="noopener">这种钱包</a>中的一个，它有 500 QTUM，当时是 2018 年 1 月 30 日。你能看见转入 84, 854 QTUM 的交易和转出 84,354 QTUM 的交易。你能假定它下一次交易就是用这 84,354 QTUM 发送 500 QTUM 给<a href="https://qtum.info/address/Qjai23hm2YibnNL8JQWWbpUpAQMC24ARZ7/" target="_blank" rel="noopener">另一个钱包</a>，如此继续下去，造另外的 168 个钱包。</p><p><img src="https://cdn-images-1.medium.com/max/960/1*vB2iPZEmh-OouhbBXxyUIQ.jpeg" alt=""></p><p>我保证这些 staker 喜欢这 168 份交易费用，对此我只想用一个词来形容，“盲目发送(sendmanywithdupes)”。这本来只需一笔交易费即可为多个地址转入代币。在这次分析里，我看到了很多 sendmanywithdupes 交易的例子，包括去年发送 365 个 QTUM 到多个地址的那个著名系列，后来用来挖矿。注意，将 QTUM 拆分为单独的挖矿地址并没有改变赢得区块奖励的可能性，因为钱包软件保证了在有 27,375 个代币的单个钱包地址和分别有365个代币（共27,375个代币）的 75 个地址之间，赢得区块奖励的概率都是一样的。</p><p>中国的节点增长源自哪里？一种可能是中国视频流媒体公司宣布他们将在商业网络中部署 50,000 个节点。 我们可以折腾区块链，看看是否可以发现有关新节点的什么模式或细节。我们截取 3 月 24 日至 3 月 30 日的获得区块奖励的钱包，其中对同时满足 QTUM 少于 600 且 2018 年 1 月 1 日之后有过代币交易的钱包进一步过滤：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*-Mi-J1oN2KhPHpIRoD7l1A.jpeg" alt=""></p><p>直方图显示的是在不同日期转入（创建）500 QTUM 的块奖励获奖钱包数。因为块奖励与钱包重量成正比（还有一些随机影响），我们可以反过来处理块奖励计算，并回答这个问题：如果网络权重为 3340 万，一周内赢得 129 块奖励所需的钱包大小是多少？ [参考1] 答案是大约100万枚代币。如果你按 500 QTUM 部署 100万个，那么你将有 2000 个钱包，这肯定在中国的增长范围内，甚至可能有点低。在任何情况下，概率论表明如果你有一个有着 100 万个代币的钱包，或者每个有 500 个代币的 2000 个钱包，都能在一周内赢得 129 个块奖励。</p><hr><p>我希望你能享受这次关于区块链操作的讨论，并学到点东西。4月1日是复活节星期天，如果你关注复活节，那我希望你复活节快乐。</p><p>今天是复活节，我们在梵蒂冈写完博客。这里是基督教(Catholic Christianity)，圣彼得大教堂(St. Peter’s Basilica)和西斯廷教堂(the Sistine Chapel)之家。在西斯廷教堂，文艺复兴时期的艺术天才米开朗基罗花了10年（1502-1512）亲自画天花板和墙壁。 创世纪的标志性形象 – 创造亚当（所以亚当必须是人类的“<a href="https://qtum.info/block/1" target="_blank" rel="noopener">第1块(block 1)</a>”？）并给出了加密货币创世块的名称。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*i9tS3hJOpurRxNIvv1eEjQ.jpeg" alt=""></p><p>注意在线安全，我会在社交媒体上看到你</p><p>Jackson</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*F4j_asy0MBUS2hb-Y5ByBw.jpeg" alt=""></p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>在一周内获得 129 份块奖励，每天 600 块，也就是 4,200 块。钱包重量为：</li></ol><p><img src="https://cdn-images-1.medium.com/max/1280/1*DVu4tRWb7_ivXfJgGOEkew.jpeg" alt=""></p><ol><li>看我之前写在<a href="https://medium.com/@jb395official" target="_blank" rel="noopener">Medium</a>上的博客</li></ol><p><img src="https://cdn-images-1.medium.com/max/960/1*kuYpVPZtss0PO5Y2TbqyCw.jpeg" alt=""></p><ol><li>不是从无人机拍摄，而是一些<a href="https://www.youtube.com/watch?v=eMGL1_nSjIk" target="_blank" rel="noopener">不错的视频</a>,关于圣彼得广场和圣彼得大教堂的，1080P。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;https://medium.com/@jb395official/newbie-wallets-april-1-2018-26ea7a06489c&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://medium.com
      
    
    </summary>
    
      <category term="区块链" scheme="http://xichen.pub/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://xichen.pub/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Qtum" scheme="http://xichen.pub/tags/Qtum/"/>
    
      <category term="翻译" scheme="http://xichen.pub/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】 钱包和密钥</title>
    <link href="http://xichen.pub/2018/07/12/2018-07-12-%E7%BF%BB%E8%AF%91-%E9%92%B1%E5%8C%85%E5%92%8C%E5%AF%86%E9%92%A5/"/>
    <id>http://xichen.pub/2018/07/12/2018-07-12-翻译-钱包和密钥/</id>
    <published>2018-07-12T06:11:00.000Z</published>
    <updated>2018-09-01T09:38:33.211Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://medium.com/@jb395official/wallets-and-keys-july-23-2018-92abf2a2d2bf" target="_blank" rel="noopener">https://medium.com/@jb395official/wallets-and-keys-july-23-2018-92abf2a2d2bf</a><br>译者：中山大学数学学院（珠海）林学渊<br>大二时给量子做的翻译，转载注明出处，谢谢</p><p>Wallets and Keys — July 25, 2018</p><h1 id="钱包和密钥-2018年7月25日"><a href="#钱包和密钥-2018年7月25日" class="headerlink" title="钱包和密钥-2018年7月25日"></a>钱包和密钥-2018年7月25日</h1><p>本文考虑钱包和密钥。先简要介绍，再上例子。大多数例子基于浏览器上的 <a href="https://qtumwallet.org/" target="_blank" rel="noopener">Qtum Web 钱包</a>，类似于以太坊钱包 MyEtherWallet和MyCrypto。 Qtum Web 钱包运行在浏览器上，并不需要下载区块链，而是通过专用全节点连接到区块链。</p><p><img src="https://cdn-images-1.medium.com/max/960/1*sxyzaMzH1k1QMIM4WOmawA.jpeg" alt="变色龙示威，[Yathin S Krishnappa](https://commons.wikimedia.org/wiki/User:Yathin_sk)摄，裁剪过"></p><p>Web 钱包是一个强大的变色龙，提供了很多恢复其他类型Qtum钱包的方式。没有 Web 钱包恢复不了的钱包（如果你用本博客的技术的话）。注意Web钱包具有完整QRC20令牌功能。</p><p>注意事项：本博客和钱包恢复步骤包括处理私钥和种子词。在你尝试这些步骤前，确保你完全理解流程且电脑没有恶意软件和病毒。简单地发送QTUM或代币到一个新钱包比乱动私钥更安全，但有时无法发送代币，比如，你的手机钱包掉马桶或被忘在浴缸里一整夜。永远不要把你的私钥或种子词给别人因为他们能拿走你的币。</p><p><img src="https://cdn-images-1.medium.com/max/960/1*2co82T2PlBqiWtajX0A4uA.jpeg" alt=""></p><p>我是一名独立研究员，偶尔写博客和主持社交媒体，十分中意Qtum的技术指导。如果你对本文有想法或批评，请在社交软件上发给我或在下面评论。</p><hr><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><blockquote><p>TL;DR Qtum 钱包的安装使用了随机生成的私钥或种子词。通过导出私钥或种子词，你能在各种钱包之间转移你的 Qtum 地址。重要的是保证私钥和种子词安全–保持你的私人私密！</p></blockquote><p>你知道钱包在区块链建立它们的身份时使用了一个 Qtum地址 “Q…”。 这个地址生成自公钥，而公钥生成自私钥。</p><p>Satoshi 给比特币取了错误的名字 “钱包”， 因为钱包实际上不存任何币或代币，它们存在区块链里。“钱包”的正确名字应该是“密钥库”因为钱包的主要工作是保存和管理私钥，通过私钥来支持交易。</p><h1 id="私钥和种子词"><a href="#私钥和种子词" class="headerlink" title="私钥和种子词"></a>私钥和种子词</h1><p><img src="https://cdn-images-1.medium.com/max/960/1*zQsSpuPYc66g-_peB2qwDA.jpeg" alt=""></p><p>一个私钥是一个简陋的字符串，但它是通往王国的关键。私钥（不用密码）允许存储在由私钥生成的地址中的QTUM访问。你需要十分小心地使用私钥，因为如果任何一个人（黑客、恶意软件、甜言蜜语的热心人）拿了你的私钥，他们就可以拿了你的钱。</p><p><img src="https://cdn-images-1.medium.com/max/960/1*r8NdMNvHsshagpqlV-agtg.jpeg" alt=""></p><p>私钥也能用种子词生成。典型的是，钱包使用的种子词有两种，桌面钱包使用 bip-039 种子词，手机钱包使用“字典”种子词。这两种不相容，这个差别由 Web 钱包管理，它两种都能接受，是 bip-039 种子词则使用 “从助记符中恢复” ，是“字典”种子词则使用“从手机钱包恢复”。</p><p>比特币改进协议（Bitcoin Improvement Protocol 39 （bip-039)）给出了规则，生成私钥要使用从 2,048 个单词列表中导出的 12 个种子词[参考文献1]。手机钱包使用的“字典”单词一列是 4,216个类似bip-039的单词[参考文献2]。</p><p>输入种子词来恢复钱包有风险，因为私钥是从种子词里精确地生成而来，多一个符号或一个空格都会生成一个完全不同的私钥和完全不同的 Qtum 地址。如果你错输了种子词，你会创建给钱包创建一个你不期望的 Qtum 地址。如果你发币给那个地址，你很有可能永远无法再输入那个错字恢复钱包地址，这就意味着你的币永久丢失了。</p><p>下图显示了用于创建钱包或恢复钱包的所有 Web 钱包选项： </p><ol><li><p>生成新钱包 – 创建一个随机地址，下载一个密钥文件</p></li><li><p>用助记符创建 – 创建 12 个种子词生成的一个随机地址</p></li><li><p>从助记符恢复 – 使用 12 个 bip-039 种子词从另一个钱包恢复一个地址</p></li><li><p>从 WIF 恢复 – 从一个密钥中恢复一个地址</p></li><li><p>从手机钱包恢复 – 使用 12 个 “字典” 种子词从一个 Qtum 手机钱包中恢复一个地址</p></li><li><p>从密钥文件恢复 – 从 Web 钱包创建的密钥文件中恢复一个地址</p></li><li><p>从 Ledger 恢复 - 允许使用安全存储在 Ledger 硬件钱包中的私钥进行交易</p></li></ol><p><img src="https://cdn-images-1.medium.com/max/1600/1*jbZEYQ8-jqb70LjZTJ8ZuQ.jpeg" alt=""></p><p>让我们逐个详细地介绍这些选项。</p><ol><li>生成新钱包</li></ol><p>生成新钱包会创建一个随机地址并下载一个密钥文件，其名称由 unix 纪元时间（以毫秒为单位）给出，例如 “1532053935952.txt”，其中包含由密码加密的文本，例如：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;“<span class="keyword">version</span>”:”<span class="number">0.1</span><span class="comment">",”content”:”tFz3ctzaITRniFjD6lDm1m8Zyu7LeNjNm/j2ao/hxoIhYAwqlC9iZYZ9TCermbrxF2ljd/wTXnRq/Ca6nYPYZNJ4GC0=”&#125;</span></span><br></pre></td></tr></table></figure><p>将密钥文件保存在计算机上，并备份到多个USB设备。重新启动 / 恢复用“生成新钱包”选项创建的钱包的唯一方法是通过加载密钥文件并输入密码来“从密钥文件恢复”（请参阅​​下面的步骤6）。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*wIaJRnmbnL0uMZ0ceN1uUw.jpeg" alt=""></p><p>使用又长又强的密码，而不是像“12345”这样的简单密码。</p><ol><li>用助记符创建</li></ol><p>“用助记符创建” 创建 12 个种子词生成的一个随机地址。你必须重新输入那 12 个种子词，确保你以及保存好种子词了。</p><p>用这个选项你只要下面的 3 步就能从助记符（种子词）中恢复钱包。你也能（必须能）通过“转储为密钥文件”创建一个密钥文件来备份钱包。现在你有 2 种方式恢复钱包，使用种子词和密钥文件。这很有效地使你恢复钱包的能力翻倍，但也意味着你现在需要安全地存储三样东西（密码，种子词和密钥文件）。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*kVzIe1b-8C_WO3GPruXO7w.jpeg" alt=""></p><p>注意，助记符不同于 Core 钱包密码短语（这是一种自由格式的文本密码短语并且不是种子词）</p><ol><li>从助记符恢复</li></ol><p>“从助记符恢复”使用 12 个 bip-039 种子词从另一个钱包恢复一个地址。输入种子词时，他们必须和原种子词字字匹配。这意味着全部小写（永远没有大写字母）因为这是种子词生成的形式。任何差异或额外单词都会为钱包创建一个不同的随机的地址，也就是它会显示 0 零钱，这很危险，如果你发送 QTUM 给这个新地址的话。确保你检查过地址并确认那就是你要的地址。安全一点的是从助记符恢复以保存密钥文件，并使用密钥文件恢复钱包以打开钱包。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*3xqlhNWHTzGOt5X1U40CrQ.jpeg" alt=""></p><ol><li>从 WIF 恢复</li></ol><p>WIF 电子钱包导入格式（Wallet Import Format） 是私钥一种纠错和缩短的格式[参考文献3]。你遇到的大多数私钥都使用WIF，通常长度为52个字符，而本地私钥使用 64 个十六进制字符。 Web钱包和Core钱包提供私钥作为WIF，此选项将允许从WIF私钥恢复钱包地址。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*Pr47C0oYLqIihq1LjbJxiQ.jpeg" alt=""></p><ol><li>从手机钱包恢复</li></ol><p>“从手机钱包恢复”使用 12 个 “字典” 种子词从一个 Qtum 手机钱包中恢复一个地址。要让这种恢复正常工作，必须为每个字符正确输入手机钱包种子词（现在这听起来熟悉吗？）。单词总是小写，永远不会有大写字符。 此外，请勿在任何单词后面输入尾随空格，否则生成一个非常危险的新随机地址。 请确认这个选项创建的地址与你手机钱包中的地址相匹配（否则你输入的种子词不正确）。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*hdW_vYwAWFOqlo_TMtSrfQ.jpeg" alt=""></p><p>选择 CONFIRM 后，选择要恢复的地址：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*-72KpXo1e-I1CAzME0bYaQ.jpeg" alt=""></p><ol><li>从密钥文件恢复</li></ol><p>“从密钥文件恢复”从 Web 钱包创建的密钥文件中恢复一个地址。从电脑加载密钥文件并输入密码来恢复钱包地址。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*NviSnaTLVTYbDunYyVGXhA.jpeg" alt=""></p><ol><li>从 Ledger 恢复</li></ol><p>这个选项与其他选项的工作方式不同。“从 Ledger 恢复”允许使用安全存储在 Ledger 硬件钱包中的私钥进行交易。对于这个选项来说，私钥不会离开硬件钱包，而是 Ledger 签署交易（允许手动验证）和批准交易。</p><p>要使用 Ledger 硬件钱包，请在 Web 钱包上选择“从 Ledger 恢复”，连接你的 Ledger，登录并启动 Qtum 应用程序，然后选择CONNECT 来让 Web 钱包连接到 Ledger。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*4t8J2AThaRn_wiRKSY7ddw.jpeg" alt=""></p><p>选择默认路径 m/44’/88’/0’/0 并单击绿色挂锁按钮：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*RtixVkMflh7ai-Z3O5ghFw.jpeg" alt=""></p><p>在屏幕上默认路径 m/44’/88’/0’/0 选择所需的地址，然后单击绿色挂锁按钮：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*dyuJxEWOqPHcsVwzUHe9yA.jpeg" alt=""></p><p>这仅仅会启动标准 Web 钱包页面，因为私钥仍然锁定在Ledger中，没有可用的私钥，并且“转储到密钥文件” 按钮不可用。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*0F1OkKnfXaNqlTOp1dMh-w.jpeg" alt=""></p><hr><h1 id="测试网例子"><a href="#测试网例子" class="headerlink" title="测试网例子"></a>测试网例子</h1><p><img src="https://cdn-images-1.medium.com/max/960/1*KrwCpKAiDIp_cWbzep2dEQ.jpeg" alt="测试网资源管理器"></p><p>接下来是在各种 Qtum 钱包之间转移私钥或种子词来恢复钱包的一些真实示例。在本练习中，我使用Qtum Testnet，如果你需要在 Testnet 上进行复习，请参阅<a href="https://medium.com/@jb395official/testnet-and-qtum-mainnet-performance-january-1-8-e7af03a5d430" target="_blank" rel="noopener">这个博客</a>。</p><p><img src="https://cdn-images-1.medium.com/max/960/1*3v9Agworepo_g-Paz5bAtQ.jpeg" alt=""></p><p>让我说我对 Testnet QTUM 的价格发展感到非常失望。似乎 <a href="https://testnet.qtum.info/misc/rich-list" target="_blank" rel="noopener">Testnet QTUM 大佬</a> 正在操纵这种币抑制价格，这对于 Testnet QTUM 持有者来说是很伤心。 没有价格升值，而且这种币似乎永远停留在 0 satoshis。 Testnet QTUM 在任何主要交易所，任何小型交易所或任何交易所都没有交易对。 它基本上是一个毫无价值的币，我们唯一可以做的就是在 Qtum Testnet 上进行测试，所以我们就这样做。</p><h2 id="A-手机到-Web-钱包"><a href="#A-手机到-Web-钱包" class="headerlink" title="A. 手机到 Web 钱包"></a>A. 手机到 Web 钱包</h2><p>要在网络钱包上恢复 Qtum 手机钱包，请在移动设备上转到个人资料 - 电子钱包备份并输入你的个人识别码以查看种子词（你之前也应保存它们）。 在 Web 钱包上，选择“从手机钱包恢复”，准确输入种子词，然后选择确认。 从 Qtum 地址列表中（除非你在移动设备上选择了其他地址，否则应该是最重要的地址）找到所需的 Qtum 地址并选择 CHOOSE。检查恢复的地址是否与你的移动钱包地址相同（如果没有，请重新输入种子词并仔细检查所有字符）。使用“转储作为密钥文件”成功还原后，你可能要备份密钥文件。</p><h2 id="B-Core-到-Web-钱包"><a href="#B-Core-到-Web-钱包" class="headerlink" title="B. Core 到 Web 钱包"></a>B. Core 到 Web 钱包</h2><p>在 Qtum Core 钱包（显示 qtum-qt）上，选择 “帮助” - “调试窗口” - “命令”，并输入 dumpprivkey 命令需要的所有地址（有关多个地址的信息，请参阅参考资料4）。 复制 WIF 私钥，这里是 “cPuz…”。 在 Web 钱包上选择“从 WIF 恢复”，粘贴私钥，然后单击确认。 使用“转储为密钥文件”成功还原后，你可能要备份密钥文件。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*ujFP9icgoj1eEZ0-Fr2rVA.jpeg" alt=""></p><p>C. Web 到 Core 钱包</p><p>这与上面的 B 正好相反。 在 Web 钱包上选择“查看钱包信息”，查看私钥并复制私钥。 在 qtum-qt Core 钱包上选择“帮助” - “调试窗口” - “控制台”并输入命令 importprivkey 并粘贴私钥：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*0Rc6meMnP-lpORRXl8fyFg.jpeg" alt=""></p><p>Core 钱包将扫描区块链一两分钟，调试窗口标题将显示（Not Responding），Console 响应为“null”，你应该看到新地址加了 QTUM 余额。 你应该对 wallet.dat 文件重新备份，因为它包含一个新的私钥。 </p><p>D. 手机到 Core 钱包</p><p>显然，做 A - 手机到 Web 钱包再做 C - Web 到 Core 钱包。</p><p>E. Qbao 到 Web 钱包</p><p>在Qbao上转到“我” - “助记符导出” - 输入你的 PIN（密码）并复制助记符（12个种子词 - 你之前应该保存这些）。 在 Web 钱包上，选择“从手机钱包恢复”，并仔细输入12个种子字（无额外空格）并选择确认。 通过选择 CHOOSE 从“从手机钱包恢复”列表中选择所需的地址。 你可能要使用“转储为密钥文件”来保存密钥文件。</p><p>F. Electrum 到 Web 钱包</p><p>要使用种子词将地址从 Electrum 钱包转移到 Web 钱包，你需要在初始安装中将 Electrum 设置为与 Qtum 手机种子词兼容（然后使用手机钱包种子词来恢复 Electrum 上的手机钱包 ）。这个设置的 Electrum 配置截屏为：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*3pODwbYSz0uYGPaesLpgaQ.jpeg" alt=""></p><p>在这个截图之后，你输入手机钱包种子词（这些单词也与“从手机钱包中恢复”的 Web 钱包选项兼容）。</p><p>如果你尚未将 Electrum 钱包设置为与手机钱包兼容，则可以使用私钥恢复 Web 钱包上的 Electrum 钱包。 在 Electrum 钱包上选择“钱包” - “私钥” - “导出”，你将导出文件 qtum-electrum-private-keys.csv 或只复制一个私钥。 在 Web 钱包上选择“从 WIF 恢复”，粘贴私钥并选择确认。 检查钱包地址是否正确。 你可能需要使用“转储为密钥文件”来保存密钥文件。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*4q46uLQwpBZ-X4u2t6OX9w.jpeg" alt=""></p><p>F. Core 到 Core</p><p>见下面的参考文献4。</p><hr><p>我希望这个关于私钥和种子词的解释有助于你理解钱包。请记住，钱包不会存储硬币或代币。 硬币和代币总是存储在区块链中，但钱包存储私钥并使用私钥管理交易。 直接使用私钥和种子词时请务必小心。 确保你的计算机不含病毒和恶意软件，并且永远不要使用在线存储来存储私钥，种子词或密码</p><p>保持在线安全。</p><p>Jackson</p><hr><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol><li><p><a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki" target="_blank" rel="noopener">bip-039 参数</a>。 <a href="https://github.com/bitcoin/bips/blob/master/bip-0039/english.txt" target="_blank" rel="noopener">bip-039种子词 英语单词表</a>。 如果你的 bip-039 种子词不在这个表中，那么你写错了！</p></li><li><p><a href="https://github.com/qtumproject/qtum-android/blob/5a14b25a82fe04d9436147d776d1482e7f7ad242/app/src/main/java/org/qtum/wallet/utils/DictionaryWords.java" target="_blank" rel="noopener">“字典”种子词列表</a>。 如果你的种子词不在这个列表中，你就错了！</p></li><li><p>钱包导入格式（Wallet Import Format），比特币的一个<a href="https://en.bitcoin.it/wiki/Wallet_import_format" target="_blank" rel="noopener">例子</a>。</p></li><li><p>转移私钥 - Core 到 Core 钱包（显示为 qtum-qt Desktop GUI Core 钱包）</p></li></ol><p>在导出私钥之前，最好更新防病毒软件并运行完整的防病毒扫描。 永远不要把私钥给任何人，他们可以拿走你的 QTUM。</p><ol><li>如果你有加密钱包，请解锁钱包（而不是仅用于 staking）</li></ol><ul><li>转到“设置” - “解锁钱包”，取消选中“仅限 staking”，输入你的密码并按“确定” </li><li>你应该看到小挂锁符号搭扣打开了 </li></ul><p><img src="https://cdn-images-1.medium.com/max/1280/1*AIswxXEdSuAIpFnoPEfjAg.png" alt=""></p><ol><li>选择要导出私钥的 Qtum 地址</li></ol><ul><li><p>转到“文件” - “接收地址…”，然后复制 Qtum 地址以导出私钥</p></li><li><p>选择地址并按 COPY，关闭该窗口 </p></li><li><p>如果你的钱包有多个持有 QTUM 的接收地址，你可以找到哪些地址持有 QTUM，请转到“文件” - “调试窗口” - “控制台”并输入命令 listaddressgroupings 。</p><p><img src="https://cdn-images-1.medium.com/max/1280/1*vTy9q9TrXS5QHJEt9KknMQ.png" alt=""></p><p>滚动列表并复制保存 QTUM 的地址以导出这些私钥</p></li></ul><ol><li>打开控制台并输入命令以导出私钥</li></ol><ul><li><p>转到“文件” - “调试窗口” - “控制台”</p></li><li><p>在控制台底部，开始输入命令dumpprivkey</p></li><li><p>然后粘贴你刚刚复制的地址。 这个命令看起来像这样：</p><p><code>dumpprivkey QskjfhGF28374Daskfjh238742837482374</code><br><img src="https://cdn-images-1.medium.com/max/1280/1*DaZMckv-xWHur4FZNLFAtA.png" alt=""></p></li><li><p>输入命令</p></li></ul><ol><li>私钥将作为包含 52 个字符的文本字符串显示在控制台上</li></ol><ul><li>将私钥复制到文本文件中并保证其安全。这是一个未加密的私钥，任何拥有这个私钥的人都可以使用你的 QTUM。 切勿将私钥交给任何人。</li></ul><ol><li><p>要在第二个 Qtum Core 钱包上导入这个私钥，请启动该钱包并将其解锁（如果已加密）</p></li><li><p>在控制台中输入 importprivkey 命令</p></li></ol><ul><li><p>转到“文件” - “调试窗口” - “控制台”，并在底部开始输入命令importprivkey </p></li><li><p>复制并粘贴先前转储的私钥。 该命令看起来像这样：<br><code>importprivkey Siufy238746FGasj127356asjdhYTVss93845kajsfmyQTUM</code><br><img src="https://cdn-images-1.medium.com/max/1280/1*zQ60gUGNG0AGvu5X4wgUXw.png" alt=""></p></li><li><p>输入命令</p></li><li><p>钱包将重新扫描本地区块链大约两分钟，以查找此新地址的交易，在此期间，调试窗口标题将显示“无响应(Not Responding）”</p></li></ul><p><img src="https://cdn-images-1.medium.com/max/1280/1*Nx79UjkLWp6vezmBGlT-Qg.png" alt=""></p><ul><li>然后响应 “null”</li></ul><p><img src="https://cdn-images-1.medium.com/max/1280/1*jCEK9RvFGL9PWx6kc_pqjw.png" alt=""></p><ul><li>你应该看到新私钥的未花费的交易的值已添加到钱包的总余额中。</li></ul><p>你可能要将所有转移过的私钥（它将与你在步骤 2 中开始的地址）中的所有 QTUM 发送到另一个地址，因为私钥已导出并暴露在加密钱包之外（丢弃这个私钥）。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;https://medium.com/@jb395official/wallets-and-keys-july-23-2018-92abf2a2d2bf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://medium.c
      
    
    </summary>
    
      <category term="区块链" scheme="http://xichen.pub/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://xichen.pub/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Qtum" scheme="http://xichen.pub/tags/Qtum/"/>
    
      <category term="翻译" scheme="http://xichen.pub/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】 以太坊的挑战者：量子链（QTUM）</title>
    <link href="http://xichen.pub/2018/07/06/2018-07-06-%E7%BF%BB%E8%AF%91-%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%9A%84%E6%8C%91%E6%88%98%E8%80%85-%E9%87%8F%E5%AD%90%E9%93%BE(QTUM)/"/>
    <id>http://xichen.pub/2018/07/06/2018-07-06-翻译-以太坊的挑战者-量子链(QTUM)/</id>
    <published>2018-07-06T06:11:00.000Z</published>
    <updated>2018-09-01T09:32:42.291Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://strategiccoin.com/the-ethereum-challengers-qtum/" target="_blank" rel="noopener">https://strategiccoin.com/the-ethereum-challengers-qtum/</a><br>译者：中山大学数学学院（珠海）林学渊<br>大二时给量子做的翻译，转载注明出处，谢谢</p><h1 id="以太坊的挑战者：量子链（QTUM）"><a href="#以太坊的挑战者：量子链（QTUM）" class="headerlink" title="以太坊的挑战者：量子链（QTUM）"></a>以太坊的挑战者：量子链（QTUM）</h1><p>– Guest Contributor</p><p><a href="https://twitter.com/bitgenstein" target="_blank" rel="noopener">Peter Keay</a> 是 <a href="https://twitter.com/icoalert" target="_blank" rel="noopener">ICO Alert</a> 的全球化总监，也是 Bitgenstein’s Table加密哲学播客节目的主持人。他是“以太坊的挑战者”系列作者。 这篇文章最初发表在<a href="https://blog.icoalert.com/the-ethereum-challengers-ep-6-qtum-qtum-d3278493c61d" target="_blank" rel="noopener">这里</a>。 该系列涵盖的其他竞争对手包括 <a href="https://bitgenste.in/rsk" target="_blank" rel="noopener">RSK</a>，<a href="https://bitgenste.in/eos" target="_blank" rel="noopener">EOS</a>和<a href="https://bitgenste.in/ada" target="_blank" rel="noopener">Cardano</a>。</p><p>很多加密货币用户和投资者都十分支持比特币或以太坊，甚至达到了“极端主义者”的程度。</p><p>极端主义者们认为，他们喜欢的币将占据市场主导地位并广泛应用，而所有其他加密货币最终都会消亡 - 或者只是作为主导币的测试网络。</p><p><img src="https://cdn-images-1.medium.com/max/640/1*WFAo_yOnaJnRnQNweUymow.jpeg" alt="有些人只看到辩论的幽默。"></p><p>实际上，BTC和ETH货币是当今最重要的数字资产，而且在可预见的未来可能也是如此。 然而比特币和以太坊是完全不同的，它们的优点和缺点都不一样。</p><p>所以，在2016年，一个简单的想法诞生了：</p><p>如果加密货币同时拥有比特币和以太坊的优点会怎样？</p><p><img src="https://cdn-images-1.medium.com/max/800/1*SXhk8TmWZlFV805WmRVgmw.png" alt="以太坊经典和比特币现金的优势，个人看法。（The Cryptos漫画）"></p><h2 id="遇见-Qtum。发音为“Quantum”"><a href="#遇见-Qtum。发音为“Quantum”" class="headerlink" title="遇见 Qtum。发音为“Quantum”"></a>遇见 Qtum。发音为“Quantum”</h2><blockquote><p>译者注：发音和中文“狂腾”相近</p></blockquote><p>Qtum 结合了比特币技术和以太坊技术。</p><p>在“以太坊的挑战者”的系列中，我已经为大多数挑战者做了一些相关概念的总结。 例如，我们讨论了<a href="https://bitgenste.in/rsk" target="_blank" rel="noopener">图灵完整性和侧链与RSK</a>，<a href="https://bitgenste.in/eos" target="_blank" rel="noopener">PoS和DPoS与EOS</a>，以及<a href="https://bitgenste.in/ada" target="_blank" rel="noopener">用Cardano的形式验证</a>。</p><p>自从 Qtum（请记住：在你的心里请读作“Quantum”）将其平台作为比特币和以太坊的结合来推广时，让我们来谈谈两个主要的区块链交易模型。 然后，我们将讨论 Qtum 的其他功能，包括一些近期的公告，并看看它如何处理我们的七大问题。</p><p>所以，首先是交易模型。比特币使用 UTXO 模型。 以太坊使用帐户模型。 Qtum 想两者都要。</p><h2 id="UTXO-模型（BTC）vs-账户模型"><a href="#UTXO-模型（BTC）vs-账户模型" class="headerlink" title="UTXO 模型（BTC）vs. 账户模型"></a>UTXO 模型（BTC）vs. 账户模型</h2><p>你是否曾把 BTC 从一个地址发送到另一个地址，结果在块浏览器中看到你的帐户实际发送了更多的BTC？</p><p>这是 UTXO 模型的工作原理决定的，但对于习惯帐户模型的人来说，这并不直观。 事实上，看你的地址，显然发送的 BTC 比告诉你的要多得多，这十分可怕。</p><p><img src="https://cdn-images-1.medium.com/max/640/1*-SBxQwqWIf1V5G94Uz1uCw.gif" alt="我把它交给了美联储。"></p><p>你习惯帐户模型，在那里你的帐户有余额。</p><p>例如，你的以太坊地址也是你的以太坊帐户。 你可以从余额中支出并接收余额付款。</p><p>虽然建议仅使用一次地址 - 出于隐私和安全的原因 - 实际上帐户模型会激励用户重复使用地址，因为这是最简单的用钱方式。</p><blockquote><p>以太坊账户类型：以太坊有两种账户：由私钥控制的账户 - 如果你使用ETH，则为你所有 - 以及由合约代码控制的账户。<br>私钥帐户制作并签署要发送给其他帐户的信息，而合约帐户会在收到信息时激活其代码以执行各种交易（包括发送其他信息，签订合约以及读取或写入自己的存储）。请注意，区块链中的“信息”包括交易。</p></blockquote><p>帐户模型使用类似于银行帐户的余额管理系统。</p><p>但是像比特币这样的 UTXO（Unspent Transaction Output，未花费的交易输出）模型是不同的。</p><p>用 UTXO 模型的感觉类似于你只用支票付款，一直持有直到你需要用掉它。</p><p><img src="https://cdn-images-1.medium.com/max/640/1*xY4xGhypSmxWvPgpdhwCPA.png" alt="比特币是你最卑微的仆人。 并且把财富作为支票的内容。"></p><p>正如你不能在银行只兑现支票的某一部分，而是必须兑现全部。在比特币里，一个地址收到一定钱后又只想只花掉其中一点，这样不行，它必须花掉所有的钱。</p><p>当你发送 BTC 时，你会花费 “vins” 并生成新的 “vouts”. UTXO 无法重复使用，所以通过花费 vins 并生成 vouts 后 UTXO 就被销毁了。</p><p>因此，如果你收到一个声称有 3.152 BTC 的 UTXO vin，然后发送 2.1 BTC，你实际上必须发送整个 3.152 BTC - 在这种情况下，作为两个 vouts：〜2.1给你的收件人和~1.052给你自己。 （小的采矿费会略微降低实际数量。）你收到的 3.152 BTC的 UTXO 已完成使命且无法重复使用，但 BTC 仍然存在于新的 UTXO 中。</p><p>在后台，你创建的 vout 脚本（发送）需要vin脚本的许可。 换句话说，为了花钱，你必须有一张有效的支票或多张支票，证明你过去收到过这笔钱（或者更多），并且支票一定不能撕掉。</p><p>因此，在帐户模型中，你的余额会被检查并借记和贷记，这不是比特币的工作方式。</p><p>如果你将BTC从Ledger钱包发送给其他人并在一个块代理商上检查交易，你可能已经注意到了这一点。</p><p>看似任意数量的BTC会被发送出去。 但你发送的实际金额将发送给收件人，剩余部分将转到一个你能控制的新地址。 你没有发送给收件人的BTC仍然是你的，但会被发送到新地址。</p><p>这是 UTXO 的工作原理决定的。 同样，如果你收到了两个分别为 1.1 BTC 和 0.8 BTC 的 UTXO，并且你想花费 1.3 BTC，那么两个 UTXO 都将 “被花费”，其余的将作为新的 UTXO 发送给你 - 在这种情况下，有 0.6 BTC，减去交易费用。</p><p>为什么这可能比简单的账户余额系统更好？</p><p>UTXO 模型激励用户限制他们对地址的重复使用，因为每次花费时 BTC 都会自动发送到新地址。</p><p>这样更安全，即使是对于<a href="https://bitgenste.in/quantum" target="_blank" rel="noopener">量子计算（quantum computing）</a>这样的进步也是如此，因为在你的地址开始使用之前，你的公钥不会泄露。 你的公共地址是公钥的哈希，而不是你的公钥本身，即使很多人错误地使用这些术语。 公钥和地址是相关但不同的东西。</p><p><img src="https://cdn-images-1.medium.com/max/640/1*9HAqy2m1Y0WHtSx2UQPvvw.png" alt="仅仅因为有人知道你的地址并不意味着他们有你的公钥。 除非你透露了它。"></p><p>但是，一旦地址开始花钱，该地址的公钥就会发布到区块链，因此理论上容易受到攻击，立刻就暴露了。 但是，如果地址的余额为空，即使成功攻击你的公钥也毫无价值 - 它发送到了你控制的新地址，并带有未公开的公钥 - 因此当BTC将“零钱”发送到新地址时，你将重新获得未知公钥安全上的好处。</p><p>一次性地址也具有隐私优势。 这种从地址到地址发送 BTC 的行为使得跟踪个人变得更加困难。 BTC 本身仍然可以很容易被跟踪，但在许多情况下，很难确定所涉及的大量地址的所有权。</p><p>其他代币以其他方式实现了类似或更高级别的隐私优势和安全性，不仅拥有这些优点，同时还保留了重复使用地址的便利性。 然而，这些代币在测试时间上没有比特币长，或者程度上没有比特币剧烈，并且他们的解决方案可能存在无法预料的复杂情况。</p><p>如果像以太坊这样的帐户模型加密货币的用户遵循仅使用每个地址一次的推荐做法，他们享有与UTXO提供的相同的安全和隐私权益。 但在比特币中，用户更有可能遵循这一最佳实践，因为它是默认行为。</p><blockquote><p>附注：这些优点不适用于不再受欢迎的单地址钱包。 单地址钱包将UTXO的“零钱”发送回同一地址。<br>它们适用于其他两种主要类型：<br>1）随机生成新地址的钱包，现在也不常见。 当发送BTC时，用过的UTXO的“零钱”被发送到新的随机地址。 这是有风险的，因为如果钱包丢失，自上次备份以来生成的随机地址也将丢失。</p></blockquote><p><img src="https://cdn-images-1.medium.com/max/640/1*aRc8XGDo6I7T_P0xmjMftw.jpeg" alt="而且，在至少一种情况下，密钥实际上不是随机生成的而是后来被盗。"></p><blockquote><p>2）能生成确定地址的钱包。 你今天用BTC的钱包可能会确定性地创建地址。 例如，硬件钱包和Electrum桌面钱包都是确定性的。 它们包含几乎无限的数学生成地址池。 无论何时发送BTC，这些钱包都会将用过的UTXO发送的“零钱”发送到新生成的地址。 确定性地址生成优于随机地址生成，因为一个种子可以重新生成所有相同的地址，从而提供更好的备份和恢复功能。</p></blockquote><h2 id="比特币的简单支付验证"><a href="#比特币的简单支付验证" class="headerlink" title="比特币的简单支付验证"></a>比特币的简单支付验证</h2><p>UTXO模型的一个优点是 SPV，(Simplified Payment Verification，简单支付验证），允许客户端验证一个交易是否包含在一个块中，而无需下载和验证整个区块链。</p><p>简而言之，希望下载的数据更少，因为任何人一旦把钱用出去，UTXO输出就会被遗忘。</p><p>块标题足以进行验证，因为它们可以提供 <a href="https://hackernoon.com/merkle-trees-181cb4bc30b4" target="_blank" rel="noopener">Merkle branchas</a> “包含证明（proof of inclusion）”在 Satoshi 的<a href="https://bitcoin.org/bitcoin.pdf" target="_blank" rel="noopener">原白皮书</a>中描述了 SPV 背后的想法，尽管不是所有的功能。</p><p>这种轻量级验证方法确实存在一些风险，但是 <a href="https://bitcoin.org/en/developer-guide#application-of-bloom-filters" target="_blank" rel="noopener">Bloom 过滤器</a>和连接到多个节点而不是一个节点的各种措施用于缓解此方法带来的安全问题。否则，轻型比特币客户端联系的完整节点可能会有<br>1) 通过假装不存在的交易欺骗用户或<br>2）获得所需的数据轻松跟踪比特币用户。</p><h2 id="结合两种模型：Qtum"><a href="#结合两种模型：Qtum" class="headerlink" title="结合两种模型：Qtum"></a>结合两种模型：Qtum</h2><p>Qtum 以 UTXO 模型及其 SPV 功能为基础运行，但增加了以太坊虚拟机 - 并且还支持其他虚拟机，我们稍后会介绍。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*xRqWbdSxhH6PKQOk4BLd5g.png" alt=""></p><p>此外，尽管 UTXO 模型（BTC，BCH，LTC和DGB都是UTXO代币的例子）不支持退款，但 Qtum 可以通过创建新输出来退款。 在以太坊设置 “gas 限制” 并获得所有未使用的有作用的 gas 退款，因为以太坊没有运行在 UTXO 模型上。 但Qtum已成功启用此退款功能，即使它基于比特币的交易模式。</p><p>使用比特币运行，Qtum 可以轻松采用比特币开发，如 SegWit 和闪电网络（Lightning Network），以及之后的<a href="https://github.com/bitcoin/bips" target="_blank" rel="noopener">比特币改进建议</a>。</p><p>使用以太坊的虚拟机运行，允许 Qtum 支持 Turing 完整的智能合约，这是比特币无法支持的。</p><h2 id="为什么比特币脚本不够用"><a href="#为什么比特币脚本不够用" class="headerlink" title="为什么比特币脚本不够用"></a>为什么比特币脚本不够用</h2><p>比特币的智能合约能力非常有限 - 尽管 RSK 和 CounterParty 正致力于以不同的方式在比特币区块链上实现智能合约。</p><p>特别是，比特币的脚本语言没有循环功能。 根据给定的变量，代码不能执行多次。 这一点或其他因素使比特币语言只能完成最简单的任务。</p><p>因此，Qtum 通过在比特币代码之上允许以太币虚拟机，在比特币代码库上实现图灵完备脚本 - 尽管不在实际比特币区块链上。</p><p>为了做到这一点，它中间需要多一层。</p><h2 id="Qtum-帐户抽象层"><a href="#Qtum-帐户抽象层" class="headerlink" title="Qtum 帐户抽象层"></a>Qtum 帐户抽象层</h2><p>为了使智能合约虚拟机及帐户模型适用于比特币的无帐户UTXO模型，Qtum包含了一个“帐户抽象层”。正如你可能想象的那样，让基于帐户的系统在无帐户底层上运行需要在 AAL（Account Abstract Layer，用户抽象层） 做一些复杂工作。</p><p>最终结果是为用户提供了 UTXO 和开发人员优势的图灵完备的以太坊虚拟机的优势。</p><p><img src="https://cdn-images-1.medium.com/max/640/1*VxxBCg15Nx_u7YLmPn06vg.png" alt="和区块链一样，它并不那么简单，但你 get 到了要点。"></p><h2 id="新操作码"><a href="#新操作码" class="headerlink" title="新操作码"></a>新操作码</h2><blockquote><p>操作码：代码行的一部分，用于标识将要执行的操作。 有关其他示例，请查看比特币的可用操作码。 这些操作码是比特币脚本语言的所有功能。</p></blockquote><p>寻求为比特币添加智能合约功能的解决方案，例如 RSK，通常需要一些新的操作码，且需要比特币来升级其代码。</p><p>Qtum 不需要比特币分支来添加新的操作码，因为它已经将比特币的代码分配到一个新项目中，因此能够简单地添加新的操作码。</p><blockquote><p>技术说明：Qtum仍然使用比特币脚本语言，但是三个新的操作码使虚拟机能够在此基础上运行</p><ul><li>OP_EXEC：执行特定的以太坊虚拟机字节码。</li><li>OP_EXEC_ASSIGN：与上述相同，可以包含合约地址和合约数据。它可选择将资金转移到智能合约上。</li><li>OP_TXHASH：推送当前执行的交易的ID哈希。<br>Qtum 必须允许智能合约在添加到区块链时立即执行，因此前两个操作码将以特殊优先级进行处理。</li></ul></blockquote><p>通过添加这些操作码及帐户抽象层，Qtum 成功允许比特币代码库支持以太坊虚拟机。</p><p>现在，任何以太坊应用程序都可以在Qtum上运行，并享受UTXO基础带来的好处。</p><p>但是等等……还有更多。</p><h2 id="权益证明，模板和向后兼容性"><a href="#权益证明，模板和向后兼容性" class="headerlink" title="权益证明，模板和向后兼容性"></a>权益证明，模板和向后兼容性</h2><p>Qtum对以太坊虚拟机的实现并不意味着它包含了以太坊的局限性。</p><p>像比特币一样，以太坊是建立在工作量证明之上的。节点消耗大量能量，首先解决非常困难的难题，并声称采矿奖励。我们在<a href="https://bitgenste.in/eos" target="_blank" rel="noopener">EOS第2章中</a>里讨论了的共识模型，包括工作量证明。</p><p>Qtum取而代之的是建立在 Peercoin（PPC）之上的 Proof of Stake 模型，这是第一个使用赌注模型生效的加密货币。</p><p><img src="https://cdn-images-1.medium.com/max/640/1*RyqgUQ-pGjYU47LX7LasHw.png" alt="Qtum延续了用权益证明征服强大神仙的悠久传统。"></p><p>Stof of Stake共识模型允许Qtum在没有高计算能力需求和每秒更多交易数的情况下运行。</p><p>如果您想详细阅读有关权益证明的信息，特别是与工作量证明相比较，我推荐以太坊团队成员撰写的<a href="https://github.com/ethereum/wiki/wiki/Proof-of-Stake-FAQ" target="_blank" rel="noopener">文章</a>。 不可否认，许多其他货币已经转移到了权益证明，以太坊计划在某些时候部分或全部这样做。</p><p>Qtum 还在实施模板以简化 dApp 开发 - 这是 NEM 等备选方案的重点，也是通过Crowd Machine 等项目引入以太坊的。</p><p>Qtum确实提供了一项功能，与 PoS 和模板不同，以太坊很可能永远不具备：向后兼容性。 Qtum 节点即使没有完全更新到最新版本的 Qtum，也可以参与共识。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*137VSsgkWHEwgn6lxK0tNA.png" alt=""></p><h2 id="Qtum-X86-虚拟机"><a href="#Qtum-X86-虚拟机" class="headerlink" title="Qtum X86 虚拟机"></a>Qtum X86 虚拟机</h2><p>Qtum AAL最着名的是允许使用以太坊虚拟机，但它也允许用其他虚拟机。</p><p>在5月23号，即本文发布的几个星期前，Qtum在<a href="https://blog.qtum.org/qtum-x86-virtual-machine-qtum-enterprise-version-progress-update-2ff249968e2b" target="_blank" rel="noopener">韩国 Qtum X86 虚拟机会议</a>上做了一个演讲。X86 VM 允许开发人员使用许多不同的编程语言。提到的C和C++已经支持了，其他像Rust, Python 和 Go 正在路上。</p><p>目前的Qtum路线图将 X86 集成放在 2018 年末。</p><h2 id="Qtum-Enterprise（Qtum-X）"><a href="#Qtum-Enterprise（Qtum-X）" class="headerlink" title="Qtum Enterprise（Qtum X）"></a>Qtum Enterprise（Qtum X）</h2><p>Qtum Enterprise（Qtum X）也在同一个5月23日的会议中描述，是一项旨在吸引企业的新举措。 Qtum X 将是一个权威证明（Proof of Authority）系统，允许每秒更多的交易。</p><p>Qtum X 和 Qtum 是独立的产品，至少目前是这样。 我还没有找到关于这两种产品是否可以互通的任何信息，即它们是否将共享相同的货币。</p><p>宣布之后可能还需要很长时间才能获得许多细节，特别是英语版，所以如果有读者有更多信息，我会十分感谢分享。</p><h2 id="连接到世界"><a href="#连接到世界" class="headerlink" title="连接到世界"></a>连接到世界</h2><p>除了Qtum X和X86虚拟机之外，Qtum还有许多其他项目正在开发中，旨在吸引开发人员和企业加入Qtum生态系统。</p><p>API。 模板。 功能齐全的SDK。 原子交换。 Qtum 卫星。</p><p>原子交换：将一种加密货币交易给另一种货币而不涉及任何第三方。 在典型的原子交换中，在一个区块链上启动时间锁定的智能合约。 如果另一方未在规定时间内交付所交易的货币，则该交易将被取消。</p><p>是的，我不是在开玩笑说卫星。 与Nexus一样，Qtum计划与SpaceChain合作发射卫星。 看来，与前者相比，Qtum在审查阻力之后，主要是在现阶段拉动宣传噱头 - 正如他们所说的那样，“无可争议地证明了我们决心成为世界领先的加密货币和区块链平台。”</p><p>好吧，让我们把话题带回地球。</p><h2 id="Qtum如何回答我们的七大问题？"><a href="#Qtum如何回答我们的七大问题？" class="headerlink" title="Qtum如何回答我们的七大问题？"></a>Qtum如何回答我们的七大问题？</h2><p><img src="https://cdn-images-1.medium.com/max/800/1*u1FBYguBW9JqCVrAL6l1JQ.png" alt=""></p><p>1.可扩展性</p><p>由于它是从比特币和以太坊构建的，因此Qtum每秒没有大量的交易。 权益证明（Proof of Stake）有助于实现 SegWit，将 TPS 提升至 60 左右。截至我看到的最新信息，Qtum 未来的可扩展性开发可能包括脱链渠道抑或类似于以太坊提议的分片的功能。 Qtum Enterprise（Qtum X）将使用授权证书来实现更高的交易吞吐量。 目前尚不清楚Qtum X和Qtum将如何或是否将在此时集成，但由于其可扩展性优势，企业可能对Qtum X感兴趣。</p><p><img src="https://cdn-images-1.medium.com/max/480/0*-sNt1eVMIsXAVRif" alt=""></p><p>2.治理</p><p>Qtum的股权证明，最初建立在PeerCoin开创性的PoS代码之上。Qtum确实有一个分散治理协议（DGP）。 Qtum X 将在权威证明上运行。</p><p>Qtum区块链基金会指导DGP范围之外的决策。</p><p>3.开发复杂性</p><p>虽然Qtum可以使用以太坊的EVM和Solidity，但新的Qtum X86虚拟机还是会允许 C 和 C++ 和之后其他语言比如 Ruby, Go, Python. 与以太坊不同，Qtum的EVM始终向后兼容。</p><p>eSML是Qtum的计划语言，具有正式的验证能力。我们在<a href="https://bitgenste.in/ada" target="_blank" rel="noopener">episode #3 (Cardano)</a>讨论了正式验证。正式验证是 Cardano 的主要关注点。 公平地说，一些第三方解决方案以及可能即将推出的 Casper 也将为以太坊引进正式验证。</p><p>4.时间轴</p><p>Qtum 很活跃，新的 X86 虚拟机将在今年晚些时候集成。 Qtum X（Qtum Enterprise）项目时间表在撰写本文时尚不清楚。</p><p>5.广义特征</p><p>如上所述，模板计划为应用程序开发人员提供通用功能，减少重复性工作和错误倾向。 除此之外，尚未出现广义特征。 随着X86虚拟机的集成，我不会惊讶于看到许多有趣的功能。</p><p>6.可采纳性</p><p>几个基本的 Qtum 可采用性功能已经到位，例如 Ledger 钱包集成，但由于以业务为中心的 Qtum X 仍处于早期开发阶段，我怀疑我们不会知道最终的 Qtum dApp 生态系统以及后来的游戏有多么对用户友好。</p><p>Qtum 确实有交易费用，但是像以太坊的费用一样，它们可能最终会被企业从用户那里抽象出来。 我没有找到有关 Qtum 上人类可读的地址计划的信息。</p><p>7.市场地位</p><p>据我所知，Qtum没有像我们迄今为止讨论过的大多数解决方案那样大的开发者社区。 然而，在Qtum上运行了一些dApp和ICO。 如果Qtum区块链基金会能够在加强Qtum营销的同时快速实现计划中的X86 VM，Qtum X和更多功能，那么它可能会使它们成为强大的以太坊挑战者。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*YbD8z2mQTGnDUvETLRg_WA.png" alt=""></p><p>当然，随着我们通过市值进一步向下移动，我们应该期待看到处于早期阶段的项目。 他们根本没有顶级项目那么多的嗡嗡声 - 也没有多少钱。</p><p>Qtum带来了其他智能合约平台的许多优势，以及它自己的一些重点。 因此，尽管我大声地认为Qtum确实需要一个新的标识，但我很高兴看到该项目的去向。</p><p>毕竟，在<a href="https://bitgenste.in/neo" target="_blank" rel="noopener">NEO的第4集</a>中，我们讨论了中国项目在中国的表现如何比外国项目更好。 事实上，好多了。 中国的强大优势可能会使Qtum成为以太坊的严峻挑战者。</p><p><img src="https://cdn-images-1.medium.com/max/640/1*8-ezmr50c9Frcnkc0ppQOg.gif" alt=""></p><p>与本系列中的所有平台一样，我将密切关注 Qtum 及 X86 VM 和 Qtum X 的发布。</p><p><a href="https://twitter.com/bitgenstein" target="_blank" rel="noopener">让我知道你对Twitter上Qtum的看法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;https://strategiccoin.com/the-ethereum-challengers-qtum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://strategiccoin.com/the-ethere
      
    
    </summary>
    
      <category term="区块链" scheme="http://xichen.pub/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://xichen.pub/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Qtum" scheme="http://xichen.pub/tags/Qtum/"/>
    
      <category term="翻译" scheme="http://xichen.pub/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】 深入理解以太坊虚拟机 - 如何解释一个智能合约的方法调用</title>
    <link href="http://xichen.pub/2018/06/30/2018-06-30-%E7%BF%BB%E8%AF%91-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%99%9A%E6%8B%9F%E6%9C%BA-EVM%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E7%AE%80%E4%BB%8B/"/>
    <id>http://xichen.pub/2018/06/30/2018-06-30-翻译-深入理解以太坊虚拟机-EVM汇编代码简介/</id>
    <published>2018-06-30T06:11:00.000Z</published>
    <updated>2018-09-01T09:22:40.504Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://medium.com/@hayeah/how-to-decipher-a-smart-contract-method-call-8ee980311603" target="_blank" rel="noopener">https://medium.com/@hayeah/how-to-decipher-a-smart-contract-method-call-8ee980311603</a><br>译者：中山大学数学学院（珠海）林学渊<br>大二时给量子做的翻译，转载注明出处，谢谢</p><h1 id="如何解释一个智能合约的方法调用"><a href="#如何解释一个智能合约的方法调用" class="headerlink" title="如何解释一个智能合约的方法调用"></a>如何解释一个智能合约的方法调用</h1><hr><p>在本系列的前几篇文章中，我们已经看到了 Solidity 如何在 EVM 存储中表示复杂的数据结构。但是如果没有办法与数据交互，数据就毫无用处。智能合约是数据与外部世界交互的中介。</p><p>在本文中，我们将看到 Solidity 和 EVM 如何使外部程序能够调用合约的方法并使其状态发生变化。</p><p>“外部程序” 不限于 DApp / JavaScript。 任何可以使用 HTTP RPC 与以太坊节点进行通信的程序都可以通过创建交易来与部署在区块链上的任何合约进行交互。</p><p>创建一个交易就像创建一个 HTTP 请求。 Web 服务器可以接受你的 HTTP 请求并更改数据库。同理，网络将接受一个交易，然后底层区块链扩展以包括状态的改变。</p><p>交易对于智能合约来说就像是 HTTP 请求对于 Web 服务。</p><p>如果对 EVM 汇编和 Solidity 的数据表示不熟悉，请参阅本系列以前的文章以了解更多信息：</p><ul><li><a href="https://medium.com/@hayeah/diving-into-the-ethereum-vm-6e8d5d2f3c30" target="_blank" rel="noopener">EVM汇编代码简介</a></li><li><a href="https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-2-storage-layout-bc5349cb11b7" target="_blank" rel="noopener">如何表示固定长度的数据类型</a></li><li><a href="https://medium.com/@hayeah/diving-into-the-ethereum-vm-the-hidden-costs-of-arrays-28e119f04a9b" target="_blank" rel="noopener">如何表示动态数据类型</a></li></ul><h1 id="合约交易"><a href="#合约交易" class="headerlink" title="合约交易"></a>合约交易</h1><p>我们来看一个将状态变量设置为 <code>0x1</code> 的交易。与之交互的合约有变量 <code>a</code> 的一个 setter 和一个 getter：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">  uint256 a;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setA</span><span class="params">(uint256 _a)</span> </span>&#123;</span><br><span class="line">    a = _a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getA</span><span class="params">()</span> <span class="title">returns</span><span class="params">(uint256)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该合约部署在测试网络Rinkeby上。可以使用 Etherscan 查看地址<a href="https://rinkeby.etherscan.io/address/0x62650ae5c5777d1660cc17fcd4f48f6a66b9a4c2#code" target="_blank" rel="noopener">0x62650ae5….</a></p><p>我创建了一个可以调用 <code>setA(1)</code> 的交易。可以在地址<a href="https://rinkeby.etherscan.io/tx/0x7db471e5792bbf38dc784a5b983ee6a7bbe3f1db85dd4daede9ee88ed88057a5" target="_blank" rel="noopener">0x7db471e5….</a>处查看此交易</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*IkWyWsud_E7DD6QfpPoKHQ.jpeg" alt=""></p><p>交易的输入数据是：<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>xee919d5000000000000000000000000000000000000000000000000000000<span class="number">00000000001</span></span><br></pre></td></tr></table></figure></p><p>对 EVM 来说，这仅仅是 36 个字节的原始数据。将它作为 <code>calldata</code> 传给未经处理的智能合约。如果智能合约是一个 Solidity 程序，那么它将这些输入字节解释为一个方法调用，并为 <code>setA(1)</code> 执行相应的汇编代码。</p><p>输入数据可以分解为两个子部分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法选择器 (4 bytes)</span></span><br><span class="line"><span class="number">0xee919d5</span></span><br><span class="line"><span class="comment"># 第一个参数 (32 bytes)</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000001</span></span><br></pre></td></tr></table></figure><p>前四个字节是方法选择器，其余部分是 32 字节块的方法参数。在这个例子里只有 1 个参数，值 <code>0x1</code>。</p><p>方法选择器是方法签名的 kecccak256 哈希。在这个例子里，方法签名是 <code>setA(uint256)</code> ，它是方法的名称和参数的类型。</p><p>我们用 Python 来计算一下方法选择器。首先，散列方法签名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 pyethereum https://github.com/ethereum/pyethereum/#installation</span></span><br><span class="line">&gt; <span class="keyword">from</span> ethereum.utils <span class="keyword">import</span> sha3</span><br><span class="line">&gt; sha3(<span class="string">"setA(uint256)"</span>).hex()</span><br><span class="line"><span class="string">'ee919d50445cd9f463621849366a537968fe1ce096894b0d0c001528383d4769'</span></span><br></pre></td></tr></table></figure><p>然后获取哈希的前4个字节：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; sha3(<span class="string">"setA(uint256)"</span>)[<span class="number">0</span>:<span class="number">4</span>].hex()</span><br><span class="line"><span class="string">'ee919d50'</span></span><br></pre></td></tr></table></figure><h1 id="应用程序二进制接口（ABI）"><a href="#应用程序二进制接口（ABI）" class="headerlink" title="应用程序二进制接口（ABI）"></a>应用程序二进制接口（ABI）</h1><p>就 EVM 而言，交易的输入数据（<code>calldata</code>）只是一个字节序列。EVM 没有内置的方法调用的支持。</p><p>智能合约可以选择通过结构化方式来处理输入数据以模拟方法调用，如前一节所述。</p><p>如果 EVM 上的语言对输入数据的解释达成一致，那么它们可以很容易地进行交互。<a href="https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI#formal-specification-of-the-encoding" target="_blank" rel="noopener">合约应用程序二进制接口</a>（ABI）指定了一种通用的编码方案。</p><p>我们已经知道 ABI 如何编码一个简单的方法调用，如 <code>setA(1)</code>。在后面的章节中，我们将看到有更复杂参数的方法调用是如何编码的。</p><h1 id="调用-Getter"><a href="#调用-Getter" class="headerlink" title="调用 Getter"></a>调用 Getter</h1><p>如果调用的方法改变了状态，那么整个网络都必须同意。这将需要一笔交易，并且会耗费 gas。</p><p>像 <code>getA()</code> 这样的 getter 方法不会改变任何东西。我们可以将方法调用发送到本地以太坊节点，而不是要求整个网络进行计算。 <code>eth_call</code> RPC 请求允许在本地模拟交易。这对只读方法或 gas 的使用评估非常有用。</p><p><code>eth_call</code> 就像缓存的 HTTP GET请求。</p><ul><li>它不会改变全局共识状态。</li><li>本地区块链（“cache”）可能有点过时。</li></ul><p>让我们发起一个 <code>eth_call</code> 调用 <code>getA</code> 方法，返回状态 <code>a</code>。</p><p>首先，计算出方法选择器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sha3(<span class="string">"getA()"</span>)[<span class="number">0</span>:<span class="number">4</span>].hex()</span><br><span class="line"><span class="string">'d46300fd'</span></span><br></pre></td></tr></table></figure><p>由于没有参数，输入数据本身就是方法选择器。 我们可以向任意一个以太坊节点发送 <code>eth_call</code> 请求。 在这个例子中，我们会将请求发送到由 infura.io 托管的公共以太坊节点：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -X POST \</span></span><br><span class="line">-H "Content-Type: application/json" \</span><br><span class="line">"https://rinkeby.infura.io/YOUR_INFURA_TOKEN" \</span><br><span class="line">--data '</span><br><span class="line">&#123;</span><br><span class="line">  "jsonrpc": "2.0",</span><br><span class="line">  "id": 1,</span><br><span class="line">  "method": "eth_call",</span><br><span class="line">  "params": [</span><br><span class="line">    &#123;</span><br><span class="line">      "to": "0x62650ae5c5777d1660cc17fcd4f48f6a66b9a4c2",</span><br><span class="line">      "data": "0xd46300fd"</span><br><span class="line">    &#125;,</span><br><span class="line">    "latest"</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">'</span><br></pre></td></tr></table></figure></p><p>EVM 执行计算并返回原始字节：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"jsonrpc"</span>:<span class="string">"2.0"</span>,</span><br><span class="line">  <span class="attr">"id"</span>:<span class="number">1</span>,</span><br><span class="line">  <span class="attr">"result"</span>:<span class="string">"0x0000000000000000000000000000000000000000000000000000000000000001"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 ABI，这些字节应该被解释为值 <code>0x1</code>。</p><h1 id="用于外部方法调用的汇编代码"><a href="#用于外部方法调用的汇编代码" class="headerlink" title="用于外部方法调用的汇编代码"></a>用于外部方法调用的汇编代码</h1><p>现在我们来看编译后的合约如何处理原始输入数据来进行方法调用的。 考虑定义了 <code>setA(uint256)</code> 的合约：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">  uint256 a;</span><br><span class="line">  <span class="comment">// 注意: `payable` 让汇编代码简单一点</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setA</span><span class="params">(uint256 _a)</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">    a = _a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">solc</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">bin</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">asm</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">optimize</span> <span class="comment">call</span><span class="string">.</span><span class="comment">sol</span></span><br></pre></td></tr></table></figure><p>被调用方法的汇编代码位于 <code>sub_0</code> 下的合约主体中：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">sub_0:</span> <span class="class">assembly </span>&#123;</span><br><span class="line">    mstore(<span class="number">0x40</span>, <span class="number">0x60</span>)</span><br><span class="line">    and(div(calldataload(<span class="number">0x0</span>), <span class="number">0x100000000000000000000000000000000000000000000000000000000</span>), <span class="number">0xffffffff</span>)</span><br><span class="line">    <span class="number">0xee919d50</span></span><br><span class="line">    dup2</span><br><span class="line">    eq</span><br><span class="line">    tag_2</span><br><span class="line">    jumpi</span><br><span class="line"><span class="symbol">  tag_1:</span></span><br><span class="line">    <span class="number">0x0</span></span><br><span class="line">    dup1</span><br><span class="line">    revert</span><br><span class="line"><span class="symbol">  tag_2:</span></span><br><span class="line">    tag_3</span><br><span class="line">    calldataload(<span class="number">0x4</span>)</span><br><span class="line">    jump(tag_4)</span><br><span class="line"><span class="symbol">  tag_3:</span></span><br><span class="line">    stop</span><br><span class="line"><span class="symbol">  tag_4:</span></span><br><span class="line">      <span class="comment">/* "call.sol":95:96  a */</span></span><br><span class="line">    <span class="number">0x0</span></span><br><span class="line">      <span class="comment">/* "call.sol":95:101  a = _a */</span></span><br><span class="line">    dup2</span><br><span class="line">    swap1</span><br><span class="line">    sstore</span><br><span class="line"><span class="symbol">  tag_5:</span></span><br><span class="line">    pop</span><br><span class="line">    jump <span class="comment">// out</span></span><br><span class="line"><span class="symbol">auxdata:</span> <span class="number">0xa165627a7a7230582016353b5ec133c89560dea787de20e25e96284d67a632e9df74dd981cc4db7a0a0029</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有两段与本次讨论无关的样板代码:</p><ul><li><code>mstore(0x40，0x60)</code> 位于顶部，用于保存内存中 sha3 哈希的前 64 个字节。无论合同是否需要，它总是存在的。</li><li><code>auxdata</code> 位于最底部，用于验证发布的源代码与部署的字节码是否相同。 这是可选的，但可以编译到编译器中。</li></ul><p>让我们将剩余的汇编代码分成两部分以便于分析：</p><ol><li>匹配选择器并跳转到方法。</li><li>加载参数，执行方法和从方法返回。</li></ol><p>首先，用于匹配选择器的汇编代码如下（带注释）：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载前 4 个字节作为方法选择器</span></span><br><span class="line"><span class="keyword">and</span>(<span class="built-in">div</span>(calldataload(<span class="number">0x0</span>), <span class="number">0x100000000000000000000000000000000000000000000000000000000</span>), <span class="number">0xffffffff</span>)</span><br><span class="line"><span class="comment">// 如果选择器匹配到 `0xee919d50`, 跳转到 setA</span></span><br><span class="line"><span class="number">0xee919d50</span></span><br><span class="line">dup2</span><br><span class="line"><span class="keyword">eq</span></span><br><span class="line">tag_2</span><br><span class="line">jumpi</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有匹配到的方法. 失败 &amp; 返回.</span></span><br><span class="line">tag_1:</span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">  dup1</span><br><span class="line">  revert</span><br><span class="line"><span class="comment">//  setA 方法的主体</span></span><br><span class="line">tag_2:</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>很直接，除了在开始从调用数据里加载 4 个字节的位交换。</p><p>为了清楚起见，低层次伪代码中的汇编逻辑如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">methodSelector = calldata[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line"><span class="keyword">if</span> methodSelector == <span class="string">"0xee919d50"</span>:</span><br><span class="line">  <span class="keyword">goto</span> tag_2 <span class="comment">// 跳转到 setA</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="comment">// 没有匹配到的方法. 失败 &amp; 返回.</span></span><br><span class="line">  revert</span><br></pre></td></tr></table></figure><p>实际方法调用的汇编代码（带注释）：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setA</span></span><br><span class="line"><span class="symbol">tag_2:</span></span><br><span class="line">  <span class="comment">// 方法调用后返回的位置</span></span><br><span class="line">  tag_3</span><br><span class="line">  <span class="comment">// 加载参数 (参数值为 0x1，0x4是地址，0x0~0x3是方法选择器).</span></span><br><span class="line">  calldataload(<span class="number">0x4</span>)</span><br><span class="line">  <span class="comment">// 执行</span></span><br><span class="line">  jump(tag_4)</span><br><span class="line"><span class="symbol">tag_4:</span></span><br><span class="line">  <span class="comment">// sstore(0x0, 0x1)</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">  dup2</span><br><span class="line">  swap1</span><br><span class="line">  sstore</span><br><span class="line"><span class="symbol">tag_5:</span></span><br><span class="line">  pop</span><br><span class="line">  <span class="comment">// 程序结束, 跳转到 tag_3 停止</span></span><br><span class="line">  jump</span><br><span class="line"><span class="symbol">tag_3:</span></span><br><span class="line">  <span class="comment">// 程序结束</span></span><br><span class="line">  stop</span><br></pre></td></tr></table></figure></p><p>在进入方法主体之前，汇编代码做了两件事：</p><ol><li>保存方法调用后返回的位置。</li><li>将来自调用数据的参数加载到堆栈上。</li></ol><p>低层次的伪代码：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存方法调用后返回的位置.</span></span><br><span class="line"><span class="variable">@returnTo</span> = tag_3</span><br><span class="line"><span class="attribute">tag_2</span>: <span class="comment">// setA</span></span><br><span class="line">  <span class="comment">// 将调用数据的参数加载到堆栈中.</span></span><br><span class="line">  <span class="variable">@arg1</span> = calldata[<span class="number">4</span>:<span class="number">4</span>+<span class="number">32</span>]</span><br><span class="line"><span class="attribute">tag_4</span>: <span class="comment">// a = _a</span></span><br><span class="line">  sstore(<span class="number">0</span>x0, <span class="variable">@arg1</span>)</span><br><span class="line">tag_5 <span class="comment">// return</span></span><br><span class="line">  jump(<span class="variable">@returnTo</span>)</span><br><span class="line"><span class="attribute">tag_3</span>:</span><br><span class="line">  stop</span><br></pre></td></tr></table></figure><p>将两部分组合在一起：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">methodSelector = calldata[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line"><span class="keyword">if</span> methodSelector == <span class="string">"0xee919d50"</span>:</span><br><span class="line">  goto tag_2 <span class="comment">// 跳转到 setA</span></span><br><span class="line"><span class="string">else:</span></span><br><span class="line">  <span class="comment">// 没有匹配的方法. 失败.</span></span><br><span class="line">  revert</span><br><span class="line"><span class="meta">@returnTo</span> = tag_3</span><br><span class="line"><span class="string">tag_2:</span> <span class="comment">// setA(uint256 _a)</span></span><br><span class="line">  <span class="meta">@arg</span>1 = calldata[<span class="number">4</span>:<span class="number">36</span>]</span><br><span class="line"><span class="string">tag_4:</span> <span class="comment">// a = _a</span></span><br><span class="line">  sstore(<span class="number">0x0</span>, <span class="meta">@arg</span>1)</span><br><span class="line">tag_5 <span class="comment">// return</span></span><br><span class="line">  jump(<span class="meta">@returnTo</span>)</span><br><span class="line"><span class="string">tag_3:</span></span><br><span class="line">  stop</span><br></pre></td></tr></table></figure></p><blockquote><p>有趣的花絮:返回的操作码是 <code>fd</code>。 但是你在黄皮书里找不到它的规范，或者在代码中实现。 实际上，<code>fd</code> 并不存在！ 这是一个无效的操作。 当 EVM 遇到无效操作时，它会因为副作用而放弃并恢复状态。</p></blockquote><h1 id="处理多个方法"><a href="#处理多个方法" class="headerlink" title="处理多个方法"></a>处理多个方法</h1><p>Solidity 编译器如何为具有多个方法的合同生成汇编代码？</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">pragma</span> solidity<span class="regexp"> ^0.4.11</span>;</span><br><span class="line"><span class="attribute">contract</span> C &#123;</span><br><span class="line">    <span class="attribute">uint256</span> a;</span><br><span class="line">    <span class="attribute">uint256</span> b;</span><br><span class="line">    <span class="attribute">function</span> setA(uint256 _a) &#123;</span><br><span class="line">      <span class="attribute">a</span> = _a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">function</span> setB(uint256 _b) &#123;</span><br><span class="line">      <span class="attribute">b</span> = _b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单。只是更多的 <code>if-else</code> 分支一个一个接上去：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// methodSelector = calldata[0:4]</span></span><br><span class="line">and(div(calldataload(<span class="number">0x0</span>), <span class="number">0x100000000000000000000000000000000000000000000000000000000</span>), <span class="number">0xffffffff</span>)</span><br><span class="line"><span class="comment">// if methodSelector == 0x9cdcf9b</span></span><br><span class="line"><span class="number">0x9cdcf9b</span></span><br><span class="line">dup2</span><br><span class="line">eq</span><br><span class="line">tag_2 <span class="comment">// SetB</span></span><br><span class="line">jumpi</span><br><span class="line"><span class="comment">// elsif methodSelector == 0xee919d50</span></span><br><span class="line">dup1</span><br><span class="line"><span class="number">0xee919d50</span></span><br><span class="line">eq</span><br><span class="line">tag_3 <span class="comment">// SetA</span></span><br><span class="line">jumpi</span><br></pre></td></tr></table></figure><p>伪代码：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">methodSelector = calldata[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line"><span class="keyword">if</span> methodSelector == <span class="string">"0x9cdcf9b"</span>:</span><br><span class="line">  <span class="keyword">goto</span> tag_2</span><br><span class="line"><span class="keyword">elsif</span> methodSelector == <span class="string">"0xee919d50"</span>:</span><br><span class="line">  <span class="keyword">goto</span> tag_3</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  // 没有匹配的方法. 失败.</span><br><span class="line">  revert</span><br></pre></td></tr></table></figure><h1 id="用于复杂方法调用的-ABI-编码"><a href="#用于复杂方法调用的-ABI-编码" class="headerlink" title="用于复杂方法调用的 ABI 编码"></a>用于复杂方法调用的 ABI 编码</h1><p><img src="https://cdn-images-1.medium.com/max/1600/1*EtXrxIQWOtodr4kw3TyJFA.jpeg" alt="别担心零。没事的。"></p><p>对于方法调用，交易的输入数据前四个字节总是方法选择器。 然后方法参数以 32 个字节的块为单位。 <a href="https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI" target="_blank" rel="noopener">ABI编码规范</a>详细说明了复杂类型参数是如何编码的，但读取会非常痛苦。</p><p>学习 ABI 编码的另一个策略是使用 <a href="https://github.com/ethereum/pyethereum/blob/4e945e2a24554ec04eccb160cff689a82eed7e0d/ethereum/abi.py" target="_blank" rel="noopener">pyethereum 的 ABI 编码函数</a>来研究如何对不同数据类型进行编码。 我们将从简单的案例开始，并构建更复杂的类型。</p><p>首先，导入 <code>encode_abi</code> 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ethereum.abi <span class="keyword">import</span> encode_abi</span><br></pre></td></tr></table></figure><p>对于有三个 uint256 参数的方法（例如 <code>foo(uint256 a，uint256 b，uint256 c)</code>），编码的参数就是一个接一个的 uint256 数字:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一个数组列出参数类型</span></span><br><span class="line"><span class="comment"># 第二个数组列出参数值</span></span><br><span class="line">&gt; encode_abi([<span class="string">"uint256"</span>, <span class="string">"uint256"</span>, <span class="string">"uint256"</span>],[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).hex()</span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000001</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000002</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br></pre></td></tr></table></figure><p>小于 32 个字节的数据类型填充为32个字节：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; encode_abi([<span class="string">"int8"</span>, <span class="string">"uint32"</span>, <span class="string">"uint64"</span>],[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).hex()</span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000001</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000002</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br></pre></td></tr></table></figure><p>对于定长数组，元素也是 32 字节的块（如果需要，填充 0 ），依次排列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; encode_abi(</span><br><span class="line">   [<span class="string">"int8[3]"</span>, <span class="string">"int256[3]"</span>],</span><br><span class="line">   [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line">).hex()</span><br><span class="line">// int8[<span class="number">3</span>]. 用 <span class="number">0</span> 填充到 <span class="number">32</span> bytes.</span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000001</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000002</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line">// int256[<span class="number">3</span>].</span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000004</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000005</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000006</span></span><br></pre></td></tr></table></figure><h1 id="动态数组的-ABI-编码"><a href="#动态数组的-ABI-编码" class="headerlink" title="动态数组的 ABI 编码"></a>动态数组的 ABI 编码</h1><p>ABI 引入了一个间接层来对动态数组进行编码，遵循称为<a href="https://github.com/ethereum/pyethereum/blob/4e945e2a24554ec04eccb160cff689a82eed7e0d/ethereum/abi.py#L735-L741" target="_blank" rel="noopener">头尾编码</a>的方案。</p><p>这个想法是，动态数组的元素封装在交易的 calldata 的尾部。 参数（“头部”）是对数组元素所在的 calldata 的引用。</p><p>如果我们调用一个含 3 个动态数组的方法，则参数会像这样编码（为了清晰起见添加了注释和换行符）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&gt; encode_abi(</span><br><span class="line">  [<span class="string">"uint256[]"</span>, <span class="string">"uint256[]"</span>, <span class="string">"uint256[]"</span>],</span><br><span class="line">  [[<span class="number">0xa1</span>, <span class="number">0xa2</span>, <span class="number">0xa3</span>], [<span class="number">0xb1</span>, <span class="number">0xb2</span>, <span class="number">0xb3</span>], [<span class="number">0xc1</span>, <span class="number">0xc2</span>, <span class="number">0xc3</span>]]</span><br><span class="line">).hex()</span><br><span class="line">/************* 头部 (<span class="number">32</span>*<span class="number">3</span> bytes) *************/</span><br><span class="line">// arg1: 查看位置 <span class="number">0x60</span> 寻找数组数据</span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000060</span></span><br><span class="line">// arg2: 查看位置 <span class="number">0xe0</span> 寻找数组数据</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000e0</span></span><br><span class="line">// arg3: 查看位置 <span class="number">0x160</span> 寻找数组数据</span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000160</span></span><br><span class="line">/************* 尾部 (<span class="number">128</span>**<span class="number">3</span> bytes) *************/</span><br><span class="line">// 位置 <span class="number">0x60</span>. arg1 的数据.</span><br><span class="line">// 长度后跟元素</span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>a1</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>a2</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>a3</span><br><span class="line">// 位置 <span class="number">0xe0</span>. arg2 的数据.</span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b1</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b2</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b3</span><br><span class="line">// 位置 <span class="number">0x160</span>. arg3 的数据.</span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>c1</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>c2</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>c3</span><br></pre></td></tr></table></figure><p>所以头部有三个 32 字节的参数，指向尾部的位置，它包含三个动态数组的实际数据。</p><p>例如，第一个参数是 <code>0x60</code>，指向 calldata 的第96个（<code>0x60</code>）字节。 如果你看第 96 个字节，它是一个数组的开始。 前 32 个字节是长度，后面是三个元素。</p><p>可以混合动态和静态参数。 这里有一个 <code>(静态, 动态, 静态)</code> 参数的例子。 静态参数按原样编码，而第二个动态数组的数据放置在尾部：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; encode_abi(</span><br><span class="line">  [<span class="string">"uint256"</span>, <span class="string">"uint256[]"</span>, <span class="string">"uint256"</span>],</span><br><span class="line">  [<span class="number">0xaaaa</span>, [<span class="number">0xb1</span>, <span class="number">0xb2</span>, <span class="number">0xb3</span>], <span class="number">0xbbbb</span>]</span><br><span class="line">).hex()</span><br><span class="line">/************* 头部 (<span class="number">32</span>*<span class="number">3</span> bytes) *************/</span><br><span class="line">// arg1: <span class="number">0xaaaa</span></span><br><span class="line"><span class="number">000000000000000000000000000000000000000000000000000000000000</span>aaaa</span><br><span class="line">// arg2: 查看数组数据的位置 <span class="number">0x60</span> </span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000060</span></span><br><span class="line">// arg3: <span class="number">0xbbbb</span></span><br><span class="line"><span class="number">000000000000000000000000000000000000000000000000000000000000</span>bbbb</span><br><span class="line">/************* 尾部 (<span class="number">128</span> bytes) *************/</span><br><span class="line">// 位置 <span class="number">0x60</span>. arg2 的数据.</span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b1</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b2</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b3</span><br></pre></td></tr></table></figure><p>很多零，但没关系。</p><h1 id="编码字节"><a href="#编码字节" class="headerlink" title="编码字节"></a>编码字节</h1><p>字符串和字节数组也用头尾编码。唯一的区别是这些字节以 32 字节的块形式紧密打包，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; encode_abi(</span><br><span class="line">  [<span class="string">"string"</span>, <span class="string">"string"</span>, <span class="string">"string"</span>],</span><br><span class="line">  [<span class="string">"aaaa"</span>, <span class="string">"bbbb"</span>, <span class="string">"cccc"</span>]</span><br><span class="line">).hex()</span><br><span class="line">// arg1: 查看位置 <span class="number">0x60</span> 寻找字符串数据</span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000060</span></span><br><span class="line">// arg2: 查看位置 <span class="number">0xa0</span> 寻找字符串数据</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>a0</span><br><span class="line">// arg3: 查看位置 <span class="number">0xe0</span> 寻找字符串数据</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000e0</span></span><br><span class="line">// <span class="number">0x60</span> (<span class="number">96</span>). arg1 的数据</span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000004</span></span><br><span class="line"><span class="number">6161616100000000000000000000000000000000000000000000000000000000</span></span><br><span class="line">// <span class="number">0xa0</span> (<span class="number">160</span>). arg2 的数据</span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000004</span></span><br><span class="line"><span class="number">6262626200000000000000000000000000000000000000000000000000000000</span></span><br><span class="line">// <span class="number">0xe0</span> (<span class="number">224</span>). arg3 的数据</span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000004</span></span><br><span class="line"><span class="number">6363636300000000000000000000000000000000000000000000000000000000</span></span><br></pre></td></tr></table></figure><p>对于每个字符串/字节数组，它前 32 个字节对​​长度进行编码，后跟字节。</p><p>如果字符串大于 32 字节，则使用多个 32 字节的块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// encode <span class="number">48</span> bytes of string data</span><br><span class="line">ethereum.abi.encode_abi(</span><br><span class="line">  [<span class="string">"string"</span>],</span><br><span class="line">  [<span class="string">"a"</span> * (<span class="number">32</span>+<span class="number">16</span>)]</span><br><span class="line">).hex()</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000020</span></span><br><span class="line">// 字符串长度是 <span class="number">0x30</span> (<span class="number">48</span>)</span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000030</span></span><br><span class="line"><span class="number">6161616161616161616161616161616161616161616161616161616161616161</span></span><br><span class="line"><span class="number">6161616161616161616161616161616100000000000000000000000000000000</span></span><br></pre></td></tr></table></figure><h1 id="嵌套数组"><a href="#嵌套数组" class="headerlink" title="嵌套数组"></a>嵌套数组</h1><p>嵌套数组，每个嵌套有一个间接寻址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt; encode_abi(</span><br><span class="line">  [<span class="string">"uint256[][]"</span>],</span><br><span class="line">  [[[<span class="number">0xa1</span>, <span class="number">0xa2</span>, <span class="number">0xa3</span>], [<span class="number">0xb1</span>, <span class="number">0xb2</span>, <span class="number">0xb3</span>], [<span class="number">0xc1</span>, <span class="number">0xc2</span>, <span class="number">0xc3</span>]]]</span><br><span class="line">).hex()</span><br><span class="line">// arg1: 外层数组位于 <span class="number">0x20</span>.</span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000020</span></span><br><span class="line">// <span class="number">0x20</span>. 每个元素都是一个内部数组的位置。</span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000060</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000e0</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000160</span></span><br><span class="line">// array[<span class="number">0</span>] at <span class="number">0x60</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>a1</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>a2</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>a3</span><br><span class="line">// array[<span class="number">1</span>] at <span class="number">0xe0</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b1</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b2</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b3</span><br><span class="line">// array[<span class="number">2</span>] at <span class="number">0x160</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>c1</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>c2</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>c3</span><br></pre></td></tr></table></figure><p>呀，很多零。</p><h1 id="gas-成本-amp-ABI-编码设计"><a href="#gas-成本-amp-ABI-编码设计" class="headerlink" title="gas 成本 &amp; ABI 编码设计"></a>gas 成本 &amp; ABI 编码设计</h1><p>为什么 ABI 将方法选择器截断为只有 4 个字节？ 如果不用 sha256 的全部 32 个字节，那么对于不同的方法是否会出现碰撞？ 如果截断是为了节省成本，为什么还要在方法选择器中节省 28 字节却让它浪费更多的零填充字节？</p><p>这两个设计选择似乎是矛盾的……直到我们考虑交易的 gas 成本。</p><ul><li>21000 支付给每笔交易</li><li>4 支付给交易的每个 0 字节数据或代码</li><li>68 支付给交易的每个非零数据或代码</li></ul><p>啊哈！ 零字节便宜17倍，所以零填充不是那么糟糕。</p><p>方法选择器是一个加密哈希，它是伪随机的。一个随机字符串往往会有大部分非零字节，因为每个字节只有 0.3％（1/255）的可能性为 0。</p><ul><li><p><code>0x1</code> 填充为 32 字节，成本 192 gas</p><p>4 * 31 (零字节) + 68 (1个非零字节)</p></li><li><p>sha256 很可能有 32 个非零字节，成本约为 2176 gas</p><p>32 * 68</p></li><li><p>sha256 截断为 4 个字节，成本约为 272 gas </p><p>32 * 4</p></li></ul><p>ABI 展示了另一个由 gas 成本结构激励的低级设计的例子。</p><h1 id="负整数…"><a href="#负整数…" class="headerlink" title="负整数…"></a>负整数…</h1><p>负整数通常使用称为<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%A3%9C%E6%95%B8" target="_blank" rel="noopener">补码</a>的方案来表示。int8 的 <code>-1</code> 编码全是1 <code>1111 1111</code>。</p><p>ABI 使用 1 来填充负整数，所以 -1 会填充为：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 16进制表示</span></span><br><span class="line">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span><br></pre></td></tr></table></figure><p>小负数主要是 1，因此耗费大量 gas。</p><p><code>¯\_(ツ)_/¯</code></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>要与智能合约交互，需要向其发送原始字节。它执行一些计算，可能会改变它自己的状态，然后返回原始字节。方法调用实际上不存在。 这是 ABI 创造的集体幻想。</p><p>ABI被指定为低级格式，但在功能上它更像是跨语言 RPC 框架的序列化格式。</p><p>我们可以在 DApp 和 Web App 的架构层之间进行类比：</p><ul><li>区块链就像支持数据库。</li><li>合约就像一个 web 服务。</li><li>交易就像一个请求。</li><li>ABI 是数据交换格式，如<a href="https://en.wikipedia.org/wiki/Protocol_Buffers" target="_blank" rel="noopener">协议缓冲区</a>。</li></ul><p>如果你喜欢这篇文章，你应该在Twitter @hayeah上关注我。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;https://medium.com/@hayeah/how-to-decipher-a-smart-contract-method-call-8ee980311603&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://
      
    
    </summary>
    
      <category term="区块链" scheme="http://xichen.pub/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://xichen.pub/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Qtum" scheme="http://xichen.pub/tags/Qtum/"/>
    
      <category term="翻译" scheme="http://xichen.pub/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】 深入理解以太坊虚拟机 - 如何表示动态数据类型</title>
    <link href="http://xichen.pub/2018/06/24/2018-06-24-%E7%BF%BB%E8%AF%91-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%A6%82%E4%BD%95%E8%A1%A8%E7%A4%BA%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://xichen.pub/2018/06/24/2018-06-24-翻译-深入理解以太坊虚拟机-如何表示动态数据类型/</id>
    <published>2018-06-24T06:11:00.000Z</published>
    <updated>2018-09-01T09:21:21.040Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://medium.com/@hayeah/diving-into-the-ethereum-vm-the-hidden-costs-of-arrays-28e119f04a9b" target="_blank" rel="noopener">https://medium.com/@hayeah/diving-into-the-ethereum-vm-the-hidden-costs-of-arrays-28e119f04a9b</a><br>译者：中山大学数学学院（珠海）林学渊<br>大二时给量子做的翻译，转载注明出处，谢谢</p><h1 id="如何表示动态数据类型"><a href="#如何表示动态数据类型" class="headerlink" title="如何表示动态数据类型"></a>如何表示动态数据类型</h1><p>数组的隐性成本</p><hr><p>Solidity 提供了我们熟悉的数据结构。除了简单的如数字和结构体，也有其他数据类型，它们能随着数据的添加而动态变化。3个主要的动态类型是：</p><ul><li>映射：<code>mapping(bytes32 =&gt; uint256)</code>，<code>mapping(address =&gt; string)</code>，等等。</li><li>数组：<code>[]uint256</code>，<code>[]byte</code>，等等。</li><li>字节数组：只有两种，字符串和字节。</li></ul><p>在本系列第二篇文章中，我们已经看到固定长度的简单类型在存储中是如何表示的。</p><ul><li>基础类型：<code>uint256</code>，<code>byte</code>，等等。</li><li>定长数组：<code>[10]uint8</code>，<code>[32]byte</code>，<code>bytes32</code>。</li><li>结构体：用以上两种类型组装而成。</li></ul><p>固定长度的存储变量在存储中一个接一个存储，尽可能轻量地打包成32字节的块。</p><blockquote><p>如果对这个不熟，我建议看: <a href="https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-2-storage-layout-bc5349cb11b7" target="_blank" rel="noopener">Diving Into The Ethereum VM Part II — Storage Cost</a></p></blockquote><p>在这篇文章中，我们深入理解 Solidity 是如何支持更多复杂的数据结构的。 Solidity 中的数组和映射可能看起来很熟悉，但它们的实现方式使它们具有本质的不同。</p><p>我们从映射开始，这是三者中最简单的一种。 事实证明，数组和字节数组只是有更多的功能的映射。</p><h1 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h1><p>在 <code>uint256 =&gt; uint256</code> 映射中存储一个值：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    mapping(<span class="function"><span class="params">uint256</span> =&gt;</span> uint256) items;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      items[<span class="number">0xC0FEFE</span>] = <span class="number">0x42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译:<br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">solc</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">bin</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">asm</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">optimize</span> <span class="comment">c</span><span class="literal">-</span><span class="comment">mapping</span><span class="string">.</span><span class="comment">sol</span></span><br></pre></td></tr></table></figure></p><p>汇编代码:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">  <span class="comment">// 什么也没干. 可以优化.</span></span><br><span class="line">  <span class="number">0xc0fef</span>e</span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">  swap1</span><br><span class="line">  dup2</span><br><span class="line">  mstore</span><br><span class="line">  <span class="number">0x20</span></span><br><span class="line">  mstore</span><br><span class="line">  <span class="comment">// 存储 0x42 到地址 0x798...187c</span></span><br><span class="line">  <span class="number">0x42</span></span><br><span class="line">  <span class="number">0x79826054ee948a209ff4a6c9064d7398508d2c1909a392f899d301c6d</span>232187c</span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure></p><p>我们可以将 EVM 存储视为键值对数据库，每个键限制为 32 个字节。不是直接使用键 <code>0xC0FEFE</code> ，而是将键散列为 <code>0x798...187c</code>，并将值 <code>0x42</code> 存储在那里。使用的哈希函数是 <code>keccak256（SHA256）</code>。</p><p>在这个例子里，我们没有看到 <code>keccak256</code> 指令，因为优化器已经预先计算结果并将其内联到字节码里了。可以从这些没用的 <code>mstore</code> 指令中看到这种计算的痕迹。</p><h1 id="计算地址"><a href="#计算地址" class="headerlink" title="计算地址"></a>计算地址</h1><p>让我们用一些 Python 代码来将 <code>0xC0FEFE</code> 散列为 <code>0x798...187c</code>。如果你想跟着做，你需要 Python 3.6，或者安装 <a href="https://pypi.python.org/pypi/pysha3" target="_blank" rel="noopener">pysha3</a> 来获得 <code>keccak_256</code> 哈希函数。</p><p>定义两个辅助函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> sha3</span><br><span class="line"><span class="comment"># 把一个数转化为 32 字节的数组</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bytes32</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> binascii.unhexlify(<span class="string">'%064x'</span> % i)</span><br><span class="line"><span class="comment"># 计算 32 字节数组的 keccak256 哈希</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">keccak256</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sha3.keccak_256(x).hexdigest()</span><br></pre></td></tr></table></figure><p>把一个数转化为 32 字节的数组:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; bytes32(1)</span></span><br><span class="line">b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01'</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; bytes32(0xC0FEFE)</span></span><br><span class="line">b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc0\xfe\xfe'</span><br></pre></td></tr></table></figure></p><p>用 <code>+</code> 运算把两个字节数组接在一起：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; bytes32(1) + bytes32(2)</span></span><br><span class="line">b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02'</span><br></pre></td></tr></table></figure></p><p>计算字节数组的 keccak256 哈希<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; keccak256(bytes(1))</span></span><br><span class="line">'bc36789e7a1e281436464229828f817d6612f7b477d66591ff96a9e064bcc98a'</span><br></pre></td></tr></table></figure></p><p>现在我们可以计算 <code>0x798...187c</code>了。</p><p>存储变量 <code>items</code> 的位置是 <code>0x0</code>（因为它是第一个存储变量）。要获取地址，将键 <code>0xc0fefe</code> 与 <code>items</code> 的位置接在一起：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># key = 0xC0FEFE, position = 0</span></span><br><span class="line">&gt;&gt;&gt; keccak256(bytes32(<span class="number">0</span>xC0FEFE) + bytes32(<span class="number">0</span>))</span><br><span class="line">'<span class="number">79826054</span>ee948a209ff4a6c<span class="number">9064</span>d<span class="number">739850</span>8d2c<span class="number">1909</span>a392f899d301c6d<span class="number">232187</span>c'</span><br></pre></td></tr></table></figure></p><p>计算一个键的存储地址的公式为：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keccak256(<span class="name">bytes32</span>(<span class="name">key</span>) + bytes32(<span class="name">position</span>))</span><br></pre></td></tr></table></figure></p><h1 id="2-个映射"><a href="#2-个映射" class="headerlink" title="2 个映射"></a>2 个映射</h1><p>让我们用公式来计算值会存储到哪个位置！假设我们有2个映射：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line">contract C &#123;</span><br><span class="line">    mapping(uint256 =&gt; uint256) itemsA;</span><br><span class="line">    mapping(uint256 =&gt; uint256) itemsB;</span><br><span class="line">    function C() &#123;</span><br><span class="line">      itemsA[0xAAAA] = 0xAAAA;</span><br><span class="line">      itemsB[0xBBBB] = 0xBBBB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>itemsA</code> 的位置为 <code>0</code>, 键为 <code>0xAAAA</code>:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> key = 0xAAAA, position = 0</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; keccak256(bytes32(0xAAAA) + bytes32(0))</span></span><br><span class="line">'839613f731613c3a2f728362760f939c8004b5d9066154aab51d6dadf74733f3'</span><br></pre></td></tr></table></figure></p><p><code>itemsB</code> 的位置为 <code>1</code>, 键为 <code>0xBBBB</code>:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> key = 0xBBBB, position = 1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; keccak256(bytes32(0xBBBB) + bytes32(1))</span></span><br><span class="line">'34cb23340a4263c995af18b23d9f53b67ff379ccaa3a91b75007b010c489d395'</span><br></pre></td></tr></table></figure></p><p>我们用编译器证明我们的计算：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> solc --bin --asm --optimize  c-mapping-2.sol</span></span><br></pre></td></tr></table></figure></p><p>汇编代码:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">tag_2:</span></span><br><span class="line">  // ... 忽略内存优化，可以优化掉</span><br><span class="line">  <span class="number">0xaaaa</span></span><br><span class="line">  <span class="number">0x839613f731613c3a2f728362760f939c8004b5d9066154aab51d6dadf74733f3</span></span><br><span class="line">  sstore</span><br><span class="line">  <span class="number">0xbbbb</span></span><br><span class="line">  <span class="number">0x34cb23340a4263c995af18b23d9f53b67ff379ccaa3a91b75007b010c489d395</span></span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure></p><p>和我们想的一样。</p><h1 id="汇编里的-KECCAK256"><a href="#汇编里的-KECCAK256" class="headerlink" title="汇编里的 KECCAK256"></a>汇编里的 KECCAK256</h1><p>编译器能预先计算一个键的地址，因为涉及的键是常量。如果键是一个变量，那么散列需要用汇编代码完成。现在我们要禁用这个优化，以便看到哈希如何在汇编中完成。</p><p>事实证明，通过引入一个额外变量 <code>i</code> 可以简化优化器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line">contract C &#123;</span><br><span class="line">    mapping(uint256 =&gt; uint256) items;</span><br><span class="line">    // 这个变量使常值优化失败</span><br><span class="line">    uint256 i = 0xC0FEFE;</span><br><span class="line">    function C() &#123;</span><br><span class="line">      items[i] = 0x42;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量位置还是 <code>0x0</code>, 所以我们认为地址和前面一样。</p><p>编译，但这次没有哈希预计算：<br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">$</span> <span class="comment">solc</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">bin</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">asm</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">optimize</span>  <span class="comment">c</span><span class="literal">-</span><span class="comment">mapping</span><span class="literal">-</span><span class="literal">-</span><span class="comment">no</span><span class="literal">-</span><span class="comment">constant</span><span class="literal">-</span><span class="comment">folding</span><span class="string">.</span><span class="comment">sol</span></span><br></pre></td></tr></table></figure></p><p>汇编代码:<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">  <span class="comment">// `i` 入栈</span></span><br><span class="line">  sload(<span class="number">0x1</span>)</span><br><span class="line">    [<span class="meta">0xC0FEFE</span>]</span><br><span class="line">  <span class="comment">// 存储键 `0xC0FEFE` 到内存 0x0, 准备哈希.</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">    [<span class="meta">0x0 0xC0FEFE</span>]</span><br><span class="line">  swap1</span><br><span class="line">    [<span class="meta">0xC0FEFE 0x0</span>]</span><br><span class="line">  dup2</span><br><span class="line">    [<span class="meta">0x0 0xC0FEFE 0x0</span>]</span><br><span class="line">  mstore</span><br><span class="line">    [<span class="meta">0x0</span>]</span><br><span class="line">    memory: &#123;</span><br><span class="line">      <span class="number">0x00</span> =&gt; <span class="number">0xC0FEFE</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 保持位置 `0x0` 到内存 0x20 (32), 准备哈希.</span></span><br><span class="line">  <span class="number">0x20</span> <span class="comment">// 32</span></span><br><span class="line">    [<span class="meta">0x20 0x0</span>]</span><br><span class="line">  dup2</span><br><span class="line">    [<span class="meta">0x0 0x20 0x0</span>]</span><br><span class="line">  swap1</span><br><span class="line">    [<span class="meta">0x20 0x0 0x0</span>]</span><br><span class="line">  mstore</span><br><span class="line">    [<span class="meta">0x0</span>]</span><br><span class="line">    memory: &#123;</span><br><span class="line">      <span class="number">0x00</span> =&gt; <span class="number">0xC0FEFE</span></span><br><span class="line">      <span class="number">0x20</span> =&gt; <span class="number">0x0</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 从第 0 个字节开始，依次哈希内存中接下来的 0x40 (64) 字节</span></span><br><span class="line">  <span class="number">0x40</span> <span class="comment">// 64</span></span><br><span class="line">    [<span class="meta">0x40 0x0</span>]</span><br><span class="line">  swap1</span><br><span class="line">    [<span class="meta">0x0 0x40</span>]</span><br><span class="line">  keccak256</span><br><span class="line">    [<span class="meta">0x798...187c</span>]</span><br><span class="line">  <span class="comment">// 保存 0x42 到计算地址</span></span><br><span class="line">  <span class="number">0x42</span></span><br><span class="line">    [<span class="meta">0x42 0x798...187c</span>]</span><br><span class="line">  swap1</span><br><span class="line">    [<span class="meta">0x798...187c 0x42</span>]</span><br><span class="line">  sstore</span><br><span class="line">    store: &#123;</span><br><span class="line">      <span class="number">0x798</span>..<span class="number">.187</span>c =&gt; <span class="number">0x42</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><code>mstore</code> 指令在内存中写入 32 个字节。 内存要便宜得多，只需要 3 gas 来读写。汇编代码前半部分通过将键和位置加载到相邻的内存块中来“连接”键和位置：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 0                   31  32                 63</span><br><span class="line">[<span class="string">    key (32 bytes)    </span>][<span class="symbol"> position (32 bytes) </span>]</span><br></pre></td></tr></table></figure></p><p>然后，<code>keccak256</code> 指令散列该内存区域中的数据。成本取决于有多少数据被散列：</p><ul><li>30 付给每个SHA3操作。</li><li>6 付给每个32字节的字。</li></ul><p>对于 <code>uint256</code> 键，gas 成本是 42（<code>30 + 6 * 2</code>）。</p><h1 id="映射大数值"><a href="#映射大数值" class="headerlink" title="映射大数值"></a>映射大数值</h1><p>每个存储单元只能存储 32 个字节。如果试图存储更大的结构会发生什么？</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0</span>.<span class="number">4</span>.<span class="number">11</span><span class="comment">;</span></span><br><span class="line">contract C &#123;</span><br><span class="line">    mapping(uint256 =&gt; Tuple) tuples<span class="comment">;</span></span><br><span class="line">    struct Tuple &#123;</span><br><span class="line">      uint256 a<span class="comment">;</span></span><br><span class="line">      uint256 <span class="keyword">b;</span></span><br><span class="line"><span class="keyword"> </span>     uint256 c<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    function C() &#123;</span><br><span class="line">      tuples[<span class="number">0x1</span>].a = <span class="number">0x1A</span><span class="comment">;</span></span><br><span class="line">      tuples[<span class="number">0x1</span>].<span class="keyword">b </span>= <span class="number">0x1B</span><span class="comment">;</span></span><br><span class="line">      tuples[<span class="number">0x1</span>].c = <span class="number">0x1C</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译，你可以看到 3 个 sstore 指令：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">tag_2:</span></span><br><span class="line">  // ...忽略未优化代码</span><br><span class="line">  <span class="number">0x1a</span></span><br><span class="line">  <span class="number">0xada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7d</span></span><br><span class="line">  sstore</span><br><span class="line">  <span class="number">0x1b</span></span><br><span class="line">  <span class="number">0xada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7e</span></span><br><span class="line">  sstore</span><br><span class="line">  <span class="number">0x1c</span></span><br><span class="line">  <span class="number">0xada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7f</span></span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure></p><p>注意，除了最后一位数字，计算出的地址都是相同的。<code>Tuple</code> 结构的字段一个接一个地排列（.7d，.7e，.7f）。</p><h2 id="映射不打包"><a href="#映射不打包" class="headerlink" title="映射不打包"></a>映射不打包</h2><p>由于映射的设计方式，即使只存储 1 个字节，每一项的最小存储量也是 32 个字节：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    mapping(uint256 =&gt; uint8) items;</span><br><span class="line">    function C() &#123;</span><br><span class="line">      items[<span class="number">0xA</span>] = <span class="number">0xAA</span>;</span><br><span class="line">      items[<span class="number">0xB</span>] = <span class="number">0xBB</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果值大于 32 字节，则以 32 字节为单位支付存储费用。</p><h1 id="动态数组是-Mappings"><a href="#动态数组是-Mappings" class="headerlink" title="动态数组是 Mappings++"></a>动态数组是 Mappings++</h1><p>（译者注：C和C++的梗）</p><p>在经典程序语言中，数组只是一个在内存中连续排列数据项的列表。假设你有一个含 100 个 <code>uint8</code> 元素的数组，那么它将占用 100 个字节的内存。在此方案中，将整个阵列批量加载到 CPU 缓存中并循环遍历项目很便宜。</p><p>对于大多数语言而言，数组比映射便宜。不过，对于 Solidity 而言，数组是一种更昂贵的映射。数组的数据项按顺序放置在存储中，如：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>x290d...e563</span><br><span class="line"><span class="number">0</span>x290d...e564</span><br><span class="line"><span class="number">0</span>x290d...e565</span><br><span class="line"><span class="number">0</span>x290d...e566</span><br></pre></td></tr></table></figure></p><p>但记住，每次对这些存储单元的访问实际上都是数据库中的键值查找。访问数组元素与访问映射元素没有区别。</p><p>考虑类型 <code>[] uint256</code>，它与映射（<code>uint256 =&gt; uint256</code>）基本相同，并增加了使其“类似数组”的功能：</p><ul><li><code>length</code> 表示有多少数据项。</li><li>绑定检查。读取或写入超出长度的索引时会引发错误。</li><li>比映射更复杂的存储打包行为。</li><li>数组缩小时自动释放未使用的存储单元。</li><li>对 <code>bytes</code> 和 <code>string</code> 进行特殊优化，使短数组（小于31字节）的存储效率更高。</li></ul><h1 id="简单数组"><a href="#简单数组" class="headerlink" title="简单数组"></a>简单数组</h1><p>我们来看看存储三个数据项的数组：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c-darray.sol</span></span><br><span class="line"><span class="selector-tag">pragma</span> <span class="selector-tag">solidity</span> ^<span class="selector-tag">0</span><span class="selector-class">.4</span><span class="selector-class">.11</span>;</span><br><span class="line"><span class="selector-tag">contract</span> <span class="selector-tag">C</span> &#123;</span><br><span class="line">    <span class="selector-tag">uint256</span><span class="selector-attr">[]</span> <span class="selector-tag">chunks</span>;</span><br><span class="line">    <span class="selector-tag">function</span> <span class="selector-tag">C</span>() &#123;</span><br><span class="line">      <span class="selector-tag">chunks</span><span class="selector-class">.push</span>(<span class="number">0</span>xAA);</span><br><span class="line">      <span class="selector-tag">chunks</span><span class="selector-class">.push</span>(<span class="number">0</span>xBB);</span><br><span class="line">      <span class="selector-tag">chunks</span><span class="selector-class">.push</span>(<span class="number">0</span>xCC);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>数组访问的汇编代码太复杂，无法跟踪。我们用 Remix 调试器来运行合约：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*9l0i7RLrlH0yq9BTb_oM-w.jpeg" alt=""></p><p>可以看到使用了 4 个存储单元：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">key:</span> <span class="number">0x0000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="symbol">value:</span> <span class="number">0x0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="symbol">key:</span> <span class="number">0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563</span></span><br><span class="line"><span class="symbol">value:</span> <span class="number">0x00000000000000000000000000000000000000000000000000000000000000aa</span></span><br><span class="line"><span class="symbol">key:</span> <span class="number">0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e564</span></span><br><span class="line"><span class="symbol">value:</span> <span class="number">0x00000000000000000000000000000000000000000000000000000000000000bb</span></span><br><span class="line"><span class="symbol">key:</span> <span class="number">0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e565</span></span><br><span class="line"><span class="symbol">value:</span> <span class="number">0x00000000000000000000000000000000000000000000000000000000000000cc</span></span><br></pre></td></tr></table></figure></p><p>一个块的位置是 <code>0x0</code>，它用于存储数组的长度（<code>0x3</code>）。散列变量的位置以查找数组数据项的地址：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> position = 0</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; keccak256(bytes32(0))</span></span><br><span class="line">'290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563'</span><br></pre></td></tr></table></figure></p><p>数组中的每个数据项都从该地址（<code>0x29..63</code>，<code>0x29..64</code>，<code>0x29..65</code>）开始顺序布局。</p><h1 id="动态数组打包"><a href="#动态数组打包" class="headerlink" title="动态数组打包"></a>动态数组打包</h1><p>你怎么看这些所有重要的打包行为？基于映射的数组的一个优点是打包。 四个数据项的 <code>uint128 []</code> 数组恰好填满两个存储单元（加 1 用于存储长度）。</p><p>考虑：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint128[] s;</span><br><span class="line">    function C() &#123;</span><br><span class="line">        s.length = <span class="number">4</span>;</span><br><span class="line">        s[<span class="number">0</span>] = <span class="number">0xAA</span>;</span><br><span class="line">        s[<span class="number">1</span>] = <span class="number">0xBB</span>;</span><br><span class="line">        s[<span class="number">2</span>] = <span class="number">0xCC</span>;</span><br><span class="line">        s[<span class="number">3</span>] = <span class="number">0xDD</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 Remix 上运行, 最终存储的状态是：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">key:</span> <span class="number">0x0000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="symbol">value:</span> <span class="number">0x0000000000000000000000000000000000000000000000000000000000000004</span></span><br><span class="line"><span class="symbol">key:</span> <span class="number">0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563</span></span><br><span class="line"><span class="symbol">value:</span> <span class="number">0x000000000000000000000000000000bb000000000000000000000000000000aa</span></span><br><span class="line"><span class="symbol">key:</span> <span class="number">0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e564</span></span><br><span class="line"><span class="symbol">value:</span> <span class="number">0x000000000000000000000000000000dd000000000000000000000000000000cc</span></span><br></pre></td></tr></table></figure></p><p>和我们想的一样，只用了 3 个存储单元。长度存储在 <code>0x0</code> 处，即存储变量的位置。四个数据项打包在两个独立的存储单元中。该数组的起始地址是变量位置的哈希值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> position = 0</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; keccak256(bytes32(0))</span></span><br><span class="line">'290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563'</span><br></pre></td></tr></table></figure><p>现在每增加两个数组元素，地址才会增加一次。看起来ok！</p><p>但汇编代码本身并没有得到很好的优化。由于只使用两个存储单元，因此我们希望优化器也只使用两个 <code>sstore</code> 进行分配。然而，在引入边界检查（以及其他）情况下，不可能优化 <code>sstore</code> 指令。</p><p>四个 <code>sstore</code> 指令用于分配：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* <span class="string">"c-bytes--sstore-optimize-fail.sol"</span>:<span class="number">105</span>:<span class="number">116</span>  s<span class="string">[0]</span> = 0xAA */</span><br><span class="line">sstore</span><br><span class="line">/* <span class="string">"c-bytes--sstore-optimize-fail.sol"</span>:<span class="number">126</span>:<span class="number">137</span>  s<span class="string">[1]</span> = 0xBB */</span><br><span class="line">sstore</span><br><span class="line">/* <span class="string">"c-bytes--sstore-optimize-fail.sol"</span>:<span class="number">147</span>:<span class="number">158</span>  s<span class="string">[2]</span> = 0xCC */</span><br><span class="line">sstore</span><br><span class="line">/* <span class="string">"c-bytes--sstore-optimize-fail.sol"</span>:<span class="number">168</span>:<span class="number">179</span>  s<span class="string">[3]</span> = 0xDD */</span><br><span class="line">sstore</span><br></pre></td></tr></table></figure><h1 id="字节数组-amp-字符串"><a href="#字节数组-amp-字符串" class="headerlink" title="字节数组 &amp; 字符串"></a>字节数组 &amp; 字符串</h1><p><code>bytes</code> 和 <code>string</code> 是分别针对字节和字符进行优化的特殊数组类型。如果数组的长度小于 31 个字节，则只用一个存储单元来存储整个数组。较长的字节数组与正常数组的表示方式大致相同。</p><p>我们来看一个实际使用的短字节数组：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// c-<span class="keyword">bytes--long.sol</span></span><br><span class="line"><span class="keyword">pragma </span>solidity ^<span class="number">0</span>.<span class="number">4</span>.<span class="number">11</span><span class="comment">;</span></span><br><span class="line"><span class="symbol">contract</span> C &#123;</span><br><span class="line">    <span class="keyword">bytes </span>s<span class="comment">;</span></span><br><span class="line">    <span class="meta">function</span> C() &#123;</span><br><span class="line">        s.<span class="keyword">push(0xAA);</span></span><br><span class="line"><span class="keyword"> </span>       s.<span class="keyword">push(0xBB);</span></span><br><span class="line"><span class="keyword"> </span>       s.<span class="keyword">push(0xCC);</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于数组只有 3 个字节（小于 31 个字节），因此它只占用一个存储单元。在 Remix 中运行，存储状态为：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">key:</span> <span class="number">0x0000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="symbol">value:</span> <span class="number">0xaabbcc0000000000000000000000000000000000000000000000000000000006</span></span><br></pre></td></tr></table></figure></p><p>数据 <code>0xaabbcc...</code> 从左到右存储。后面的 0 是空数据。最后一个字节 <code>0x06</code> 是数组的编码长度。 公式为 <code>encodedLength / 2 = length</code>。这种情况下，实际长度是 <code>6/2 = 3</code>。</p><p>字符串的工作方式和这个完全相同。</p><h1 id="长字节数组"><a href="#长字节数组" class="headerlink" title="长字节数组"></a>长字节数组</h1><p>如果数据量大于 31 字节，则字节数组就像 <code>[]byte</code>。让我们看看长度为 128 字节的字节数组：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c-bytes--long.sol</span></span><br><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    bytes s;</span><br><span class="line">    function C() &#123;</span><br><span class="line">        s.length = <span class="number">32</span> * <span class="number">4</span>;</span><br><span class="line">        s[<span class="number">31</span>] = <span class="number">0x1</span>;</span><br><span class="line">        s[<span class="number">63</span>] = <span class="number">0x2</span>;</span><br><span class="line">        s[<span class="number">95</span>] = <span class="number">0x3</span>;</span><br><span class="line">        s[<span class="number">127</span>] = <span class="number">0x4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 Remix 运行，可以看到存储里使用了 4 个存储单元：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0000</span>..<span class="number">.0000</span></span><br><span class="line"><span class="number">0x0000</span>..<span class="number">.0101</span></span><br><span class="line"><span class="number">0x290d</span>...e563</span><br><span class="line"><span class="number">0x0000</span>..<span class="number">.0001</span></span><br><span class="line"><span class="number">0x290d</span>...e564</span><br><span class="line"><span class="number">0x0000</span>..<span class="number">.0002</span></span><br><span class="line"><span class="number">0x290d</span>...e565</span><br><span class="line"><span class="number">0x0000</span>..<span class="number">.0003</span></span><br><span class="line"><span class="number">0x290d</span>...e566</span><br><span class="line"><span class="number">0x0000</span>..<span class="number">.0004</span></span><br></pre></td></tr></table></figure></p><p>存储单元 <code>0x0</code> 不再用于存储数据。整个存储单元现在存储编码后的数组长度。为了得到实际的长度，做 <code>length =（encodedLength - 1）/ 2</code>。在这种情况下，长度为 <code>128 =（0x101 - 1）/ 2</code>。实际字节存储在 <code>0x290d...e563</code> 中，以及按顺序排列的存储单元中。</p><p>字节数组的汇编代码非常大。除了正常的边界检查和调整数组大小的东西，它还要编码/解码长度，以及在长和短字节数组之间进行转换。</p><blockquote><p>为什么要对长度进行编码？因为这种方式有一个简单的方法来检测一个字节数组是短还是长。注意，长数组的编码长度总是奇数，短数组的编码长度总是偶数。汇编只需要查看最后一位，看它是零（偶/短）还是非零（奇/长）。</p></blockquote><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>查看 Solidity 编译器的内部工作，我们发现熟悉的数据结构（如映射和数组）与传统的编程语言的完全不同。</p><p>回顾一下：</p><ul><li>数组就像映射，效率不高。</li><li>比映射更复杂的汇编代码。</li><li>比较小类型（字节，uint8，字符串）映射更好的存储效率。</li></ul><p>汇编代码没有很好地优化。即使打包过了，还是每个分配要一个 <code>sstore</code> 。<br>EVM 存储是一个键值对数据库，非常像 git。如果你改变了任何东西，那么根节点的校验和就会改变。如果两个根节点具有相同的校验和，则存储的数据相同。</p><p>要了解 Solidity 和 EVM 的独特之处，可以想象数组中的每个元素都是一个文件在 git 存储库中。当你改变一个数组元素的值时，你实际上正在创建一个 git commit。在遍历数组时，无法一次加载整个数组，您必须查看存储库并分别查找每个文件。</p><p>不仅如此，每个文件被限制为 32 个字节！因为我们需要将数据结构分割成32个字节的块，所以 Solidity 的编译器由于各种逻辑和优化技巧而复杂化，所有这些都是在汇编中完成的。</p><p>然而，32 字节的限制完全是任意的。备份键值存储可以使用键存储任意数量的字节。也许在将来我们可以添加一个新的 EVM 指令来存储任意字节和一个关键字。</p><p>目前，EVM 存储是一个预先假定为32字节数组的键值对数据库。</p><p>请参阅 <a href="https://github.com/ethereum/solidity/blob/3b07c4d38e40c52ee8a4d16e56e2afa1a0f27905/libsolidity/codegen/ArrayUtils.cpp#L624" target="_blank" rel="noopener">ArrayUtils::resizeDynamicArray</a>，了解编译器在调整数组大小时的作用。通常情况下，数据结构将作为标准库的一部分在语言中完成，但在 Solidity 中，它会被烧录入编译器。</p><p>如果你喜欢这篇文章，你应该在 Twitter <a href="https://twitter.com/hayeah" target="_blank" rel="noopener">@hayeah</a> 上关注我。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;https://medium.com/@hayeah/diving-into-the-ethereum-vm-the-hidden-costs-of-arrays-28e119f04a9b&quot; target=&quot;_blank&quot; rel=&quot;noopener
      
    
    </summary>
    
      <category term="区块链" scheme="http://xichen.pub/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://xichen.pub/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Qtum" scheme="http://xichen.pub/tags/Qtum/"/>
    
      <category term="翻译" scheme="http://xichen.pub/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】 深入理解以太坊虚拟机 - 如何表示固定长度的数据类型</title>
    <link href="http://xichen.pub/2018/06/18/2018-06-18-%E7%BF%BB%E8%AF%91-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%A6%82%E4%BD%95%E8%A1%A8%E7%A4%BA%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://xichen.pub/2018/06/18/2018-06-18-翻译-深入理解以太坊虚拟机-如何表示固定长度的数据类型/</id>
    <published>2018-06-18T06:11:00.000Z</published>
    <updated>2018-09-01T09:19:47.898Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-2-storage-layout-bc5349cb11b7" target="_blank" rel="noopener">https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-2-storage-layout-bc5349cb11b7</a><br>译者：中山大学数学学院（珠海）林学渊<br>大二时给量子做的翻译，转载注明出处，谢谢</p><h1 id="如何表示固定长度的数据类型"><a href="#如何表示固定长度的数据类型" class="headerlink" title="如何表示固定长度的数据类型"></a>如何表示固定长度的数据类型</h1><p>我是怎样学会了担忧以及计算存储成本</p><hr><p>在本系列文章的第一篇中，我们看了一个简单 Solidity 合约的汇编代码：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">contract</span> C &#123;</span><br><span class="line">    <span class="attribute">uint256</span> a;</span><br><span class="line">    <span class="attribute">function</span> C() &#123;</span><br><span class="line">      <span class="attribute">a</span> = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该合约实际上是调用了 <code>sstore</code> 指令：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="function"><span class="title">sstore</span><span class="params">(<span class="number">0</span>x0, <span class="number">0</span>x1)</span></span></span><br></pre></td></tr></table></figure></p><ul><li>EVM 把值 0x1 保存在存储位置 0x0.</li><li>每个存储位置实际上能存 32 字节 (或者 256 比特).<blockquote><p>如果对这个不熟，我建议看: <a href="https://blog.qtum.org/diving-into-the-ethereum-vm-6e8d5d2f3c30" target="_blank" rel="noopener">Diving Into The Ethereum VM Part 1 — Assembly &amp; Bytecode</a></p></blockquote></li></ul><p>在本篇文章中，我们关注 Solidity 如何使用32字节的块来表示更多复杂的数据类型，比如结构体和数组。我们也能看到如何优化存储，及怎样可能优化失败。<br>在典型的程序语言中，理解数据类型在底层如何表示不是特别有用。但在 Solidity (或任何 EVM 语言) 这种知识至关重要，因为存储访问太贵了。</p><ul><li><code>sstore</code> 花费 20000 gas, 或者比基础算术指令贵约 5000倍.</li><li><code>sload</code> 花费 200 gas, 或者比基础算术指令贵约 100倍.</li></ul><p>对于“花费”，我们这里谈的是真钱，不仅仅是性能上的多少毫秒。运行和使用合约的花费中，<code>sstore</code> 和 <code>sload</code> 占主导地位！</p><h1 id="磁带解析"><a href="#磁带解析" class="headerlink" title="磁带解析"></a>磁带解析</h1><p><img src="https://cdn-images-1.medium.com/max/1600/1*BfkvMOBrd2aJQ46p9DeDtg.jpeg" alt="图灵机. Source: http://raganwald.com/"></p><p>构建通用计算机的两个基本要素：</p><ol><li>一种循环方式，无论是跳转还是递归。</li><li>无限内存</li></ol><p>EVM 汇编代码提供跳转，EVM 存储提供无限内存。这些对一切都够用了，包括模拟一个运行以太坊的世界，其以太坊又模拟了一个运行以太坊的世界…</p><p><img src="https://cdn-images-1.medium.com/max/1600/0*WmSMw86hQrhFLhCo.gif" alt="Diving Into The Microverse Battery"></p><p>EVM 存储一个合约像是一条没有尽头的磁带，磁带的每个单元有32字节，像这样：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">32 字节</span>][<span class="symbol">32 字节</span>][<span class="string">32 字节</span>]...</span><br></pre></td></tr></table></figure></p><p>我们会看到数据如何在无尽的磁带上变得生动起来的。</p><blockquote><p>磁带长度为 2²⁵⁶, 或者每个合约有大约10⁷⁷个单元。宇宙的可观测的粒子数是10⁸⁰。大约1000个合约就足以容纳所有质子，中子和电子。不要相信营销炒作，因为它比无限更短。</p></blockquote><h1 id="空白磁带"><a href="#空白磁带" class="headerlink" title="空白磁带"></a>空白磁带</h1><p>存储最初是空白的，默认为 0 。拥有无限磁带并不需要花费任何东西。</p><p>我们来看一个简单的合约来说明零价值行为：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">pragma</span> solidity<span class="regexp"> ^0.4.11</span>;</span><br><span class="line"><span class="attribute">contract</span> C &#123;</span><br><span class="line">    <span class="attribute">uint256</span> a;</span><br><span class="line">    <span class="attribute">uint256</span> b;</span><br><span class="line">    <span class="attribute">uint256</span> c;</span><br><span class="line">    <span class="attribute">uint256</span> d;</span><br><span class="line">    <span class="attribute">uint256</span> e;</span><br><span class="line">    <span class="attribute">uint256</span> f;</span><br><span class="line">    <span class="attribute">function</span> C() &#123;</span><br><span class="line">      <span class="attribute">f</span> = 0xc0fefe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>存储中的布局很简单。</p><ul><li>变量 <code>a</code> 位于位置 <code>0x0</code></li><li>变量 <code>b</code> 位于位置 <code>0x1</code></li><li>如此下去…<br>关键问题: 如果我们只用 <code>f</code>, 我们给 <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>, <code>e</code>花多少?<br>编译看一下：<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">$</span> <span class="comment">solc</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">bin</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">asm</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">optimize</span> <span class="comment">c</span><span class="literal">-</span><span class="comment">many</span><span class="literal">-</span><span class="comment">variables</span><span class="string">.</span><span class="comment">sol</span></span><br></pre></td></tr></table></figure></li></ul><p>汇编:<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sstore(0x5, 0xc0fefe)</span></span><br><span class="line"><span class="symbol">tag_2:</span></span><br><span class="line">  <span class="number">0xc0fefe</span></span><br><span class="line">  <span class="number">0x5</span></span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure></p><p>因此，存储变量的声明不需要任何费用，因为没有初始化。 Solidity 为该变量保留一个位置，并且只有当你存储某些内容时才支付 gas 。</p><p>在这种情况下，我们只为存储到 <code>0x5</code> 花钱。</p><p>如果我们手工编写汇编，我们可以任意选择存储位置而不必“扩展”存储：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入任意位置</span></span><br><span class="line"><span class="function"><span class="title">sstore</span><span class="params">(<span class="number">0</span>xc0fefe, <span class="number">0</span>x42)</span></span></span><br></pre></td></tr></table></figure><h1 id="读取-0"><a href="#读取-0" class="headerlink" title="读取 0"></a>读取 0</h1><p>你不仅可以在存储的任何位置写入，还可以立即从任何位置读取。读取未初始化的位置仅返回 <code>0x0</code> 。</p><p>让我们看一个读取未初始化位置的合约：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">pragma</span> solidity<span class="regexp"> ^0.4.11</span>;</span><br><span class="line"><span class="attribute">contract</span> C &#123;</span><br><span class="line">    <span class="attribute">uint256</span> a;</span><br><span class="line">    <span class="attribute">function</span> C() &#123;</span><br><span class="line">      <span class="attribute">a</span> = a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译:<br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">$</span> <span class="comment">solc</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">bin</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">asm</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">optimize</span> <span class="comment">c</span><span class="literal">-</span><span class="comment">zero</span><span class="literal">-</span><span class="comment">value</span><span class="string">.</span><span class="comment">sol</span></span><br></pre></td></tr></table></figure></p><p>汇编代码:<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">  <span class="comment">// sload(0x0) returning 0x0</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">  dup1</span><br><span class="line">  sload</span><br><span class="line">  <span class="comment">// a + 1; where a == 0</span></span><br><span class="line">  <span class="number">0x1</span></span><br><span class="line">  <span class="keyword">add</span></span><br><span class="line">  <span class="comment">// sstore(0x0, a + 1)</span></span><br><span class="line">  swap1</span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure></p><p>注意：生成从未初始化位置加载数据的代码是有效的。</p><p>然而，我们可以比 Solidity 编译器更聪明。由于我们知道<code>tag_2</code>是构造函数，并且从未写入过，所以我们可以用<code>0x0</code>替换<code>sload</code>序列。这可以省 5,000 gas。</p><h1 id="结构体的表示"><a href="#结构体的表示" class="headerlink" title="结构体的表示"></a>结构体的表示</h1><p>我们来看第一个复杂数据类型，一个有 6 个字段的结构体：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0</span>.<span class="number">4</span>.<span class="number">11</span><span class="comment">;</span></span><br><span class="line">contract C &#123;</span><br><span class="line">    struct Tuple &#123;</span><br><span class="line">      uint256 a<span class="comment">;</span></span><br><span class="line">      uint256 <span class="keyword">b;</span></span><br><span class="line"><span class="keyword"> </span>     uint256 c<span class="comment">;</span></span><br><span class="line">      uint256 d<span class="comment">;</span></span><br><span class="line">      uint256 e<span class="comment">;</span></span><br><span class="line">      uint256 f<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    Tuple t<span class="comment">;</span></span><br><span class="line">    function C() &#123;</span><br><span class="line">      t.f = <span class="number">0xC0FEFE</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>存储中的布局和状态变量一样。</p><ul><li>变量 <code>t.a</code> 位于位置 <code>0x0</code></li><li>变量 <code>t.b</code> 位于位置 <code>0x1</code></li><li>如此下去…</li></ul><p>和之前类似，我们可以直接向 <code>t.f</code> 写入而不用给初始化花钱。</p><p>编译：<br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">$</span> <span class="comment">solc</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">bin</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">asm</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">optimize</span> <span class="comment">c</span><span class="literal">-</span><span class="comment">struct</span><span class="literal">-</span><span class="comment">fields</span><span class="string">.</span><span class="comment">sol</span></span><br></pre></td></tr></table></figure></p><p>我们看到了一样的汇编代码：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">tag_2:</span></span><br><span class="line">  <span class="number">0xc0fefe</span></span><br><span class="line">  <span class="number">0x5</span></span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure></p><h1 id="定长数组"><a href="#定长数组" class="headerlink" title="定长数组"></a>定长数组</h1><p>声明一个定长数组：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint256[<span class="number">6</span>] numbers;</span><br><span class="line">    function C() &#123;</span><br><span class="line">      numbers[<span class="number">5</span>] = <span class="number">0xC0FEFE</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于编译器确切地知道有多少个 <code>uint256</code> （ 32 个字节），因此它可以简单地将数组元素放在存储器中，就像存储变量和结构体一样。</p><p>在这份合约中，我们再次存储到位置 <code>0x5</code> 。</p><p>编译：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ solc --bin --<span class="keyword">asm</span> --optimize c-<span class="keyword">static</span>-<span class="built_in">array</span>.sol</span><br></pre></td></tr></table></figure></p><p>汇编代码：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">tag_2:</span></span><br><span class="line">  <span class="number">0xc0fefe</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">  <span class="number">0x5</span></span><br><span class="line"><span class="symbol">tag_4:</span></span><br><span class="line">  <span class="keyword">add</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line"><span class="symbol">tag_5:</span></span><br><span class="line">  <span class="keyword">pop</span></span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure></p><p>它稍微长一些，但如果你稍微眯起一点，你会发现它实际上是一样的。我们手动进一步优化：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">tag_2:</span></span><br><span class="line">  <span class="number">0xc0fefe</span></span><br><span class="line">  // <span class="number">0</span>+<span class="number">5.</span> 用 <span class="number">0x5</span> 代替</span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">  <span class="number">0x5</span></span><br><span class="line">  <span class="keyword">add</span></span><br><span class="line">  // <span class="keyword">Push</span> then <span class="keyword">pop</span> immediately. Useless, just remove.</span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">  <span class="keyword">pop</span></span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure></p><p>除去标签和伪指令，我们再次得到相同的字节码序列：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">tag_2:</span></span><br><span class="line">  <span class="number">0xc0fefe</span></span><br><span class="line">  <span class="number">0x5</span></span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure></p><h1 id="数组边界检测"><a href="#数组边界检测" class="headerlink" title="数组边界检测"></a>数组边界检测</h1><p>我们已经看到，定长数组与结构体或状态变量两者具有相同的存储布局，但生成的汇编代码是不同的。原因是 Solidity 为数组访问生成了边界检查。</p><p>让我们再次编译数组合约，这次先关闭优化：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ solc --bin --<span class="keyword">asm</span> c-<span class="keyword">static</span>-<span class="built_in">array</span>.sol</span><br></pre></td></tr></table></figure></p><p>注释一下，在每条指令后打印机器状态：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">  <span class="number">0xc0fef</span>e</span><br><span class="line">    [<span class="number">0xc0fef</span>e]</span><br><span class="line">  <span class="number">0x5</span></span><br><span class="line">    [<span class="number">0x5</span> <span class="number">0xc0fef</span>e]</span><br><span class="line">  dup1</span><br><span class="line">  <span class="comment">/* 数组边界检测代码 */</span></span><br><span class="line">  <span class="comment">// 5 &lt; 6</span></span><br><span class="line">  <span class="number">0x6</span></span><br><span class="line">    [<span class="number">0x6</span> <span class="number">0x5</span> <span class="number">0xc0fef</span>e]</span><br><span class="line">  dup2</span><br><span class="line">    [<span class="number">0x5</span> <span class="number">0x6</span> <span class="number">0x5</span> <span class="number">0xc0fef</span>e]</span><br><span class="line">  lt</span><br><span class="line">    [<span class="number">0x1</span> <span class="number">0x5</span> <span class="number">0xc0fef</span>e]</span><br><span class="line">  <span class="comment">// bound_check_ok = 1 (TRUE)</span></span><br><span class="line">  <span class="comment">// if(bound_check_ok) &#123; goto tag5 &#125; else &#123; invalid &#125;</span></span><br><span class="line">  tag_5</span><br><span class="line">    [tag_5 <span class="number">0x1</span> <span class="number">0x5</span> <span class="number">0xc0fef</span>e]</span><br><span class="line">  jumpi</span><br><span class="line">    <span class="comment">// 测试情形是对的. 将跳转到 tag_5.</span></span><br><span class="line">    <span class="comment">// 并且 `jumpi` 消费了栈中 2 个元素.</span></span><br><span class="line">    [<span class="number">0x5</span> <span class="number">0xc0fef</span>e]</span><br><span class="line">  invalid</span><br><span class="line"><span class="comment">// 数组访问合法，继续</span></span><br><span class="line"><span class="comment">// stack: [0x5 0xc0fefe]</span></span><br><span class="line">tag_5:</span><br><span class="line">  sstore</span><br><span class="line">    []</span><br><span class="line">    storage: &#123; <span class="number">0x5</span> =&gt; <span class="number">0xc0fef</span>e &#125;</span><br></pre></td></tr></table></figure><p>现在可以看到边界检测代码了。编译器能够优化这些东西，但并不完美。</p><p>在本文的后面，我们将看到数组边界检测如何干扰编译器的优化，使得定长数组比存储变量或结构的效率低得多。</p><h1 id="打包行为"><a href="#打包行为" class="headerlink" title="打包行为"></a>打包行为</h1><p>存储很贵（啊啊啊我已经说一百万次了）。一个关键的优化是尽可能多地将数据打包到一个 32 字节的单元中。</p><p>考虑有四个存储变量（每个 64 比特）的合约，总共可以累加到 256 比特（ 32 字节）：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">pragma</span> solidity<span class="regexp"> ^0.4.11</span>;</span><br><span class="line"><span class="attribute">contract</span> C &#123;</span><br><span class="line">    <span class="attribute">uint64</span> a;</span><br><span class="line">    <span class="attribute">uint64</span> b;</span><br><span class="line">    <span class="attribute">uint64</span> c;</span><br><span class="line">    <span class="attribute">uint64</span> d;</span><br><span class="line">    <span class="attribute">function</span> C() &#123;</span><br><span class="line">      <span class="attribute">a</span> = 0xaaaa;</span><br><span class="line">      <span class="attribute">b</span> = 0xbbbb;</span><br><span class="line">      <span class="attribute">c</span> = 0xcccc;</span><br><span class="line">      <span class="attribute">d</span> = 0xdddd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们希望编译器只用一个 <code>sstore</code> ，所以将它们放在同一个存储单元中。</p><p>编译：<br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">$</span> <span class="comment">solc</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">bin</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">asm</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">optimize</span> <span class="comment">c</span><span class="literal">-</span><span class="comment">many</span><span class="literal">-</span><span class="comment">variables</span><span class="literal">-</span><span class="literal">-</span><span class="comment">packing</span><span class="string">.</span><span class="comment">sol</span></span><br></pre></td></tr></table></figure></p><p>汇编代码：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">tag_2:</span></span><br><span class="line">    /* <span class="string">"c-many-variables--packing.sol"</span>:<span class="number">121</span>:<span class="number">122</span>  a */</span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">    /* <span class="string">"c-many-variables--packing.sol"</span>:<span class="number">121</span>:<span class="number">131</span>  a = <span class="number">0xaaaa</span> */</span><br><span class="line">  dup1</span><br><span class="line">  sload</span><br><span class="line">    /* <span class="string">"c-many-variables--packing.sol"</span>:<span class="number">125</span>:<span class="number">131</span>  <span class="number">0xaaaa</span> */</span><br><span class="line">  <span class="number">0xaaaa</span></span><br><span class="line">  <span class="keyword">not</span>(<span class="number">0xffffffffffffffff</span>)</span><br><span class="line">    /* <span class="string">"c-many-variables--packing.sol"</span>:<span class="number">121</span>:<span class="number">131</span>  a = <span class="number">0xaaaa</span> */</span><br><span class="line">  swap1</span><br><span class="line">  swap2</span><br><span class="line">  <span class="keyword">and</span></span><br><span class="line">  <span class="keyword">or</span></span><br><span class="line">  <span class="keyword">not</span>(<span class="keyword">sub</span>(exp(<span class="number">0x2</span>, <span class="number">0x80</span>), exp(<span class="number">0x2</span>, <span class="number">0x40</span>)))</span><br><span class="line">    /* <span class="string">"c-many-variables--packing.sol"</span>:<span class="number">139</span>:<span class="number">149</span>  b = <span class="number">0xbbbb</span> */</span><br><span class="line">  <span class="keyword">and</span></span><br><span class="line">  <span class="number">0xbbbb0000000000000000</span></span><br><span class="line">  <span class="keyword">or</span></span><br><span class="line">  <span class="keyword">not</span>(<span class="keyword">sub</span>(exp(<span class="number">0x2</span>, <span class="number">0xc0</span>), exp(<span class="number">0x2</span>, <span class="number">0x80</span>)))</span><br><span class="line">    /* <span class="string">"c-many-variables--packing.sol"</span>:<span class="number">157</span>:<span class="number">167</span>  c = <span class="number">0xcccc</span> */</span><br><span class="line">  <span class="keyword">and</span></span><br><span class="line">  <span class="number">0xcccc00000000000000000000000000000000</span></span><br><span class="line">  <span class="keyword">or</span></span><br><span class="line">  <span class="keyword">sub</span>(exp(<span class="number">0x2</span>, <span class="number">0xc0</span>), <span class="number">0x1</span>)</span><br><span class="line">    /* <span class="string">"c-many-variables--packing.sol"</span>:<span class="number">175</span>:<span class="number">185</span>  d = <span class="number">0xdddd</span> */</span><br><span class="line">  <span class="keyword">and</span></span><br><span class="line">  <span class="number">0xdddd000000000000000000000000000000000000000000000000</span></span><br><span class="line">  <span class="keyword">or</span></span><br><span class="line">  swap1</span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure></p><p>有很多我无法破译的位交换，但不用在意这些细节。关键要注意的是，只用了一个 <code>sstore</code>。</p><p>优化成功！</p><h1 id="打破优化"><a href="#打破优化" class="headerlink" title="打破优化"></a>打破优化</h1><p>要是优化器可以一直完美工作就好了。让我们打破它。我们唯一的改变是我们使用帮助函数来设置存储变量：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0</span>.<span class="number">4</span>.<span class="number">11</span><span class="comment">;</span></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint64 a<span class="comment">;</span></span><br><span class="line">    uint64 <span class="keyword">b;</span></span><br><span class="line"><span class="keyword"> </span>   uint64 c<span class="comment">;</span></span><br><span class="line">    uint64 d<span class="comment">;</span></span><br><span class="line">    function C() &#123;</span><br><span class="line">      setAB()<span class="comment">;</span></span><br><span class="line">      setCD()<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    function setAB() internal &#123;</span><br><span class="line">      a = <span class="number">0xaaaa</span><span class="comment">;</span></span><br><span class="line">      <span class="keyword">b </span>= <span class="number">0xbbbb</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    function setCD() internal &#123;</span><br><span class="line">      c = <span class="number">0xcccc</span><span class="comment">;</span></span><br><span class="line">      d = <span class="number">0xdddd</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译<br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">$</span> <span class="comment">solc</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">bin</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">asm</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">optimize</span> <span class="comment">c</span><span class="literal">-</span><span class="comment">many</span><span class="literal">-</span><span class="comment">variables</span><span class="literal">-</span><span class="literal">-</span><span class="comment">packing</span><span class="literal">-</span><span class="comment">helpers</span><span class="string">.</span><span class="comment">sol</span></span><br></pre></td></tr></table></figure></p><p>汇编输出太多了。我们将忽略大部分细节并关注结构：<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span> 构造函数</span><br><span class="line">tag_2:</span><br><span class="line">  <span class="string">//</span> <span class="string">...</span></span><br><span class="line">  <span class="string">//</span> 跳转到 tag_5，调用 <span class="keyword">set</span>AB<span class="params">()</span> </span><br><span class="line">  jump</span><br><span class="line">tag_4:</span><br><span class="line">  <span class="string">//</span> <span class="string">...</span></span><br><span class="line">  <span class="string">//</span> 跳转到 tag_7，调用 <span class="keyword">set</span>CD<span class="params">()</span></span><br><span class="line">  jump</span><br><span class="line"><span class="string">//</span> 函数 <span class="keyword">set</span>AB<span class="params">()</span></span><br><span class="line">tag_5:</span><br><span class="line">  <span class="string">//</span> 位交换，设置 a, b</span><br><span class="line">  <span class="string">//</span> <span class="string">...</span></span><br><span class="line">  sstore</span><br><span class="line">tag_9:</span><br><span class="line">  jump  <span class="string">//</span> 返回 <span class="keyword">set</span>AB<span class="params">()</span> 的调用者</span><br><span class="line"><span class="string">//</span> 函数 <span class="keyword">set</span>CD<span class="params">()</span></span><br><span class="line">tag_7:</span><br><span class="line">  <span class="string">//</span> 位交换，设置 c, d</span><br><span class="line">  <span class="string">//</span> <span class="string">...</span></span><br><span class="line">  sstore</span><br><span class="line">tag_10:</span><br><span class="line">  jump  <span class="string">//</span> 返回 <span class="keyword">set</span>CD<span class="params">()</span> 的调用者</span><br></pre></td></tr></table></figure></p><p>现在有两个 <code>sstore</code> ，而不是一个。 Solidity 编译器可以在标签内进行优化，但不能跨标签进行优化。</p><blockquote><p>调用函数可能会花费更多，而不是太多，不仅因为函数调用很贵（它们只是跳转指令），而且因为 <code>sstore</code> 优化可能会失败。</p></blockquote><p>为了解决这个问题， Solidity 编译器需要学习如何内联函数，使得本质上得到的代码与不调用函数的相同：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">a</span> = <span class="number">0</span>xaaaa<span class="comment">;</span></span><br><span class="line"><span class="attribute">b</span> = <span class="number">0</span>xbbbb<span class="comment">;</span></span><br><span class="line"><span class="attribute">c</span> = <span class="number">0</span>xcccc<span class="comment">;</span></span><br><span class="line"><span class="attribute">d</span> = <span class="number">0</span>xdddd<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>如果我们仔细阅读完整的汇编输出，我们会看到函数 setAB（）和 setCD（）的汇编代码被包含了两次，使代码臃肿，还花费额外 gas 部署合约。我们稍后在了解合约生命周期时再讨论这一点。</p><h1 id="为什么优化器坏了"><a href="#为什么优化器坏了" class="headerlink" title="为什么优化器坏了"></a>为什么优化器坏了</h1><p>优化器不会跨标签进行优化。考虑 “1 + 1” ，如果在同一标签下，它可以优化为 <code>0x2</code> ：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 优化成功!</span><br><span class="line"><span class="symbol">tag_0:</span></span><br><span class="line">  <span class="number">0x1</span></span><br><span class="line">  <span class="number">0x1</span></span><br><span class="line">  <span class="keyword">add</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></p><p>但会优化失败，如果指令被标签分开了的话：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 优化失败!</span><br><span class="line"><span class="symbol">tag_0:</span></span><br><span class="line">  <span class="number">0x1</span></span><br><span class="line">  <span class="number">0x1</span></span><br><span class="line"><span class="symbol">tag_1:</span></span><br><span class="line">  <span class="keyword">add</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></p><p>这个行为在 0.4.13 版时是真的。以后可能会变。</p><h1 id="再次打破优化"><a href="#再次打破优化" class="headerlink" title="再次打破优化"></a>再次打破优化</h1><p>让我们看看优化失败的另一种方式。打包是否适用于定长数组？考虑：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint64[<span class="number">4</span>] numbers;</span><br><span class="line">    function C() &#123;</span><br><span class="line">      numbers[<span class="number">0</span>] = <span class="number">0x0</span>;</span><br><span class="line">      numbers[<span class="number">1</span>] = <span class="number">0x1111</span>;</span><br><span class="line">      numbers[<span class="number">2</span>] = <span class="number">0x2222</span>;</span><br><span class="line">      numbers[<span class="number">3</span>] = <span class="number">0x3333</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同样，我们希望只用一个 <code>sstore</code> 指令将 4 个 64 比特的数字打包到一个 32 字节的存储单元中。</p><p>编译后的汇编代码太长了。作为替代，计算 <code>sstore</code> 和 <code>sload</code> 指令的数量：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ solc --bin --<span class="keyword">asm</span> --optimize c-<span class="keyword">static</span>-<span class="keyword">array</span>--packing.sol | grep -E <span class="string">'(sstore|sload)'</span></span><br><span class="line">  sload</span><br><span class="line">  sstore</span><br><span class="line">  sload</span><br><span class="line">  sstore</span><br><span class="line">  sload</span><br><span class="line">  sstore</span><br><span class="line">  sload</span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure></p><p>嗷！不！！即使这个定长数组的存储布局与等效的结构体或存储变量完全相同，优化也会失败。它现在需要四对 <code>sload</code> 和 <code>sstore</code> 。</p><p>快速浏览汇编代码可以发现，每个数组访问都有边界检测代码，并在不同的标签下进行组织。但标签边界打破了优化。</p><p>然而有一点小小的安慰的是，3 个额外的 <code>sstore</code> 指令比第一个便宜：</p><ul><li><code>sstore</code> 花费 20,000 gas用于第一次写入新位置。</li><li><code>sstore</code> 花费 5,000 gas用于后续写入现有位置。</li></ul><p>所以这个特定优化的失败花费我们 35k 而不是 20k ，多了 75％ 。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>如果 Solidity 编译器能够计算出存储变量的大小，它只须简单地将它们放在一个接一个的存储空间中。如果可能的话，编译器将数据紧密地打包成32字节的块。</p><p>总结我们目前为止看到的打包行为：</p><ul><li>存储变量：有。</li><li>结构字段：有。</li><li>定长数组：无。理论上，有。</li></ul><p>由于存储访问成本非常高，因此应该将存储变量视为数据库架构。在编写合约时，可能会很有用的是做小型实验，并检查汇编代码以确定编译器是否正在优化。</p><p>可以肯定， Solidity 编译器将来会有所改进。不幸的是，现在我们还不能盲目信任它的优化器。</p><p>理解存储变量要花钱，字面意思，花钱。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-2-storage-layout-bc5349cb11b7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;htt
      
    
    </summary>
    
      <category term="区块链" scheme="http://xichen.pub/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://xichen.pub/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Qtum" scheme="http://xichen.pub/tags/Qtum/"/>
    
      <category term="翻译" scheme="http://xichen.pub/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】 深入理解以太坊虚拟机 - EVM汇编代码简介</title>
    <link href="http://xichen.pub/2018/06/12/2018-06-12-%E7%BF%BB%E8%AF%91-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%99%9A%E6%8B%9F%E6%9C%BA-EVM%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E7%AE%80%E4%BB%8B/"/>
    <id>http://xichen.pub/2018/06/12/2018-06-12-翻译-深入理解以太坊虚拟机-EVM汇编代码简介/</id>
    <published>2018-06-12T06:11:00.000Z</published>
    <updated>2018-09-01T09:17:39.617Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://blog.qtum.org/diving-into-the-ethereum-vm-6e8d5d2f3c30" target="_blank" rel="noopener">https://blog.qtum.org/diving-into-the-ethereum-vm-6e8d5d2f3c30</a><br>译者：中山大学数学学院（珠海）林学渊<br>大二时给量子做的翻译，转载注明出处，谢谢</p><h1 id="EVM汇编代码简介"><a href="#EVM汇编代码简介" class="headerlink" title="EVM汇编代码简介"></a>EVM汇编代码简介</h1><hr><p>Solidity 提供了很多高级语言抽象，但这些功能很难让我理解程序运行时到底发生了什么。阅读 Solidity 的文档仍然使我对一些基础的东西感到疑惑。</p><p>string, bytes32, byte[], bytes 有什么区别?</p><ul><li>什么时候应该用哪个？</li><li>把 string 转为 bytes 发生了什么？转为 byte[] 呢？</li><li>这些需要多少 gas ？</li></ul><p>mapping 在以太坊虚拟机里是怎么存的？</p><ul><li>为什么不能把 mapping 删了？</li><li>能构建 maping 到 maping 的数据结构吗？(当然可以，但这是怎么实现的？)</li><li>为什么有存储 mapping ，但是没有内存 mapping ?</li></ul><p>编译后的合约在以太坊虚拟机里长什么样？</p><ul><li>合约如何创建？</li><li>构造方法是什么？真的吗？</li><li>回退函数是什么？</li></ul><p>我想，学习一门在以太坊虚拟机( EVM )上运行的高级语言如 Solidity 会是一个好的自我投资。有以下原因。</p><ol><li>Solidity 不是最后一门语言。更好的 EVM 语言正在到来。(漂亮，对不对？)</li><li>EVM是个数据库引擎。理解用任意一种 EVM 语言写的智能合约前，必须理解数据是如何被组织、存储和操控的。</li><li>了解如何成为一个贡献者。以太坊工具链刚刚起步，深入理解EVM会帮助你给你自己或其他人造出惊艳的工具。</li><li>智力挑战。EVM使得你能在密码学、数据结构和程序语言设计的交汇处获得最佳实践。</li></ol><p>在本系列文章中，我会解构一些简单的 Solidity 智能合约，以便理解它们作为 EVM 字节码时如何工作。</p><p>我希望学习和写作的要点：</p><ul><li>EVM 字节码的基础</li><li>不同数据类型( mapping, array )的表现形式</li><li>合约创建时发生了什么</li><li>一个方法调用时发生了什么</li><li>ABI 桥如何区别了 EVM 语言</li></ul><p>我的终极目标是能够完全理解一个编译后的 Solidity 合约。先从一些基础的 EVM 字节码开始阅读吧！</p><p>一个有用的引用：<a href="https://gist.github.com/hayeah/bd37a123c02fecffbe629bf98a8391df" target="_blank" rel="noopener">EVM 指令集</a></p><h1 id="一个简单的智能合约"><a href="#一个简单的智能合约" class="headerlink" title="一个简单的智能合约"></a>一个简单的智能合约</h1><p>我们的第一个合约有构造函数和一个常量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// c1.sol</span><br><span class="line">pragma solidity ^0.4.11;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint256 a;</span><br><span class="line">    function C() &#123;</span><br><span class="line">      a = 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用 <code>solc</code> 命令编译：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">$ solc --<span class="keyword">bin </span>--asm <span class="built_in">c1</span>.sol</span><br><span class="line">======= <span class="built_in">c1</span>.sol:C =======</span><br><span class="line"><span class="symbol">EVM</span> assembly:</span><br><span class="line">    <span class="comment">/* "c1.sol":26:94  contract C &#123;... */</span></span><br><span class="line">  mstore(<span class="number">0x40</span>, <span class="number">0x60</span>)</span><br><span class="line">    <span class="comment">/* "c1.sol":59:92  function C() &#123;... */</span></span><br><span class="line">  jumpi(tag_1, iszero(callvalue))</span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">  dup1</span><br><span class="line">  <span class="keyword">revert</span></span><br><span class="line"><span class="keyword">tag_1:</span></span><br><span class="line"><span class="keyword">tag_2:</span></span><br><span class="line"><span class="keyword"> </span>   <span class="comment">/* "c1.sol":84:85  1 */</span></span><br><span class="line">  <span class="number">0x1</span></span><br><span class="line">    <span class="comment">/* "c1.sol":80:81  a */</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">    <span class="comment">/* "c1.sol":80:85  a = 1 */</span></span><br><span class="line">  dup2</span><br><span class="line">  swap1</span><br><span class="line">  sstore</span><br><span class="line">  <span class="keyword">pop</span></span><br><span class="line"><span class="keyword"> </span>   <span class="comment">/* "c1.sol":59:92  function C() &#123;... */</span></span><br><span class="line"><span class="symbol">tag_3</span>:</span><br><span class="line">    <span class="comment">/* "c1.sol":26:94  contract C &#123;... */</span></span><br><span class="line"><span class="symbol">tag_4</span>:</span><br><span class="line">  dataSize(<span class="keyword">sub_0)</span></span><br><span class="line"><span class="keyword"> </span> dup1</span><br><span class="line">  dataOffset(<span class="keyword">sub_0)</span></span><br><span class="line"><span class="keyword"> </span> <span class="number">0x0</span></span><br><span class="line">  codecopy</span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">  return</span><br><span class="line"><span class="symbol">stop</span></span><br><span class="line"><span class="keyword">sub_0: </span>assembly &#123;</span><br><span class="line">        <span class="comment">/* "c1.sol":26:94  contract C &#123;... */</span></span><br><span class="line">      mstore(<span class="number">0x40</span>, <span class="number">0x60</span>)</span><br><span class="line"><span class="symbol">    tag_1:</span></span><br><span class="line">      <span class="number">0x0</span></span><br><span class="line">      dup1</span><br><span class="line">      <span class="keyword">revert</span></span><br><span class="line"><span class="keyword">auxdata: </span><span class="number">0xa165627a7a72305820af3193f6fd31031a0e0d2de1ad2c27352b1ce081b4f3c92b5650ca4dd542bb770029</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">Binary:</span></span><br><span class="line"><span class="keyword">60606040523415600e57600080fd5b5b60016000819055505b5b60368060266000396000f30060606040525b600080fd00a165627a7a72305820af3193f6fd31031a0e0d2de1ad2c27352b1ce081b4f3c92b5650ca4dd542bb770029</span></span><br></pre></td></tr></table></figure><p>数字 <code>6060604052...</code> 是 EVM 真正运行的字节码。</p><h1 id="蹒跚学步"><a href="#蹒跚学步" class="headerlink" title="蹒跚学步"></a>蹒跚学步</h1><p>一半的汇编是模板，以至于在大多数 Solidity 程序中都一样。我们等下再来看这些。现在，我们来实验我们合约独特的一部分，存储变量的声明：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">a</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>这个声明的字节码表示是 <code>6001600081905550</code> 。根据指令换行：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">60 </span><span class="number">01</span></span><br><span class="line"><span class="symbol">60 </span><span class="number">00</span></span><br><span class="line"><span class="number">81</span></span><br><span class="line"><span class="number">90</span></span><br><span class="line"><span class="number">55</span></span><br><span class="line"><span class="number">50</span></span><br></pre></td></tr></table></figure></p><p>EVM 底层循环是从上到下运行每一条指令。<br>我们注释一下汇编代码(以 <code>tag_2</code> 开头)以便阅读：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">tag_2:</span></span><br><span class="line">  <span class="comment">// 60 01</span></span><br><span class="line">  <span class="number">0x1</span></span><br><span class="line">  <span class="comment">// 60 00</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">  <span class="comment">// 81</span></span><br><span class="line">  dup2</span><br><span class="line">  <span class="comment">// 90</span></span><br><span class="line">  swap1</span><br><span class="line">  <span class="comment">// 55</span></span><br><span class="line">  sstore</span><br><span class="line">  <span class="comment">// 50</span></span><br><span class="line">  pop</span><br></pre></td></tr></table></figure></p><p>注意汇编中的 <code>0x1</code> 实际上是 <code>push(0x1)</code> 的缩写。这条指令表示吧数字 <code>1</code> 入栈。</p><p>如果只盯着这个看，很难捕获到发生了什么。不要担心，模仿 EVM 一行一行地走，很简单的。</p><h1 id="模仿-EVM"><a href="#模仿-EVM" class="headerlink" title="模仿 EVM"></a>模仿 EVM</h1><p>EVM 是堆栈机器。指令可以使用栈中的值作为参数，也可以把某一些值入栈作为结果。举个例子， <code>add</code> 指令。</p><p>假设栈中有 2 个值：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure></p><p>当 EVM 看到 <code>add</code> 时，它把栈顶的 2 项出栈相加，然后把结果入栈回去，操作后：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">3</span>]</span><br></pre></td></tr></table></figure></p><p>以后我们仍然用 <code>[]</code> 这个符号来表示栈：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空栈</span></span><br><span class="line"><span class="built_in">stack</span>: []</span><br><span class="line"><span class="comment">// 有3个元素的栈. 栈顶元素是 3. 栈底元素是 1.</span></span><br><span class="line"><span class="built_in">stack</span>: [<span class="number">3</span> <span class="number">2</span> <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p><p>用 <code>{}</code> 来表示合约存储:<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空存储</span></span><br><span class="line"><span class="symbol">store:</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 值 0x1 存储在地址 0x0.</span></span><br><span class="line"><span class="symbol">store:</span> &#123; <span class="number">0x0</span> =&gt; <span class="number">0x1</span> &#125;</span><br></pre></td></tr></table></figure></p><p>现在我们来看一些实际的字节码。我们将模仿EVM运行字节序列 <code>6001600081905550</code> ，同时写出每一条指令运行后的机器状态：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 60 01: 将1入栈</span></span><br><span class="line"><span class="number">0x1</span></span><br><span class="line"><span class="symbol">  stack:</span> [<span class="number">0x1</span>]</span><br><span class="line"><span class="comment">// 60 00: 将0入栈</span></span><br><span class="line"><span class="number">0x0</span></span><br><span class="line"><span class="symbol">  stack:</span> [<span class="number">0x0</span> <span class="number">0x1</span>]</span><br><span class="line"><span class="comment">// 81: 复制栈中的第二个元素，入栈</span></span><br><span class="line">dup2</span><br><span class="line"><span class="symbol">  stack:</span> [<span class="number">0x1</span> <span class="number">0x0</span> <span class="number">0x1</span>]</span><br><span class="line"><span class="comment">// 90: 交换栈顶2个元素</span></span><br><span class="line">swap1</span><br><span class="line"><span class="symbol">  stack:</span> [<span class="number">0x0</span> <span class="number">0x1</span> <span class="number">0x1</span>]</span><br><span class="line"><span class="comment">// 55: 把值 0x1 存储到地址 0x0</span></span><br><span class="line"><span class="comment">// 这条指令使用了栈顶的两个元素</span></span><br><span class="line">sstore</span><br><span class="line"><span class="symbol">  stack:</span> [<span class="number">0x1</span>]</span><br><span class="line"><span class="symbol">  store:</span> &#123; <span class="number">0x0</span> =&gt; <span class="number">0x1</span> &#125;</span><br><span class="line"><span class="comment">// 50: 出栈，即丢掉栈顶一个元素</span></span><br><span class="line">pop</span><br><span class="line"><span class="symbol">  stack:</span> []</span><br><span class="line"><span class="symbol">  store:</span> &#123; <span class="number">0x0</span> =&gt; <span class="number">0x1</span> &#125;</span><br></pre></td></tr></table></figure><p>运行完了。栈空了，同时有一个元素存储到了存储器里。</p><p>值得注意的是 Solidity 决定把状态变量 <code>uint256 a</code> 存储到地址 <code>0x0</code> 。很可能其他语言会把状态变量存到其他地方。</p><p>写出伪代码， EVM 运行 <code>6001600081905550</code> 就像是这样：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="function"><span class="title">sstore</span><span class="params">(<span class="number">0</span>x0, <span class="number">0</span>x1)</span></span></span><br></pre></td></tr></table></figure><p>看仔细一点，会发现 <code>dup2</code>, <code>swap1</code>, <code>pop</code> 是多余的。汇编代码可以更简单：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x1</span></span><br><span class="line"><span class="number">0x0</span></span><br><span class="line">sstore</span><br></pre></td></tr></table></figure><p>你可以试着模拟运行上面的<code>3</code>条指令，肯定会惊喜地发现它们结束时的机器状态是一样的：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">stack:</span> []</span><br><span class="line"><span class="symbol">store:</span> &#123; <span class="number">0x0</span> =&gt; <span class="number">0x1</span> &#125;</span><br></pre></td></tr></table></figure><h1 id="2-个存储变量"><a href="#2-个存储变量" class="headerlink" title="2 个存储变量"></a>2 个存储变量</h1><p>添加另一个相同数据类型的存储变量：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c2.sol</span></span><br><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint256 a;</span><br><span class="line">    uint256 b;</span><br><span class="line">    function C() &#123;</span><br><span class="line">      a = <span class="number">1</span>;</span><br><span class="line">      b = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译，注意 <code>tag_2</code>:<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ solc --bin --asm c2.sol</span><br><span class="line"><span class="comment">// ... more stuff omitted</span></span><br><span class="line">tag_2:</span><br><span class="line">    <span class="comment">/* "c2.sol":99:100  1 */</span></span><br><span class="line">  <span class="number">0x1</span></span><br><span class="line">    <span class="comment">/* "c2.sol":95:96  a */</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">    <span class="comment">/* "c2.sol":95:100  a = 1 */</span></span><br><span class="line">  dup2</span><br><span class="line">  swap1</span><br><span class="line">  sstore</span><br><span class="line">  <span class="keyword">pop</span></span><br><span class="line">    <span class="comment">/* "c2.sol":112:113  2 */</span></span><br><span class="line">  <span class="number">0x2</span></span><br><span class="line">    <span class="comment">/* "c2.sol":108:109  b */</span></span><br><span class="line">  <span class="number">0x1</span></span><br><span class="line">    <span class="comment">/* "c2.sol":108:113  b = 2 */</span></span><br><span class="line">  dup2</span><br><span class="line">  swap1</span><br><span class="line">  sstore</span><br><span class="line">  <span class="keyword">pop</span></span><br></pre></td></tr></table></figure></p><p>汇编伪代码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="function"><span class="title">sstore</span><span class="params">(<span class="number">0</span>x0, <span class="number">0</span>x1)</span></span></span><br><span class="line"><span class="comment">// b = 2</span></span><br><span class="line"><span class="function"><span class="title">sstore</span><span class="params">(<span class="number">0</span>x1, <span class="number">0</span>x2)</span></span></span><br></pre></td></tr></table></figure><p>现在我们知道这两个存储变量是依次存储的，<code>a</code> 存储在地址 <code>0x0</code>，<code>b</code> 存储在地址 <code>0x1</code>。</p><h1 id="打包存储"><a href="#打包存储" class="headerlink" title="打包存储"></a>打包存储</h1><p>每个存储单元能存 32 字节。如果全部使用 32 字节的话，如果一个变量只要 16 字节，那就很浪费了。 Solidity 通过把 2 个短的数据类型打包成 1 个来提高存储效率。</p><p>把 <code>a</code> 和 <code>b</code> 改成每个 16 字节：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">pragma</span> solidity<span class="regexp"> ^0.4.11</span>;</span><br><span class="line"><span class="attribute">contract</span> C &#123;</span><br><span class="line">    <span class="attribute">uint128</span> a;</span><br><span class="line">    <span class="attribute">uint128</span> b;</span><br><span class="line">    <span class="attribute">function</span> C() &#123;</span><br><span class="line">      <span class="attribute">a</span> = <span class="number">1</span>;</span><br><span class="line">      <span class="attribute">b</span> = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译合约：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> solc --bin --asm c3.sol</span></span><br></pre></td></tr></table></figure><p>生成的汇编代码更复杂了：<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">  // a = 1</span><br><span class="line">  0x1</span><br><span class="line">  0x0</span><br><span class="line">  dup1</span><br><span class="line">  0x100</span><br><span class="line">  exp</span><br><span class="line">  dup2</span><br><span class="line">  sload</span><br><span class="line">  dup2</span><br><span class="line">  0xffffffffffffffffffffffffffffffff</span><br><span class="line">  mul</span><br><span class="line">  not</span><br><span class="line">  and</span><br><span class="line">  swap1</span><br><span class="line">  dup4</span><br><span class="line">  0xffffffffffffffffffffffffffffffff</span><br><span class="line">  and</span><br><span class="line">  mul</span><br><span class="line">  or</span><br><span class="line">  swap1</span><br><span class="line">  sstore</span><br><span class="line">  pop</span><br><span class="line">  // b = 2</span><br><span class="line">  0x2</span><br><span class="line">  0x0</span><br><span class="line">  0x10</span><br><span class="line">  0x100</span><br><span class="line">  exp</span><br><span class="line">  dup2</span><br><span class="line">  sload</span><br><span class="line">  dup2</span><br><span class="line">  0xffffffffffffffffffffffffffffffff</span><br><span class="line">  mul</span><br><span class="line">  not</span><br><span class="line">  and</span><br><span class="line">  swap1</span><br><span class="line">  dup4</span><br><span class="line">  0xffffffffffffffffffffffffffffffff</span><br><span class="line">  and</span><br><span class="line">  mul</span><br><span class="line">  or</span><br><span class="line">  swap1</span><br><span class="line">  sstore</span><br><span class="line">  pop</span><br></pre></td></tr></table></figure></p><p>上面的汇编代码把 2 个变量打包到1个存储地址( <code>0x0</code> )，像这样：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">         b         </span>][<span class="symbol">         a         </span>]</span><br><span class="line">[<span class="string">16 bytes / 128 bits</span>][<span class="symbol">16 bytes / 128 bits</span>]</span><br></pre></td></tr></table></figure><p>打包的原因是目前最贵的操作就是存储空间的使用：</p><ul><li><code>sstore</code> 花费 20,000 gas 来第一次写入一个新地址</li><li><code>sstore</code> 花费 5,000 gas 来随后写入一个已存在的地址</li><li><code>sload</code> 花费 500 gas</li><li>大多数指令只花费 3~10 gas</li></ul><p>通过使用相同的地址， Solidity 为第二个变量存储只支付 5,000 而不是 20,000，省了 15,000 gas。</p><h1 id="更多优化"><a href="#更多优化" class="headerlink" title="更多优化"></a>更多优化</h1><p>不分别同 2 个 <code>sstore</code> 指令来保存 <code>a</code> 和 <code>b</code> ，而把2个128比特的数字打包到内存里再使用1个 <code>sstore</code> ，从而节省 5,000 gas。</p><p>你可以通过 <code>optimize</code> 标志来让Solidity做这个操作：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">$</span> <span class="comment">solc</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">bin</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">asm</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">optimize</span> <span class="comment">c3</span><span class="string">.</span><span class="comment">sol</span></span><br></pre></td></tr></table></figure><p>这个方式生成的汇编代码只使用1个 <code>sload</code> 和1个 <code>sstore</code> :<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">tag_2:</span></span><br><span class="line">    <span class="comment">/* "c3.sol":95:96  a */</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">    <span class="comment">/* "c3.sol":95:100  a = 1 */</span></span><br><span class="line">  dup1</span><br><span class="line">  sload</span><br><span class="line">    <span class="comment">/* "c3.sol":108:113  b = 2 */</span></span><br><span class="line">  <span class="number">0x200000000000000000000000000000000</span></span><br><span class="line">  not(<span class="keyword">sub(exp(0x2, </span><span class="number">0x80</span>), <span class="number">0x1</span>))</span><br><span class="line">    <span class="comment">/* "c3.sol":95:100  a = 1 */</span></span><br><span class="line">  <span class="keyword">swap1</span></span><br><span class="line"><span class="keyword"> </span> <span class="keyword">swap2</span></span><br><span class="line"><span class="keyword"> </span> <span class="keyword">and</span></span><br><span class="line"><span class="keyword"> </span>   <span class="comment">/* "c3.sol":99:100  1 */</span></span><br><span class="line">  <span class="number">0x1</span></span><br><span class="line">    <span class="comment">/* "c3.sol":95:100  a = 1 */</span></span><br><span class="line">  <span class="keyword">or</span></span><br><span class="line"><span class="keyword"> </span> <span class="keyword">sub(exp(0x2, </span><span class="number">0x80</span>), <span class="number">0x1</span>)</span><br><span class="line">    <span class="comment">/* "c3.sol":108:113  b = 2 */</span></span><br><span class="line">  <span class="keyword">and</span></span><br><span class="line"><span class="keyword"> </span> <span class="keyword">or</span></span><br><span class="line"><span class="keyword"> </span> <span class="keyword">swap1</span></span><br><span class="line"><span class="keyword"> </span> sstore</span><br></pre></td></tr></table></figure></p><p>字节码是<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">600080547002000000000000000000000000000000006001608060020</span>a03199091166001176001608060020a<span class="number">0316179055</span></span><br></pre></td></tr></table></figure></p><p>格式化字节码成一行一条指令的形式：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// push 0x0</span></span><br><span class="line"><span class="number">60</span> <span class="number">00</span></span><br><span class="line"><span class="comment">// dup1</span></span><br><span class="line"><span class="number">80</span></span><br><span class="line"><span class="comment">// sload</span></span><br><span class="line"><span class="number">54</span></span><br><span class="line"><span class="comment">// push17 作为 32 字节的数字，把接下来的 17 字节入栈</span></span><br><span class="line"><span class="number">70</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="comment">/* not(sub(exp(0x2, 0x80), 0x1)) */</span></span><br><span class="line"><span class="comment">// push 0x1</span></span><br><span class="line"><span class="number">60</span> <span class="number">01</span></span><br><span class="line"><span class="comment">// push 0x80 (32)</span></span><br><span class="line"><span class="number">60</span> <span class="number">80</span></span><br><span class="line"><span class="comment">// push 0x80 (2)</span></span><br><span class="line"><span class="number">60</span> <span class="number">02</span></span><br><span class="line"><span class="comment">// exp</span></span><br><span class="line"><span class="number">0</span>a</span><br><span class="line"><span class="comment">// sub</span></span><br><span class="line"><span class="number">03</span></span><br><span class="line"><span class="comment">// not</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="comment">// swap1</span></span><br><span class="line"><span class="number">90</span></span><br><span class="line"><span class="comment">// swap2</span></span><br><span class="line"><span class="number">91</span></span><br><span class="line"><span class="comment">// and</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="comment">// push 0x1</span></span><br><span class="line"><span class="number">60</span> <span class="number">01</span></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="comment">/* sub(exp(0x2, 0x80), 0x1) */</span></span><br><span class="line"><span class="comment">// push 0x1</span></span><br><span class="line"><span class="number">60</span> <span class="number">01</span></span><br><span class="line"><span class="comment">// push 0x80</span></span><br><span class="line"><span class="number">60</span> <span class="number">80</span></span><br><span class="line"><span class="comment">// push 0x02</span></span><br><span class="line"><span class="number">60</span> <span class="number">02</span></span><br><span class="line"><span class="comment">// exp</span></span><br><span class="line"><span class="number">0</span>a</span><br><span class="line"><span class="comment">// sub</span></span><br><span class="line"><span class="number">03</span></span><br><span class="line"><span class="comment">// and</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="comment">// swap1</span></span><br><span class="line"><span class="number">90</span></span><br><span class="line"><span class="comment">// sstore</span></span><br><span class="line"><span class="number">55</span></span><br></pre></td></tr></table></figure></p><p>在汇编代码里有4个魔法变量：</p><ul><li><p>0x1 (16 字节), 使用低 16 位字节</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 字节码表示 <span class="number">0</span>x01</span><br><span class="line"><span class="number">16</span>:<span class="number">32</span> <span class="number">0</span>x000000000000000000000<span class="number">00000000000</span></span><br><span class="line"><span class="number">00</span>:<span class="number">16</span> <span class="number">0</span>x000000000000000000000<span class="number">00000000001</span></span><br></pre></td></tr></table></figure></li><li><p>0x2 (16 字节), 使用高 16 位字节</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//字节码表示 <span class="number">0</span>x2000000000000000000000<span class="number">00000000000</span></span><br><span class="line"><span class="number">16</span>:<span class="number">32</span> <span class="number">0</span>x000000000000000000000<span class="number">00000000002</span></span><br><span class="line"><span class="number">00</span>:<span class="number">16</span> <span class="number">0</span>x000000000000000000000<span class="number">00000000000</span></span><br></pre></td></tr></table></figure></li><li><p><code>not(sub(exp(0x2, 0x80), 0x1))</code></p></li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高 16 字节的二进制掩码</span></span><br><span class="line"><span class="attribute">16</span>:<span class="number">32</span> <span class="number">0</span>xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</span><br><span class="line"><span class="number">00</span>:<span class="number">16</span> <span class="number">0</span>x00000000000000000000000000000000</span><br></pre></td></tr></table></figure><ul><li><code>sub(exp(0x2, 0x80), 0x1)</code></li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 低 16 字节的二进制掩码</span></span><br><span class="line"><span class="attribute">16</span>:<span class="number">32</span> <span class="number">0</span>x00000000000000000000000000000000 </span><br><span class="line"><span class="number">00</span>:<span class="number">16</span> <span class="number">0</span>xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</span><br></pre></td></tr></table></figure><p>代码对这些值做了位交换以获得需要的结果：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">16<span class="selector-pseudo">:32</span> 0<span class="selector-tag">x00000000000000000000000000000002</span> </span><br><span class="line">00<span class="selector-pseudo">:16</span> 0<span class="selector-tag">x00000000000000000000000000000001</span></span><br></pre></td></tr></table></figure></p><p>最后，这个 32 字节的值存储在地址 0x0。</p><h2 id="gas-的使用"><a href="#gas-的使用" class="headerlink" title="gas 的使用"></a>gas 的使用</h2><blockquote><p>60008054700<strong>200000000000000000000000000000000</strong>6001608060020a03199091166001176001608060020a0316179055</p></blockquote><p>注意 <code>0x200000000000000000000000000000000</code> 嵌在字节码里了。但编译器也可能选择用指令 <code>exp(0x2, 0x81)</code> 计算值，这将生成更短的字节码序列。</p><p>结果好像是 <code>0x200000000000000000000000000000000</code> 比 <code>exp(0x2, 0x81)</code> 更便宜。我们看一下分别需要花费的 gas：</p><ul><li>4 gas  花在一笔交易中的每一个为 0 的数据或代码</li><li>68 gas 花在一笔交易中的每一个非 0 的数据或代码</li></ul><p>比较一下总的gas花费：</p><ul><li><p>字节码 <code>0x200000000000000000000000000000000</code>. 它有很多 0 ，更便宜<br>(1 <em> 68) + (16 </em> 4) = 196.</p></li><li><p>字节码 <code>608160020a</code>. 更短，但没有0.<br>5 * 68 = 340.</p></li></ul><p>更长但有更多 0 的序列实际上更便宜！</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>EVM 编译器实际上没有优化字节码大小或速度抑或内存效率。取而代之的是，它优化了 gas 的使用，这是一个间接的层面，可以激励以太坊区块链进行高效计算。</p><p>我们已经看到了 EVM 一些诡异的方面：</p><ul><li>EVM 是 256 比特机器。以 32 字节为块来操作数据最自然。</li><li>持久化存储很贵。</li><li>Solidity 编译器为了最小化 gas 的使用采取了有趣的做法。</li></ul><p>gas 成本的设定是任意的，以后可能会变。随着成本的变化，编译器会做出不同的选择。</p><hr><p>在本系列文章中，关于 EVM 我会写：</p><ul><li>EVM 汇编代码的介绍</li><li>定长数据类型如何表示</li><li>动态数据类型如何表示</li><li>ABI编码的外部函数如何调用</li><li>一个新合约创建时发生了什么</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;https://blog.qtum.org/diving-into-the-ethereum-vm-6e8d5d2f3c30&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.qtum.org/diving-i
      
    
    </summary>
    
      <category term="区块链" scheme="http://xichen.pub/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://xichen.pub/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Qtum" scheme="http://xichen.pub/tags/Qtum/"/>
    
      <category term="翻译" scheme="http://xichen.pub/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】 QtumJS 文档</title>
    <link href="http://xichen.pub/2018/06/06/2018-06-06-%E7%BF%BB%E8%AF%91-QtumJS%E6%96%87%E6%A1%A3/"/>
    <id>http://xichen.pub/2018/06/06/2018-06-06-翻译-QtumJS文档/</id>
    <published>2018-06-06T06:11:00.000Z</published>
    <updated>2018-09-01T09:12:38.174Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://github.com/qtumproject/qtumjs-doc" target="_blank" rel="noopener">https://github.com/qtumproject/qtumjs-doc</a><br>译者：中山大学数学学院（珠海）林学渊<br>大二时给量子做的翻译，转载注明出处，谢谢</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><blockquote><p>安装 qtumjs</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> qtumjs</span><br></pre></td></tr></table></figure><p>QtumJS是一个用于在Qtum区块链上开发DApp的JavaScript库。您可以使用此库来开发在浏览器中运行的前端UI以及在NodeJS中运行的后端脚本。</p><p>主要的类：<br>类 | 描述<br>——— | ———–<br>QtumRPCRaw | 使用 JSONRPC 1.0调用合约，直接访问 <code>qtumd</code> 的区块链 RPC 服务。<br>QtumRPC | <code>QtumRPCRaw</code> 的封装，提供像 JSONRPC 2.0 这样的接口。<br>Contract | 与智能合约交互的抽象层。使用 <a href="https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI" target="_blank" rel="noopener">ABI encoding/decoding</a>.</p><p>QtumJS 使用 <a href="https://www.typescriptlang.org/" target="_blank" rel="noopener">TypeScript</a> 开发, 因此为所有 API 提供了健壮的类型定义。 我们建议使用 <a href="https://code.visualstudio.com/" target="_blank" rel="noopener">VSCode</a> 来获得语言支持，例如类型提示和自动完成。</p><p>当然，你愿意的话也可以选择使用普通的 JavaScript 和记事本。</p><p>本文档是 QtumJS API 及其基本用法的参考文档。有关 QtumJS 的教程式介绍，查看: <a href="https://github.com/qtumproject/qtumbook/blob/master/part2/erc20-js.md" target="_blank" rel="noopener">QtumBook - ERC20 With QtumJS</a>.</p><h2 id="运行-Qtum-RPC"><a href="#运行-Qtum-RPC" class="headerlink" title="运行 Qtum RPC"></a>运行 Qtum RPC</h2><blockquote><p>开发模式运行 qtumd：</p></blockquote><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm \</span><br><span class="line">  -<span class="ruby">-name myapp \</span></span><br><span class="line"><span class="ruby">  -v <span class="string">`pwd`</span><span class="symbol">:/dapp</span> \</span></span><br><span class="line"><span class="ruby">  -p <span class="number">3889</span><span class="symbol">:</span><span class="number">3889</span> \</span></span><br><span class="line"><span class="ruby">  hayeah/qtumportal</span></span><br></pre></td></tr></table></figure><blockquote><p>测试网络（testnet）运行 qtumd：</p></blockquote><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm \</span><br><span class="line">  -<span class="ruby">-name myapp \</span></span><br><span class="line"><span class="ruby">  -e <span class="string">"QTUM_NETWORK=testnet"</span> \</span></span><br><span class="line"><span class="ruby">  -v <span class="string">`pwd`</span><span class="symbol">:/dapp</span> \</span></span><br><span class="line"><span class="ruby">  -p <span class="number">3889</span><span class="symbol">:</span><span class="number">3889</span> \</span></span><br><span class="line"><span class="ruby">  hayeah/qtumportal</span></span><br></pre></td></tr></table></figure><p>QtumJS 依赖 <code>qtumd</code> 提供的访问 QTUM 区块链的 JSON-RPC 服务。</p><p>更多细节请查看: <a href="https://github.com/qtumproject/qtumbook/blob/master/SUMMARY.md#part-1---running-qtum" target="_blank" rel="noopener">QtumBook - Running QTUM</a>.</p><aside class="notice"><br>默认 JSON-RPC 是 “qtum：test”，运行端口为 3889<br></aside><h1 id="ERC20-实例"><a href="#ERC20-实例" class="headerlink" title="ERC20 实例"></a>ERC20 实例</h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Qtum,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">"qtumjs"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> repoData = <span class="built_in">require</span>(<span class="string">"./solar.json"</span>)</span><br><span class="line"><span class="keyword">const</span> qtum = <span class="keyword">new</span> Qtum(<span class="string">"http://qtum:test@localhost:3889"</span>, repoData)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myToken = qtum.contract(<span class="string">"zeppelin-solidity/contracts/token/CappedToken.sol"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params">fromAddr, toAddr, amount</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> tx = <span class="keyword">await</span> myToken.send(<span class="string">"transfer"</span>, [toAddr, amount], &#123;</span><br><span class="line">    senderAddress: fromAddr,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"transfer tx:"</span>, tx.txid)</span><br><span class="line">  <span class="built_in">console</span>.log(tx)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> tx.confirm(<span class="number">3</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"transfer confirmed"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设 <code>solar.json</code> 包含已部署的合约，则可以使用 qtumjs 调用代币合约的方法来流通代币。</p><p>一个实例 <a href="https://github.com/qtumproject/qtumbook-mytoken-qtumjs-cli/blob/29fab6dfcca55013c7efa8ee5e91bbc8c40ca55a/solar.development.json.example" target="_blank" rel="noopener">solar.json</a>. 这个可以使用 <a href="https://github.com/qtumproject/solar" target="_blank" rel="noopener">solar</a> 部署工具自动生成。</p><p>完整实例: <a href="https://github.com/qtumproject/qtumbook-mytoken-qtumjs-cli" target="_blank" rel="noopener">qtumproject/qtumbook-mytoken-qtumjs-cli</a></p><p>合约开发, 查看 <a href="https://github.com/qtumproject/solar" target="_blank" rel="noopener">Solar Smart Contract Deployment Tool</a>.</p><p>为了充实教程, 查看 <a href="https://github.com/qtumproject/qtumbook/blob/master/part2/erc20-js.md" target="_blank" rel="noopener">QtumBook - ERC20 With QtumJS</a>.</p><h1 id="Qtum"><a href="#Qtum" class="headerlink" title="Qtum"></a>Qtum</h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> repoData = <span class="built_in">require</span>(<span class="string">"./solar.json"</span>)</span><br><span class="line"><span class="keyword">const</span> qtum = <span class="keyword">new</span> Qtum(<span class="string">"http://qtum:test@localhost:3889"</span>, repoData)</span><br></pre></td></tr></table></figure><p><code>Qtum</code> 是 <code>qtumjs</code> API 的一个对象. 它提供两个主要功能：</p><ul><li>对 <code>qtumd</code> RPC 服务的访问. 它是 <a href="#qtumrpc">QtumRPC</a> 的子类.</li><li>实例化 <a href="#contract-2">Contract</a> 对象的工厂方法, 用于与已部署的合约进行交互。</li></ul><table><thead><tr><th>参数</th><th>类型</th></tr></thead><tbody><tr><td>url</td><td>string</td></tr><tr><td></td><td>qtumd RPC 服务的 URL</td></tr><tr><td>repoData</td><td><a href="#icontractsrepodata">IContractsRepoData</a></td></tr><tr><td></td><td>关于 Solidity 合约的信息.</td></tr></tbody></table><p><code>repoData</code> 包含所有已部署合约或库的 ABI 定义，以及它们的部署地址。这些信息用于实例化 <code>Contract</code> 实例。</p><p>使用 <code>Qtum</code> 的工厂方法实例化的 <code>Contract</code> 对象能够解码所有在 <code>repoData</code> 里的事件类型. 但是手动构建的合约只能解码在其范围内定义的事件类型, 这也是 Solidity 编译器输出 ABI 定义的限制。</p><p>建议使用 Qtum 来实例化 <code>Contract</code> 对象.</p><h2 id="contract"><a href="#contract" class="headerlink" title="contract"></a>contract</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myToken = qtum.contract(<span class="string">"zeppelin-solidity/contracts/token/CappedToken.sol"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>实例化这个合约使用了 <a href="https://github.com/qtumproject/qtumbook-mytoken-qtumjs-cli/blob/29fab6dfcca55013c7efa8ee5e91bbc8c40ca55a/solar.development.json.example#L3" target="_blank" rel="noopener">这些</a> 信息。</p></blockquote><p>实例化 <code>Contract</code> 对象的工厂方法，使用了 <code>repoData</code> 中的 ABI 定义和地址。合约对象是使用一个事件 log 解码器来配置的，这个解码器能解码所有 <code>repoData</code> 中已知的事件类型。</p><table><thead><tr><th>参数</th><th>类型</th></tr></thead><tbody><tr><td>name</td><td>string</td></tr><tr><td></td><td>作为 <code>repoData.contracts</code> map 的 key，用于获取合约信息。</td></tr></tbody></table><h2 id="rawCall"><a href="#rawCall" class="headerlink" title="rawCall"></a>rawCall</h2><p>继承自 <a href="#rawcall-2">QtumRPC#rawcall</a></p><h1 id="Contract"><a href="#Contract" class="headerlink" title="Contract"></a>Contract</h1><p>与智能合约交互的抽象层。</p><p>这比使用 <code>QtumRPC</code> 直接调用 RPC 的 <code>sendcontract</code> 和 <code>calltocontract</code> 方法更方便。它处理 ABI 编码，转换 JS 和 Solidity 值。</p><ul><li>有 API 用于确认交易。</li><li>有 API 用于调用合约方法，使用 <code>call</code> 或 <code>send</code> .</li><li>有 API 用于获取合约 log 事件。</li></ul><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rpc = <span class="keyword">new</span> QtumRPC(<span class="string">"http://qtum:test@localhost:3889"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myToken = <span class="keyword">new</span> Contract(rpc, repo.contracts[</span><br><span class="line">  <span class="string">"zeppelin-solidity/contracts/token/CappedToken.sol"</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure><blockquote><p>合约 <a href="https://github.com/qtumproject/qtumbook-mytoken-qtumjs-cli/blob/29fab6dfcca55013c7efa8ee5e91bbc8c40ca55a/solar.development.json.example#L3" target="_blank" rel="noopener">信息</a> 可以使用 <a href="https://github.com/qtumproject/solar" target="_blank" rel="noopener">solar</a>. 生成</p></blockquote><table><thead><tr><th>参数</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>rpc</td><td>QtumRPC</td><td>RPC 对象，用于与合约进行交互</td></tr><tr><td>info</td><td><a href="#icontractinfo">IContractInfo</a></td><td>信息，用于部署合约</td></tr></tbody></table><p>建议使用 <a href="#contract">Qtum#contract</a> 而不是这个构造器。</p><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">totalSupply</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> myToken.call(<span class="string">"totalSupply"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// supply is a BigNumber instance (see: bn.js)</span></span><br><span class="line">  <span class="keyword">const</span> supply = result.outputs[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"supply"</span>, supply.toNumber())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实例输出:</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">address</span>: <span class="string">'a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3'</span>,</span><br><span class="line">  executionResult:</span><br><span class="line">   &#123; <span class="attr">gasUsed</span>: <span class="number">21689</span>,</span><br><span class="line">     excepted: <span class="string">'None'</span>,</span><br><span class="line">     newAddress: <span class="string">'a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3'</span>,</span><br><span class="line">     output: <span class="string">'00000000000000000000000000000000000000000000000000000000000036b0'</span>,</span><br><span class="line">     codeDeposit: <span class="number">0</span>,</span><br><span class="line">     gasRefunded: <span class="number">0</span>,</span><br><span class="line">     depositSize: <span class="number">0</span>,</span><br><span class="line">     gasForDeposit: <span class="number">0</span> &#125;,</span><br><span class="line">  transactionReceipt:</span><br><span class="line">   &#123; <span class="attr">stateRoot</span>: <span class="string">'5a0d9cd5df18165c75755f4345ca81da94f9247c1c031171fd6e2ce1a368844c'</span>,</span><br><span class="line">     gasUsed: <span class="number">21689</span>,</span><br><span class="line">     bloom: <span class="string">'0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="string">0000000000000000000000000000000000000000000000000'</span>,</span><br><span class="line">     log: [] &#125;,</span><br><span class="line">  outputs: [ <span class="xml"><span class="tag">&lt;<span class="name">BN:</span> <span class="attr">36b0</span>&gt;</span> ] &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>模拟 “mint” 调用:</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> myToken.call(<span class="string">"mint"</span>, [<span class="string">"dcd32b87270aeb980333213da2549c9907e09e94"</span>, <span class="number">1000</span>])</span><br></pre></td></tr></table></figure><blockquote><p>运行结果:</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"address"</span>: <span class="string">"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3"</span>,</span><br><span class="line">  <span class="attr">"executionResult"</span>: &#123;</span><br><span class="line">    <span class="attr">"gasUsed"</span>: <span class="number">39306</span>,</span><br><span class="line">    <span class="attr">"excepted"</span>: <span class="string">"None"</span>,</span><br><span class="line">    <span class="attr">"newAddress"</span>: <span class="string">"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3"</span>,</span><br><span class="line">    <span class="attr">"output"</span>: <span class="string">"0000000000000000000000000000000000000000000000000000000000000001"</span>,</span><br><span class="line">    <span class="attr">"codeDeposit"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"gasRefunded"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"depositSize"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"gasForDeposit"</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"transactionReceipt"</span>: &#123;</span><br><span class="line">    <span class="attr">"stateRoot"</span>: <span class="string">"9922edb770bd700a212427d3bc0764a9fed953a987952b2619b8a78dac7498aa"</span>,</span><br><span class="line">    <span class="attr">"gasUsed"</span>: <span class="number">39306</span>,</span><br><span class="line">    <span class="attr">"bloom"</span>: <span class="string">"00000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000020000000000008000000000000000000000000000000000000000000000000020000000020000000000800000000000000400000000010000000000000000000000000000000000000000000000000000000000000000000000000000080000000080000000000000000000000000000000000000000000000000000000002010000000000000000000000000000000200000000000000000020000000000000000000000000000000000000000000000000020000000000000000"</span>,</span><br><span class="line">    <span class="attr">"log"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"address"</span>: <span class="string">"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3"</span>,</span><br><span class="line">        <span class="attr">"topics"</span>: [</span><br><span class="line">          <span class="string">"0f6798a560793a54c3bcfe86a93cde1e73087d944c0ea20544137d4121396885"</span>,</span><br><span class="line">          <span class="string">"000000000000000000000000dcd32b87270aeb980333213da2549c9907e09e94"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"data"</span>: <span class="string">"00000000000000000000000000000000000000000000000000000000000003e8"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"address"</span>: <span class="string">"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3"</span>,</span><br><span class="line">        <span class="attr">"topics"</span>: [</span><br><span class="line">          <span class="string">"ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef"</span>,</span><br><span class="line">          <span class="string">"0000000000000000000000000000000000000000000000000000000000000000"</span>,</span><br><span class="line">          <span class="string">"000000000000000000000000dcd32b87270aeb980333213da2549c9907e09e94"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"data"</span>: <span class="string">"00000000000000000000000000000000000000000000000000000000000003e8"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"outputs"</span>: [</span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"logs"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"Mint"</span>,</span><br><span class="line">      <span class="attr">"to"</span>: <span class="string">"dcd32b87270aeb980333213da2549c9907e09e94"</span>,</span><br><span class="line">      <span class="attr">"amount"</span>: <span class="string">"3e8"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"Transfer"</span>,</span><br><span class="line">      <span class="attr">"from"</span>: <span class="string">"0000000000000000000000000000000000000000"</span>,</span><br><span class="line">      <span class="attr">"to"</span>: <span class="string">"dcd32b87270aeb980333213da2549c9907e09e94"</span>,</span><br><span class="line">      <span class="attr">"value"</span>: <span class="string">"3e8"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>callcontract</code> 在你本地 qtumd 节点 “模拟” 执行合约方法。这是免费的，实际上并不修改区块链。</p><p>这个免费。</p><table><thead><tr><th>参数</th><th>类型</th></tr></thead><tbody><tr><td>method</td><td>string</td></tr><tr><td></td><td>合约方法名</td></tr><tr><td>args</td><td>Array\<any></any></td></tr><tr><td></td><td>调用方法的参数</td></tr><tr><td>opts</td><td>IContractCallRequestOptions</td></tr><tr><td></td><td>调用配置项</td></tr><tr><td>@return</td><td>Promise\&lt;<a href="#icontractcallresult">IContractCallResult</a>&gt;</td></tr><tr><td></td><td>调用结果，带有 ABI 解码的输出</td></tr></tbody></table><h2 id="send"><a href="#send" class="headerlink" title="send"></a>send</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">mint</span>(<span class="params">toAddr, amount</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Submit a `sendtocontract` transaction, invoking the `mint` method.</span></span><br><span class="line">  <span class="keyword">const</span> tx = <span class="keyword">await</span> myToken.send(<span class="string">"mint"</span>, [toAddr, amount])</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"tx:"</span>, tx)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Wait for 3 confirmations. The callback receives the</span></span><br><span class="line">  <span class="comment">// updated transaction info for each additional confirmation.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Both arguments are optional. `await tx.confirm()` would do.</span></span><br><span class="line">  <span class="keyword">const</span> receipt = <span class="keyword">await</span> tx.confirm(<span class="number">3</span>, <span class="function">(<span class="params">updatedTx</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"new confirmation"</span>, updatedTx.txid, updatedTx.confirmations)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"tx receipt:"</span>, <span class="built_in">JSON</span>.stringify(receipt, <span class="literal">null</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实例输出:</p></blockquote><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mint tx: <span class="number">858347704258506012</span>f538b19b9702d636dc350bc25a7e60d404bf3d2c08efd9</span><br><span class="line">&#123; amount: <span class="number">0</span>,</span><br><span class="line">  fee: -<span class="number">0.081064</span>,</span><br><span class="line">  confirmations: <span class="number">0</span>,</span><br><span class="line">  trusted: true,</span><br><span class="line">  txid: '<span class="number">85834770425850</span><span class="number">6012</span>f538b19b<span class="number">9702</span>d636dc350bc25a7e60d404bf3d2c08efd9',</span><br><span class="line">  walletconflicts: [],</span><br><span class="line">  time: <span class="number">1515475961</span>,</span><br><span class="line">  timereceived: <span class="number">1515475961</span>,</span><br><span class="line">  'bip125-replaceable': 'no',</span><br><span class="line">  details:</span><br><span class="line">   [ &#123; account: '',</span><br><span class="line">       category: 'send',</span><br><span class="line">       amount: <span class="number">0</span>,</span><br><span class="line">       vout: <span class="number">0</span>,</span><br><span class="line">       fee: -<span class="number">0.081064</span>,</span><br><span class="line">       abandoned: false &#125; ],</span><br><span class="line">  hex: '<span class="number">020000000100</span>6a977de<span class="number">7001</span>4fdc<span class="number">2546</span>ed19a<span class="number">53132608</span>6c6c<span class="number">9631</span>cb1c<span class="number">5352</span>db5f09e<span class="number">147736</span>b<span class="number">01000000494830</span><span class="number">45022100</span>b4ca<span class="number">3277</span>0a9f<span class="number">4267</span>9c6d20b7ddb5feb<span class="number">160303</span>fceafc2db0fedba18a22f0b<span class="number">64360220</span>3c<span class="number">2568</span>eb689fd324e76a12f<span class="number">367552</span>fe4cce36b29f<span class="number">8174738209</span>f<span class="number">881959</span>aadbab01feffffff<span class="number">02000000000000</span><span class="number">00006301040340</span>0d<span class="number">0301284440</span>c10f<span class="number">19000000000000</span><span class="number">000000000000</span>dcd32b<span class="number">8727</span>0aeb<span class="number">98033321</span>3da<span class="number">2549</span>c<span class="number">9907</span>e09e<span class="number">94000000</span></span><br><span class="line"><span class="number">00000000000000</span><span class="number">00000000000000</span><span class="number">00000000000000</span><span class="number">00000000000003</span>e814a778c05f1d0f70f<span class="number">1133</span>f4bbf78c1a9a7bf84aed3c<span class="number">2601</span>e<span class="number">7290</span>2e<span class="number">0000001976</span>a914dcd32b<span class="number">8727</span>0aeb<span class="number">98033321</span>3da<span class="number">2549</span>c<span class="number">9907</span>e09e<span class="number">9488</span>ac212e<span class="number">0000</span>',</span><br><span class="line">  method: 'mint',</span><br><span class="line">  confirm: [Function: confirm] &#125;</span><br></pre></td></tr></table></figure><blockquote><p>回调打印 3 次，分别对应每次确认</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">new</span> confirmation <span class="number">858347704258506012f</span>538b19b9702d636dc350bc25a7e60d404bf3d2c08efd9 <span class="number">1</span></span><br><span class="line"><span class="built_in">new</span> confirmation <span class="number">858347704258506012f</span>538b19b9702d636dc350bc25a7e60d404bf3d2c08efd9 <span class="number">2</span></span><br><span class="line"><span class="built_in">new</span> confirmation <span class="number">858347704258506012f</span>538b19b9702d636dc350bc25a7e60d404bf3d2c08efd9 <span class="number">3</span></span><br></pre></td></tr></table></figure><blockquote><p>确认后返回的交易收据：</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"blockHash"</span>: <span class="string">"3b53ad132c26f9c30e5be9f664573428dad8b52e167becea4428d6903cb32740"</span>,</span><br><span class="line">  <span class="attr">"blockNumber"</span>: <span class="number">13917</span>,</span><br><span class="line">  <span class="attr">"transactionHash"</span>: <span class="string">"79338589bb75e1865be889142890a4e25d3b9dbd454ce3f3c2614587c85e2ed3"</span>,</span><br><span class="line">  <span class="attr">"transactionIndex"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"from"</span>: <span class="string">"dcd32b87270aeb980333213da2549c9907e09e94"</span>,</span><br><span class="line">  <span class="attr">"to"</span>: <span class="string">"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3"</span>,</span><br><span class="line">  <span class="attr">"cumulativeGasUsed"</span>: <span class="number">39306</span>,</span><br><span class="line">  <span class="attr">"gasUsed"</span>: <span class="number">39306</span>,</span><br><span class="line">  <span class="attr">"contractAddress"</span>: <span class="string">"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3"</span>,</span><br><span class="line">  <span class="attr">"logs"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"Mint"</span>,</span><br><span class="line">      <span class="attr">"to"</span>: <span class="string">"dcd32b87270aeb980333213da2549c9907e09e94"</span>,</span><br><span class="line">      <span class="attr">"amount"</span>: <span class="string">"7d0"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"Transfer"</span>,</span><br><span class="line">      <span class="attr">"from"</span>: <span class="string">"0000000000000000000000000000000000000000"</span>,</span><br><span class="line">      <span class="attr">"to"</span>: <span class="string">"dcd32b87270aeb980333213da2549c9907e09e94"</span>,</span><br><span class="line">      <span class="attr">"value"</span>: <span class="string">"7d0"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"rawlogs"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"address"</span>: <span class="string">"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3"</span>,</span><br><span class="line">      <span class="attr">"topics"</span>: [</span><br><span class="line">        <span class="string">"0f6798a560793a54c3bcfe86a93cde1e73087d944c0ea20544137d4121396885"</span>,</span><br><span class="line">        <span class="string">"000000000000000000000000dcd32b87270aeb980333213da2549c9907e09e94"</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"data"</span>: <span class="string">"00000000000000000000000000000000000000000000000000000000000007d0"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"address"</span>: <span class="string">"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3"</span>,</span><br><span class="line">      <span class="attr">"topics"</span>: [</span><br><span class="line">        <span class="string">"ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef"</span>,</span><br><span class="line">        <span class="string">"0000000000000000000000000000000000000000000000000000000000000000"</span>,</span><br><span class="line">        <span class="string">"000000000000000000000000dcd32b87270aeb980333213da2549c9907e09e94"</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"data"</span>: <span class="string">"00000000000000000000000000000000000000000000000000000000000007d0"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个交易，在网络全局执行合约方法，会改变区块链。</p><p>这要花费 gas.</p><p>对一个合约有 2 个异步步骤</p><ol><li>你提交交易到网络</li><li>一旦提交，等待一个指定的确认数</li></ol><p>成功确认后，返回带有ABI解码的事件日志的交易收据 (<a href="#icontractsendreceipt">IContractSendReceipt</a>)</p><table><thead><tr><th>参数</th><th>类型</th></tr></thead><tbody><tr><td>method</td><td>string</td></tr><tr><td></td><td>合约方法名</td></tr><tr><td>args</td><td>Array\<any></any></td></tr><tr><td></td><td>所调用方法的参数</td></tr><tr><td>opts</td><td><a href="#icontractsendrequestoptions">IContractSendRequestOptions</a></td></tr><tr><td></td><td><em>可选</em> 发送配置项</td></tr><tr><td>@return</td><td>Promise\&lt;<a href="#icontractsendresult">IContractSendResult</a>&gt;</td></tr><tr><td></td><td>调用结果, 带有 ABI 解码的输出</td></tr></tbody></table><h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p>如果没有歧义，使用方法名称来调用/发送方法。 如果相同方法名称具有多个定义，请使用方法签名来调用/发送方法。</p><blockquote><p>方法名 foo 可能有多个定义:</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">int256 _a</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">uint256 _a, uint256 _b</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">int256 _a, int256 _b</span>)</span>;</span><br></pre></td></tr></table></figure><blockquote><p><code>foo</code> 方法有 0 个参数和有 1 个参数没有歧义。可以直接调用。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">contract.call(<span class="string">"foo"</span>)</span><br><span class="line">contract.call(<span class="string">"foo"</span>, [<span class="number">1</span>])</span><br></pre></td></tr></table></figure><blockquote><p><code>foo</code> 方法带 2 个参数的有歧义，必须带完整方法签名：</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">contract.call(<span class="string">"foo(uint256,uint256)"</span>, [<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">contract.call(<span class="string">"foo(int256,int256)"</span>, [<span class="number">1</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure><h2 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getLogs</span>(<span class="params">fromBlock=<span class="number">0</span>, toBlock=<span class="string">"latest"</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> logs = <span class="keyword">await</span> myToken.logs(&#123;</span><br><span class="line">    fromBlock,</span><br><span class="line">    toBlock,</span><br><span class="line">    minconf: <span class="number">1</span>,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(logs, <span class="literal">null</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实例输出</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"entries"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"blockHash"</span>: <span class="string">"369c6ded05c27ae7efc97964cce083b0ea9b8b950e67c51e52cb1bf898b9c415"</span>,</span><br><span class="line">      <span class="string">"blockNumber"</span>: <span class="number">12184</span>,</span><br><span class="line">      <span class="string">"transactionHash"</span>: <span class="string">"d1638a53f38fd68c5763e2eef9d86b9fc6ee7ea3f018dae7b1e385b4a9a78bc7"</span>,</span><br><span class="line">      <span class="string">"transactionIndex"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="string">"from"</span>: <span class="string">"dcd32b87270aeb980333213da2549c9907e09e94"</span>,</span><br><span class="line">      <span class="string">"to"</span>: <span class="string">"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3"</span>,</span><br><span class="line">      <span class="string">"cumulativeGasUsed"</span>: <span class="number">39306</span>,</span><br><span class="line">      <span class="string">"gasUsed"</span>: <span class="number">39306</span>,</span><br><span class="line">      <span class="string">"contractAddress"</span>: <span class="string">"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3"</span>,</span><br><span class="line">      <span class="string">"topics"</span>: [</span><br><span class="line">        <span class="string">"0f6798a560793a54c3bcfe86a93cde1e73087d944c0ea20544137d4121396885"</span>,</span><br><span class="line">        <span class="string">"000000000000000000000000dcd32b87270aeb980333213da2549c9907e09e94"</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="string">"data"</span>: <span class="string">"00000000000000000000000000000000000000000000000000000000000003e8"</span>,</span><br><span class="line">      <span class="string">"event"</span>: &#123;</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"Mint"</span>,</span><br><span class="line">        <span class="string">"to"</span>: <span class="string">"dcd32b87270aeb980333213da2549c9907e09e94"</span>,</span><br><span class="line">        <span class="string">"amount"</span>: <span class="string">"3e8"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"blockHash"</span>: <span class="string">"369c6ded05c27ae7efc97964cce083b0ea9b8b950e67c51e52cb1bf898b9c415"</span>,</span><br><span class="line">      <span class="string">"blockNumber"</span>: <span class="number">12184</span>,</span><br><span class="line">      <span class="string">"transactionHash"</span>: <span class="string">"d1638a53f38fd68c5763e2eef9d86b9fc6ee7ea3f018dae7b1e385b4a9a78bc7"</span>,</span><br><span class="line">      <span class="string">"transactionIndex"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="string">"from"</span>: <span class="string">"dcd32b87270aeb980333213da2549c9907e09e94"</span>,</span><br><span class="line">      <span class="string">"to"</span>: <span class="string">"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3"</span>,</span><br><span class="line">      <span class="string">"cumulativeGasUsed"</span>: <span class="number">39306</span>,</span><br><span class="line">      <span class="string">"gasUsed"</span>: <span class="number">39306</span>,</span><br><span class="line">      <span class="string">"contractAddress"</span>: <span class="string">"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3"</span>,</span><br><span class="line">      <span class="string">"topics"</span>: [</span><br><span class="line">        <span class="string">"ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef"</span>,</span><br><span class="line">        <span class="string">"0000000000000000000000000000000000000000000000000000000000000000"</span>,</span><br><span class="line">        <span class="string">"000000000000000000000000dcd32b87270aeb980333213da2549c9907e09e94"</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="string">"data"</span>: <span class="string">"00000000000000000000000000000000000000000000000000000000000003e8"</span>,</span><br><span class="line">      <span class="string">"event"</span>: &#123;</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"Transfer"</span>,</span><br><span class="line">        <span class="string">"from"</span>: <span class="string">"0000000000000000000000000000000000000000"</span>,</span><br><span class="line">        <span class="string">"to"</span>: <span class="string">"dcd32b87270aeb980333213da2549c9907e09e94"</span>,</span><br><span class="line">        <span class="string">"value"</span>: <span class="string">"3e8"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"count"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="string">"nextblock"</span>: <span class="number">12185</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取由合约生成的 <a href="http://solidity.readthedocs.io/en/develop/abi-spec.html#events" target="_blank" rel="noopener">Solidity 事件日志</a> 。</p><p>通过指定 <code>fromBlock</code> 和 <code>toBlock</code>，可以将事件日志查询限制块号范围。 例如，可以查询块 1000 到 1500 之间的事件日志。</p><p>此外，你可以使用 <code>minconf</code> 指定事件日志之前确认的最小数量作为结果返回。</p><table><thead><tr><th>参数</th><th>类型</th></tr></thead><tbody><tr><td>opts</td><td><a href="#irpcwaitforlogsrequest">IRPCWaitForLogsRequest</a></td></tr><tr><td></td><td>事件日志查询参数</td></tr><tr><td>@return</td><td>Promise\&lt;<a href="#icontracteventlogs">IContractEventLogs</a>&gt;</td></tr><tr><td></td><td>日志查询结果，带有 ABI 解码的输出</td></tr></tbody></table><h2 id="onLogs"><a href="#onLogs" class="headerlink" title="onLogs"></a>onLogs</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myToken.onLog(<span class="function">(<span class="params">entry</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(entry)</span><br><span class="line">&#125;, &#123; <span class="attr">minconf</span>: <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure><p>订阅合约新事件。每次收到新事件时都会调用回调。默认情况下，<code>onLog</code> 监听来自区块链顶端的日志。 使用 <code>fromBlock</code> 也可以接收较早的事件。</p><table><thead><tr><th>参数</th><th>类型</th></tr></thead><tbody><tr><td>callback</td><td>(entry: <a href="#icontracteventlog">IContractEventLog</a>) =&gt; void</td></tr><tr><td>opts</td><td><a href="#irpcwaitforlogsrequest">IRPCWaitForLogsRequest</a></td></tr><tr><td></td><td>事件日志查询参数</td></tr></tbody></table><h2 id="logEmitter"><a href="#logEmitter" class="headerlink" title="logEmitter"></a>logEmitter</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.emitter = myToken.logEmitter(&#123; <span class="attr">minconf</span>: <span class="number">1</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.emitter.on(<span class="string">"Mint"</span>, (event) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.emitter.on(<span class="string">"Transfer"</span>, (event) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.emitter.on(<span class="string">"?"</span>, (event) =&gt; &#123;</span><br><span class="line">  <span class="comment">// all un-decodeable events</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用 <a href="https://github.com/primus/eventemitter3" target="_blank" rel="noopener">EventsEmitter</a> 接口订阅合约新事件。发出的事件是 <a href="#icontracteventlog">IContractEventLog</a> 对象。</p><p>Solidity 事件名作为发出的事件名使用。</p><p>缺失 ABI 定义的事件 (即不能解析) 会发送 “?”.</p><table><thead><tr><th>参数</th><th>类型</th></tr></thead><tbody><tr><td>opts</td><td><a href="#irpcwaitforlogsrequest">IRPCWaitForLogsRequest</a></td></tr><tr><td></td><td>事件日志查询参数</td></tr></tbody></table><h2 id="receipt"><a href="#receipt" class="headerlink" title="receipt"></a>receipt</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> txid = <span class="string">"62fecfd27d71ddb260ac48c73c8f0f87e96d0b3a598ed2c2251caa4e6f9a9d97"</span></span><br><span class="line"><span class="keyword">const</span> receipt = <span class="keyword">await</span> qrcToken.receipt(txid)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(receipt, <span class="literal">null</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><blockquote><p>实例输出</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"blockHash"</span>: <span class="string">"af37cb8d9905521542243005fadc9f18c1498c9823e35fa277ea1c37174c289a"</span>,</span><br><span class="line">  <span class="string">"blockNumber"</span>: <span class="number">83981</span>,</span><br><span class="line">  <span class="string">"transactionHash"</span>: <span class="string">"62fecfd27d71ddb260ac48c73c8f0f87e96d0b3a598ed2c2251caa4e6f9a9d97"</span>,</span><br><span class="line">  <span class="string">"transactionIndex"</span>: <span class="number">28</span>,</span><br><span class="line">  <span class="string">"from"</span>: <span class="string">"57142e3bcf000f28890b5d979afc7ea90204e1de"</span>,</span><br><span class="line">  <span class="string">"to"</span>: <span class="string">"49665919e437a4bedb92faa45ed33ebb5a33ee63"</span>,</span><br><span class="line">  <span class="string">"cumulativeGasUsed"</span>: <span class="number">37029</span>,</span><br><span class="line">  <span class="string">"gasUsed"</span>: <span class="number">37029</span>,</span><br><span class="line">  <span class="string">"contractAddress"</span>: <span class="string">"49665919e437a4bedb92faa45ed33ebb5a33ee63"</span>,</span><br><span class="line">  <span class="string">"logs"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"type"</span>: <span class="string">"Transfer"</span>,</span><br><span class="line">      <span class="string">"from"</span>: <span class="string">"57142e3bcf000f28890b5d979afc7ea90204e1de"</span>,</span><br><span class="line">      <span class="string">"to"</span>: <span class="string">"c0ed80283c53c300c31c2bda6eca841e53cb6a21"</span>,</span><br><span class="line">      <span class="string">"value"</span>: <span class="string">"1ba5add5700"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"rawlogs"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"address"</span>: <span class="string">"49665919e437a4bedb92faa45ed33ebb5a33ee63"</span>,</span><br><span class="line">      <span class="string">"topics"</span>: [</span><br><span class="line">        <span class="string">"ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef"</span>,</span><br><span class="line">        <span class="string">"00000000000000000000000057142e3bcf000f28890b5d979afc7ea90204e1de"</span>,</span><br><span class="line">        <span class="string">"000000000000000000000000c0ed80283c53c300c31c2bda6eca841e53cb6a21"</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="string">"data"</span>: <span class="string">"000000000000000000000000000000000000000000000000000001ba5add5700"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取已被网络接受的交易收据。 如果交易尚未确认，则返回空值。</p><p>交易事件日志是 ABI 编码</p><table><thead><tr><th>参数</th><th>类型</th></tr></thead><tbody><tr><td>txid</td><td>string</td></tr><tr><td></td><td>交易 ID</td></tr><tr><td>@return</td><td>Promise\&lt;<a href="#icontractsendreceipt">IContractSendReceipt</a>&gt;</td></tr><tr><td></td><td>交易收据, 带有事件日志.</td></tr></tbody></table><h1 id="QtumRPC"><a href="#QtumRPC" class="headerlink" title="QtumRPC"></a>QtumRPC</h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rpc = <span class="keyword">new</span> QtumRPC(<span class="string">'http://qtum:test@localhost:3889'</span>);</span><br></pre></td></tr></table></figure><p>这是一个用于直接访问 <code>qtumd</code> RPC API 的 JSON-RPC 客户端。它不会为你处理任何 ABI 编码或解码。</p><p>有需要的话你可以把 RPC 用户名和密码包含到 URL 里。在例子中，用户名是 <code>qtum</code> ，密码是 <code>test</code>.</p><p>QtumRPC类有一些在合约抽象内部使用的未公开的方法。 考虑将来可能会发生变化的任何未经证实的不受支持的内容。 现在，rawCall是唯一的公共API。<br>注意: <code>QtumRPC</code> 类有一些没文档的 public 方法在 <code>Contract</code> 抽象层内部使用到了. 你要考虑到之后可能不支持的无文档的内容. 现在 <code>rawCall</code> 是唯一发布的 API.</p><table><thead><tr><th>参数</th><th>类型</th></tr></thead><tbody><tr><td>url</td><td>string</td></tr><tr><td></td><td>qtumd RPC 服务的 URL</td></tr></tbody></table><h2 id="rawCall-1"><a href="#rawCall-1" class="headerlink" title="rawCall"></a>rawCall</h2><blockquote><p>调用 <code>getinfo</code> RPC 方法以获取 Qutm 区块链的基本信息：</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> info = <span class="keyword">await</span> rpc.rawCall(<span class="string">"getinfo"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(info)</span><br></pre></td></tr></table></figure><blockquote><p><code>getinfo</code> 的输出:</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">version</span>: <span class="number">141300</span>,</span><br><span class="line">  protocolversion: <span class="number">70016</span>,</span><br><span class="line">  walletversion: <span class="number">130000</span>,</span><br><span class="line">  balance: <span class="number">0</span>,</span><br><span class="line">  stake: <span class="number">0</span>,</span><br><span class="line">  blocks: <span class="number">85685</span>,</span><br><span class="line">  timeoffset: <span class="number">0</span>,</span><br><span class="line">  connections: <span class="number">8</span>,</span><br><span class="line">  proxy: <span class="string">''</span>,</span><br><span class="line">  difficulty:</span><br><span class="line">   &#123; <span class="string">'proof-of-work'</span>: <span class="number">0.0000152587890625</span>,</span><br><span class="line">     <span class="string">'proof-of-stake'</span>: <span class="number">5207642.8878753</span> &#125;,</span><br><span class="line">  testnet: <span class="literal">false</span>,</span><br><span class="line">  moneysupply: <span class="number">100322740</span>,</span><br><span class="line">  keypoololdest: <span class="number">1513325658</span>,</span><br><span class="line">  keypoolsize: <span class="number">100</span>,</span><br><span class="line">  paytxfee: <span class="number">0</span>,</span><br><span class="line">  relayfee: <span class="number">0.004</span>,</span><br><span class="line">  errors: <span class="string">''</span> &#125;</span><br></pre></td></tr></table></figure><p>发起一个 JSON-RPC 1.0 方法调用, 返回调用结果. 如果 JSON API 返回不是 200 HTTP 结果，则抛出错误。</p><blockquote><p>使用 <code>try...catch</code> 处理错误:</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> rpc.rawCall(<span class="string">"unknown-method-hohoho"</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"err"</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="All-RPC-方法"><a href="#All-RPC-方法" class="headerlink" title="All RPC 方法"></a>All RPC 方法</h2><p>qtumd 支持的所有 RPC 方法 .</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">== Blockchain ==</span><br><span class="line">callcontract <span class="string">"address"</span> <span class="string">"data"</span> (<span class="built_in"> address </span>)</span><br><span class="line">getaccountinfo <span class="string">"address"</span></span><br><span class="line">getbestblockhash</span><br><span class="line">getblock <span class="string">"blockhash"</span> ( verbose )</span><br><span class="line">getblockchaininfo</span><br><span class="line">getblockcount</span><br><span class="line">getblockhash height</span><br><span class="line">getblockheader <span class="string">"hash"</span> ( verbose )</span><br><span class="line">getchaintips</span><br><span class="line">getdifficulty</span><br><span class="line">getmempoolancestors txid (verbose)</span><br><span class="line">getmempooldescendants txid (verbose)</span><br><span class="line">getmempoolentry txid</span><br><span class="line">getmempoolinfo</span><br><span class="line">getrawmempool ( verbose )</span><br><span class="line">getstorage <span class="string">"address"</span></span><br><span class="line">gettransactionreceipt <span class="string">"hash"</span></span><br><span class="line">gettxout <span class="string">"txid"</span> n ( include_mempool )</span><br><span class="line">gettxoutproof [<span class="string">"txid"</span>,<span class="built_in">..</span>.] ( blockhash )</span><br><span class="line">gettxoutsetinfo</span><br><span class="line">listcontracts (start maxDisplay)</span><br><span class="line">preciousblock <span class="string">"blockhash"</span></span><br><span class="line">pruneblockchain</span><br><span class="line">searchlogs &lt;fromBlock&gt; &lt;toBlock&gt; (address) (topics)</span><br><span class="line">verifychain ( checklevel nblocks )</span><br><span class="line">verifytxoutproof <span class="string">"proof"</span></span><br><span class="line">waitforlogs (fromBlock) (toBlock) (filter) (minconf)</span><br><span class="line"></span><br><span class="line">== Control ==</span><br><span class="line">getinfo</span><br><span class="line">getmemoryinfo</span><br><span class="line">help ( <span class="string">"command"</span> )</span><br><span class="line">stop</span><br><span class="line"></span><br><span class="line">== Generating ==</span><br><span class="line">generate nblocks ( maxtries )</span><br><span class="line">generatetoaddress nblocks<span class="built_in"> address </span>(maxtries)</span><br><span class="line"></span><br><span class="line">== Mining ==</span><br><span class="line">getblocktemplate ( TemplateRequest )</span><br><span class="line">getmininginfo</span><br><span class="line">getnetworkhashps ( nblocks height )</span><br><span class="line">getstakinginfo</span><br><span class="line">getsubsidy [nTarget]</span><br><span class="line">prioritisetransaction &lt;txid&gt; &lt;priority delta&gt; &lt;fee delta&gt;</span><br><span class="line">submitblock <span class="string">"hexdata"</span> ( <span class="string">"jsonparametersobject"</span> )</span><br><span class="line"></span><br><span class="line">==<span class="built_in"> Network </span>==</span><br><span class="line">addnode <span class="string">"node"</span> <span class="string">"add|remove|onetry"</span></span><br><span class="line">clearbanned</span><br><span class="line">disconnectnode <span class="string">"node"</span></span><br><span class="line">getaddednodeinfo ( <span class="string">"node"</span> )</span><br><span class="line">getconnectioncount</span><br><span class="line">getnettotals</span><br><span class="line">getnetworkinfo</span><br><span class="line">getpeerinfo</span><br><span class="line">listbanned</span><br><span class="line">ping</span><br><span class="line">setban <span class="string">"subnet"</span> <span class="string">"add|remove"</span> (bantime) (absolute)</span><br><span class="line">setnetworkactive <span class="literal">true</span>|<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">== Rawtransactions ==</span><br><span class="line">createrawtransaction [&#123;<span class="string">"txid"</span>:<span class="string">"id"</span>,<span class="string">"vout"</span>:n&#125;,<span class="built_in">..</span>.] &#123;<span class="string">"address"</span>:amount,<span class="string">"data"</span>:<span class="string">"hex"</span>,<span class="built_in">..</span>.&#125; ( locktime )</span><br><span class="line">decoderawtransaction <span class="string">"hexstring"</span></span><br><span class="line">decodescript <span class="string">"hexstring"</span></span><br><span class="line">fromhexaddress <span class="string">"hexaddress"</span></span><br><span class="line">fundrawtransaction <span class="string">"hexstring"</span> ( options )</span><br><span class="line">gethexaddress <span class="string">"address"</span></span><br><span class="line">getrawtransaction <span class="string">"txid"</span> ( verbose )</span><br><span class="line">sendrawtransaction <span class="string">"hexstring"</span> ( allowhighfees )</span><br><span class="line">signrawtransaction <span class="string">"hexstring"</span> ( [&#123;<span class="string">"txid"</span>:<span class="string">"id"</span>,<span class="string">"vout"</span>:n,<span class="string">"scriptPubKey"</span>:<span class="string">"hex"</span>,<span class="string">"redeemScript"</span>:<span class="string">"hex"</span>&#125;,<span class="built_in">..</span>.] [<span class="string">"privatekey1"</span>,<span class="built_in">..</span>.] sighashtype )</span><br><span class="line"></span><br><span class="line">== Util ==</span><br><span class="line">createmultisig nrequired [<span class="string">"key"</span>,<span class="built_in">..</span>.]</span><br><span class="line">estimatefee nblocks</span><br><span class="line">estimatepriority nblocks</span><br><span class="line">estimatesmartfee nblocks</span><br><span class="line">estimatesmartpriority nblocks</span><br><span class="line">signmessagewithprivkey <span class="string">"privkey"</span> <span class="string">"message"</span></span><br><span class="line">validateaddress <span class="string">"address"</span></span><br><span class="line">verifymessage <span class="string">"address"</span> <span class="string">"signature"</span> <span class="string">"message"</span></span><br><span class="line"></span><br><span class="line">== Wallet ==</span><br><span class="line">abandontransaction <span class="string">"txid"</span></span><br><span class="line">addmultisigaddress nrequired [<span class="string">"key"</span>,<span class="built_in">..</span>.] ( <span class="string">"account"</span> )</span><br><span class="line">addwitnessaddress <span class="string">"address"</span></span><br><span class="line">backupwallet <span class="string">"destination"</span></span><br><span class="line">bumpfee <span class="string">"txid"</span> ( options )</span><br><span class="line">createcontract <span class="string">"bytecode"</span> (gaslimit gasprice <span class="string">"senderaddress"</span> broadcast)</span><br><span class="line">dumpprivkey <span class="string">"address"</span></span><br><span class="line">dumpwallet <span class="string">"filename"</span></span><br><span class="line">encryptwallet <span class="string">"passphrase"</span></span><br><span class="line">getaccount <span class="string">"address"</span></span><br><span class="line">getaccountaddress <span class="string">"account"</span></span><br><span class="line">getaddressesbyaccount <span class="string">"account"</span></span><br><span class="line">getbalance ( <span class="string">"account"</span> minconf include_watchonly )</span><br><span class="line">getnewaddress ( <span class="string">"account"</span> )</span><br><span class="line">getrawchangeaddress</span><br><span class="line">getreceivedbyaccount <span class="string">"account"</span> ( minconf )</span><br><span class="line">getreceivedbyaddress <span class="string">"address"</span> ( minconf )</span><br><span class="line">gettransaction <span class="string">"txid"</span> ( include_watchonly ) (waitconf)</span><br><span class="line">getunconfirmedbalance</span><br><span class="line">getwalletinfo</span><br><span class="line">importaddress <span class="string">"address"</span> ( <span class="string">"label"</span> rescan p2sh )</span><br><span class="line">importmulti <span class="string">"requests"</span> <span class="string">"options"</span></span><br><span class="line">importprivkey <span class="string">"qtum"</span> ( <span class="string">"label"</span> ) ( rescan )</span><br><span class="line">importprunedfunds</span><br><span class="line">importpubkey <span class="string">"pubkey"</span> ( <span class="string">"label"</span> rescan )</span><br><span class="line">importwallet <span class="string">"filename"</span></span><br><span class="line">keypoolrefill ( newsize )</span><br><span class="line">listaccounts ( minconf include_watchonly)</span><br><span class="line">listaddressgroupings</span><br><span class="line">listlockunspent</span><br><span class="line">listreceivedbyaccount ( minconf include_empty include_watchonly)</span><br><span class="line">listreceivedbyaddress ( minconf include_empty include_watchonly)</span><br><span class="line">listsinceblock ( <span class="string">"blockhash"</span> target_confirmations include_watchonly)</span><br><span class="line">listtransactions ( <span class="string">"account"</span> count skip include_watchonly)</span><br><span class="line">listunspent ( minconf maxconf  [<span class="string">"addresses"</span>,<span class="built_in">..</span>.] [include_unsafe] )</span><br><span class="line">lockunspent unlock ([&#123;<span class="string">"txid"</span>:<span class="string">"txid"</span>,<span class="string">"vout"</span>:n&#125;,<span class="built_in">..</span>.])</span><br><span class="line">move <span class="string">"fromaccount"</span> <span class="string">"toaccount"</span> amount ( minconf <span class="string">"comment"</span> )</span><br><span class="line">removeprunedfunds <span class="string">"txid"</span></span><br><span class="line">reservebalance [&lt;reserve&gt; [amount]]</span><br><span class="line">sendfrom <span class="string">"fromaccount"</span> <span class="string">"toaddress"</span> amount ( minconf <span class="string">"comment"</span> <span class="string">"comment_to"</span> )</span><br><span class="line">sendmany <span class="string">"fromaccount"</span> &#123;<span class="string">"address"</span>:amount,<span class="built_in">..</span>.&#125; ( minconf <span class="string">"comment"</span> [<span class="string">"address"</span>,<span class="built_in">..</span>.] )</span><br><span class="line">sendmanywithdupes <span class="string">"fromaccount"</span> &#123;<span class="string">"address"</span>:amount,<span class="built_in">..</span>.&#125; ( minconf <span class="string">"comment"</span> [<span class="string">"address"</span>,<span class="built_in">..</span>.] )</span><br><span class="line">sendtoaddress <span class="string">"address"</span> amount ( <span class="string">"comment"</span> <span class="string">"comment_to"</span> subtractfeefromamount )</span><br><span class="line">sendtocontract <span class="string">"contractaddress"</span> <span class="string">"data"</span> (amount gaslimit gasprice senderaddress broadcast)</span><br><span class="line">setaccount <span class="string">"address"</span> <span class="string">"account"</span></span><br><span class="line">settxfee amount</span><br><span class="line">signmessage <span class="string">"address"</span> <span class="string">"message"</span></span><br></pre></td></tr></table></figure><h2 id="实例-getblockcount"><a href="#实例-getblockcount" class="headerlink" title="实例: getblockcount"></a>实例: getblockcount</h2><p>返回最长的区块链的块数。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> rpc.rawCall(<span class="string">"getblockcount"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>结果</p></blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">85687</span></span><br></pre></td></tr></table></figure><h2 id="实例-getnewaddress"><a href="#实例-getnewaddress" class="headerlink" title="实例: getnewaddress"></a>实例: getnewaddress</h2><p>返回接收付款的新 Qtum 地址。可能对要为用户生成存款地址的交易所有用。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> rpc.rawCall(<span class="string">"getnewaddress"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>结果</p></blockquote><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QS<span class="symbol">nrDTj4</span>U<span class="symbol">NcRwKdhY8</span>sUZEd<span class="number">74</span>VzwqeAddW</span><br></pre></td></tr></table></figure><h2 id="实例-fromhexaddress"><a href="#实例-fromhexaddress" class="headerlink" title="实例: fromhexaddress"></a>实例: fromhexaddress</h2><p>把一个 base58 pubkeyhash 地址转化成 16 进制地址用于智能合约。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> rpc.rawCall(<span class="string">"gethexaddress"</span>, [<span class="string">"QSnrDTj4UNcRwKdhY8sUZEd74VzwqeAddW"</span>])</span><br></pre></td></tr></table></figure><blockquote><p>结果</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">43d</span>ebdac95a0eaa4ff92d6b873944a4d92beae59</span><br></pre></td></tr></table></figure><h2 id="实例-gettransactionreceipt"><a href="#实例-gettransactionreceipt" class="headerlink" title="实例: gettransactionreceipt"></a>实例: gettransactionreceipt</h2><p>获得确认交易的收据。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> txid = <span class="string">"62fecfd27d71ddb260ac48c73c8f0f87e96d0b3a598ed2c2251caa4e6f9a9d97"</span></span><br><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> rpc.rawCall(<span class="string">"gettransactionreceipt"</span>, [txid])</span><br></pre></td></tr></table></figure><blockquote><p>结果</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"blockHash"</span>: <span class="string">"af37cb8d9905521542243005fadc9f18c1498c9823e35fa277ea1c37174c289a"</span>,</span><br><span class="line">    <span class="string">"blockNumber"</span>: <span class="number">83981</span>,</span><br><span class="line">    <span class="string">"transactionHash"</span>: <span class="string">"62fecfd27d71ddb260ac48c73c8f0f87e96d0b3a598ed2c2251caa4e6f9a9d97"</span>,</span><br><span class="line">    <span class="string">"transactionIndex"</span>: <span class="number">28</span>,</span><br><span class="line">    <span class="string">"from"</span>: <span class="string">"57142e3bcf000f28890b5d979afc7ea90204e1de"</span>,</span><br><span class="line">    <span class="string">"to"</span>: <span class="string">"49665919e437a4bedb92faa45ed33ebb5a33ee63"</span>,</span><br><span class="line">    <span class="string">"cumulativeGasUsed"</span>: <span class="number">37029</span>,</span><br><span class="line">    <span class="string">"gasUsed"</span>: <span class="number">37029</span>,</span><br><span class="line">    <span class="string">"contractAddress"</span>: <span class="string">"49665919e437a4bedb92faa45ed33ebb5a33ee63"</span>,</span><br><span class="line">    <span class="string">"log"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"address"</span>: <span class="string">"49665919e437a4bedb92faa45ed33ebb5a33ee63"</span>,</span><br><span class="line">        <span class="string">"topics"</span>: [</span><br><span class="line">          <span class="string">"ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef"</span>,</span><br><span class="line">          <span class="string">"00000000000000000000000057142e3bcf000f28890b5d979afc7ea90204e1de"</span>,</span><br><span class="line">          <span class="string">"000000000000000000000000c0ed80283c53c300c31c2bda6eca841e53cb6a21"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"data"</span>: <span class="string">"000000000000000000000000000000000000000000000000000001ba5add5700"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h1 id="类型词典"><a href="#类型词典" class="headerlink" title="类型词典"></a>类型词典</h1><h2 id="IContractInfo"><a href="#IContractInfo" class="headerlink" title="IContractInfo"></a>IContractInfo</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IContractInfo &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 合约的 ABI 定义, solc 生成.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  abi: IABIMethod[]</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 合约地址</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  address: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 合约所有者的地址</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  sender?: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与部署合约交互所需的最少部署信息。</p><h2 id="IContractCallResult"><a href="#IContractCallResult" class="headerlink" title="IContractCallResult"></a>IContractCallResult</h2><p>调用一个合约方法的返回结果，带有解码的输出和日志。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IContractCallResult <span class="keyword">extends</span> IRPCCallContractResult &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ABI 解码的输出</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  outputs: <span class="built_in">any</span>[]</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ABI 解码的日志</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  logs: <span class="built_in">Array</span>&lt;IDecodedSolidityEvent | <span class="literal">null</span>&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IRPCCallContractResult &#123;</span><br><span class="line">  address: <span class="built_in">string</span></span><br><span class="line">  executionResult: IExecutionResult,</span><br><span class="line">  transactionReceipt: &#123;</span><br><span class="line">    stateRoot: <span class="built_in">string</span>,</span><br><span class="line">    gasUsed: <span class="built_in">string</span>,</span><br><span class="line">    bloom: <span class="built_in">string</span>,</span><br><span class="line">    log: <span class="built_in">any</span>[],</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IExecutionResult &#123;</span><br><span class="line">  gasUsed: <span class="built_in">number</span>,</span><br><span class="line">  excepted: <span class="built_in">string</span>,</span><br><span class="line">  newAddress: <span class="built_in">string</span>,</span><br><span class="line">  output: <span class="built_in">string</span>,</span><br><span class="line">  codeDeposit: <span class="built_in">number</span>,</span><br><span class="line">  gasRefunded: <span class="built_in">number</span>,</span><br><span class="line">  depositSize: <span class="built_in">number</span>,</span><br><span class="line">  gasForDeposit: <span class="built_in">number</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实例:</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"address"</span>: <span class="string">"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3"</span>,</span><br><span class="line">  <span class="string">"executionResult"</span>: &#123;</span><br><span class="line">    <span class="string">"gasUsed"</span>: <span class="number">39306</span>,</span><br><span class="line">    <span class="string">"excepted"</span>: <span class="string">"None"</span>,</span><br><span class="line">    <span class="string">"newAddress"</span>: <span class="string">"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3"</span>,</span><br><span class="line">    <span class="string">"output"</span>: <span class="string">"0000000000000000000000000000000000000000000000000000000000000001"</span>,</span><br><span class="line">    <span class="string">"codeDeposit"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">"gasRefunded"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">"depositSize"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">"gasForDeposit"</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"transactionReceipt"</span>: &#123;</span><br><span class="line">    <span class="string">"stateRoot"</span>: <span class="string">"9922edb770bd700a212427d3bc0764a9fed953a987952b2619b8a78dac7498aa"</span>,</span><br><span class="line">    <span class="string">"gasUsed"</span>: <span class="number">39306</span>,</span><br><span class="line">    <span class="string">"bloom"</span>: <span class="string">"00000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000020000000000008000000000000000000000000000000000000000000000000020000000020000000000800000000000000400000000010000000000000000000000000000000000000000000000000000000000000000000000000000080000000080000000000000000000000000000000000000000000000000000000002010000000000000000000000000000000200000000000000000020000000000000000000000000000000000000000000000000020000000000000000"</span>,</span><br><span class="line">    <span class="string">"log"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"address"</span>: <span class="string">"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3"</span>,</span><br><span class="line">        <span class="string">"topics"</span>: [</span><br><span class="line">          <span class="string">"0f6798a560793a54c3bcfe86a93cde1e73087d944c0ea20544137d4121396885"</span>,</span><br><span class="line">          <span class="string">"000000000000000000000000dcd32b87270aeb980333213da2549c9907e09e94"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"data"</span>: <span class="string">"00000000000000000000000000000000000000000000000000000000000003e8"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"address"</span>: <span class="string">"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3"</span>,</span><br><span class="line">        <span class="string">"topics"</span>: [</span><br><span class="line">          <span class="string">"ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef"</span>,</span><br><span class="line">          <span class="string">"0000000000000000000000000000000000000000000000000000000000000000"</span>,</span><br><span class="line">          <span class="string">"000000000000000000000000dcd32b87270aeb980333213da2549c9907e09e94"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"data"</span>: <span class="string">"00000000000000000000000000000000000000000000000000000000000003e8"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"outputs"</span>: [</span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"logs"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"type"</span>: <span class="string">"Mint"</span>,</span><br><span class="line">      <span class="string">"to"</span>: <span class="string">"dcd32b87270aeb980333213da2549c9907e09e94"</span>,</span><br><span class="line">      <span class="string">"amount"</span>: <span class="string">"3e8"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"type"</span>: <span class="string">"Transfer"</span>,</span><br><span class="line">      <span class="string">"from"</span>: <span class="string">"0000000000000000000000000000000000000000"</span>,</span><br><span class="line">      <span class="string">"to"</span>: <span class="string">"dcd32b87270aeb980333213da2549c9907e09e94"</span>,</span><br><span class="line">      <span class="string">"value"</span>: <span class="string">"3e8"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Contract#call</code> 的返回类型.</p><h2 id="IContractSendRequestOptions"><a href="#IContractSendRequestOptions" class="headerlink" title="IContractSendRequestOptions"></a>IContractSendRequestOptions</h2><p><a href="#send">Contract#send</a> 的配置项</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * `send` 合约方法的配置项.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IContractSendRequestOptions &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 要发送的 QTUM 数. 例如 0.1, 默认: 0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  amount?: <span class="built_in">number</span> | <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * gasLimit, 默认: 200000, 最大: 40000000</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  gasLimit?: <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 每 gas 的 Qtum 价格, 默认: 0.00000001, 最小:0.00000001</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  gasPrice?: <span class="built_in">number</span> | <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 发送者的 quantum 地址</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  senderAddress?: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IContractSendResult"><a href="#IContractSendResult" class="headerlink" title="IContractSendResult"></a>IContractSendResult</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tx = <span class="keyword">await</span> contract.send(method, args)</span><br><span class="line"><span class="keyword">await</span> tx.confirm(<span class="number">3</span>, <span class="function">(<span class="params">updatedTx, receipt</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>返回 <a href="#send">Contract#send</a> 的值。</p><p><code>confirm</code> 方法用来等待交易确认。</p><p><code>confirm</code> 方法的参数:</p><table><thead><tr><th>参数</th><th>类型</th></tr></thead><tbody><tr><td>n</td><td>number</td></tr><tr><td></td><td><em>可选</em> 须等待的确认数</td></tr><tr><td>callback</td><td>IContractSendConfirmationHandler</td></tr><tr><td></td><td><em>可选</em> 回调函数，每次确认都会调用</td></tr></tbody></table><p>回调值为:</p><table><thead><tr><th>参数</th><th>类型</th></tr></thead><tbody><tr><td>updatedTx</td><td>IRPCGetTransactionResult</td></tr><tr><td></td><td>关于提交给网络的交易的基本信息</td></tr><tr><td>receipt</td><td>IContractSendReceipt</td></tr><tr><td></td><td>关于已确认交易的其他信息</td></tr></tbody></table><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="#irpcgettransactionresult">IRPCGetTransactionResult</a></li><li><a href="#icontractsendreceipt">IContractSendReceipt</a></li></ul><h2 id="IRPCGetTransactionResult"><a href="#IRPCGetTransactionResult" class="headerlink" title="IRPCGetTransactionResult"></a>IRPCGetTransactionResult</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IRPCGetTransactionResult &#123;</span><br><span class="line">  amount: <span class="built_in">number</span>,</span><br><span class="line">  fee: <span class="built_in">number</span>,</span><br><span class="line">  confirmations: <span class="built_in">number</span>,</span><br><span class="line">  blockhash: <span class="built_in">string</span>,</span><br><span class="line">  blockindex: <span class="built_in">number</span>,</span><br><span class="line">  blocktime: <span class="built_in">number</span>,</span><br><span class="line">  txid: <span class="built_in">string</span>,</span><br><span class="line">  walletconflicts: <span class="built_in">any</span>[],</span><br><span class="line">  time: <span class="built_in">number</span>,</span><br><span class="line">  timereceived: <span class="built_in">number</span>,</span><br><span class="line">  <span class="string">"bip125-replaceable"</span>: <span class="string">"no"</span> | <span class="string">"yes"</span> | <span class="string">"unknown"</span>,</span><br><span class="line">  details: <span class="built_in">any</span>[]</span><br><span class="line">  hex: <span class="built_in">string</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于提交给网络的交易的基本信息。</p><h2 id="IContractSendReceipt"><a href="#IContractSendReceipt" class="headerlink" title="IContractSendReceipt"></a>IContractSendReceipt</h2><p><a href="#send">Contract#send</a> 的合约收据, 带有解码的事件日志</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IContractSendReceipt <span class="keyword">extends</span> IRPCGetTransactionReceiptBase &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 使用 ABI 解码的日志</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  logs: IDecodedLog[],</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 未解码的日志</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  rawlogs: ITransactionLog[],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解码的 Solidity 事件日志</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IDecodedLog &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 事件日志名称</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">type</span>: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 键值映射作为事件日志参数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  [key: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实例</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"blockHash"</span>: <span class="string">"3b53ad132c26f9c30e5be9f664573428dad8b52e167becea4428d6903cb32740"</span>,</span><br><span class="line">  <span class="attr">"blockNumber"</span>: <span class="number">13917</span>,</span><br><span class="line">  <span class="attr">"transactionHash"</span>: <span class="string">"79338589bb75e1865be889142890a4e25d3b9dbd454ce3f3c2614587c85e2ed3"</span>,</span><br><span class="line">  <span class="attr">"transactionIndex"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"from"</span>: <span class="string">"dcd32b87270aeb980333213da2549c9907e09e94"</span>,</span><br><span class="line">  <span class="attr">"to"</span>: <span class="string">"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3"</span>,</span><br><span class="line">  <span class="attr">"cumulativeGasUsed"</span>: <span class="number">39306</span>,</span><br><span class="line">  <span class="attr">"gasUsed"</span>: <span class="number">39306</span>,</span><br><span class="line">  <span class="attr">"contractAddress"</span>: <span class="string">"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3"</span>,</span><br><span class="line">  <span class="attr">"logs"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"Mint"</span>,</span><br><span class="line">      <span class="attr">"to"</span>: <span class="string">"dcd32b87270aeb980333213da2549c9907e09e94"</span>,</span><br><span class="line">      <span class="attr">"amount"</span>: <span class="string">"7d0"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"Transfer"</span>,</span><br><span class="line">      <span class="attr">"from"</span>: <span class="string">"0000000000000000000000000000000000000000"</span>,</span><br><span class="line">      <span class="attr">"to"</span>: <span class="string">"dcd32b87270aeb980333213da2549c9907e09e94"</span>,</span><br><span class="line">      <span class="attr">"value"</span>: <span class="string">"7d0"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"rawlogs"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"address"</span>: <span class="string">"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3"</span>,</span><br><span class="line">      <span class="attr">"topics"</span>: [</span><br><span class="line">        <span class="string">"0f6798a560793a54c3bcfe86a93cde1e73087d944c0ea20544137d4121396885"</span>,</span><br><span class="line">        <span class="string">"000000000000000000000000dcd32b87270aeb980333213da2549c9907e09e94"</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"data"</span>: <span class="string">"00000000000000000000000000000000000000000000000000000000000007d0"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"address"</span>: <span class="string">"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3"</span>,</span><br><span class="line">      <span class="attr">"topics"</span>: [</span><br><span class="line">        <span class="string">"ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef"</span>,</span><br><span class="line">        <span class="string">"0000000000000000000000000000000000000000000000000000000000000000"</span>,</span><br><span class="line">        <span class="string">"000000000000000000000000dcd32b87270aeb980333213da2549c9907e09e94"</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"data"</span>: <span class="string">"00000000000000000000000000000000000000000000000000000000000007d0"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="#irpcgettransactionreceiptbase">IRPCGetTransactionReceiptBase</a></li></ul><h2 id="IRPCWaitForLogsRequest"><a href="#IRPCWaitForLogsRequest" class="headerlink" title="IRPCWaitForLogsRequest"></a>IRPCWaitForLogsRequest</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IRPCWaitForLogsRequest &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 查找日志的开始块号。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  fromBlock?: <span class="built_in">number</span> | <span class="string">"latest"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 查找日志的停止块号. 如果是 null, 会无限期等待</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  toBlock?: <span class="built_in">number</span> | <span class="string">"latest"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 过滤日志的条件。 地址和主题分别指定为十六进制字符串数组</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  filter?: ILogFilter,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 日志返回前的最少确认数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  minconf?: <span class="built_in">number</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IContractEventLogs"><a href="#IContractEventLogs" class="headerlink" title="IContractEventLogs"></a>IContractEventLogs</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询合约事件日志的结果。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IContractEventLogs &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 事件日志, ABI 解码.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  entries: IContractEventLog[]</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回的事件日志数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  count: <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 要开始查询新事件日志的块号</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  nextblock: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询合约事件日志的结果。</p><p>要查询尚未出现的新日志，请在查询事件日志时将 <code>nextblock</code> 用作 <code>startBlock</code>：</p><ul><li><a href="#icontracteventlog">IContractEventLog</a></li></ul><h2 id="IContractEventLog"><a href="#IContractEventLog" class="headerlink" title="IContractEventLog"></a>IContractEventLog</h2><p>一条解码的合约事件日志</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IContractLogEntry <span class="keyword">extends</span> ILogEntry &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Solidity 事件, ABI 解码. 如果没有找到 ABI 定义，为 Null</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  event?: ISolidityEvent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  qtumd 返回的原始日志数据，不是 ABI 解码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ILogEntry <span class="keyword">extends</span> IRPCGetTransactionReceiptBase &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * EVM 日志主题</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  topics: <span class="built_in">string</span>[]</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * EVM 日志数据, 十六进制字符串</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  data: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * qtumd 返回的交易收据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IRPCGetTransactionReceiptBase &#123;</span><br><span class="line">  blockHash: <span class="built_in">string</span></span><br><span class="line">  blockNumber: <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line">  transactionHash: <span class="built_in">string</span></span><br><span class="line">  transactionIndex: <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">from</span>: <span class="built_in">string</span></span><br><span class="line">  to: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  cumulativeGasUsed: <span class="built_in">number</span></span><br><span class="line">  gasUsed: <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line">  contractAddress: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实例</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"blockHash"</span>: <span class="string">"369c6ded05c27ae7efc97964cce083b0ea9b8b950e67c51e52cb1bf898b9c415"</span>,</span><br><span class="line">  <span class="string">"blockNumber"</span>: <span class="number">12184</span>,</span><br><span class="line">  <span class="string">"transactionHash"</span>: <span class="string">"d1638a53f38fd68c5763e2eef9d86b9fc6ee7ea3f018dae7b1e385b4a9a78bc7"</span>,</span><br><span class="line">  <span class="string">"transactionIndex"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="string">"from"</span>: <span class="string">"dcd32b87270aeb980333213da2549c9907e09e94"</span>,</span><br><span class="line">  <span class="string">"to"</span>: <span class="string">"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3"</span>,</span><br><span class="line">  <span class="string">"cumulativeGasUsed"</span>: <span class="number">39306</span>,</span><br><span class="line">  <span class="string">"gasUsed"</span>: <span class="number">39306</span>,</span><br><span class="line">  <span class="string">"contractAddress"</span>: <span class="string">"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3"</span>,</span><br><span class="line">  <span class="string">"topics"</span>: [</span><br><span class="line">    <span class="string">"0f6798a560793a54c3bcfe86a93cde1e73087d944c0ea20544137d4121396885"</span>,</span><br><span class="line">    <span class="string">"000000000000000000000000dcd32b87270aeb980333213da2549c9907e09e94"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"data"</span>: <span class="string">"00000000000000000000000000000000000000000000000000000000000003e8"</span>,</span><br><span class="line">  <span class="string">"event"</span>: &#123;</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"Mint"</span>,</span><br><span class="line">    <span class="string">"to"</span>: <span class="string">"dcd32b87270aeb980333213da2549c9907e09e94"</span>,</span><br><span class="line">    <span class="string">"amount"</span>: <span class="string">"3e8"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IDecodedSolidityEvent"><a href="#IDecodedSolidityEvent" class="headerlink" title="IDecodedSolidityEvent"></a>IDecodedSolidityEvent</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个解码的 Solidity 事件日志</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IDecodedSolidityEvent &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 事件名称</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">type</span>: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 键值映射作为事件日志参数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  [key: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Example</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"type"</span>: <span class="string">"Transfer"</span>,</span><br><span class="line">  <span class="string">"from"</span>: <span class="string">"0000000000000000000000000000000000000000"</span>,</span><br><span class="line">  <span class="string">"to"</span>: <span class="string">"dcd32b87270aeb980333213da2549c9907e09e94"</span>,</span><br><span class="line">  <span class="string">"value"</span>: <span class="string">"3e8"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解码的 Solidity 事件日志。 事件参数存储在键值映射中。</p><h2 id="IRPCGetTransactionReceiptBase"><a href="#IRPCGetTransactionReceiptBase" class="headerlink" title="IRPCGetTransactionReceiptBase"></a>IRPCGetTransactionReceiptBase</h2><p>网络接受的交易收据。它由 <code>gettransactionreceipt</code> RPC 调用返回。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IRPCGetTransactionReceiptBase &#123;</span><br><span class="line">  blockHash: <span class="built_in">string</span></span><br><span class="line">  blockNumber: <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line">  transactionHash: <span class="built_in">string</span></span><br><span class="line">  transactionIndex: <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">from</span>: <span class="built_in">string</span></span><br><span class="line">  to: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  cumulativeGasUsed: <span class="built_in">number</span></span><br><span class="line">  gasUsed: <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line">  contractAddress: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IContractsRepoData"><a href="#IContractsRepoData" class="headerlink" title="IContractsRepoData"></a>IContractsRepoData</h2><p>合约相关信息</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IContractsRepoData &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 部署合约的相关信息</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  contracts: &#123;</span><br><span class="line">    [key: <span class="built_in">string</span>]: IContractInfo,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 部署库的相关信息</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  libraries: &#123;</span><br><span class="line">    [key: <span class="built_in">string</span>]: IContractInfo,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 部署合约/库引用的合约信息，但未部署</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  related: &#123;</span><br><span class="line">    [key: <span class="built_in">string</span>]: &#123;</span><br><span class="line">      abi: IABIMethod[],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 与部署合约进行交互所需的最少部署信息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IContractInfo &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 合约的 ABI 定义, solc 生成.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  abi: IABIMethod[]</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 合约地址</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  address: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 合约所有者的地址</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  sender?: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IABIMethod &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  <span class="keyword">type</span>: <span class="built_in">string</span>,</span><br><span class="line">  payable: <span class="built_in">boolean</span>,</span><br><span class="line">  inputs: IABIInput[],</span><br><span class="line">  outputs: IABIOutput[],</span><br><span class="line">  constant: <span class="built_in">boolean</span>,</span><br><span class="line">  anonymous: <span class="built_in">boolean</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用开发工具 <a href="https://github.com/qtumproject/solar" target="_blank" rel="noopener">solar</a> 自动生成。</p><p>样例 <a href="https://github.com/qtumproject/qtumbook-mytoken-qtumjs-cli/blob/29fab6dfcca55013c7efa8ee5e91bbc8c40ca55a/solar.development.json.example" target="_blank" rel="noopener">solar.json</a>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;https://github.com/qtumproject/qtumjs-doc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/qtumproject/qtumjs-doc&lt;/a&gt;&lt;br&gt;译者
      
    
    </summary>
    
      <category term="区块链" scheme="http://xichen.pub/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://xichen.pub/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Qtum" scheme="http://xichen.pub/tags/Qtum/"/>
    
      <category term="翻译" scheme="http://xichen.pub/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】 Bitcoin Core 0.15.0版本说明</title>
    <link href="http://xichen.pub/2018/05/30/2018-05-30-%E7%BF%BB%E8%AF%91-BitcoinCore0.15.0%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E/"/>
    <id>http://xichen.pub/2018/05/30/2018-05-30-翻译-BitcoinCore0.15.0版本说明/</id>
    <published>2018-05-30T06:11:00.000Z</published>
    <updated>2018-09-01T09:10:04.367Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://bitcoin.org/en/release/v0.15.0" target="_blank" rel="noopener">https://bitcoin.org/en/release/v0.15.0</a><br>译者：中山大学数学学院（珠海）林学渊<br>大二时给量子做的翻译，转载注明出处，谢谢</p><h1 id="0-15-0版本说明"><a href="#0-15-0版本说明" class="headerlink" title="0.15.0版本说明"></a>0.15.0版本说明</h1><h2 id="当前对隔离见证的支持"><a href="#当前对隔离见证的支持" class="headerlink" title="当前对隔离见证的支持"></a>当前对隔离见证的支持</h2><p>版本0.15.0支持通过 <code>addwitnessaddress</code> RPC 添加隔离见证地址，但请注意，这是一个 测试/专家 RPC，它不保证从备份恢复。 要是你知道你在做什么，就使用这个 RPC 吧。下一个版本将提供更完整的隔离见证的钱包支持。</p><h2 id="加密钱包重新扫描"><a href="#加密钱包重新扫描" class="headerlink" title="加密钱包重新扫描"></a>加密钱包重新扫描</h2><p>和以前的版本一样，当使用加密的 HD 钱包时，如果没有解锁钱包，密钥池不会被自动检测。 这意味着，目前，如果要从加密 HD 钱包的备份恢复，用户必须用非常长的时间解锁钱包并手动触发重新扫描，否则当自动检测程序无法运行时，会有可能丢失一些密钥。 不幸的是，在这个版本中没有 <code>rescan</code> RPC，它放在以后的版本中。所以现在重新扫描可以使用其中一个 <code>import*</code> 命令触发，同时要用另一个（可信）钱包生成的虚拟地址。</p><h1 id="重大改动"><a href="#重大改动" class="headerlink" title="重大改动"></a>重大改动</h1><h2 id="性能改进"><a href="#性能改进" class="headerlink" title="性能改进"></a>性能改进</h2><p>版本0.15包含许多重要的性能改进，这使得初始块下载，启动，交易和块验证速度更快：</p><ul><li>链状态数据库 (用于跟踪 UTXO ) 已从每交易模型更改为每交易输出模型（请查看 <a href="https://github.com/bitcoin/bitcoin/pull/10195" target="_blank" rel="noopener">PR 10195</a>）。 这个模型的优点是它：<ul><li>避免反序列化和序列化未使用输出的CPU开销；</li><li>更可预测的内存使用情况;</li><li>更简单的代码;</li><li>适用于各种未来的缓存刷新策略。<br>因此，在初始块下载（IBD）和重新索引期间验证区块链的速度提高约30-40％，使用的内存减少10-20％，并且刷新到磁盘的频率要更低。 唯一的缺点是磁盘上的数据库大小增加15％。 在从以前的格式转换过来的过程中，可能会使用额外几千兆字节。</li></ul></li><li>早期版本在刷新 UTXO 到磁盘时遇到了内存使用量激增。 结果，实际只有一半的可用内存用作缓存，而另一半则被保留以应付数据刷新。 不会再有这种情况了（请查看 <a href="https://github.com/bitcoin/bitcoin/pull/10148" target="_blank" rel="noopener">PR 10148</a>），并且整个可用缓存（请查看 <code>-dbcache</code>）现在确实用作缓存。 这将数据刷新频率降低了2倍甚至更多。</li><li>在前面的版本中, 当交易被内存池接受时，交易的签名验证会被缓存。版本 0.15 版本0.15将其有效性扩展为缓存整个脚本（请查看 <a href="https://github.com/bitcoin/bitcoin/pull/10192" target="_blank" rel="noopener">PR 10192</a>）。 这意味着如果块中的交易已被内存池接受，私钥签名不需要重新计算。 经验测试表明，这使新块的验证速度提高40-50％。</li><li>LevelDB 已经升级到版本1.20 (请查看 <a href="https://github.com/bitcoin/bitcoin/pull/10544" target="_blank" rel="noopener">PR 10544</a>). 这个版本包括用于在支持SSE 4.2的体系结构中 CRC 的硬件加速 。因此，同步和块验证现在更快。</li><li>针对支持SSE 4的体系结构（参见 <a href="https://github.com/bitcoin/bitcoin/pull/10821" target="_blank" rel="noopener">PR 10821</a>），SHA256哈希已优化。 在支持的硬件上 SHA256 速度提高了约50％，这导致IBD和块验证速度提高了约5％。 在版本0.15中，默认情况下，发布版本中禁用SHA256硬件优化，但可以在构建时使用 <code>--enable-experimental-asm</code> 启用。 </li><li>重新填充密钥池不再刷新每个密钥对应的钱包，使创建新钱包的速度提高了20倍。 部分加速用来将默认密钥池增加到1000个密钥，以使恢复能力更加健壮。（见 <a href="https://github.com/bitcoin/bitcoin/pull/10831" target="_blank" rel="noopener">PR 10831</a>).</li></ul><h2 id="手续费评估的改进"><a href="#手续费评估的改进" class="headerlink" title="手续费评估的改进"></a>手续费评估的改进</h2><p>版本0.15中，手续费评估速度有了明显提高，钱包使用的手续费评估更准确，而对于<code>estimatesmartfee</code> 和 <code>estimaterawfee</code> RPC（见 <a href="https://github.com/bitcoin/bitcoin/pull/10199" target="_blank" rel="noopener">PR 10199</a>）的高级用户而言，手续费评估的可选范围更广。</p><h3 id="内部逻辑和钱包行为的变化"><a href="#内部逻辑和钱包行为的变化" class="headerlink" title="内部逻辑和钱包行为的变化"></a>内部逻辑和钱包行为的变化</h3><ul><li>手续费评估现在在3个不同的时间范围内进行跟踪。这使更长远的目标和评估方法能更迅速地适应条件的变化。</li><li>评估现在可以选择 <em>保守的</em> 或 <em>经济的</em>。 保守评估使用更长的时间范围来产生评估，不易受费用条件快速变化影响。经济评估使用更短的时间范围，受费用条件的短期变化影响更大。 在低交易活动期间（例如在周末），经济评估可能会相当低，但如果通行费用迅速增加，则可能导致交易未被证实。</li><li>默认，钱包使用保守的手续费评估来增加在预期目标内被确认的交易的可靠性。对于被标记为可替换的交易，钱包默认会使用经济评估，因为如果费用条件迅速变化，费用可能会“冲突” (查看 <a href="https://github.com/bitcoin/bitcoin/pull/10589" target="_blank" rel="noopener">PR 10589</a>).</li><li>现在可以对最多1008个块的确认目标进行评估（一周内）。</li><li>存储更多关于历史收费率的数据，从而使手续费评估更精确。</li><li>对由于驱逐或其他未确认的原因而离开内存池的交易，不再考虑手续费评估，使手续费评估更准确。</li><li>手续费评估逻辑将确保收集到足够的数据以返回有意义的估算值。 如果数据不足，则使用后备的默认费用。</li></ul><h3 id="手续费评估-RPC-的变化"><a href="#手续费评估-RPC-的变化" class="headerlink" title="手续费评估 RPC 的变化"></a>手续费评估 RPC 的变化</h3><ul><li><code>estimatefee</code> RPC 现在废弃了，建议使用 <code>estimatesmartfee</code> (支持 GUI)</li><li><code>estimatesmartfee</code> RPC 接口改变 (查看 <a href="https://github.com/bitcoin/bitcoin/pull/10707" target="_blank" rel="noopener">PR 10707</a>):<ul><li><code>nblocks</code> 参数重命名成 <code>conf_target</code> (与其他RPC方法一致).</li><li>增加 <code>estimate_mode</code> 参数. 该参数为以下字符串之一： <code>CONSERVATIVE</code>, <code>ECONOMICAL</code> 或 <code>UNSET</code> (默认是 <code>CONSERVATIVE</code>).</li><li>RPC返回对象现在包含一个 <code>error</code> 成员，它返回处理期间遇到的错误。</li><li>如果 Bitcoin Core 运行时间不够长，并且没有足够的数据块或交易来产生准确的手续费评估，则会返回一个错误（之前使用-1表示错误，这可能会导致费率混淆）。</li></ul></li><li>新增 <code>estimaterawfee</code> RPC 提供原始费用数据. 外部客户端可以在他们自己的手续费评估逻辑中查询和使用这些数据。</li></ul><h2 id="多钱包支持"><a href="#多钱包支持" class="headerlink" title="多钱包支持"></a>多钱包支持</h2><p>Bitcoin Core现在支持加载多个独立钱包 (查看 <a href="https://github.com/bitcoin/bitcoin/pull/8694" target="_blank" rel="noopener">PR 8694</a>, <a href="https://github.com/bitcoin/bitcoin/pull/10849" target="_blank" rel="noopener">PR 10849</a>).钱包是完全分开的，具有个人余额，钥匙和收到的交易.</p><p>启动比特币时使用 <code>-wallet</code> 参数可启用多钱包，在命令行或比特币配置文件中都可以。</p><p><strong>在Bitcoin-Qt中，只有第一个钱包才会显示并可用于创建和签署交易。</strong> 未来版本将支持 GUI 来选多个钱包。 但是，即使在版本0.15的其他加载的钱包中，仍然会与后台节点的当前提示保持同步。 这可能很有用，如果是运行一个修剪过的节点的话，因为加载一个最新同步超出修剪高度的钱包导致必须下载并重新验证整个区块链。 继续同步后台中的所有钱包可避免此问题。</p><p>Bitcoin Core 0.15.0 包括下列RPC接口的改动及多钱包的 <code>bitcoin-cli</code> :</p><ul><li>当用一个钱包运行 Bitcoin Core 时，RPC 接口或  <code>bitcoin-cli</code> <strong>不会</strong> 变化。所有 RPC 调用和 <code>bitcoin-cli</code> 命令和之前一样继续运行.</li><li>当用多钱包运行 Bitcoin Core 时, 所有 <em>节点级</em> RPC 方法和之前一样继续运行. HTTP RPC 请求应该发送至 <code>&lt;RPC IP address&gt;:&lt;RPC port&gt;</code> , 并且 <code>bitcoin-cli</code> 命令应该和之前一样继续运行. 一个 <em>节点级</em> RPC 方法是不需要访问钱包的任意方法。</li><li>当用多钱包运行 Bitcoin Core 时, <em>钱包级</em> RPC 方法必须指定他们在每个请求中所针对的钱包。 HTTP RPC 请求应该发送至 <code>&lt;RPC IP address&gt;:&lt;RPC port&gt;/wallet/&lt;wallet name&gt;</code> , 例如 <code>127.0.0.1:8332/wallet/wallet1.dat</code>. <code>bitcoin-cli</code> 命令应该使用 <code>-rpcwallet</code> 选项运行, 例如 <code>bitcoin-cli -rpcwallet=wallet1.dat getbalance</code>.</li><li>添加了一个新的 <em>节点级</em> <code>listwallets</code> RPC 方法来显示当前加载哪些钱包。 此方法返回的名称与HTTP端点和 <code>rpcwallet</code> 参数中使用的名称相同。</li></ul><p>请注意，虽然现在完全支持多钱包，但对于版本0.15.0，RPC多钱包界面应被视为不稳定，并且未来版本中可能存在向后不兼容的更改。</p><h2 id="在GUI中-RBF-replace-by-fee-控制"><a href="#在GUI中-RBF-replace-by-fee-控制" class="headerlink" title="在GUI中 RBF(replace-by-fee)控制"></a>在GUI中 RBF(replace-by-fee)控制</h2><p>Bitcoin Core 支持从版本0.12.0开始创建 replace-by-fee（RBF）交易，并且自0.14.0版本开始包含一个 <code>bumpfee</code> RPC 方法，用支付更高费用的新交易取代未经证实的选择性RBF交易。</p><p>在版本0.15中，创建一个选择性的RBF交易，和用更高费用的交易替换未确认的交易都在GUI中支持（见 <a href="https://github.com/bitcoin/bitcoin/pull/9592" target="_blank" rel="noopener">PR 9592</a>).</p><h2 id="移除币龄优先"><a href="#移除币龄优先" class="headerlink" title="移除币龄优先"></a>移除币龄优先</h2><p>Bitcoin Core前面的版本中, 每块的一部分可以根据他们花费的 UTXO 的年龄和价值预留给交易。 这个概念（币龄优先）是矿工的一项政策选择，并且没有围绕包括币龄优先交易的共识规则。 在实践中，只有少数矿工继续使用币龄优先进行交易。 Bitcoin Core 0.15删除了币龄优先的所有支持（见 <a href="https://github.com/bitcoin/bitcoin/pull/9602" target="_blank" rel="noopener">PR 9602</a>）。 这具有以下意义：</p><ul><li><em>免费交易</em> 的概念已被移除。即使没有附加矿工费，高币龄优先交易也会允许进行转账。 这是不可能的，因为不再有币龄优先的概念。 控制免费交易的<code>-limitfreerelay</code> 和 <code>-relaypriority</code> 选项已被移除。</li><li><code>-sendfreetransactions</code> 选项已被移除, 因为几乎所有的矿工都不要不附加交易费的交易。</li><li><code>-blockprioritysize</code> 选项已被移除.</li><li><code>estimatepriority</code> 和 <code>estimatesmartpriority</code> RPCs 已被移除.</li><li><code>getmempoolancestors</code>, <code>getmempooldescendants</code>, <code>getmempoolentry</code> 和 <code>getrawmempool</code> RPCs 不再返回 <code>startingpriority</code> 和 <code>currentpriority</code>.</li><li><code>prioritisetransaction</code> RPC 不再有 <code>priority_delta</code> 参数, 它替换成 <code>dummy</code> 参数，以便与使用位置参数的客户端向后兼容。 RPC 仍然适用于通过使用<code>fee_delta</code> 参数来改变交易的明显费率。</li><li><code>-minrelaytxfee</code> 现在可以设为 0. 如果设置了 <code>minrelaytxfee</code> , 那么小于 <code>minrelaytxfee</code> (每 kB) 的费用拒绝中继，挖掘和创建交易。默认为1000 satoshi / kB。</li><li><code>-printpriority</code> 选项升级为只在挖矿代码输出费率和包含在块中的交易哈希.</li></ul><h2 id="内存池持久化重启"><a href="#内存池持久化重启" class="headerlink" title="内存池持久化重启"></a>内存池持久化重启</h2><p>版本0.14 引入了内存池持久化重启（内存池在关闭之前保存到数据目录中的 <code>mempool.dat</code> 文件中，并在节点重新启动时恢复内存池）。 版本0.15允许使用<code>-persistmempool</code> 命令行选项打开或关闭此功能（请参阅 <a href="https://github.com/bitcoin/bitcoin/pull/9966" target="_blank" rel="noopener">PR 9966</a>）。 默认情况下，该选项设置为true，内存池在关机时保存并在启动时重新加载。 如果设置为false，则 <code>mempool.dat</code> 文件将不会在启动时加载或在关闭时保存。</p><h2 id="新-RPC-方法"><a href="#新-RPC-方法" class="headerlink" title="新 RPC 方法"></a>新 RPC 方法</h2><p>版本 0.15 引入一些新的 RPC 方法:</p><ul><li><code>abortrescan</code> 停止当前钱包的重新扫描, 比如，在被一个 <code>importprivkey</code> 调用触发时 (查看 <a href="https://github.com/bitcoin/bitcoin/pull/10208" target="_blank" rel="noopener">PR 10208</a>).</li><li><code>combinerawtransaction</code> 接受一个原始交易的JSON数组，将它们组合成一个原始交易 (查看 <a href="https://github.com/bitcoin/bitcoin/pull/10571" target="_blank" rel="noopener">PR 10571</a>).</li><li><code>estimaterawfee</code> 返回原始费用数据，以便可以使用定制的逻辑来分析数据并计算估算值。 有关费用估算逻辑和接口更改的完整详细信息，请参阅 <a href="#fee-estimation-improvements">手续费评估的改进</a> </li><li><code>getchaintxstats</code> 返回关于链中交易总数和速率的统计信息(查看 <a href="https://github.com/bitcoin/bitcoin/pull/9733" target="_blank" rel="noopener">PR 9733</a>).</li><li><code>listwallets</code> 列出当前加载的钱包。查看<em>多钱包</em>  ( <a href="#multi-wallet-support">多钱包支持</a>) 获得更多细节。</li><li><code>uptime</code> 返回自上次启动以来 <code>bitcoind</code> 服务器的总运行时间 (查看 <a href="https://github.com/bitcoin/bitcoin/pull/10400" target="_blank" rel="noopener">PR 10400</a>).</li></ul><h2 id="底层-RPC-更改"><a href="#底层-RPC-更改" class="headerlink" title="底层 RPC 更改"></a>底层 RPC 更改</h2><ul><li><p>在使用 Bitcoin Core 的多钱包模式时, 钱包方法的RPC请求必须指定它们的用途。 有关完整的详细信息，请参阅 <a href="#multi-wallet-support">多钱包支持</a> 。</p></li><li><p>新的数据库模型不再存储关于未使用输出的交易版本的信息（请参阅 <a href="#performance-improvements">性能改进</a>). 这意味着:</p><ul><li><code>gettxout</code> RPC 的返回不再有 <code>version</code> 字段.</li><li><code>gettxoutsetinfo</code> RPC 报告 <code>hash_serialized_2</code> 而不是<code>hash_serialized</code>, 后者没有提交未使用输出的交易版本，但确实提交了高度和coinbase 信息。</li><li><code>getutxos</code> REST 路径不再以JSON格式报告 <code>txvers</code> 字段。<br>始终以二进制格式报告交易版本为0。</li></ul></li><li><p><code>estimatefee</code> RPC 废弃. 用户应该转向使用 <code>estimatedmartfee</code> RPC，这会返回更好的费用估算。查看 <a href="#fee-estimation-improvements">手续费评估的改进</a> 详细了解费用估算逻辑和接口的变化。</p></li><li><p><code>gettxoutsetinfo</code> 的返回现在包含 <code>disk_size</code> 和 <code>bogosize</code> 而不是<br><code>bytes_serialized</code>。第一个是对实际磁盘使用情况的更准确的估计，但不是确定性的。 第二个与磁盘使用无关，但也与UTXO集大小无关，与数据库无关:它将每个UTXO条目计数为 50 + 其scriptPubKey长度 (查看 <a href="https://github.com/bitcoin/bitcoin/pull/10426" target="_blank" rel="noopener">PR 10426</a>).</p></li><li><p><code>signrawtransaction</code> 不能再用于将多个交易组合为单个交易. 作为替代, 使用新的 <code>combinerawtransaction</code> RPC (查看 <a href="https://github.com/bitcoin/bitcoin/pull/10571" target="_blank" rel="noopener">PR 10571</a>).</p></li><li><p><code>fundrawtransaction</code> 不再接受一个 <code>reserveChangeKey</code> 选项. 此选项用于允许 RPC 用户使用密钥池中的密钥为更改地址提供原始交易处理，而无需将其从密钥池中的可用密钥中移除。密匙能重用，通过调用 <code>getnewaddress</code> , 但这可能会导致混淆或危险的行为 (查看 <a href="https://github.com/bitcoin/bitcoin/pull/10784" target="_blank" rel="noopener">PR 10784</a>).</p></li><li><p><code>estimatepriority</code> 和 <code>estimatesmartpriority</code> 已被移除. 查看 <a href="#removal-of-coin-age-priority">移除币龄优先</a>.</p></li><li><p><code>listunspent</code> RPC 现在可以接受一个 <code>query_options</code> 参数 (查看 <a href="https://github.com/bitcoin/bitcoin/pull/8952" target="_blank" rel="noopener">PR 8952</a>), 它是一个包含一个或多个以下成员的JSON字段：</p><ul><li><code>minimumAmount</code> - 一个数字，指定每个UTXO的最小值</li><li><code>maximumAmount</code> - 一个数字，指定每个UTXO的最大值</li><li><code>maximumCount</code> - 一个数字，指定UTXO的最小数量</li><li><code>minimumSumAmount</code> - 一个数字，指定UTXO的最大数量</li></ul></li><li><p><code>getmempoolancestors</code>, <code>getmempooldescendants</code>, <code>getmempoolentry</code> 和 <code>getrawmempool</code> RPCs 不再返回 <code>startingpriority</code> 和 <code>currentpriority</code>. 查看 <a href="#removal-of-coin-age-priority">移除币龄优先</a>.</p></li><li><p><code>dumpwallet</code> RPC 现在返回虚拟钱包（dumped wallet）的完整绝对路径. 即使成功，它也不会返回任何值 (查看 <a href="https://github.com/bitcoin/bitcoin/pull/9740" target="_blank" rel="noopener">PR 9740</a>).</p></li></ul><ul><li><p><code>getpeerinfo</code> RPC中, 每个peer的返回对象现在返回一个 <code>addrbind</code> 成员，其中包含到peer的连接的IP地址和端口。 这是除了包含本地节点的IP地址和端口的 <code>addrlocal</code> 成员之外，由peer方报告的成员 (查看 <a href="https://github.com/bitcoin/bitcoin/pull/10478" target="_blank" rel="noopener">PR 10478</a>).</p></li><li><p><code>disconnectnode</code> RPC 现在可以断开由节点ID（以及IP地址/端口）指定的节点。 要根据节点ID断开节点，请使用新的 <code>nodeid</code> 参数 (查看 <a href="https://github.com/bitcoin/bitcoin/pull/10143" target="_blank" rel="noopener">PR 10143</a>).</p></li><li><p><code>prioritisetransaction</code> 的第二个参数已经从 <code>priority_delta</code> 重命名成 <code>dummy</code>，因为 Bitcoin Core 不再有币龄优先的概念。 <code>dummy</code> 参数没有功能影响，但为了兼容性保留位置。查看 <a href="#removal-of-coin-age-priority">移除币龄优先</a>.</p></li><li><p><code>resendwallettransactions</code> RPC 抛出错误如果 <code>-walletbroadcast</code> 选项设置为 false (查看 <a href="https://github.com/bitcoin/bitcoin/pull/10995" target="_blank" rel="noopener">PR 10995</a>).</p></li><li><p><code>submitblock</code> RPC 的第二个参数从 <code>parameters</code> 重命名为 <code>dummy</code>. 这个参数从来没有任何效果，重命名只是将这个事实传达给用户 (查看 <a href="https://github.com/bitcoin/bitcoin/pull/10191" target="_blank" rel="noopener">PR 10191</a>)<br>(用户应该，无论如何，使用 <code>submitblock</code> 的位置参数以便与BIP 22兼容。)</p></li><li><p><code>getblock</code> 的 <code>verbose</code> 参数重命名成 <code>verbosity</code> ，现在接受 0 到 2 的int整数. verbose等级0等同于 <code>verbose=false</code>。 verbose等级1相当于<code>verbose=true</code>. Verbose 等级 2 将给出由 <code>getrawtransaction</code> 给出的输出中每个交易的完整交易详情。为了兼容性，仍旧保留使用详细命名参数和布尔值的旧行为。</p></li><li>错误代码已更新为更准确的以下错误情况 (查看 <a href="https://github.com/bitcoin/bitcoin/pull/9853" target="_blank" rel="noopener">PR 9853</a>):<ul><li><code>getblock</code> 现在返回 RPC_MISC_ERROR 如果区块在硬盘上找不到 (比如如果区块被修剪). 之前返回 RPC_INTERNAL_ERROR.</li><li><code>pruneblockchain</code> 现在返回 RPC_MISC_ERROR 如果由于节点不是处于修剪模式而无法修剪区块。 之前返回 RPC_METHOD_NOT_FOUND.</li><li><code>pruneblockchain</code> 现在返回 RPC_INVALID_PARAMETER 如果由于提供的时间戳太晚了而无法修剪区块. 之前返回 RPC_INTERNAL_ERROR.</li><li><code>pruneblockchain</code> 现在返回 RPC_MISC_ERROR 如果由于区块链太短而无法修剪区块. 之前返回 RPC_INTERNAL_ERROR.</li><li><code>setban</code> 现在返回 RPC_CLIENT_INVALID_IP_OR_SUBNET if the supplied IP address<br>or subnet is invalid. 之前返回 RPC_CLIENT_NODE_ALREADY_ADDED.</li><li><code>setban</code> 现在返回 RPC_CLIENT_INVALID_IP_OR_SUBNET 如果提供的IP地址或子网无效. 之前返回 RPC_MISC_ERROR.</li><li><code>removeprunedfunds</code> 现在返回 RPC_WALLET_ERROR 如果 <code>bitcoind</code> 无法移除交易. 之前返回 RPC_INTERNAL_ERROR.</li><li><code>removeprunedfunds</code> 现在返回 RPC_INVALID_PARAMETER 如果在钱包中交易不存在. 之前返回 RPC_INTERNAL_ERROR.</li><li><code>fundrawtransaction</code> 现在返回 RPC_INVALID_ADDRESS_OR_KEY 如果提供了无效的更改地址. 之前返回 RPC_INVALID_PARAMETER.</li><li><code>fundrawtransaction</code> 现在返回 RPC_WALLET_ERROR 如果 <code>bitcoind</code> 不能创建一个交易. 错误消息提供了更多详细信息。. 之前返回  RPC_INTERNAL_ERROR.</li><li><code>bumpfee</code> 现在返回 RPC_INVALID_PARAMETER 如果提供的交易在钱包中有后代. 之前返回 RPC_MISC_ERROR.</li><li><code>bumpfee</code> 现在返回 RPC_INVALID_PARAMETER 如果提供的交易在内存池中有后代. 之前返回 RPC_MISC_ERROR.</li><li><code>bumpfee</code> 现在返回 RPC_WALLET_ERROR 如果提供的交易已被开采或与挖矿交易发生冲突. 之前返回 RPC_INVALID_ADDRESS_OR_KEY.</li><li><code>bumpfee</code> 现在返回 RPC_WALLET_ERROR 如果提供的交易不是BIP 125可替换. 之前返回 RPC_INVALID_ADDRESS_OR_KEY.</li><li><code>bumpfee</code> 现在返回 RPC_WALLET_ERROR 如果提供的交易已经被不同的交易冲突. 之前返回 RPC_INVALID_REQUEST.</li><li><code>bumpfee</code> 现在返回 RPC_WALLET_ERROR 如果提供的交易包含不属于该钱包的输入. 之前返回 RPC_INVALID_ADDRESS_OR_KEY.</li><li><code>bumpfee</code> 现在返回 RPC_WALLET_ERROR 如果提供的交易有多个变更输出. 之前返回 RPC_MISC_ERROR.</li><li><code>bumpfee</code> 现在返回 RPC_WALLET_ERROR 如果提供的交易没有变化输出. 之前返回 RPC_MISC_ERROR.</li><li><code>bumpfee</code> 现在返回 RPC_WALLET_ERROR 如果手续费太高. 之前返回RPC_MISC_ERROR.</li><li><code>bumpfee</code> 现在返回 RPC_WALLET_ERROR 如果手续费太低. 之前返回RPC_MISC_ERROR.</li><li><code>bumpfee</code> 现在返回 RPC_WALLET_ERROR 如果变化的产出太小而不能收费. 之前返回 RPC_MISC_ERROR.</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;https://bitcoin.org/en/release/v0.15.0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://bitcoin.org/en/release/v0.15.0&lt;/a&gt;&lt;br&gt;译者：中山大学数
      
    
    </summary>
    
      <category term="区块链" scheme="http://xichen.pub/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://xichen.pub/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Qtum" scheme="http://xichen.pub/tags/Qtum/"/>
    
      <category term="翻译" scheme="http://xichen.pub/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】 十大 Qtum 新用户会问的问题</title>
    <link href="http://xichen.pub/2018/05/24/2018-05-24-%E7%BF%BB%E8%AF%91-%E5%8D%81%E5%A4%A7Qtum%E6%96%B0%E7%94%A8%E6%88%B7%E4%BC%9A%E9%97%AE%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://xichen.pub/2018/05/24/2018-05-24-翻译-十大Qtum新用户会问的问题/</id>
    <published>2018-05-24T06:11:00.000Z</published>
    <updated>2018-09-01T09:04:47.018Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://medium.com/@jb395official/top-10-qtum-new-user-questions-april-22-2018-307a65dad83f" target="_blank" rel="noopener">https://medium.com/@jb395official/top-10-qtum-new-user-questions-april-22-2018-307a65dad83f</a><br>译者：中山大学数学学院（珠海）林学渊<br>大二时给量子做的翻译，转载注明出处，谢谢</p><h1 id="十大-Qtum-新用户会问的问题-2018年4月22日"><a href="#十大-Qtum-新用户会问的问题-2018年4月22日" class="headerlink" title="十大 Qtum 新用户会问的问题 - 2018年4月22日"></a>十大 Qtum 新用户会问的问题 - 2018年4月22日</h1><p>以下是 Qtum 新用户的前 10 个问题和回答，但首先是关于 Qtum 主网性能和网络权重的更新。</p><p>我是独立的区块链研究人员，喜欢在 Qtum 社区混，最近担任社交媒体渠道的管理员。 我很欣赏 Qtum 团队的技术指导，希望很快能在网上与你聊天。 下面分析的数据来自屏幕抓取<a href="https://qtum.info/" target="_blank" rel="noopener">区块链资源管理器</a>，从 <a href="https://github.com/JB395/QtumMon" target="_blank" rel="noopener">qtumd 服务器钱包记录</a>，以及来自 Lisboa 的 <a href="https://goo.gl/maps/B9dyrhV1p3K2" target="_blank" rel="noopener">A Ginjinha</a> 的加密电报消息。</p><hr><h2 id="网络权重"><a href="#网络权重" class="headerlink" title="网络权重"></a>网络权重</h2><p>新用户留步 - 这是对区块链性能的一些更详细的分析 - 你可以跳到下面的 Q&amp;A 一节。</p><p>钱包计算网络权重的估计值，用于给出块奖励的平均时间。 钱包算法是短期的，并且有一些变化。 网络权重来源于赢得下一个区块奖励的难度，该区块奖励会根据Qtum股权证明中的每个区块进行调整。 以下是从4月15日至21日所有区块的钱包计算的网络权重估算图：</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*HlufWe2LbEVsHHQAwJ_9pQ.jpeg" alt=""></p><p>这个博客的定期读者知道我在比钱包更长的时间范围内计算我自己的网络权重估计值，还有更多的数据点。 4月15日至21日，已知余额326万美元的大钱包在 4207 块奖励中获得 684 个奖励，网络权重为2000万美元。 </p><p>网络权重为 2000 万，意味着参与 stake 采矿的 Qtum 钱包的年回报率为4.4％[参考文献1]：</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*bDrvGJpdyyVJV2GfPfVy1g.jpeg" alt=""></p><h2 id="块间​​距"><a href="#块间​​距" class="headerlink" title="块间​​距"></a>块间​​距</h2><p>Qtum 的块间隔平均大约 144 秒，或每天 600 块。 调整块奖励难度以保持该平均间隔，但是由随机抽奖算法选择块奖励获胜者引起的块间距存在一些变化。 下面的柱状图显示了 4 月 15 日至 21 日分组为 16 秒桶的块间隔数，其中块间距为 2 秒至 256 秒。 在这段时间里，有两个区块间隔大于 20 分钟，最长的区块在 26:55 处是 138,226。</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*2ioRZNg1E8emtXQb2tVWOA.jpeg" alt=""></p><h2 id="电报翻译"><a href="#电报翻译" class="headerlink" title="电报翻译"></a>电报翻译</h2><p>社交网络上的 Qtum 社区拥有全球成员（就像全球有 Qtum 节点一样）。 Qtum Telegram 提供英语，西班牙语，中文，韩语和俄语的频道。 为了帮助沟通，你可以将 Google Chrome 与电报网络版一起使用，并让 Google 翻译提高你的语言技能：</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*L2s2bRYMAURWx60G86Hl6A.jpeg" alt=""></p><p><img src="https://cdn-images-1.medium.com/max/1200/1*C5ws3EAbwEb6wK4F7POsLQ.jpeg" alt=""></p><p>如果你正在翻译 Telegram note，那么用户名也将被翻译，这可以给出一些有趣的结果。 点击 Chrome 浏览器地址栏最右侧的 Google 翻译图标，然后选择“选项”来管理翻译。</p><p>出于安全原因，必须输入你的电报帐户的用户名，这在全球所有电报渠道中都是唯一的。 此外，如果我可以要求电报用户输入一个配置文件照片，只是为了让它更有趣。 它不一定是 Instagram 那种质量的图片，也可以放你的宠物，最喜欢的旅游景点等，你甚至可以放在多张照片，并显示你的个性，例如，看到我的第二张照片😉。</p><hr><h1 id="十大-Qtum新用户会问的问题"><a href="#十大-Qtum新用户会问的问题" class="headerlink" title="十大 Qtum新用户会问的问题"></a>十大 Qtum新用户会问的问题</h1><p>欢迎来到 Qtum！ 加密货币欢迎新用户加入他们的社区。 新用户意味着增长，采用，新想法和新问题。 来自新用户的唯一愚蠢问题就是未经询问的问题。 Cryptocurrencies 和区块链 2.0 是一种快速发展的技术，有很多值得学习的东西，几个月前的活跃用户似乎是专家。 作为一个新用户，我希望这个 Q&amp;A 将加速你对Qtum的认识，并且在几个月内，你也可以成为专家。 如果你是Qtum的新手，以下参考资料中的词汇表可能会对术语有所帮助。</p><h2 id="Q-1"><a href="#Q-1" class="headerlink" title="Q 1."></a>Q 1.</h2><p>我需要投入多少 QTUM？ 如何为 Staking 工作提供奖励？ 是否有masternodes(主节点)？</p><p>你可以在你的钱包中使用低至 1.0 QTUM，但需要更多的奖励才能赢得块奖励。 Qtum 使用权益证明(PoS)，在随机抽奖过程中获得块奖励，其中获胜的可能性取决于你的钱包中的硬币数量与网络上的硬币总数。 每个 Qtum Core 钱包都是网络上分散的完整节点; 没有masternodes(主节点)。</p><p>你 stake 的硬币越多，你的钱包就越能赢得 4 QTUM的奖励。 Staking 将会给予每年几个百分点的回报。 要估算块奖励的平均时间，请检查 <a href="https://qtum.info/misc/stake-calculator" target="_blank" rel="noopener">stake 计算器</a>。 这个估计值是一个区块奖励的平均时间，Qtum区块奖励不会像池塘挖掘一样累积或累积，并且你的区块奖励可能会早于估计值或稍后。 在 staking 中，将你的硬币分成不同的钱包或不同的地址不会改变你获胜的几率; 只有一种方法可以提高你的赔率：购买更多的 QTUM！</p><h2 id="Q-2"><a href="#Q-2" class="headerlink" title="Q 2."></a>Q 2.</h2><p>什么钱包可用于 staking？</p><p>只有 Qtum Core 钱包（qtum-qt 桌面 GUI 钱包，qtumd 服务器钱包）可用于 staking。 这些钱包在 Qtum 网络上运行一个完整的节点，通过实时验证所有事务/块来保护网络，并接收块奖励作为这项工作的激励。 放钱包应该全天候运行，因为它们只能在线时获得奖励。 下面的例子集中在 qtum-qt，这是一个非常适合初学者的桌面 GUI 钱包，但你也可以使用 qtumd 和命令行界面。</p><p>你可以从<a href="https://qtumeco.io/wallet" target="_blank" rel="noopener">Qtum网站</a>下载最新的Qtum Core钱包：</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*xJ3GlmvvlPKyaiJAOreNgA.jpeg" alt=""></p><p>非新手用户可能对 Qtum Project GitHub 存储库感兴趣，其中包含所有钱包分发包和 <a href="https://github.com/qtumproject/qtum/releases" target="_blank" rel="noopener">GitHub</a> 上的SHA-256哈希验证。</p><h2 id="Q-3"><a href="#Q-3" class="headerlink" title="Q 3."></a>Q 3.</h2><p>还有哪些钱包？ </p><p>除 Qtum Core 钱包外，Qtum 还提供 Web 钱包（如MyEtherWallet），Electrum 钱包（支持 Ledger 和 Trezor 硬件钱包）和 Android 手机钱包。 在 qtumeco.io/wallet 获取这些钱包。</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*1bsmuRj1gQ3c99Ik82gS7A.jpeg" alt=""></p><h1 id="Q-4"><a href="#Q-4" class="headerlink" title="Q 4."></a>Q 4.</h1><p>我的QTUM丢失了。 Blockchain Explorer说我的余额太低了，wtf？ [参考文献2]</p><p>这可能是新手遇到的最常见的问题（不要问我怎么知道，但是对于 Earlz 来说，在 Testnet 早期的时候为新手回答了这个问题），特别是如果你是区块链的新手，或来自具有帐户架构的区块链。 </p><p>Qtum 使用 Unspent Transaction Output（UTXO）模型存储值，与比特币相同。 这意味着当你发送 QTUM 交易时，你的钱包将选择以前的一笔或多笔交易，交易金额超过你支付的金额，并全部发送这些交易。 你的钱包还将提供一个“更改地址”，以便返回更改。</p><p><img src="https://cdn-images-1.medium.com/max/1200/1*DEBFKI_0ObnVxCSJzQFyYw.jpeg" alt=""></p><p>像这样想。 如果你想以 3 欧元的价格购买咖啡，并给咖啡店一张 5 欧元的纸币，那么他们将返还 2 欧元。 这正是钱包使用更改地址所做的事情（除非你启用了硬币控制功能）。</p><p>你的钱包将显示其管理的所有地址的总余额，包括更改地址，但资源管理器一次只能显示单个地址的余额。 资源管理器和钱包从他们的角度展示了 QTUM 的正确平衡，但除非你知道 UTXO 如何使用更改地址，否则它可能会令人困惑。</p><p>请记住，从技术上讲，钱包中没有真正的 QTUM “硬币”（或 QRC20 代币）。 “硬币”实际上是作为区块链块中的交易存储的，“钱币”实际上是钱包地址的所有先前交易的未使用值的钱包的总和。 钱包确实具有存储和管理私钥的关键工作，并且钱包本质上是一个区块链浏览器，可让你管理实际存储在区块链中的“硬币”和代币。</p><h1 id="Q-5"><a href="#Q-5" class="headerlink" title="Q 5."></a>Q 5.</h1><p>我过去常常获得固定的奖励，但最近并没有那么多。 如何检查我的钱包设置是否正确？</p><p>请记住，随着有机增长和商业 DAPP 的部署涉及到钱包，网络权重的趋势正在上升，这意味着固定大小的钱包的块奖励之间的时间也在增加。 对于 Qtum 生态系统来说，不断上升的网络权重是一件好事：它意味着更大，更强大，更安全的网络。 你可以使用 <a href="https://qtum.info/misc/stake-calculator" target="_blank" rel="noopener">Stake计算器</a> 检查你的预期时间以获得积分奖励。</p><p>要确定你的 Qtum Core 钱包是否正确 staking，请检查以下事项：</p><p><img src="https://cdn-images-1.medium.com/max/1200/1*T3BGH_fL89iqh7Jr_-3W2Q.jpeg" alt=""></p><ol><li>同步到最新块，将鼠标悬停在钱包右下角的小复选标记图标上</li></ol><p><img src="https://cdn-images-1.medium.com/max/1200/1*dGWbHEUn3PwjkV-ZxKbY1w.jpeg" alt=""></p><ol><li>解锁仅用于 staking，将鼠标悬停在小挂锁图标上（这将显示稍微打开，显示“unlocked for staking only”）。</li></ol><p><img src="https://cdn-images-1.medium.com/max/1200/1*cMH4Tsq8D1ki1ZmFDX0vWw.jpeg" alt=""></p><ol><li>电脑时钟在正确时间的几秒钟内设置。 使用 “getinfo” 命令进行检查，并参见问题 9 以输入命令。 这里计算机时间和 Qtum 网络时间同步（“timeoffset”为零秒）。</li></ol><p>如果你的钱包具有此配置，你只需等待块奖励，由于块奖励抽奖的随机性，可能会在下一个块（但非常不可能）或预期时间的 5 到 9 倍之间出现 。</p><h1 id="Q-6"><a href="#Q-6" class="headerlink" title="Q 6."></a>Q 6.</h1><p>我的钱包不同步。 我能做什么？</p><p>要参与 staking 或甚至正确查看近期交易的余额，你的钱包必须与区块链正确同步并加载最新的区块。 以下是故障排除列表，但请确保你了解这些步骤，并在有任何问题时向社交媒体寻求帮助。</p><p>如果你的钱包卡在“从2017年9月6日落后XX周”这意味着钱包甚至没有开始同步（生日快乐到 Qtum - 2017年9月6日是 Qtum 主网推出的日期）所以下面的步骤 3 怀疑是看端口连接问题。</p><ol><li><p>安装最新版本的Qtum核心钱包<br><a href="https://qtumeco.io/wallet" target="_blank" rel="noopener">https://qtumeco.io/wallet</a> 或 <a href="https://github.com/qtumproject/qtum/releases" target="_blank" rel="noopener">https://github.com/qtumproject/qtum/releases</a></p></li><li><p>退出钱包。 制作 wallet.dat 文件的多个备份副本。 这是非常重要的 - 如果你没有做好钱包备份，那么你将失去你的 QTUM。</p></li><li><p>确保钱包应用程序可以通过防火墙/路由器进行通信，如果需要，为端口 3888 TCP 输入/输出（端口映射或转发）添加白名单。 钱包应该能够连接至少几个对等点，运行一段时间后最多可以连接8个活动连接点。 有时使用addnode命令添加第一个节点会有所帮助，例如：</p></li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">addnode</span> 35<span class="selector-class">.197</span><span class="selector-class">.138</span><span class="selector-class">.163</span><span class="selector-pseudo">:3888</span> <span class="selector-tag">add</span></span><br></pre></td></tr></table></figure><p>请查看下面关于输入命令的问题 9。</p><ol><li>确保计算机时区设置正确，计算机时钟设置准确。 使用 getinfo 命令检查时间，如上面的回答 5 所示。</li></ol><p><img src="https://cdn-images-1.medium.com/max/1200/1*aAFI3UQMf8kZfrL9jMvsFQ.jpeg" alt=""></p><ol><li><p>只有拥有良好的 wallet.dat 备份时才执行下一步。 在钱包停止的情况下，删除区块链（文件夹：blocks，chainstate，database和stateQtum - 与 wallet.dat 文件位于相同的 “Qtum” 文件夹中）。 这会导致你的钱包在重新启动时重新加载整个区块链。 别担心，区块链会保存你的硬币/代币余额，全球共有 7000 份。 如果你的钱包卡在区块链中部分同步，则此步骤非常有效。</p></li><li><p>确保至少有2 GB的磁盘存储空间。</p></li><li><p>重新启动计算机。 再次运行钱包。 祝你好运！</p></li></ol><h1 id="Q-7"><a href="#Q-7" class="headerlink" title="Q 7."></a>Q 7.</h1><p>如何在钱包中看到 QRC20 代币？</p><p>QRC20 代币与你的钱包 Q 地址相关联。 只有在将该代币添加到钱包后，你才能看到 QRC20 代币并发送这些代币 - 通过将特定的QRC20代币“添加”到你的钱包中，告诉你要管理该特定代币的钱包。 要将QRC20代币添加到你的 Qtum Core 钱包，请查看<a href="https://blog.qtum.org/qtum-core-qrc-20-tokens-1c2734d6290c" target="_blank" rel="noopener">这本手册</a>。</p><h1 id="Q-8"><a href="#Q-8" class="headerlink" title="Q 8."></a>Q 8.</h1><p>我怎样才能保证钱包的安全？</p><p><img src="https://cdn-images-1.medium.com/max/1200/1*2CA9hz7YwzrW7OuivFNghw.jpeg" alt=""></p><p>生命中存在很大的风险，明天你可能会屈服于Mac卡车综合症（被Mac卡车碾过）。 加密中也存在很多风险：交换被黑客入侵，诈骗者，智能合约爆炸，哦，我的天。 基于我在社区中看到的故障排除，你的硬币的主要风险是人类阅读此博客时的人为错误。</p><p>有两种方式可以保证破坏你的QTUM：1）丢失核心钱包的 wallet.dat 文件，2）丢失密码/密码短语/种子单词。 对于核心钱包，wallet.dat 文件包含钱包的私钥。 如果因为没有很好的备份而丢失了这个文件，你的 QTUM 将会永远丢失。 同样，如果你丢失钱包的密码/密码/种子字，你的 QTUM 将永远丢失。 有一些非常狭窄的角落案例，你可以从忘记的密码/种子词中恢复。 密码和种子词必须正确输入，字符为字符，大写/小写正确，没有多余的空格等。在加密中，没有密码重置，没有退款，纠纷或类似的事情，如果 你不喜欢你的硬币的个人责任，那么加密不适合你。</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*eH5OHiU8_2LRCqWH7uAafg.jpeg" alt=""></p><p>对于一般的安全性，Ledger Nano S 和 Trezor 等硬件钱包是最好的方法。 如果你将运行用于 Qtum staking 的核心钱包，最佳做法是从专用计算机中放弃使用电子邮件或浏览网页（为什么？因为你可以通过浏览网页和钓鱼邮件获取恶意软件）。</p><p>如果你在 QTUM 中持有任何价值，你应该阅读，理解并实施这些博客中的优秀建议：QTUM 钱包使用最佳实践以及此非官方指南来加密，备份和恢复你的 Qtum 钱包。</p><h1 id="Q-9"><a href="#Q-9" class="headerlink" title="Q 9."></a>Q 9.</h1><p>如何输入命令以查看有关我的钱包的更多信息？</p><p><img src="https://cdn-images-1.medium.com/max/1200/1*oQLmHQaBdJ-aWyCxRpsPWw.jpeg" alt=""></p><p>在菜单栏中选择“帮助”，然后选择“调试窗口”</p><p><img src="https://cdn-images-1.medium.com/max/1200/1*MHliKybjSiEkGOrWq4zPOA.jpeg" alt=""></p><p>在调试窗口中选择“控制台”<br><img src="https://cdn-images-1.medium.com/max/1200/1*A1OwIzeRZfzWGcLbsKaTKQ.jpeg" alt=""></p><p>在控制台的底部，你可以输入一个命令，一个好的命令开始是“帮助”</p><h1 id="Q-10"><a href="#Q-10" class="headerlink" title="Q 10."></a>Q 10.</h1><p>我在哪里可以找到关于 Qtum 的更多信息？</p><p>以下是一些很好的参考资料：<br><a href="https://github.com/qtumproject/qtum/wiki/Qtum-Wallet-Tutorial" target="_blank" rel="noopener">Qtum使用指南</a><br><a href="https://github.com/qtumproject/qtum/wiki/QTUM-wallet-usage-best-practices" target="_blank" rel="noopener">Qtum钱包最佳使用指南</a><br><a href="https://steemit.com/qtum/@cryptominder/qtum-staking-tutorial-using-qtum-qt" target="_blank" rel="noopener">Cryptominder对非常官方 staking 指南</a><br><a href="https://medium.com/@Qtum" target="_blank" rel="noopener">在Qtum博客上看到的新闻和公告</a><br>Twitter反馈: <a href="https://twitter.com/qtumofficial" target="_blank" rel="noopener">Qtum官方</a>和<a href="https://twitter.com/PatrickXDai" target="_blank" rel="noopener">PatrickXDai</a><br><a href="https://t.me/joinchat/D5oBaw29NeOdpw6qqqf2lw" target="_blank" rel="noopener">Qtum Telegram</a>（英文），<a href="https://www.reddit.com/r/Qtum/" target="_blank" rel="noopener">Qtum subreddit</a>，<a href="https://discordapp.com/invite/zyVMQSv" target="_blank" rel="noopener">Qtum Discord</a> 。</p><hr><p>我们今天在里斯本完成博客。根据葡萄牙的海军实力，葡萄牙在十五世纪和十六世纪因全球勘探而闻名。 葡萄牙拥有四个 Qtum 节点，在伊比利亚半岛拥有独特的历史和文化。 在里斯本，你可以享受丰富的历史，有轨电车，美味的 pastéisde nata 和法多（深情的蓝调）。</p><p>Obrigado e fique seguro在线，</p><p>Jackson</p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><p>年百分比=（100 x 600块/天x 365天x 4 QTUM /块）/网络权重（百万）</p></li><li><p>“wtf”是技术首字母缩略词，意思是“这种行为的技术解释是什么(What is the Technical explanation For this behavior)”。 有关 “wtf” 的更多信息，请查看<a href="https://youtu.be/3wlUPf9PZpY" target="_blank" rel="noopener">加泰罗尼亚 DJ Sak Noel - 洛卡人</a> NSFW 的说明。</p></li></ol><p><img src="https://cdn-images-1.medium.com/max/1200/1*zruqR3PkZar_-0S3rkrjGQ.jpeg" alt=""></p><ol><li>这样美丽的<a href="https://youtu.be/dEzOuI5yI84" target="_blank" rel="noopener">里斯本无人机视频</a>。 DJI Mavic Pro，4k观看。</li></ol><p><img src="https://cdn-images-1.medium.com/max/1200/1*Fiuju-k-p4q1u4YH5wVzEA.jpeg" alt=""></p><ol><li>再见Avicii，RIP。 新用户调查的音乐，<a href="https://youtu.be/HW6He6mD0Kk" target="_blank" rel="noopener">挪威DJ Kygo - Stargazing</a>。 注意音乐录影带导演如何使用黑暗并揭示乐团。</li></ol><p>而多一点能量，阿姆斯特丹DJ也会<a href="https://youtu.be/Z8V5GfFeUDs" target="_blank" rel="noopener">这样</a>。</p><ol><li>Qtum词汇表</li></ol><p>积分奖励(Block rewards) - Qtum Proof of Stake 矿工的奖励，目前在随机抽奖过程中每隔~2分钟支付4.0 QTUM。 </p><p>Earlz - Jordan Earls，Qtum联合创始人兼首席开发人员，区块链架构师，并在加密中运用最好的胡子。 </p><p>主网或主网点火(Mainnet or Mainnet Ignition) - 公共 Qtum 区块链，于2017年9月6日推出.</p><p>Patrick - Patrick Dai，Qtum 联合创始人兼首席执行官，环球传播福音传播者和Qtum项目的主唱。 </p><p>PoS - 权益证明(Proof of Stake)，Qtum 区块链一致性算法，基于 SHA-256 哈希算法。 </p><p>QRC20 - Qtum 区块链的数字资产代币，以以太坊 ERC20 代币为模型。</p><p>量子链(QTUM) - Qtum Mainnet区块链硬币，用于支持 Qtum 智能合约。 </p><p>量子基金会(Qtum Foundation) - 在新加坡注册的非营利性基金会，负责监督 Qtum 平台。 </p><p>测试网络(Testnet) - 用于测试和开发的 Qtum 网络，请查看 <a href="https://testnet.qtum.info/" target="_blank" rel="noopener">Testnet Explorer</a>。 </p><p>5.请查看我之前的 Medium 博客。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;https://medium.com/@jb395official/top-10-qtum-new-user-questions-april-22-2018-307a65dad83f&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;h
      
    
    </summary>
    
      <category term="区块链" scheme="http://xichen.pub/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://xichen.pub/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Qtum" scheme="http://xichen.pub/tags/Qtum/"/>
    
      <category term="翻译" scheme="http://xichen.pub/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】 Qtum 对等连接</title>
    <link href="http://xichen.pub/2018/05/18/2018-05-18-%E7%BF%BB%E8%AF%91-Qtum%E5%AF%B9%E7%AD%89%E8%BF%9E%E6%8E%A5/"/>
    <id>http://xichen.pub/2018/05/18/2018-05-18-翻译-Qtum对等连接/</id>
    <published>2018-05-18T06:11:00.000Z</published>
    <updated>2018-09-01T09:04:47.015Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://medium.com/@jb395official/qtum-peer-connections-may-21-2018-ba12bda71e4f" target="_blank" rel="noopener">https://medium.com/@jb395official/qtum-peer-connections-may-21-2018-ba12bda71e4f</a><br>译者：中山大学数学学院（珠海）林学渊<br>大二时给量子做的翻译，转载注明出处，谢谢</p><h1 id="Qtum-对等连接-—-2018年3月21日"><a href="#Qtum-对等连接-—-2018年3月21日" class="headerlink" title="Qtum 对等连接 — 2018年3月21日"></a>Qtum 对等连接 — 2018年3月21日</h1><p><img src="https://cdn-images-1.medium.com/max/2000/1*DLn-FMh3pWKz3nQTc9pHfg.jpeg" alt="圣巴西尔大教堂，莫斯科 - 简化的网络建筑 - 沙皇大炮，安德烈Chokhov，造于1586年"></p><p>这篇文章深入探讨了运行 Qtum 全节点时其中一个最有趣的问题：钱包/节点如何连接到其他 Qtum 对等方，它需要多少连接，以及无法连接时如何排除错误？</p><p>对大多数应用程序来说，家庭网络足够简单易用，但是当你使用 Qtum 节点遇到问题时，你打算怎么处理？ 路由器 - 防火墙 - 杀毒软件体系具有许多内置保护功能，可以确保你网络的安全和正常运行，但运行加密货币钱包可能会与这些内置保护措施发生冲突。</p><p>我们使用社交媒体上的 “好友请求” 心智模型来探索节点连接。“好友请求” 就是你发送一个请求给你想聊天的人，比如在 Facebook，Telegram 等等。类似地，你的节点将 “好友请求” 发送出去，与其他节点连接，它们确认请求后就可以与你的节点聊天了。你的节点也能够从其他节点接收“好友请求”。</p><p>我们将会了解什么是 Qtum 全节点，Qtum 网络与对等连接如何运作，以及如何覆盖可以阻止这些通信的防火墙和路由器。 我们将花一些时间在端口和网络协议上，并会涉及与 “netstat” 网络状态相关的工具。 我希望在我们完成这些工作之后，你将了解你的 Qtum 节点如何能愉快地与世界各地的同行聊天。</p><p>我是一名独立的区块链研究员，偶尔写博客和主持社交媒体，十分中意 Qtum 团队的技术指导。 我希望在社交媒体上能够很快与大家聊天。 请在 Qtum 的<a href="https://t.me/joinchat/D5oBaw29NeOdpw6qqqf2lw" target="_blank" rel="noopener">电报</a>，<a href="https://www.reddit.com/r/Qtum/" target="_blank" rel="noopener">Reddit</a>，<a href="https://discordapp.com/channels/360663359433211905/360663359433211908" target="_blank" rel="noopener">Discord</a> 和 <a href="https://forum.qtum.org/" target="_blank" rel="noopener">Forum</a> 社交频道上搜索 “Jackson” 或 “JB395”。</p><hr><h2 id="Qtum-主网性能"><a href="#Qtum-主网性能" class="headerlink" title="Qtum 主网性能"></a>Qtum 主网性能</h2><p>Qtum 主网持续稳定运行，最近通过了 150,000 个区块和7,000 个完全分散的 权益证明 节点。 我的计算结果显示，网络权重为 2080 万，因为在一周内稳定的总余额 185 万的大型钱包赢得了8.9％的区块奖励。这表示 Qtum 权益节点的年回报率为4.2％：</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*KCSVoU82wzhlgFKLefQ4tg.jpeg" alt=""></p><hr><h2 id="反杀毒软件"><a href="#反杀毒软件" class="headerlink" title="反杀毒软件"></a>反杀毒软件</h2><blockquote><p>TL;DR 由于历史原因，许多杀毒程序在下载 Qtum 钱包安装文件时会误报病毒错误，并隔离或删除这些下载。 要解决此问题，请为杀毒程序添加白名单，如果有问题，请从 <a href="https://github.com/qtumproject/qtum/releases" target="_blank" rel="noopener">Qtum GitHub 站点</a> 下载并使用验证文件校验。<br>译者注：<code>TL;DR</code> 是 “too long; don’t read” 的缩写，意思是太长别看。</p></blockquote><p>在运行我们的钱包并让它发出“好友请求”之前，我们必须安装钱包，但是在下载钱包安装文件时可能会出现一些问题，因为有杀毒软件。</p><p>杀毒软件当然没有最完美的终端（台式机等）恶意软件保护技术，但它是我们大多数人使用的。 杀毒软件通过将文件签名与已知的恶意软件文件签名进行匹配来工作。 这可能是最令人沮丧的，因为你从开始下载钱包安装文件，下载完成，到最后它却消失了。 发生了什么？</p><p>回到比特币历史中，人们曾在比特币挖矿文件中发现了一些恶意代码，并且自从杀毒程序标记比特币挖矿文件以来，这些文件与 Qtum 节点文件十分相近。</p><p><img src="https://cdn-images-1.medium.com/max/1200/1*F0tBSjIUOR538NSEvvQtTg.jpeg" alt=""></p><p>这是来自 McAfee 杀毒软件的下载警告消息，它在这方面表现很好，提供了一个“接受风险”选项以允许下载安装文件。 其他杀毒软件对用户不太方便，因为它们会在不发出警告的情况下隔离或删除文件。 如果你下载的钱包文件消失了，请在杀毒程序中寻找添加白名单的方法（或者最坏的情况下，暂时关闭杀毒软件进行下载）。 也可能你能够下载并安装钱包，这是因为文件只有在杀毒软件下一次完整扫描你的计算机时才会消失。 这可以通过在杀毒程序中添加白名单来解决。</p><p>那么该怎么办？ 请到 Qtum GitHub 站点获取最新版本（<a href="https://github.com/qtumproject/qtum/releases）" target="_blank" rel="noopener">https://github.com/qtumproject/qtum/releases）</a> 下载正确版本的钱包来安装，并验证 SHA256 校验和。</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*RINDC-dDc1PzVB7L4aCezw.jpeg" alt=""></p><p>将相应的校验和复制到你最喜欢的校验和工具中以验证文件：</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*_Iff43e3B7AQJYbmdkWrQA.jpeg" alt=""></p><hr><h2 id="Qtum-对等连接"><a href="#Qtum-对等连接" class="headerlink" title="Qtum 对等连接"></a>Qtum 对等连接</h2><blockquote><p>TL;DR Qtum 节点（核心钱包）将连接多达 125 个对等点。 前 8 个连接仅出站：节点伸出以连接到其他 8 个节点。 如果路由器和家庭网络的端口 3888 处于打开状态，则该节点将接受对等点 9 到 125 的入站连接。如果该节点也用作 Staking 钱包，则它将通过 8 或 125 个连接同样获得块奖励。 具有多于 8 个对等连接的节点支持连接到网络的新节点，并将下载块来同步这些新节点。 有 8 个出站连接的节点不能这样做。</p></blockquote><p>现在我们已经绕过杀毒程序并安装了钱包，我们可以启动该节点并开始连接到其他节点。</p><h1 id="全节点-8-vs-125-个连接"><a href="#全节点-8-vs-125-个连接" class="headerlink" title="全节点 - 8 vs. 125 个连接"></a>全节点 - 8 vs. 125 个连接</h1><p>在了解关于 Qtum 对等连接如何工作的细节之前，我们先看一下全节点的角色，Staking 钱包以及出站连接与入站连接的问题。</p><p>Qtum 全节点（qtumd 或 qtum-qt Core 钱包）连接到 Qtum 对等网络，将整个区块链同步到本地存储中，并实时验证和传送每个区块和交易。 Qtum 节点以此验证来保护网络，然后将块/交易转发给其他节点。 一个 Qtum 节点不需要持有任何 QTUM 或者为了当这个重要的安全角色而 Staking。 只有 Qtum 核心钱包（ qtumd 和 qtum-qt）才能成为全节点，不过轻量级交易钱包提供商也可以运行全节点，可能基于 qtumd。</p><p>一个 Qtum 全节点可能另外持有 QTUM 并 Staking 以赢取块奖励。 这些放大的全节点有助于保护网络，并有机会赢得块奖励。</p><p>对 Qtum 来说，全节点始终是钱包，但钱包并不总是全节点，例如，Android 手机钱包和 Web 钱包不是全节点，也不能用于 Staking 。 在这篇文章中，我会写关于 “节点” 的内容，但请记住，这是真正的 Qtum 核心钱包，可能会或可能不会 Staking。</p><p>按照设计，节点建立的前 8 个连接只是出站连接。 这意味着你的节点将主动发送 “好友请求” 与其他节点连接。 最初，我发现这个“出站”的概念令人困惑; 节点始终与其对等点进行双向通信（输入和输出），但解释是对于前 8 个连接，你的节点通过主动连接其他节点来启动连接。</p><p><img src="https://cdn-images-1.medium.com/max/1200/1*0MPoIEkzK7wIsA_ZkVFyig.jpeg" alt=""></p><p>任何大于 8 个的对等连接都是入站连接（除非使用出站的 addnode 命令）。 这意味着你的节点将接受来自其他节点的连接，即远程节点发送“好友请求”。具有入站连接的节点在 Qtum 网络上具有特殊功能：它们将允许新节点连接到网络，并且将它们以前存的块下载到这些新节点。 对于有入站连接的节点，我们应该特别感谢，没有它们，网络无法通过添加新节点来增长。</p><p>我们将在下面看到，节点在主网上允许入站连接的能力取决于路由器到家庭网络的端口 3888 ，所以这些入站的好友请求可以实际到达节点。</p><p>请注意，为了获得区块奖励，Staking 钱包有8个连接还是多达125个连接没有区别，事实上，就算只有一个对等连接，钱包也可以进行交易，甚至可以赢得区块奖励（参考文献1）。</p><p>对于 qtumd（“无头”服务器钱包）用户，可以使用以下命令监听连接：</p><p>“getconnectionscount” 将给出当前对等连接数，如 8 或 124.</p><p>“getpeerinfo” 将提供有关当前对等连接的详细信息。</p><h2 id="路由器和家庭网络"><a href="#路由器和家庭网络" class="headerlink" title="路由器和家庭网络"></a>路由器和家庭网络</h2><p>大多数家庭网络通过因特网服务提供商（ISP）提供的网络接入设备连接到因特网，该服务提供商可以是电缆调制解调器，DSL调制解调器或其他网络接口设备。 调制解调器通常有一个内置路由器，路由器的工作是提供从 ISP 提供的单个公共 Internet 地址到家庭网络上多个内部IP地址的地址转换。 这些内部IP地址通常由诸如 UPnP（universal plug and play）之类的协议自动分配，重要的是要知道，路由器将单个外部 IP 地址映射到家庭网络上连接的多个设备的内部IP地址。</p><p>让我们看一下在家庭网络上运行的 Qtum 节点的简化图：</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*K-KaZ_IjqJ-S-e2CHIPAug.jpeg" alt=""></p><p>这里有很多东西需要解释。 ISP 为这个宽带客户提供的公共 IP 地址是 123.24.67.89，因特网上的任何地方的计算机都可以发送消息到这个地址。 内部网络 IP 地址为运行 Qtum 节点的计算机 A 为 192.0.0.1，计算机 B 为 192.0.0.2，正在进行网络冲浪，以此类推计算机C.</p><p>基于来回的流量，路由器知道如何将网页请求发送回计算机B，并将 Qtum 节点的出站节点请求发送回计算机A. 但是，在 Qtum 节点与前 8 个节点用那些出站的对等请求连接之后会发生什么？问题在于，对于入站的对等请求，路由器可能不够智能，无法将这些好友请求自动路由到计算机 A 中的节点，因此入站的对等请求会丢失，并且该节点无法连接到 8 个节点之上。</p><p>要解决这个问题，并允许节点接收入站的对等请求，我们可以使用端口转发为计算机 A 打开端口 3888. 要打开端口 3888，我们配置路由器将端口 3888 的所有流量转发到 IP 地址 192.0.0.1，以到达计算机 A 节点。根据你的网络设置，还可以从钱包映射端口 3888，使用 UPnP 选择设置 - 选项 - 网络 - 映射端口。</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*zKiP5nhpSi1gQ-Yc2q0WLw.jpeg" alt=""></p><p>网站 portforward.com 有程序和屏幕截图来设置数百个路由器上的端口转发（只需点击他们的广告），程序基本上是登录到你的路由器，找到设置端口转发的部分，并填写表格将 TCP 输入端口 3888 分配给你节点的本地IP地址。</p><p>老实说，端口映射应该可以允许入站连接，但我无法使其工作。 如果有人可以提供一些指点，我可以更新这个博客。</p><hr><h2 id="Netstat工具"><a href="#Netstat工具" class="headerlink" title="Netstat工具"></a>Netstat工具</h2><p>在本节中，我们添加一些实用的网络程序和诊断技术。 通常，你的家庭网络允许 Qtum 节点自动同步，但如果没有，这些工具可能有助于排除错误。</p><p>为了监控你的家庭网络，netstat（网络状态）程序是一个很好的开始。 从命令提示符运行此工具。 它内置于 Mac 和 Windows，在Linux上你可能需要安装它（apt-get install net-tools）。netstat 选项列表在参考2中给出。</p><p>“netstat -n” 命令将以数字形式显示网络地址和端口，显示一个节点连接到端口 3888 上的远程节点：</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*UvSrPc9mfo_e1Zp4Fj8c7A.jpeg" alt=""></p><h2 id="Addnode-命令"><a href="#Addnode-命令" class="headerlink" title="Addnode 命令"></a>Addnode 命令</h2><p>如果你的新节点没有与对等方连接，则需要使用 “addnode” 命令提供帮助。 你可以告诉节点向特定 IP 发送“好友请求”。但是你应该使用哪些 IP？</p><p>addnode 命令的一个很好的对等 IP 地址来源是 coinexchange.io，它列出了来自其 Qtum 节点的 “getpeerinfo” 数据。要使用此站点中的IP地址，请将其输入为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addnode 123.45.67.89:3888 add</span><br></pre></td></tr></table></figure><p>（这是一个合成的IP地址，你应该使用来自 coinexchange.io 的实际 IP 地址）</p><p>对 addnode 命令的正确响应是 “null”，然后你的节点将尝试一两分钟连接到该对等点 IP 地址。 你可以尝试手动添加 5 个或 10 个对等连接。</p><h2 id="在启动时连接"><a href="#在启动时连接" class="headerlink" title="在启动时连接"></a>在启动时连接</h2><p>在本节中，我们将了解节点如何在启动时建立连接，并使用 netstat 来监听网络并查看节点如何连接。 我们的 netstat 命令是 “netstat -an 30”，意思是每隔 30 秒以数字格式显示所有连接和监听端口。</p><p>启动节点时，有几种方法可以找到要连接的对等点。如果节点先前已经运行，它将保存 IP 地址和时间在 peers.dat 文件中。 如果节点是新的或者在 peers.dat 文件中找不到一些好的IP地址，它将向 DNS 服务器查询当前 IP 地址的列表。 最后，你可以手动输入 IP 地址来尝试使用 “addnode” 命令。</p><p>首先，我们安装时将节点设置为在全局启动，且不使用 peers.dat 文件中的历史记录（只需重命名 peers.dat 文件，使节点找不到它）。</p><p>下面是一个新节点寻找其他节点的消息序列。 这个节点没有使用留有以前“朋友”的 peers.dat 文件。 在半小时的过程中，它将尝试多个IP地址，找到两个要连接的对等点：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*XKVrxce8Y6ptxjfPnC6f3g.jpeg" alt=""></p><p>Qtum 核心钱包有一个文件，其中包含所有“好友请求”，即 peers.dat 文件。 同一个节点使用 peer.dat 文件启动（将先前的文件名改回 “peers.dat”）可使钱包在 12 分钟内与 10 个对等点连接。 下面的图表显示钱包另找新朋友（没有 peers.dat 文件 - 如上所示）与仅仅联系以前的朋友（使用peers.dat 文件）时的差异：</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*j8WpDjh7d5yzpfg2zLbHcQ.jpeg" alt=""></p><h2 id="用于网络事件的-Debug-log-文件"><a href="#用于网络事件的-Debug-log-文件" class="headerlink" title="用于网络事件的 Debug.log 文件"></a>用于网络事件的 Debug.log 文件</h2><p>Qtum 节点现在已经准备好了它的特写，我们将通过设置 debug.log 来捕获所有网络事件。 这是启动钱包时通过 debug=net 开关完成的：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\<span class="function"><span class="keyword">Program</span></span> Files\Qtum&gt;qtum-qt.exe -debug=net</span><br></pre></td></tr></table></figure><p>根据你的操作系统调整此命令。</p><p>使用此命令后，节点将记录有关网络活动的所有详细信息。</p><p>有关显示连接如何建立简单的列表（下面的参考文献7中给出了更完整的序列），日志显示：</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*hG_OEoziecwLYW259qzn5w.jpeg" alt=""></p><p>（1）启动后，我们的节点尝试根据 peers.dat 文件连接到多个 IP。 它在十天前看到节点 59.189.111.143，但现在不能连接。</p><p>（2）我们的节点连接到 DNS 种子服务器以获取最近的一些 IP 地址。</p><p>（3）我们的节点试图连接到地址 35.226.31.206，要尝试的是第6个节点。</p><p>（4）我们的节点在 35.226.31.206 处向节点发送版本消息（软件版本，块编号和时间参考）。 该版本消息是“好友请求”。远程节点将使用自己的版本消息进行响应。</p><p>（5）节点交换 verack 消息（版本确认）以确认连接。 现在它们是好友，可以开始聊天了。 我们的节点将向远程节点请求额外的IP地址，发送其他“好友请求”。</p><p>（6）我们的节点将其最新的块（它离线差了 4 块）发送到 35.226.31.206，并请求下载块以追上。</p><p>（7）我们的节点开始接收来自节点 6 的块。</p><p>请注意时间戳，节点启动后尝试连接节点 6（对等节点 1 到节点 5 未连接）需要45秒，然后等待一秒完成连接（verack 消息）并开始下载块。</p><hr><p>我在莫斯科写完博客，部分原因是我收到了来自 Qtum Telegram Russia 频道的管理员 Lisa L 的一个好友请求，要翻译之前的 Qtum Russian Community 博客，因为俄罗斯目前有 17 个 Qtum 节点，并且国际足联世界杯将于 6 月份来到俄罗斯。还要更好的理由在克里姆林宫和红场进行摄影漫步嘛？这个地区是俄罗斯的文化中心，列宁坟墓的所在地，圣巴西尔大教堂（建于 1561 年），众多的博物馆以及 2 月份记者访问时的寒冷天气。</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*czNb6yYM2zdTTMII4GXwFw.jpeg" alt="The Moscow Kremlin"></p><hr><h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><p>特别感谢 Liza L 的俄文翻译。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>我使用 Testnet 钱包来验证使用单个对等连接操作的节点，使用以下命令：</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qtum-qt.exe -testnet -noconnect <span class="attribute">-connect</span>=35.197.132.10:13888</span><br></pre></td></tr></table></figure><p><img src="https://cdn-images-1.medium.com/max/1600/1*FIXpCZF2EVT4WDX2WmJtCQ.jpeg" alt="just the one peer!"></p><ol><li>netstat工具。</li></ol><p><img src="https://cdn-images-1.medium.com/max/2000/1*YFUuVNBnF9fv2na1pyIzuw.jpeg" alt=""></p><p>Qtum 对等通信基于比特币，下面是一些相关的比特币参考：</p><ol><li>BitcoinCore — <a href="https://bitcoin.org/en/full-node" target="_blank" rel="noopener">运行完整节点</a></li></ol><ol><li>Reddit <a href="https://www.reddit.com/r/Bitcoin/comments/1scd4z/im_running_a_full_node_and_so_should_you/cdw3lrh/?context=3" target="_blank" rel="noopener">bitcoin post</a>:我正在运行一个全节点，你也来吧</li></ol><p><img src="https://cdn-images-1.medium.com/max/1200/1*lvvUJCT7f79P9ASR3ljBRA.jpeg" alt=""></p><ol><li>区块链研究的音乐。 <a href="https://youtu.be/ucTcvj6iB6g" target="_blank" rel="noopener">柴可夫斯基 - 意大利随想曲</a> - Igor Manasherov，莫斯科爱乐乐团，柴可夫斯基音乐厅，2015年6月，莫斯科。</li></ol><p><img src="https://cdn-images-1.medium.com/max/1200/1*tGHDxDANUtKs8n9tOwHNfw.jpeg" alt=""></p><ol><li>无人机在克里姆林宫上，在 <a href="https://youtu.be/-yPrVC3-B2o?t=11m25s" target="_blank" rel="noopener">YouTube</a> 上看。</li></ol><ol><li>以下是连接到 35.226.31.206 的节点 6 的更完整的日志列表：</li></ol><p><img src="https://cdn-images-1.medium.com/max/2000/1*-ZsallnwsnEpijqJ8956JQ.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;https://medium.com/@jb395official/qtum-peer-connections-may-21-2018-ba12bda71e4f&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://medi
      
    
    </summary>
    
      <category term="区块链" scheme="http://xichen.pub/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://xichen.pub/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Qtum" scheme="http://xichen.pub/tags/Qtum/"/>
    
      <category term="翻译" scheme="http://xichen.pub/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】 孤儿块</title>
    <link href="http://xichen.pub/2018/05/12/2018-05-12-%E7%BF%BB%E8%AF%91-%E5%AD%A4%E5%84%BF%E5%9D%97/"/>
    <id>http://xichen.pub/2018/05/12/2018-05-12-翻译-孤儿块/</id>
    <published>2018-05-12T06:11:00.000Z</published>
    <updated>2018-09-01T09:04:47.018Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://medium.com/@jb395official/orphan-blocks-june-16-2018-a8f4799dcc2c" target="_blank" rel="noopener">https://medium.com/@jb395official/orphan-blocks-june-16-2018-a8f4799dcc2c</a><br>译者：中山大学数学学院（珠海）林学渊<br>大二时给量子做的翻译，转载注明出处，谢谢</p><h1 id="孤儿块-—-2018年4月16日"><a href="#孤儿块-—-2018年4月16日" class="headerlink" title="孤儿块 — 2018年4月16日"></a>孤儿块 — 2018年4月16日</h1><p>这一次我们讨论孤儿块。当两个钱包在相近的时间获得块奖励并将块发布到网络时，就会产生孤儿块。其中一个区块将被接受并扩充区块链，另一个区块将成为孤儿并被拒绝。</p><p>我们看一下孤儿块的两个问题：</p><ol><li>谁挖到了孤儿块？</li><li>我的钱包是否挖到了孤儿块？我该怎么办？</li></ol><p>我们转向一位熟悉的朋友来回答这些问题：钱包的 debug.log 文件。</p><p>我承认这是一个只有少数人感兴趣的专门话题。 如果你好奇区块链，请继续阅读; 如果你认为你已经挖到了一个孤儿块，你必须阅读; 如果你对区块链和糟糕的区块链笑话有普遍兴趣，那随你便……</p><p>我是一名独立的区块链研究员，偶尔写博客和主持社交媒体，十分中意 Qtum 团队的技术指导。如果你对本文有任何意见或更正，请在社交媒体上联系我。</p><hr><h2 id="主网性能"><a href="#主网性能" class="headerlink" title="主网性能"></a>主网性能</h2><p>首先简要回顾一下 Qtum 主网的最新性能。</p><h3 id="网络权重"><a href="#网络权重" class="headerlink" title="网络权重"></a>网络权重</h3><p>我另一种计算网络权重的方法依赖于大赌注钱包所获得的积分奖励的百分比，这些大赌注钱包具有已知余额。我的方法也提供了比钱包的计算的网络权重估计更准确的数字。在上周，这些 175 万余钱的大钱包获得了9.96％的积分奖励，网络权重为 1760 万。 网络权重为 1760 万意味着年度回报率为 5.0％</p><h3 id="交易费用"><a href="#交易费用" class="headerlink" title="交易费用"></a>交易费用</h3><p>由于合约调用，最近出现了一些初始两位数的交易费用。 重量级是 167,861 块，收 5.9 QTUM 交易费，其中包括来自与 Luna Stars 促销相关的一系列 LSTR 令牌转账的 gas。</p><p><img src="https://cdn-images-1.medium.com/max/1200/1*-Y_7vQMqWzqBWDW99fYoWg.jpeg" alt="与Luna Stars DAPP约会"></p><p>该区块持有 323 笔交易，在 gas 退款后为区块奖励获奖者支付了9.9 QTUM（4.0 QTUM 区块奖励 + 5.9 交易费用(来自 10 种方式)）后支付 29.92 QTUM 的初始交易费用。 请注意，对于此区块，交易费用大于区块奖励。</p><hr><h2 id="孤儿块"><a href="#孤儿块" class="headerlink" title="孤儿块"></a>孤儿块</h2><blockquote><p>TL;DR 当两个节点在相似时间发布新块时，分散式区块链挖矿平台偶尔会挖出孤儿块。孤儿块对于分散式网络来说是完全正常和健康的。  Qtum 的孤儿块率约为1.6％，即每天有 10 个孤儿块。 Qtum 网络一视同仁处理孤儿块（它们被取消），但偶尔中断这一过程会导致孤儿块奖励搁浅，在这种情况下，可以使用一些钱包命令行工具进行恢复。</p></blockquote><h3 id="孤儿简介"><a href="#孤儿简介" class="headerlink" title="孤儿简介"></a>孤儿简介</h3><p>百老汇音乐剧“小孤儿安妮”于 1977 年在纽约市首映，并讲述了这个勇敢的（有音乐天赋的）小孤儿安妮的故事，她在孤儿院里生活艰苦，并最终被百万富翁实业家 Daddy Warbucks 领养。 在电影版的安妮故事里，汉尼根小姐，孤儿院的邪恶女校长说：</p><p><img src="https://cdn-images-1.medium.com/max/1200/1*PXxFu2Uqo7R3r_-EnSySNg.jpeg" alt="克莱斯勒大厦由大卫Shankbone，裁剪过"></p><p>.<br>“为什么所有孩子都想成为一个孤儿？我不懂。你会熬夜工作直到这个垃圾场…像克莱斯勒大厦的顶部一样耀眼。”<br>.<br>.<br>.</p><p>在 Qtum 区块链上，当两个 Staking 钱包在相似的时间产生新的区块时，就会生成孤儿块。 对于分散节点，这是偶然且完全自然的结果。 孤儿块与主区块链的关系如下：</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*EQw6NCiKguSN4v7zzGdyPQ.jpeg" alt=""></p><p>为了分析产生的孤儿块的数量，我在 Excel 中处理 debug.log 文件来检查何时挖到新块。 对于允许入站连接的钱包，每个块接收自许多不同的节点（30 个或更多），并且钱包将验证并选择一个附到本地区块链副本。 所有 30 个块都收到相同的数据，包括相同的交易 ID，因为它们来自奖励获奖钱包的那一区块，嗯，你知道这是为啥。</p><p>如果挖掘了孤儿块，与其他块相比，它将有相同的块编号，但有不同的交易 ID。 如果将一周的 debug.log 文件行导入 Excel，并运行一些字符串匹配公式，则会弹出孤儿块。</p><p>怎么算孤儿块个数？ 我在<a href="https://medium.com/@jb395official/qtum-mainnet-results-nov-27-dec-3-327c1e9bc59c" target="_blank" rel="noopener">之前的博客</a>中有一些估计。 比特币的孤儿率约为0.5％（可能是由于<a href="https://bitcoinmagazine.com/articles/how-falcon-fibre-and-the-fast-relay-network-speed-up-bitcoin-block-propagation-part-1469808784/" target="_blank" rel="noopener">快速中继网络</a>），而目前约为 23％ 以太坊叔块（<a href="https://etherscan.io/chart/uncles" target="_blank" rel="noopener">以太坊的叔块</a>激励和处理的方式与 Qtum 孤儿块不同）。</p><p>我的分析显示，<strong>Qtum 的孤儿块率为1.6％</strong>。 这意味着每天 600 块，将会有大约 10 个孤儿。 另一种看待这个问题的方法是：如果一个钱包平均 63 块（在一段时间内）挖矿，那么平均一个将成为一个孤儿。</p><hr><h2 id="谁挖到了孤儿块？"><a href="#谁挖到了孤儿块？" class="headerlink" title="谁挖到了孤儿块？"></a>谁挖到了孤儿块？</h2><p>寻找一个孤儿块有点像在干草堆里找针。解析 debug.log 文件查找孤儿意味着多达 1,000,000 行的多个 Excel 工作表。 幸运的是，有一个 Excel FINDNEEDLE 函数可以找到那些害羞的孤儿块[参考文献2]：</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*sQ2uHk_Ruc9EV_Eis7l1-A.jpeg" alt="67名孤儿发现于6月1日至6月7日，为164,075至168,274"></p><p>在一周的数据里，我发现了 67 个孤儿（可能还有几个孤儿）。 注意孤儿块 165,136 和 165,137 是相连的孤儿，孤儿高度是两个块（孤儿块 165,137 的父亲是 Mainchain 块 165,136）。</p><p>大 staking 钱包将创造许多孤儿块。 我们可以看看 QNqKe …，这是目前最大的 Staking 钱包，我相信这是一个交易热门钱包，而且也 Staking 了（我不知道是属于哪个交易所，但感谢帮忙保护区块链！）。 我们知道钱包会在每 63 块奖励中击中一个孤儿块（但有很多随机变化），而 QNqKe ……在 2 天多一点的时间里获得 63 块奖励。 这是来自 QNqKe 的孤儿块 163,638 …：</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*5XlYtw7FSOqeSTS0fqNczQ.jpeg" alt=""></p><p>请注意这个区块的两件事情，资源管理器将其标记为“孤儿”，下一个应该列出区块的空间却是空的。 这个孤儿块有上一个区块 163,637，但没有下一个区块。 有一个父块但没有子块[参考文献3]。 只有 explorer.qtum.org 会显示孤儿块，其他资源管理器没有。</p><p>主网区块 163,638 实际上是通过钱包 QgVXC 赢得的……并且其资源管理器页面显示“Mainchain”和Next Block 163,639：</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*ChoMOgV4mezMtkld8P1ufA.jpeg" alt=""></p><p>那些眼睛犀利的人可能会注意到挖到 Mainchain 块的难度高于孤儿块，这就是其他节点在孤儿块上选择 Mainchain 块的方式：赋予区块链最高难度（最安全） 。</p><hr><h2 id="当坏事情发生在好钱包时"><a href="#当坏事情发生在好钱包时" class="headerlink" title="当坏事情发生在好钱包时"></a>当坏事情发生在好钱包时</h2><p>从你的钱包中检测孤儿块的一种方法是查看 debug.log 文件。 如果你不熟悉 debug.log 文件，请参阅<a href="https://medium.com/@jb395official/the-debug-log-the-virtual-machine-log-march-13-2018-76ddbe568f2" target="_blank" rel="noopener">此博客</a>。</p><p>要查看你的钱包是否已挖到孤儿块，请打开 debug.log 文件并从底部向上搜索“conflicts with wallet transaction”。 如果你的钱包挖到了一个孤儿，你会发现这条日志行和几行后面的日志行显示 “CT_DELETED”，它会从交易表中删除孤儿交易。 如果你正在看你的桌面 GUI 钱包，你会看到一开始 0.4+ 挖矿交易出现，然后神秘地消失。</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*Wxj2bMYuyQIeUZCAT5ywGg.jpeg" alt=""></p><p>怎么看这个日志？</p><p>从 “conflicts with wallet transaction” 一行取出两个交易 ID 并在 Explorer.qtum.org 中搜索它们。 你可能会看到这些事务 ID 都不能在区块链中找到，或者它们可以显示为孤儿块。 无论结果如何，这都意味着你肯定挖到了孤儿块。</p><p>让我们来回顾一下赢得大块奖励时你的钱包有什么行为。 得到块奖励的获奖钱包将 1）选择一个或多个先前的交易金额（UTXO）来 stake 500 块，2）尽可能多地抓取内存池里正在等待的交易，并将它们组装到新块中，3）根据区块链的本地副本执行这些交易中的所有智能合约调用，4）将新块发布到网络。 当你的钱包完成所有这一切时，它不知道它是创建了一个 Mainchain 块还是一个孤儿块，因为它只是做完这一切并提交了这个 stake。</p><p>当你的钱包挖到孤儿块时，最好的办法是不要做任何事情，保持冷静。 你的钱包会发现它挖到了一个孤儿并且迟早会取消所有的孤儿块活动，包括返还 stake。</p><p>不管如何，这种孤儿块取消过程很少会中断。 我说实话，我不完全理解孤儿中断过程，但可以猜测，如果你对服务感到紧张，正在密切关注你的钱包，并开始恢复它交换 wallet.dat 文件以取回孤儿 stake - 这可能会滞留孤儿 stake。 在这种情况下，资源管理器将显示地址的正确余额，否则你的钱包将在该地址处显示余额低于 stake 的 UTXO 的金额。 钱包中丢失的金额可能与之前未花费的交易金额完全匹配，你的钱包选择为该孤立区块进行 stake。</p><p>如果你发现自己处于这种状况，那么现在是某些命令行工具的时候了。 为了从孤儿 stake 中恢复，“打捞钱包”是无效的，因为它可以修复损坏的 wallet.dat 文件，这不是问题。</p><p>请注意，我们正在查看启动钱包时使用的命令行参数，而不是在钱包运行后在调试控制台输入/qtum-cli 命令。 这些命令行工具在你从命令行启动钱包时使用。 对于 Mac OS X，你将在终端中输入命令行，如本博客中所述。 对于 Windows，你将使用本博客中描述的 Windows 命令提示符输入命令。 如果你正在运行服务器钱包 qtumd ，则可以在启动 qtumd 时添加命令行参数（请勿对这些命令使用qtum-cli）。</p><p>只有在你拥有 wallet.dat 文件的 <em>良好备份</em> 并完成上述故障排除以确认孤儿块时才使用这些步骤。</p><h3 id="重新扫描命令"><a href="#重新扫描命令" class="headerlink" title="重新扫描命令"></a>重新扫描命令</h3><p>重新扫描命令将通过你本地的区块链副本并从头构建数据库。 <a href="https://bitcoin.stackexchange.com/questions/1249/how-exactly-does-rescan-work" target="_blank" rel="noopener">在这篇文章中</a>了解重新扫描工作原理。</p><p><img src="https://cdn-images-1.medium.com/max/1200/1*IAXyRUNUM5HRX5vhq2TeCQ.jpeg" alt=""></p><p>输入重新扫描命令：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qtum-qt<span class="selector-class">.exe</span> -rescan</span><br></pre></td></tr></table></figure><p>当你输入 qtum-qt 的命令时，启动屏幕将显示状态“重新扫描… XX％”一两分钟，然后打开主钱包。</p><h3 id="Zapwallettxes-命令"><a href="#Zapwallettxes-命令" class="headerlink" title="Zapwallettxes 命令"></a>Zapwallettxes 命令</h3><p>zapwalletxes 命令将重新扫描本地区块链，并删除（“zap”）钱包中未发布在区块链上的所有交易。 在<a href="https://en.bitcoin.it/wiki/Running_Bitcoin" target="_blank" rel="noopener">维基</a> 阅读更多关于 zapwallettxes 的信息。</p><p><img src="https://cdn-images-1.medium.com/max/1200/1*aOuPNCzhDXXFHwtUzYVb7Q.jpeg" alt=""></p><p>输入 zapwallettxes 命令:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qtumd.exe –<span class="attribute">zapwallettxes</span>=2</span><br></pre></td></tr></table></figure><p>输入命令后，qtum-qt 将启动并在右下角显示“重新扫描…”。 一两分钟后，将出现完整的钱包窗口，很有希望会恢复孤儿 stake。<br><img src="https://cdn-images-1.medium.com/max/1600/1*fUeUFeDaCBmkmF4ZY8XKVA.jpeg" alt=""></p><p>如果你在 qtumd 中使用这些命令，请给它一两分钟来完成重新扫描，在此之前它不会响应 info 命令。</p><hr><p>在音乐剧和电影的结尾，百万富翁工业家爸爸 Warbucks 领养了小孤儿安妮，然后过上了奢华的生活。 同样地，Qtum 孤儿块会返还它们的 stake 然后 staking 并保护 Qtum 区块链。</p><p>请保持在线安全，</p><p>Jackson</p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>看我的过去的博客，包含以下主题：</li></ol><p><a href="https://medium.com/@jb395official/qrc20-token-update-may-28-2018-45e2e259b891" target="_blank" rel="noopener">QRC20 Token 更新</a>，设定发送QRC20代币的气体限价和气体价格，发布于2018年5月28日</p><p><a href="https://medium.com/@jb395official/qtum-peer-connections-may-21-2018-ba12bda71e4f" target="_blank" rel="noopener">Qtum 对等连接</a>，详细了解Qtum节点连接到2018年5月21日发布的其他节点，传出/传入连接以及一些用于监控流量的工具</p><p><a href="https://medium.com/@jb395official/top-10-qtum-new-user-questions-april-22-2018-307a65dad83f" target="_blank" rel="noopener">Qtum 新用户十大问题</a>，2018年4月22日发布的新Qtum用户的答案</p><p><a href="https://medium.com/@jb395official/network-hash-rates-april-4-2018-d4159365df19" target="_blank" rel="noopener">网络哈希率</a>，比特币，以太坊和Qtum网络哈希率的比较，这些数字可能会让你感到惊讶，2018年4月6日发布</p><p><a href="https://medium.com/@jb395official/newbie-wallets-april-1-2018-26ea7a06489c" target="_blank" rel="noopener">新手钱包</a> :分析块奖励获奖钱包和新中文节点，发布于2018年4月1日</p><p><a href="https://medium.com/@jb395official/the-debug-log-the-virtual-machine-log-march-13-2018-76ddbe568f2" target="_blank" rel="noopener">调试日志，虚拟机日志</a>:debug.log（和虚拟机日志）是你的朋友，<a href="https://medium.com/@jb395official/the-debug-log-the-virtual-machine-log-march-13-2018-76ddbe568f2" target="_blank" rel="noopener">如何查找和阅读调试日志</a>，发布于2018年3月13日</p><p><a href="https://medium.com/@jb395official/qtum-capped-supply-the-halving-b650b7fb955e" target="_blank" rel="noopener">QTUM上限供应减半</a>:QTUM的供应量是多少，将会有多少？ QTUM的上限，“减半”的工作原理以及2018年3月4日发布的新资源管理器</p><p><a href="https://medium.com/@jb395official/qrc20-token-report-february-25-2018-ff397a1ac070" target="_blank" rel="noopener">QRC20令牌报告</a>:QRC20令牌，BOT空投，发布于2018年2月25日</p><p><a href="https://medium.com/@jb395official/happy-new-year-qtum-mainnet-performance-february-9-15-a696e8e8396e" target="_blank" rel="noopener">Qtum PoS模拟器</a>:发布于2018年2月16日</p><p><a href="https://medium.com/@jb395official/testnet-and-qtum-mainnet-performance-january-1-8-e7af03a5d430" target="_blank" rel="noopener">Testnet</a>:Qtum测试网络，于2018年1月7日发布</p><p><a href="https://medium.com/@jb395official/qtum-mainnet-results-december-25-31-891680ee5a52" target="_blank" rel="noopener">虚拟专用网络（VPN）</a>:使用VPN进行赌注，于2017年12月31日发布</p><p><a href="https://medium.com/@jb395official/qtum-mainnet-results-december-18-24-8e43e51aca3b" target="_blank" rel="noopener">交易费用</a>，2017年12月24日发布</p><p><a href="https://medium.com/@jb395official/qtum-mainnet-results-dec-11-17-d5548947fa1f" target="_blank" rel="noopener">密码短语</a>，密码短语和密码猜测脚本，2017年12月17日发布</p><p><a href="https://medium.com/@jb395official/qtum-mainnet-results-dec-4-10-2d4bc438062d" target="_blank" rel="noopener">内存池（mempool）</a>，内存池和未确认事务的处理，于2017年12月10日发布</p><p><a href="https://medium.com/@jb395official/qtum-mainnet-results-nov-27-dec-3-327c1e9bc59c" target="_blank" rel="noopener">孤儿块</a>，发布于2017年12月3日</p><p><a href="https://medium.com/@jb395official/qtum-mainnet-results-november-20-26-ebde2cd0139" target="_blank" rel="noopener">QTUM.explorer.io合同页面</a>:2017年11月26日发布</p><p><a href="https://medium.com/@jb395official/qtum-mainnet-results-november-13-19-bfbf45d0c153" target="_blank" rel="noopener">SHA256哈希算法和难度</a>，于2017年11月20日发布</p><p><a href="https://medium.com/@jb395official/qtum-mainnet-results-november-6-12-f59dd373ff3" target="_blank" rel="noopener">“钱包赢得座位奖励”的分发</a>，2017年11月12日发布</p><p><a href="https://medium.com/@jb395official/qtum-mainnet-results-october-30-november-5-d58164b811db" target="_blank" rel="noopener">SHA256哈希算法，目标和难度</a>，于2017年11月5日发布</p><p><a href="https://medium.com/@jb395official/an-introduction-to-qtum-proof-of-stake-mining-a-racing-story-f11a3f48009f" target="_blank" rel="noopener">Qtum 采矿权益证明的介绍 - 赛车故事</a>，关于PoS采矿的ELI5故事。2017年10月29日发布</p><p><a href="https://medium.com/@jb395official/qtum-mainnet-results-october-23-29-527cd4ab887a" target="_blank" rel="noopener">基础的钱包离场</a>，2017年10月29日发布</p><p><a href="https://medium.com/@jb395official/qtum-mainnet-results-october-1-8-f413231c689a" target="_blank" rel="noopener">非官方赌注常见问题解答</a>，2017年10月26日发布</p><p><a href="https://medium.com/@jb395official/qtum-mainnet-results-october-16-22-9202990b8e8d" target="_blank" rel="noopener">网络权重，奖励时间，Nodemap</a>，2017年10月22日发布</p><p><a href="https://medium.com/@jb395official/simulating-proof-of-stake-mining-for-qtum-57401c08590a" target="_blank" rel="noopener">模拟 Qtum 采矿权益证明</a>，2017年10月21日发布</p><p><a href="https://medium.com/@jb395official/qtum-proof-of-stake-mining-439d2b82802d" target="_blank" rel="noopener">用于PoS挖掘的早期模拟器 Stake 采矿的Qtum证明</a>，2017年10月16日发布</p><p><a href="https://medium.com/@jb395official/qtum-mainnet-ignition-results-october-9-15-1efe30eb2658" target="_blank" rel="noopener">Qtum 主网点火结果10月9日至15日</a>，主网图表和图表介绍，于2017年10月15日发布</p><ol><li>另一个糟糕的杰克逊笑话。 在 Excel 中没有 FINDNEEDLE 函数，但是这些公式对于使用 E 列中的块事务 ID 和 F 列中的块号加载的 debug.log 数据工作得很好。使用字符串函数来提取事务 ID 和块号：</li></ol><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=<span class="built_in">IF</span>(<span class="built_in">FIND</span>(“height”, <span class="symbol">F2</span>),<span class="built_in">MID</span>(<span class="symbol">F2</span>, <span class="number">8</span>, <span class="number">6</span>)) — extract the block number</span><br><span class="line">=<span class="built_in">IF</span>(<span class="built_in">FIND</span>(“height”, <span class="symbol">F2</span>),<span class="built_in">MID</span>(E, <span class="number">6</span>, <span class="number">64</span>)) — extract the transaction ID</span><br></pre></td></tr></table></figure><ol><li>“孤儿”不是这些块最好的名词。 孤儿块有父母，我们知道孤儿块的父母，但他们没有孩子。 我认为一个更好的术语是 Freemartin。 显然，Satoshi 不是一个行话。</li></ol><ol><li>比特币孤儿块显示在 blockchain.info 上</li></ol><p>百老汇音乐剧安妮开幕之夜是1977年4月21日在纽约市的阿尔文剧院。 制作有2,377场演出，并于1983年1月2日结束。</p><p><img src="https://cdn-images-1.medium.com/max/1200/1*taJKu6c9RzNI4RHfsmPL7Q.jpeg" alt=""></p><ol><li><p>孤儿研究的音乐，Aileen Quinn 在 1982 年的电影“安妮”中演唱“明日”。 明天太阳会出现，明天你会赢得奖励奖励。</p></li><li><p>Spotify 专辑链接，Annie：<a href="https://open.spotify.com/album/15M8SwihPt6KSKj6jozIyL?si=rdK6nesaT92c-TLoLYoMag" target="_blank" rel="noopener">百老汇音乐剧 30 周年演员录音</a></p></li></ol><p><img src="https://cdn-images-1.medium.com/max/1200/1*jlvTvJjD1GpkbUfFCSAPmw.jpeg" alt=""></p><ol><li><a href="https://www.youtube.com/watch?v=1wjhEZTb1k8" target="_blank" rel="noopener">纽约无人机航班</a>，4k观看</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;https://medium.com/@jb395official/orphan-blocks-june-16-2018-a8f4799dcc2c&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://medium.com/
      
    
    </summary>
    
      <category term="区块链" scheme="http://xichen.pub/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://xichen.pub/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Qtum" scheme="http://xichen.pub/tags/Qtum/"/>
    
      <category term="翻译" scheme="http://xichen.pub/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
</feed>
