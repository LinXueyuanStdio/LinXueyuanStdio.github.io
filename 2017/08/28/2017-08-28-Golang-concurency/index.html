<!DOCTYPE HTML>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

    

    <title>Golang并发 | XiChen&#39;s Blog</title>
    <meta name="author" content="Lin Xueyuan">
    
    <meta name="description" content="嗨，我是兮尘，全栈数据学徒。这里没有花俏艳丽的魔法，没有苍蛮霸道的斗气，有的，仅仅是繁衍到巅峰的代码！">
    
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta property="og:title" content="Golang并发"/>
    <meta property="og:site_name" content="XiChen"/>

    
    <meta property="og:image" content=""/>
    

    <link rel="icon" type="image/png" href="/assets/images/favicon.ico" />
    <link rel="alternate" href="/atom.xml" title="XiChen" type="application/atom+xml">
    <link rel="stylesheet" href="/css/lib/materialize.min.css">
    <link rel="stylesheet" href="/css/lib/font-awesome.min.css">
    <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
    <link rel="stylesheet" href="//fonts.gdgdocs.org/css?family=Lobster" type="text/css">
    
    
        <link rel="stylesheet" href="/css/lib/prettify-tomorrow-night-eighties.css" type="text/css">
    
    <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
</head>


<body>
    <img src="/weixin_favicon.png" style="position: absolute; left: -9999px; opacity: 0; filter: alpha(opacity=0);">

    <nav class="indigo nav">
    <div class="nav-wrapper">
        <a href="#" data-activates="main-menu" class="button-collapse">
            <i class="fa fa-navicon"></i>
        </a>
        <div class="">
            <div style="font-family: Lobster, Monospace;">
                <a href="/" class="brand-logo hide-on-med-and-down" style="font-family: Lobster, Monospace;">
                    XiChen
                </a>
            </div>
            <ul class="nav-menu right hide-on-med-and-down">
                
                    <li class="tab">
                        <a class="menu-home " href="/"
                            >
                                <i class="fa fa-home "></i>
                                
                                    首页
                        </a>
                    </li>
                    
                    <li class="tab">
                        <a class="menu-archive " href="/archives"
                            >
                                <i class="fa fa-archive "></i>
                                
                                    归档
                        </a>
                    </li>
                    
                    <li class="tab">
                        <a class="menu-category category-menu" href="javascript:;"
                            data-activates="category-menu"
                            >
                                <i class="fa fa-bookmark "></i>
                                
                                    分类
                        </a>
                    </li>
                    
                    <li class="tab">
                        <a class="menu-apps " href="/apps"
                            >
                                <i class="fa fa-link "></i>
                                
                                    App
                        </a>
                    </li>
                    
                    <li class="tab">
                        <a class="menu-tools " href="/tools"
                            >
                                <i class="fa fa-wrench "></i>
                                
                                    工具
                        </a>
                    </li>
                    
                    <li class="tab">
                        <a class="menu-reading " href="/reading"
                            >
                                <i class="fa fa-book "></i>
                                
                                    读书
                        </a>
                    </li>
                    
                    <li class="tab">
                        <a class="menu-about " href="/about"
                            >
                                <i class="fa fa-user "></i>
                                
                                    关于
                        </a>
                    </li>
                    
                    <li class="tab">
                        <a class="menu-search modal-trigger " href="#search"
                            >
                                <i class="fa fa-search "></i>
                                
                                    搜索
                        </a>
                    </li>
                    
            </ul>
            <div>
    <ul class="side-nav indigo darken-1" id="main-menu">
        
        <li class="side-user">
            <div class="row">
                <div class="col s4 no-padding logo-a">
                    <img class="avatar-image circle responsive-img logo" src="/assets/images/avatar.jpg" alt="User Avatar">
                </div>
                <div class="info col s8 valign-wrapper no-padding">
                    <div class="valign">
                        <p class="name">兮尘</p>
                        <p class="desc">Web前端/Android/技术宅</p>
                    </div>
                </div>
            </div>
        </li>
        

        
            <li class="no-padding">
                <a class="waves-effect menu-home " href="/" >
                    <i class="fa fa-home "></i>
                    
                    首页
                </a>
            </li>
        
            <li class="no-padding">
                <a class="waves-effect menu-archive " href="/archives" >
                    <i class="fa fa-archive "></i>
                    
                    归档
                </a>
            </li>
        
            <li class="no-padding">
                <a class="waves-effect menu-category category-menu" href="javascript:;" data-activates="category-menu" >
                    <i class="fa fa-bookmark "></i>
                    
                    分类
                </a>
            </li>
        
            <li class="no-padding">
                <a class="waves-effect menu-apps " href="/apps" >
                    <i class="fa fa-link "></i>
                    
                    App
                </a>
            </li>
        
            <li class="no-padding">
                <a class="waves-effect menu-tools " href="/tools" >
                    <i class="fa fa-wrench "></i>
                    
                    工具
                </a>
            </li>
        
            <li class="no-padding">
                <a class="waves-effect menu-reading " href="/reading" >
                    <i class="fa fa-book "></i>
                    
                    读书
                </a>
            </li>
        
            <li class="no-padding">
                <a class="waves-effect menu-about " href="/about" >
                    <i class="fa fa-user "></i>
                    
                    关于
                </a>
            </li>
        
            <li class="no-padding">
                <a class="waves-effect menu-search modal-trigger " href="#search" >
                    <i class="fa fa-search "></i>
                    
                    搜索
                </a>
            </li>
        
    </ul>

    <ul class="side-nav indigo darken-1" id="category-menu">
    

            

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/Linux/">
                    Linux <span class="right">8 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/Tips/">
                    Tips <span class="right">7 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/Proxy/">
                    Proxy <span class="right">2 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/Deep-Learning/">
                    Deep-Learning <span class="right">2 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/Tools/">
                    Tools <span class="right">1 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/Ubuntu/">
                    Ubuntu <span class="right">4 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/算法/">
                    算法 <span class="right">3 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/区块链/">
                    区块链 <span class="right">25 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/Algorithms/">
                    Algorithms <span class="right">1 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/Latex/">
                    Latex <span class="right">2 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/GO/">
                    GO <span class="right">3 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/杂思/">
                    杂思 <span class="right">1 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/Git/">
                    Git <span class="right">1 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/Android/">
                    Android <span class="right">30 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/Web/">
                    Web <span class="right">2 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/密码学/">
                    密码学 <span class="right">1 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/Spider/">
                    Spider <span class="right">1 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/计算机组成原理/">
                    计算机组成原理 <span class="right">1 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/Github/">
                    Github <span class="right">1 篇</span></a>
                </a>
            </li>

        

    </ul>
</div>

        </div>
    </div>
</nav>

<div id="search" class="modal search-modal">
    <div class="row">
        <div class="input-field col s12">
              <input id="search-input" type="text">
              <label for="search-input">搜索</label>
        </div>

    </div>
    <div id="search-result" class="search-result col s12">

    </div>
</div>

    <main>
        <div class="container main-container">
    <nav class="page-nav hide-on-small-only">
    <div class="nav-wrapper indigo">
        <span class="breadcrumb">当前位置（分类目录）</span>
        
            
    
    
    <a class="breadcrumb" href="/categories/GO/">GO</a>


        

        
    </div>
</nav>

<article>
    <div class="card">
        <div class="card-content">
            

            <div class="article-title">
                
    
        <h1>Golang并发</h1>
    


            </div>
            <i class="fa fa-calendar"></i><time class="green-link-context" datetime="2017-08-27T20:19:00.000Z"><a href="/2017/08/28/2017-08-28-Golang-concurency/">2017-08-28</a></time>

            <span id="busuanzi_container_page_pv" class="read-times-container">
    <i class="fa fa-eye"></i>
    <span id="busuanzi_value_page_pv"></span>
</span>

            
    <div class="tags-row">
        
            <a href="/tags/GO/" class="chip green lighten-1">GO</a>
        
    </div>
    


            <div class="toc green-link-context hide-on-med-and-down">
    <ol class="section table-of-contents"><li class="section table-of-contents-item section table-of-contents-level-1"><a class="section table-of-contents-link" href="#运行期线程"><span class="section table-of-contents-number">1.</span> <span class="section table-of-contents-text">运行期线程</span></a></li><li class="section table-of-contents-item section table-of-contents-level-1"><a class="section table-of-contents-link" href="#管道（channel）"><span class="section table-of-contents-number">2.</span> <span class="section table-of-contents-text">管道（channel）</span></a></li><li class="section table-of-contents-item section table-of-contents-level-1"><a class="section table-of-contents-link" href="#同步"><span class="section table-of-contents-number">3.</span> <span class="section table-of-contents-text">同步</span></a></li><li class="section table-of-contents-item section table-of-contents-level-1"><a class="section table-of-contents-link" href="#死锁"><span class="section table-of-contents-number">4.</span> <span class="section table-of-contents-text">死锁</span></a></li><li class="section table-of-contents-item section table-of-contents-level-1"><a class="section table-of-contents-link" href="#数据竞争（data-race）"><span class="section table-of-contents-number">5.</span> <span class="section table-of-contents-text">数据竞争（data race）</span></a></li><li class="section table-of-contents-item section table-of-contents-level-1"><a class="section table-of-contents-link" href="#互斥锁"><span class="section table-of-contents-number">6.</span> <span class="section table-of-contents-text">互斥锁</span></a></li><li class="section table-of-contents-item section table-of-contents-level-1"><a class="section table-of-contents-link" href="#检测数据竞争"><span class="section table-of-contents-number">7.</span> <span class="section table-of-contents-text">检测数据竞争</span></a><ol class="section table-of-contents-child"><li class="section table-of-contents-item section table-of-contents-level-2"><a class="section table-of-contents-link" href="#数据竞争自动检测"><span class="section table-of-contents-number">7.1.</span> <span class="section table-of-contents-text">数据竞争自动检测</span></a></li></ol></li><li class="section table-of-contents-item section table-of-contents-level-1"><a class="section table-of-contents-link" href="#Select语句"><span class="section table-of-contents-number">8.</span> <span class="section table-of-contents-text">Select语句</span></a></li><li class="section table-of-contents-item section table-of-contents-level-1"><a class="section table-of-contents-link" href="#综合所有示例"><span class="section table-of-contents-number">9.</span> <span class="section table-of-contents-text">综合所有示例</span></a></li><li class="section table-of-contents-item section table-of-contents-level-1"><a class="section table-of-contents-link" href="#并行计算"><span class="section table-of-contents-number">10.</span> <span class="section table-of-contents-text">并行计算</span></a></li></ol>
</div>


            <div class="entry green-link-context">
                <h1 id="运行期线程"><a href="#运行期线程" class="headerlink" title="运行期线程"></a>运行期线程</h1><p>Go允许使用go语句开启一个新的运行期线程，即 goroutine，以一个不同的、新创建的goroutine来执行一个函数。同一个程序中的所有goroutine共享同一个地址空间。</p>
<p>Goroutine非常轻量，除了为之分配的栈空间，其所占用的内存空间微乎其微。并且其栈空间在开始时非常小，之后随着堆存储空间的按需分配或释放而变化。内部实现上，goroutine会在多个操作系统线程上多路复用。如果一个goroutine阻塞了一个操作系统线程，例如：等待输入，这个线程上的其他goroutine就会迁移到其他线程，这样能继续运行。开发者并不需要关心/担心这些细节。</p>
<p>下面所示程序会输出<code>“Hello from main goroutine”</code>。也可能会输出<code>“Hello from another goroutine”</code>，具体依赖于两个goroutine哪个先结束。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> fmt.Println(<span class="string">"Hello from another goroutine"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"Hello from main goroutine"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 至此，程序运行结束，</span></span><br><span class="line">    <span class="comment">// 所有活跃的goroutine被杀死</span></span><br><span class="line">&#125;</span><br><span class="line">goroutine1.<span class="keyword">go</span></span><br></pre></td></tr></table></figure></p>
<p>接下来的这个程序，多数情况下，会输出<code>“Hello from main goroutine”</code>和<code>“Hello from another goroutine”</code>，输出的顺序不确定。但还有另一个可能性是：第二个goroutine运行得极其慢，在程序结束之前都没来得及输出相应的消息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> fmt.Println(<span class="string">"Hello from another goroutine"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"Hello from main goroutine"</span>)</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second)        <span class="comment">// 等待1秒，等另一个goroutine结束</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//goroutine2.go</span></span><br></pre></td></tr></table></figure>
<p>下面则是一个相对更加实际的示例，其中定义了一个函数使用并发来推迟触发一个事件。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数Publish在给定时间过期后打印text字符串到标准输出</span></span><br><span class="line">   <span class="comment">// 该函数并不会阻塞而是立即返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Publish</span><span class="params">(text <span class="keyword">string</span>, delay time.Duration)</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(delay)</span><br><span class="line">        fmt.Println(<span class="string">"BREAKING NEWS:"</span>, text)</span><br><span class="line">    &#125;()    <span class="comment">// 注意这里的括号。必须调用匿名函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//publish1.go</span></span><br></pre></td></tr></table></figure></p>
<p>你可能会这样使用Publish函数：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Publish(<span class="string">"A goroutine starts a new thread of execution."</span>, <span class="number">5</span>*time.Second)</span><br><span class="line">    fmt.Println(<span class="string">"Let’s hope the news will published before I leave."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待发布新闻</span></span><br><span class="line">    time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"Ten seconds later: I’m leaving now."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//publish1.go</span></span><br></pre></td></tr></table></figure></p>
<p>这个程序，绝大多数情况下，会输出以下三行，顺序固定，每行输出之间相隔5秒。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go run publish1.go</span><br><span class="line">Let’s hope the news will published before I leave.</span><br><span class="line">BREAKING NEWS: A goroutine starts a new thread of execution.</span><br><span class="line">Ten seconds later: I’m leaving now.</span><br></pre></td></tr></table></figure></p>
<p>一般来说，通过睡眠的方式来编排线程之间相互等待是不太可能的。下一章节会介绍Go语言中的一种同步机制 - 管道，并演示如何使用管道让一个goroutine等待另一个goroutine。</p>
<h1 id="管道（channel）"><a href="#管道（channel）" class="headerlink" title="管道（channel）"></a>管道（channel）</h1><p>管道是Go语言的一个构件，提供一种机制用于两个goroutine之间通过传递一个指定类型的值来同步运行和通讯。操作符&lt;-用于指定管道的方向，发送或接收。如果未指定方向，则为双向管道。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">chan</span> Sushi        <span class="comment">// 可用来发送和接收Sushi类型的值</span></span><br><span class="line"><span class="keyword">chan</span>&lt;- <span class="keyword">float64</span>    <span class="comment">// 仅可用来发送float64类型的值</span></span><br><span class="line">&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>        <span class="comment">// 仅可用来接收int类型的值</span></span><br></pre></td></tr></table></figure></p>
<p>管道是引用类型，基于make函数来分配。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ic := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)    <span class="comment">// 不带缓冲的int类型管道</span></span><br><span class="line">wc := <span class="built_in">make</span>(<span class="keyword">chan</span> *Work, <span class="number">10</span>)    <span class="comment">// 带缓冲的Work类型指针管道</span></span><br></pre></td></tr></table></figure></p>
<p>如果通过管道发送一个值，则将&lt;-作为二元操作符使用。通过管道接收一个值，则将其作为一元操作符使用：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ic &lt;- <span class="number">3</span>        <span class="comment">// 往管道发送3</span></span><br><span class="line">work := &lt;-wc    <span class="comment">// 从管道接收一个指向Work类型值的指针</span></span><br></pre></td></tr></table></figure></p>
<p>如果管道不带缓冲，发送方会阻塞直到接收方从管道中接收了值。如果管道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。</p>
<p>关闭管道（Close）</p>
<p>close 函数标志着不会再往某个管道发送值。在调用close之后，并且在之前发送的值都被接收后，接收操作会返回一个零值，不会阻塞。一个多返回值的接收操作会额外返回一个布尔值用来指示返回的值是否发送操作传递的。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch &lt;- <span class="string">"Hello!"</span></span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println(&lt;-ch)    <span class="comment">// 输出字符串"Hello!"</span></span><br><span class="line">fmt.Println(&lt;-ch)    <span class="comment">// 输出零值 - 空字符串""，不会阻塞</span></span><br><span class="line">fmt.Println(&lt;-ch)    <span class="comment">// 再次打印输出空字符串""</span></span><br><span class="line">v, ok := &lt;-ch        <span class="comment">// 变量v的值为空字符串""，变量ok的值为false</span></span><br></pre></td></tr></table></figure></p>
<p>一个带有range子句的for语句会依次读取发往管道的值，直到该管道关闭：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 译注：要想运行该示例，需要先定义类型Sushi，如type Sushi string</span></span><br><span class="line">    <span class="keyword">var</span> ch &lt;-<span class="keyword">chan</span> Sushi = Producer()</span><br><span class="line">    <span class="keyword">for</span> s := <span class="keyword">range</span> ch &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Consumed"</span>, s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Producer</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">Sushi</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Sushi)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ch &lt;- Sushi(<span class="string">"海老握り"</span>)    <span class="comment">// Ebi nigiri</span></span><br><span class="line">        ch &lt;- Sushi(<span class="string">"鮪とろ握り"</span>) <span class="comment">// Toro nigiri</span></span><br><span class="line">        <span class="built_in">close</span>(ch)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sushi.go</span></span><br></pre></td></tr></table></figure></p>
<h1 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h1><p>下一个示例中，我们让Publish函数返回一个管道 - 用于在发布text变量值时广播一条消息：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在给定时间过期时，Publish函数会打印text变量值到标准输出</span></span><br><span class="line"><span class="comment">// 在text变量值发布后，该函数会关闭管道wait</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Publish</span><span class="params">(text <span class="keyword">string</span>, delay time.Duration)</span> <span class="params">(wait &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(delay)</span><br><span class="line">        fmt.Println(<span class="string">"BREAKING NEWS:"</span>, text)</span><br><span class="line">        <span class="built_in">close</span>(ch)    <span class="comment">// 广播 - 一个关闭的管道都会发送一个零值</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//publish2.go</span></span><br></pre></td></tr></table></figure></p>
<p>注意：我们使用了一个空结构体的管道：struct{}。这明确地指明该管道仅用于发信号，而不是传递数据。</p>
<p>我们可能会这样使用这个函数：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wait := Publish(<span class="string">"Channels let goroutines communicate."</span>, <span class="number">5</span>*time.Second)</span><br><span class="line">    fmt.Println(<span class="string">"Waiting for the news..."</span>)</span><br><span class="line">    &lt;-wait</span><br><span class="line">    fmt.Println(<span class="string">"The news is out, time to leave."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//publish2.go</span></span><br></pre></td></tr></table></figure></p>
<p>这个程序会按指定的顺序输出以下三行内容。最后一行在新闻（news）一出就会立即输出。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go run publish2.go</span></span><br><span class="line">Waiting for the news...</span><br><span class="line">BREAKING NEWS: Channels let goroutines communicate.</span><br><span class="line">The news is out, time to leave.</span><br></pre></td></tr></table></figure></p>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>现在我们在Publish函数中引入一个bug：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Publish</span><span class="params">(text <span class="keyword">string</span>, delay time.Duration)</span> <span class="params">(wait &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(delay)</span><br><span class="line">        fmt.Println(<span class="string">"BREAKING NEWS:"</span>, text)</span><br><span class="line">        <span class="comment">// 译注：注意这里将close函数调用注释掉了</span></span><br><span class="line">        <span class="comment">//close(ch)</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主程序还是像之前一样开始运行：输出第一行，然后等待5秒，这时Publish函数开启的goroutine会输出突发新闻（breaking news），然后退出，留下主goroutine独自等待。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wait := Publish(<span class="string">"Channels let goroutines communicate."</span>, <span class="number">5</span>*time.Second)</span><br><span class="line">    fmt.Println(<span class="string">"Waiting for the news..."</span>)</span><br><span class="line">    <span class="comment">// 译注：注意下面这一句</span></span><br><span class="line">    &lt;-wait</span><br><span class="line">    fmt.Println(<span class="string">"The news is out, time to leave."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此刻之后，程序无法再继续往下执行。众所周知，这种情形即为死锁。</p>
<blockquote>
<p>死锁是线程之间相互等待，其中任何一个都无法向前运行的情形。</p>
</blockquote>
<p>Go语言对于运行时的死锁检测具备良好的支持。当没有任何goroutine能够往前执行的情形发生时，Go程序通常会提供详细的错误信息。以下就是我们的问题程序的输出：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Waiting for the news...</span><br><span class="line">BREAKING NEWS: Channels let goroutines communicate.</span><br><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine 1 [chan receive]:</span><br><span class="line">main.main()</span><br><span class="line">    .../goroutineStop.go:11 +0xf6</span><br><span class="line"></span><br><span class="line">goroutine 2 [syscall]:</span><br><span class="line">created by runtime.main</span><br><span class="line">    .../go/src/pkg/runtime/proc.c:225</span><br><span class="line"></span><br><span class="line">goroutine 4 [timer goroutine (idle)]:</span><br><span class="line">created by addtimer</span><br><span class="line">    .../go/src/pkg/runtime/ztime_linux_amd64.c:73</span><br></pre></td></tr></table></figure></p>
<p>大多数情况下找出Go程序中造成死锁的原因都比较容易，那么剩下的就是如何解决这个bug了。</p>
<h1 id="数据竞争（data-race）"><a href="#数据竞争（data-race）" class="headerlink" title="数据竞争（data race）"></a>数据竞争（data race）</h1><p>死锁也许听起来令人挺忧伤的，但伴随并发编程真正灾难性的错误其实是数据竞争，相当常见，也可能非常难于调试。</p>
<blockquote>
<p>当两个线程并发地访问同一个变量，并且其中至少一个访问是写操作时，数据竞争就发生了。</p>
</blockquote>
<p>下面的这个函数就有数据竞争问题，其行为是未定义的。例如，可能输出数值1。代码之后是一个可能性解释，试图搞清楚这一切是如何发生得。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">race</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wait := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    n := <span class="number">0</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 译注：注意下面这一行</span></span><br><span class="line">        n++ <span class="comment">// 一次访问: 读, 递增, 写</span></span><br><span class="line">        <span class="built_in">close</span>(wait)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 译注：注意下面这一行</span></span><br><span class="line">    n++ <span class="comment">// 另一次冲突的访问</span></span><br><span class="line">    &lt;-wait</span><br><span class="line">    fmt.Println(n) <span class="comment">// 输出：未指定</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//datarace.go</span></span><br></pre></td></tr></table></figure></p>
<p>代码中的两个goroutine（假设命名为g1和g2）参与了一次竞争，我们无法获知操作会以何种顺序发生。以下是诸多可能中的一种：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">g1 从 n 中获取值<span class="number">0</span></span><br><span class="line">g2 从 n 中获取值<span class="number">0</span></span><br><span class="line">g1 将值从<span class="number">0</span>增大到<span class="number">1</span></span><br><span class="line">g1 将<span class="number">1</span>写到 n</span><br><span class="line">g2 将值从<span class="number">0</span>增大到<span class="number">1</span></span><br><span class="line">g2 将<span class="number">1</span>写到 n</span><br><span class="line">程序输出 n 的值，当前为<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>“数据竞争（data race）”这名字有点误导的嫌疑。不仅操作的顺序是未定义的，其实根本没有任何保证（no guarantees whatsoever）。编译器和硬件为了得到更好的性能，经常都会对代码进行上下内外的顺序变换。如果你看到一个线程处于中间行为状态时，那么当时的场景可能就像下图所示的一样：</p>
<p>避免数据竞争的唯一方式是线程间同步访问所有的共享可变数据。有几种方式能够实现这一目标。Go语言中，通常是使用管道或者锁。（sync和sync/atomic包中还有更低层次的机制可供使用，但本文中不做讨论）。</p>
<p>Go语言中，处理并发数据访问的推荐方式是使用管道从一个goroutine中往下一个goroutine传递实际的数据。有格言说得好：“不要通过共享内存来通讯，而是通过通讯来共享内存”。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sharingIsCaring</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        n := <span class="number">0</span> <span class="comment">// 仅为一个goroutine可见的局部变量.</span></span><br><span class="line">        n++</span><br><span class="line">        ch &lt;- n <span class="comment">// 数据从一个goroutine离开...</span></span><br><span class="line">    &#125;()</span><br><span class="line">    n := &lt;-ch   <span class="comment">// ...然后安全到达另一个goroutine.</span></span><br><span class="line">    n++</span><br><span class="line">    fmt.Println(n) <span class="comment">// 输出: 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//datarace.go</span></span><br></pre></td></tr></table></figure></p>
<p>以上代码中的管道肩负双重责任 - 从一个goroutine将数据传递到另一个goroutine，并且起到同步的作用：发送方goroutine会等待另一个goroutine接收数据，接收方goroutine也会等待另一个goroutine发送数据。</p>
<blockquote>
<p>Go语言内存模型 - 要保证一个goroutine中对一个变量的读操作得到的值正好是另一个goroutine中对同一个变量写操作产生的值，条件相当复杂，但goroutine之间只要通过管道来共享所有可变数据，那么就能远离数据竞争了。</p>
</blockquote>
<h1 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h1><p>有时，通过显式加锁，而不是使用管道，来同步数据访问，可能更加便捷。Go语言标准库为这一目的提供了一个互斥锁 - sync.Mutex。</p>
<p>要想这类加锁起效的话，关键之处在于：所有对共享数据的访问，不管读写，仅当goroutine持有锁才能操作。一个goroutine出错就足以破坏掉一个程序，引入数据竞争。</p>
<p>因此，应该设计一个自定义数据结构，具备明确的API，确保所有的同步都在数据结构内部完成。下例中，我们构建了一个安全、易于使用的并发数据结构，AtomicInt，用于存储一个整型值。任意数量的goroutine都能通过Add和Value方法安全地访问这个数值。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AtomicInt是一个并发数据结构，持有一个整数值</span></span><br><span class="line"><span class="comment">// 该数据结构的零值为0</span></span><br><span class="line"><span class="keyword">type</span> AtomicInt <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu sync.Mutex <span class="comment">// 锁，一次仅能被一个goroutine持有。</span></span><br><span class="line">    n  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add方法作为一个原子操作将n加到AtomicInt</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AtomicInt)</span> <span class="title">Add</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    a.mu.Lock() <span class="comment">// 等待锁释放，然后持有它</span></span><br><span class="line">    a.n += n</span><br><span class="line">    a.mu.Unlock() <span class="comment">// 释放锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Value方法返回a的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AtomicInt)</span> <span class="title">Value</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    a.mu.Lock()</span><br><span class="line">    n := a.n</span><br><span class="line">    a.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lockItUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wait := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">var</span> n AtomicInt</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        n.Add(<span class="number">1</span>) <span class="comment">// 一个访问</span></span><br><span class="line">        <span class="built_in">close</span>(wait)</span><br><span class="line">    &#125;()</span><br><span class="line">    n.Add(<span class="number">1</span>) <span class="comment">// 另一个并发访问</span></span><br><span class="line">    &lt;-wait</span><br><span class="line">    fmt.Println(n.Value()) <span class="comment">// 输出: 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//datarace.go</span></span><br></pre></td></tr></table></figure></p>
<h1 id="检测数据竞争"><a href="#检测数据竞争" class="headerlink" title="检测数据竞争"></a>检测数据竞争</h1><p>竞争有时非常难于检测。下例中的这个函数有一个数据竞争问题，执行这个程序时会输出55555。尝试一下，也许你会得到一个不同的结果。（sync.WaitGroup是Go语言标准库的一部分；用于等待一组goroutine结束运行。）<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">race</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">5</span>)</span><br><span class="line">    <span class="comment">// 译注：注意下面这行代码中的i++</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// 注意下一行代码会输出什么？为什么？</span></span><br><span class="line">            fmt.Print(i) <span class="comment">// 6个goroutine共享变量i</span></span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait() <span class="comment">// 等待所有（5个）goroutine运行结束</span></span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//raceClosure.go</span></span><br></pre></td></tr></table></figure></p>
<p>对于输出55555，一个貌似合理的解释是：执行i++的goroutine在其他goroutine执行打印语句之前就完成了5次i++操作。实际上变量i更新后的值为其他goroutine所见纯属巧合。</p>
<p>一个简单的解决方案是：使用一个局部变量，然后当开启新的goroutine时，将数值作为参数传递：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">correct</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123; <span class="comment">// 使用局部变量</span></span><br><span class="line">            fmt.Print(n)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//raceClosure.go</span></span><br></pre></td></tr></table></figure></p>
<p>这次代码就对了，程序会输出期望的结果，如：24031。注意：goroutine之间的运行顺序是不确定的。</p>
<p>仍旧使用闭包，但能够避免数据竞争也是可能的，必须小心翼翼地让每个goroutine使用一个独有的变量。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alsoCorrect</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        n := i <span class="comment">// 为每个闭包创建一个独有的变量</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Print(n)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//raceClosure.go</span></span><br></pre></td></tr></table></figure></p>
<h2 id="数据竞争自动检测"><a href="#数据竞争自动检测" class="headerlink" title="数据竞争自动检测"></a>数据竞争自动检测</h2><p>一般来说，不太可能能够自动检测发现所有可能的数据竞争情况，但Go（从版本1.1开始）有一个强大的数据竞争检测器。</p>
<p>这个工具用起来也很简单：只要在使用go命令时加上-race标记即可。开启检测器运行上面的程序会给出清晰且信息量大的输出：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go run -race raceClosure.go</span></span><br><span class="line">Race:</span><br><span class="line">==================</span><br><span class="line">WARNING: DATA RACE</span><br><span class="line">Read by goroutine 2:</span><br><span class="line">    main.func·001()</span><br><span class="line">      ../raceClosure.go:22 +0x65</span><br><span class="line"></span><br><span class="line">Previous write by goroutine 0:</span><br><span class="line">    main.race()</span><br><span class="line">        ../raceClosure.go:20 +0x19b</span><br><span class="line">    main.main()</span><br><span class="line">        ../raceClosure.go:10 +0x29</span><br><span class="line">    runtime.main()</span><br><span class="line">        ../go/src/pkg/runtime/proc.c:248 +0x91</span><br><span class="line"></span><br><span class="line">Goroutine 2 (running) created at:</span><br><span class="line">    main.race()</span><br><span class="line">      ../raceClosure.go:24 +0x18b</span><br><span class="line">    main.main()</span><br><span class="line">      ../raceClosure.go:10 +0x29</span><br><span class="line">     runtime.main()</span><br><span class="line">      ../go/src/pkg/runtime/proc.c:248 +0x91</span><br><span class="line"></span><br><span class="line">==================</span><br><span class="line">55555</span><br><span class="line">Correct:</span><br><span class="line">01234</span><br><span class="line">Also correct:</span><br><span class="line">01324</span><br><span class="line">Found 1 data race(s)</span><br><span class="line">exit status 66</span><br></pre></td></tr></table></figure></p>
<p>该工具发现一处数据竞争，包含：一个goroutine在第20行对一个变量进行写操作，跟着另一个goroutine在第22行对同一个变量进行了未同步的读操作。</p>
<p>注意：竞争检测器只能发现在运行期确实发生的数据竞争（译注：我也不太理解这话，请指导）</p>
<h1 id="Select语句"><a href="#Select语句" class="headerlink" title="Select语句"></a>Select语句</h1><p>select语句是Go语言并发工具集中的终极工具。select用于从一组可能的通讯中选择一个进一步处理。如果任意一个通讯都可以进一步处理，则从中随机选择一个，执行对应的语句。否则，如果又没有默认分支（default case），select语句则会阻塞，直到其中一个通讯完成。</p>
<p>以下是一个玩具示例，演示select语句如何用于实现一个随机数生成器：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RandomBits函数 返回一个管道，用于产生一个比特随机序列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RandomBits</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> ch &lt;- <span class="number">0</span>: <span class="comment">// 注意：分支没有对应的处理语句</span></span><br><span class="line">            <span class="keyword">case</span> ch &lt;- <span class="number">1</span>:</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//randBits.go</span></span><br></pre></td></tr></table></figure></p>
<p>下面是相对更加实际一点的例子：如何使用select语句为一个操作设置一个时间限制。代码会输出变量news的值或者超时消息，具体依赖于两个接收语句哪个先执行：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> news := &lt;-NewsAgency:</span><br><span class="line">    fmt.Println(news)</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(time.Minute):</span><br><span class="line">    fmt.Println(<span class="string">"Time out: no news in one minute."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数 time.After 是Go语言标准库的一部分；它会在等待指定时间后将当前的时间发送到返回的管道中。</p>
<h1 id="综合所有示例"><a href="#综合所有示例" class="headerlink" title="综合所有示例"></a>综合所有示例</h1><p>花点时间认真研究一下这个示例。如果你完全理解，也就对Go语言中并发的应用方式有了全面的掌握。</p>
<p>这个程序演示了如何将管道用于被任意数量的goroutine发送和接收数据，也演示了如何将select语句用于从多个通讯中选择一个。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    people := []<span class="keyword">string</span>&#123;<span class="string">"Anna"</span>, <span class="string">"Bob"</span>, <span class="string">"Cody"</span>, <span class="string">"Dave"</span>, <span class="string">"Eva"</span>&#125;</span><br><span class="line">    match := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>) <span class="comment">// 为一个未匹配的发送操作提供空间</span></span><br><span class="line">    wg := <span class="built_in">new</span>(sync.WaitGroup)</span><br><span class="line">    wg.Add(<span class="built_in">len</span>(people))</span><br><span class="line">    <span class="keyword">for</span> _, name := <span class="keyword">range</span> people &#123;</span><br><span class="line">        <span class="keyword">go</span> Seek(name, match, wg)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> name := &lt;-match:</span><br><span class="line">        fmt.Printf(<span class="string">"No one received %s’s message.\n"</span>, name)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 没有待处理的发送操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数Seek 发送一个name到match管道或从match管道接收一个peer，结束时通知wait group</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Seek</span><span class="params">(name <span class="keyword">string</span>, match <span class="keyword">chan</span> <span class="keyword">string</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> peer := &lt;-match:</span><br><span class="line">        fmt.Printf(<span class="string">"%s sent a message to %s.\n"</span>, peer, name)</span><br><span class="line">    <span class="keyword">case</span> match &lt;- name:</span><br><span class="line">        <span class="comment">// 等待某个goroutine接收我的消息</span></span><br><span class="line">    &#125;</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//matching.go</span></span><br></pre></td></tr></table></figure></p>
<p>示例输出：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go run matching.go</span></span><br><span class="line">Cody sent a message to Bob.</span><br><span class="line">Anna sent a message to Eva.</span><br><span class="line">No one received Dave’s message.</span><br></pre></td></tr></table></figure></p>
<h1 id="并行计算"><a href="#并行计算" class="headerlink" title="并行计算"></a>并行计算</h1><p>并发的一个应用是将一个大的计算切分成一些工作单元，调度到不同的CPU上同时地计算。</p>
<p>将计算分布到多个CPU上更多是一门艺术，而不是一门科学。以下是一些经验法则：</p>
<ul>
<li>每个工作单元应该花费大约100微秒到1毫秒的时间用于计算。如果单元粒度太小，切分问题以及调度子问题的管理开销可能就会太大。如果单元粒度太大，整个计算也许不得不等待一个慢的工作项结束。这种缓慢可能因为多种原因而产生，比如：调度、其他进程的中断或者糟糕的内存布局。（注意：工作单元的数目是不依赖于CPU的数目的）</li>
<li>尽可能减小共享的数据量。并发写操作的代价非常大，特别是如果goroutine运行在不同的CPU上。读操作之间的数据共享则通常不会是个问题。</li>
<li>数据访问尽量利用良好的局部性。如果数据能保持在缓存中，数据加载和存储将会快得多得多，这对于写操作也格外地重要。</li>
<li>下面的这个示例展示如何切分一个开销很大的计算并将其分布在所有可用的CPU上进行计算。先看一下有待优化的代码：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vector []<span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数Convolve 计算 w = u * v，其中 w[k] = Σ u[i]*v[j], i + j = k</span></span><br><span class="line"><span class="comment">// 先决条件：len(u) &gt; 0, len(v) &gt; 0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Convolve</span><span class="params">(u, v Vector)</span> <span class="params">(w Vector)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(u) + <span class="built_in">len</span>(v) - <span class="number">1</span></span><br><span class="line">    w = <span class="built_in">make</span>(Vector, n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; n; k++ &#123;</span><br><span class="line">        w[k] = mul(u, v, k)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数mul 返回 Σ u[i]*v[j], i + j = k.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mul</span><span class="params">(u, v Vector, k <span class="keyword">int</span>)</span> <span class="params">(res <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    n := min(k+<span class="number">1</span>, <span class="built_in">len</span>(u))</span><br><span class="line">    j := min(k, <span class="built_in">len</span>(v)<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := k - j; i &lt; n; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">        res += u[i] * v[j]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>思路很简单：确定合适大小的工作单元，然后在不同的goroutine中执行每个工作单元。以下是并发版本的 Convolve：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Convolve</span><span class="params">(u, v Vector)</span> <span class="params">(w Vector)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(u) + <span class="built_in">len</span>(v) - <span class="number">1</span></span><br><span class="line">    w = <span class="built_in">make</span>(Vector, n)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 w 切分成花费 ~100μs-1ms 用于计算的工作单元</span></span><br><span class="line">    size := max(<span class="number">1</span>, <span class="number">1</span>&lt;&lt;<span class="number">20</span>/n)</span><br><span class="line"></span><br><span class="line">    wg := <span class="built_in">new</span>(sync.WaitGroup)</span><br><span class="line">    wg.Add(<span class="number">1</span> + (n<span class="number">-1</span>)/size)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n &amp;&amp; i &gt;= <span class="number">0</span>; i += size &#123; <span class="comment">// 整型溢出后 i &lt; 0</span></span><br><span class="line">        j := i + size</span><br><span class="line">        <span class="keyword">if</span> j &gt; n || j &lt; <span class="number">0</span> &#123; <span class="comment">// 整型溢出后 j &lt; 0</span></span><br><span class="line">            j = n</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这些goroutine共享内存，但是只读</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> k := i; k &lt; j; k++ &#123;</span><br><span class="line">                w[k] = mul(u, v, k)</span><br><span class="line">            &#125;</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;(i, j)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//convolution.go</span></span><br></pre></td></tr></table></figure></p>
<p>工作单元定义之后，通常情况下最好将调度工作交给运行时和操作系统。然而，对于Go 1.* 你也许需要告诉运行时希望多少个goroutine来同时地运行代码。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    numcpu := runtime.NumCPU()</span><br><span class="line">    runtime.GOMAXPROCS(numcpu) <span class="comment">// 尝试使用所有可用的CPU</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

                
<p class="green-link-context prev-btn">
    <a href="/2017/08/28/2017-08-28-Terminal-tips/" rel="next" title="terminal tips">
    上一篇：terminal tips
  </a>
</p>



<p class="green-link-context next-btn">
    <a href="/2017/08/28/2017-08-28-Golang-setting/" rel="next" title="Golang程序配置方案小结">
    下一篇：Golang程序配置方案小结
  </a>
</p>


            </div>
			
        </div>
    </div>
</article>




    <div id="gitment_container"></div>
    <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
    <link rel="stylesheet" href="/css/gitment.css" media="screen" type="text/css">
    <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
    <script>
    var gitment = new Gitment({
        id: 'Mon Aug 28 2017 04:19:00 GMT+0800',
        owner: 'linxueyuanstdio',
        repo: 'linxueyuanstdio.github.io',
        oauth: {
            client_id: '2f7f71f1ba398039ff23',
            client_secret: '3ebc908a7042fef2d56a83a2eb8c18777374a087',
        },
    })
    gitment.render('gitment_container')
    </script>



</div>

        <div class="fixed-action-btn float-sitemap">
    <a class="btn-floating btn-large pink">
      <i class="fa fa-caret-square-o-up"></i>
    </a>
    <ul>
      <li><a class="btn-return-top btn-floating waves-effect green" title="回到顶部"><i class="fa fa-arrow-circle-o-up"></i></a></li>
      <li><a class="btn-floating waves-effect button-collapse yellow darken-1"  data-activates="main-menu" title="菜单"><i class="fa fa-navicon"></i></a></li>
    </ul>
  </div>

    </main>
    <footer class="page-footer indigo darken-1">
    
    <div class="footer-container container">
        <div class="row">
            
            <div class="social-group col m4 s12">
                <h5 class="white-text">社交</h5>
                
                    <a class="social-link" href="http://weibo.com/LinXueyuanStdio" target="_blank">
                        <i class="fa fa-2x fa-weibo"></i>
                    </a>
                
                    <a class="social-link" href="https://github.com/LinXueyuanStdio" target="_blank">
                        <i class="fa fa-2x fa-github"></i>
                    </a>
                
                    <a class="social-link" href="https://www.zhihu.com/people/lin-xue-yuan-86" target="_blank">
                        <i class="fa fa-2x fa-graduation-cap"></i>
                    </a>
                
                    <a class="social-link" href="http://twitter.com/cwBQ3A5cz3Jzso7" target="_blank">
                        <i class="fa fa-2x fa-twitter"></i>
                    </a>
                
                    <a class="social-link" href="mailto:761516186@qq.com" target="_blank">
                        <i class="fa fa-2x fa-envelope"></i>
                    </a>
                
                    <a class="social-link" href="/atom.xml" target="_blank">
                        <i class="fa fa-2x fa-rss"></i>
                    </a>
                
                
    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
    </script>
    <div class="site-visitors-container white-text">
        <span>
            <i class="fa fa-user"></i>
            <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
        </span>
        <span>&nbsp;|&nbsp;</span>
        <span>
            <i class="fa fa-eye"></i>
            <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
        </span>
    </div>


            </div>
            

            
            <div class="col m8 s12">
                <h5 class="white-text">友情链接</h5>
                
                    <a class="social-link" href="http://raytaylorlin.com/" target="_blank">raytaylorism主题作者</a>
                
                    <a class="social-link" href="https://github.com/raytaylorlin" target="_blank">Github地址</a>
                
            </div>
            
        </div>
    </div>
    

    <div class="footer-copyright green-link-context">
        <div class="container">
            © 2018 xichen.pub, All rights reserved.
            <p class="right" style="margin-top: 0;">本博客由 <a href="https://hexo.io">Hexo</a> 强力驱动 | 主题 <a href="https://github.com/raytaylorlin/hexo-theme-raytaylorism">raytaylorism</a></p>
        </div>
    </div>
</footer>


    <noscript>
    <div class="noscript">
        <p class="center-align">当前网速较慢或者你使用的浏览器不支持博客特定功能，请尝试刷新或换用Chrome、Firefox等现代浏览器</p>
    </div>
</noscript>
<div class="noscript">
    <p class="center-align">当前网速较慢或者你使用的浏览器不支持博客特定功能，请尝试刷新或换用Chrome、Firefox等现代浏览器</p>
</div>


<script src="/js/jquery.min.js"></script>
<script src="/js/materialize.min.js"></script>
<script src="/js/canvas.js"></script>

<script>
    (function($) {
        $(document).ready(function() {
            // 隐藏禁用javascript（针对微信内置浏览器）的提示
            $('.noscript').hide();

            // 图片缩放效果
            var $imgs = $('img').not('.slider-image').not('.avatar-image').not('.carousel-image').not('.card-cover-image').not('.qrcode');

            // 给图片加上点击放大效果（materialbox插件）
            $imgs.addClass('materialboxed').each(function(i, el) {
                $(this).attr('data-caption', $(this).attr('alt') || ' ');
            }).materialbox();

            // 优化表格的显示
            $('table').each(function() {
                var $table = $(this);
                // 除去多行代码的情况
                if ($table.find('pre').length == 0) {
                    $table.addClass('responsive-table striped bordered');
                }
            });

            // 首页幻灯片
            $('.slider').slider({indicators: true, full_width: true, interval: 8000});

            $(".button-collapse").sideNav();
            $(".category-menu").sideNav();

            // 针对gallery post
            $('.carousel').carousel({full_width: true});
            $('.carousel-control.prev').click(function() {
                $('.carousel').carousel('prev');
            });
            $('.carousel-control.next').click(function() {
                $('.carousel').carousel('next');
            });

            // 文章目录
            $('article').not('.simple-article').find('h1').add('h2').add('h3').add('h4').add('h5').add('h6').scrollSpy();

            // 目录随屏幕滚动（防止目录过长越过footer）
            var $toc = $('.toc');
            var scrollTargetTop = 0;
            $(window).scroll(function() {
                var $activeLink = $toc.find('a.active.section');
                if ($(window).scrollTop() < 100) {
                    scrollTargetTop = 0;
                } else {
                    if ($activeLink[0]) {
                        scrollTargetTop = $activeLink.offset().top - $toc.offset().top;
                    }
                }
                $toc.css('top', '-' + scrollTargetTop + 'px');
            });

            // 修正文章目录的left-border颜色
            var color = $('.table-of-contents-text').css('color');
            $('.table-of-contents-link').css('border-left-color', color);

            // 针对移动端做的优化：FAB按钮点击一下收回
            if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
                $('.fixed-action-btn').addClass('click-to-toggle');
            }
            // 回到顶部
            $('.btn-return-top').click(function() {
                $('body, html').animate({
                    scrollTop: 0
                }, 500);
            });

            // 重置读书页面的Tab标签页的颜色
            $('li.tab a').hover(function() {
                $(this).toggleClass('text-lighten-4');
            });
            $('.indicator').addClass('pink lighten-2');

            
            // 添加new标签
            $('.menu-apps').append('<span class="new badge pink"></span>');
            

            // 搜索功能
            $('.modal-trigger').leanModal({
                // 打开搜索框时自动聚焦
                ready: function() {
                    if ($('#search').is(":visible")) {
                        $('#search-input').focus();
                    }
                }
            });
            var searchXml = "search.xml";
            if (searchXml.length == 0) {
             	searchXml = "search.xml";
            }
            var searchPath = "/" + searchXml;
            initSearch(searchPath, 'search-input', 'search-result');
        });

        // 初始化搜索与匹配函数
        var initSearch = function(path, search_id, content_id) {
            'use strict';
            $.ajax({
                url: path,
                dataType: "xml",
                success: function(xmlResponse) {
                    // get the contents from search data
                    var datas = $("entry", xmlResponse).map(function() {
                        return {
                            title: $("title", this).text(),
                            content: $("content", this).text(),
                            url: $("url", this).text()
                        };
                    }).get();
                    var $input = document.getElementById(search_id);
                    var $resultContent = document.getElementById(content_id);
                    $input.addEventListener('input', function() {
                        var str = '<ul class=\"search-result-list\">';
                        var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                        $resultContent.innerHTML = "";
                        if (this.value.trim().length <= 0) {
                            return;
                        }
                        // perform local searching
                        datas.forEach(function(data) {
                            var isMatch = true;
                            var content_index = [];
                            var data_title = data.title.trim().toLowerCase();
                            var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                            var data_url = data.url;
                            var index_title = -1;
                            var index_content = -1;
                            var first_occur = -1;
                            // only match artiles with not empty titles and contents
                            if (data_title != '' && data_content != '') {
                                keywords.forEach(function(keyword, i) {
                                    index_title = data_title.indexOf(keyword);
                                    index_content = data_content.indexOf(keyword);
                                    if (index_title < 0 && index_content < 0) {
                                        isMatch = false;
                                    } else {
                                        if (index_content < 0) {
                                            index_content = 0;
                                        }
                                        if (i == 0) {
                                            first_occur = index_content;
                                        }
                                    }
                                });
                            }
                            // show search results
                            if (isMatch) {
                                keywords.forEach(function(keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    data_title = data_title.replace(regS, "<span class=\"search-keyword green lighten-2\">" + keyword + "</span>");
                                });

                                str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                                var content = data.content.trim().replace(/<[^>]+>/g, "");
                                if (first_occur >= 0) {
                                    // cut out 100 characters
                                    var start = first_occur - 20;
                                    var end = first_occur + 80;
                                    if (start < 0) {
                                        start = 0;
                                    }
                                    if (start == 0) {
                                        end = 100;
                                    }
                                    if (end > content.length) {
                                        end = content.length;
                                    }
                                    var match_content = content.substring(start, end);
                                    // highlight all keywords
                                    keywords.forEach(function(keyword) {
                                        var regS = new RegExp(keyword, "gi");
                                        match_content = match_content.replace(regS, "<span class=\"search-keyword green lighten-2\">" + keyword + "</span>");
                                    });

                                    str += "<p class=\"search-result\">..." + match_content + "...</p>"
                                }
                                str += "</li>";
                            }
                        });
                        str += "</ul>";
                        $resultContent.innerHTML = str;
                    });
                }
            });
        }
    })(jQuery);
</script>


<script src="/js/prettify.js"></script>
<script type="text/javascript">
    $(document).ready(function() {
        $("pre").addClass("prettyprint");
        prettyPrint();
    });
</script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>
<script type="text/javascript" async
  src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>



</body>
</html>
