{"meta":{"title":"XiChen","subtitle":"XiChen's Blog","description":"嗨，我是兮尘，全栈数据学徒。这里没有花俏艳丽的魔法，没有苍蛮霸道的斗气，有的，仅仅是繁衍到巅峰的代码！","author":"Lin Xueyuan","url":"http://xichen.pub"},"pages":[{"title":"Apps","date":"2018-01-20T04:28:46.039Z","updated":"2018-01-20T04:28:46.039Z","comments":true,"path":"apps/index.html","permalink":"http://xichen.pub/apps/index.html","excerpt":"","text":"FlappyBird在web端实现了Flappy Bird，并用神经网络作为后端，使小鸟自进化 generate-girls用GAN(对抗生成网络)生成动漫头像 preview可直接加载渲染Github上的html文件，而不需要搞出网站 robot-dance机器人跳舞，甩飞会变成巨人"},{"title":"读书","date":"2018-01-19T18:21:04.073Z","updated":"2018-01-19T18:21:04.073Z","comments":true,"path":"reading/index.html","permalink":"http://xichen.pub/reading/index.html","excerpt":"","text":""},{"title":"关于","date":"2018-01-19T18:21:04.071Z","updated":"2018-01-19T18:21:04.071Z","comments":true,"path":"about/index.html","permalink":"http://xichen.pub/about/index.html","excerpt":"","text":"大家好，我是XXX。欢迎来到我的个人技术博客。 这里用markdown写下你的简介，就跟平时写md一样就可以了。"},{"title":"工具","date":"2018-03-02T16:28:16.290Z","updated":"2018-03-02T16:28:16.290Z","comments":true,"path":"tools/index.html","permalink":"http://xichen.pub/tools/index.html","excerpt":"","text":"VPN『 没有VPN的程序员是不完整的 』 shadowsocks 蓝灯 GreenVPN 小神器『 我这么好用当然是要你来找到我啦 』 Dukto 命令行『 sexy~ 』 SpaceVim 在线IDE『 移动办公 』 jdoodle java在线编译 Java"}],"posts":[{"title":"【Android TimeCat】 原地归并排序","slug":"2018-03-01-Android-TimeCat-原地归并排序","date":"2018-03-01T04:43:00.000Z","updated":"2018-03-02T14:52:04.047Z","comments":true,"path":"2018/03/01/2018-03-01-Android-TimeCat-原地归并排序/","link":"","permalink":"http://xichen.pub/2018/03/01/2018-03-01-Android-TimeCat-原地归并排序/","excerpt":"","text":"背景Time Cat中有个需求，需要把用户的task排序。 排序规则为，先按label排，每个label下按创建日期排，task处于完成状态的话覆盖原来label。label有四个，重要紧急，重要不紧急，紧急不重要，不重要不紧急。label加上完成状态共5组。 实现思路是先用桶排序分组，再对每个组内用原地归并排序。 考虑到分组有且只有5组，用桶排序逻辑清晰，易于阅读，效率也高。 之所以用原地归并排序，是因为我想学(zhuang)习(bi)。用其他排序方法也是可以的，因为单个用户的task不会太多，而且排序放在网络请求之后，各种排序方法的差别不大。 纯java版原地归并排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* * 原地归并 */public class InPlaceMergeSort &#123; private static void reverse(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i++] = arr[j]; arr[j--] = temp; &#125; // swap [bias, bias+headSize) and [bias+headSize, bias+headSize+endSize) private static void swapAdjacentBlocks(int arr[], int bias, int oneSize, int anotherSize) &#123; reverse(arr, bias, bias + oneSize - 1); reverse(arr, bias + oneSize, bias + oneSize + anotherSize - 1); reverse(arr, bias, bias + oneSize + anotherSize - 1); &#125; private static void inplaceMerge(int arr[], int l, int mid, int r) &#123; int i = l; // 指示左侧有序串 int j = mid + 1; // 指示右侧有序串 while(i &lt; j &amp;&amp; j &lt;= r) &#123;//原地归并结束的条件。 while(i &lt; j &amp;&amp; arr[i] &lt;= arr[j]) &#123; i++; &#125; int index = j; while(j &lt;= r &amp;&amp; arr[j] &lt;= arr[i]) &#123; j++; &#125; swapAdjacentBlocks(arr, i, index-i, j-index); i += (j-index); &#125; &#125; public static void mergeSort(int arr[], int l, int r) &#123; if(l &lt; r) &#123; int mid = (l + r) / 2; mergeSort(arr, l, mid); mergeSort(arr, mid + 1, r); inplaceMerge(arr, l, mid, r); &#125; &#125; private static void print(int[] arr) &#123; for (int i : arr) &#123; System.out.print(i+\", \"); &#125; System.out.println(); &#125; /* 测试用例 */ public static void main(String[] args) &#123; int[] arr = &#123;3,5,1,7,0,6,9,11&#125;; mergeSort(arr, 0, arr.length-1); print(arr); &#125;&#125; 纯java版非原地归并排序12345678910111213141516171819202122232425262728293031private static void merge(int[] dest, int[] src, int l, int mid, int r) &#123; int i = l; int p = l; int q = mid + 1; while (p &lt;= mid &amp;&amp; q &lt;= r) &#123; if (src[p] &lt;= src[q]) &#123; dest[i++] = src[p++]; &#125; else &#123; dest[i++] = src[q++]; &#125; &#125; while (p &lt;= mid) &#123; dest[i++] = src[p++]; &#125; while (q &lt;= r) &#123; dest[i++] = src[q++]; &#125; // （原[l, r]范围的内容被复制回原数组） i = l; while (i &lt;= r) &#123; src[i] = dest[i++]; &#125; &#125;public static void mergeSort(int[] dest, int[] src, int l, int r) &#123; if (l &lt; r) &#123; int mid = (l + r) / 2; mergeSort(dest, src, l, mid); mergeSort(dest, src, mid + 1, r); merge(dest, src, l, mid, r); &#125;&#125; 项目运用版 ：桶排序 + 原地归并排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293private ArrayList&lt;DBTask&gt; sort(ArrayList&lt;DBTask&gt; taskArrayList) &#123; ArrayList&lt;DBTask&gt; sortedDBTaskList = new ArrayList&lt;&gt;(); if (taskArrayList == null || taskArrayList.size() &lt;= 0) &#123; return sortedDBTaskList; &#125; ArrayList&lt;DBTask&gt; label_0_DBTaskList = new ArrayList&lt;&gt;(); ArrayList&lt;DBTask&gt; label_1_DBTaskList = new ArrayList&lt;&gt;(); ArrayList&lt;DBTask&gt; label_2_DBTaskList = new ArrayList&lt;&gt;(); ArrayList&lt;DBTask&gt; label_3_DBTaskList = new ArrayList&lt;&gt;(); ArrayList&lt;DBTask&gt; finished_DBTaskList = new ArrayList&lt;&gt;(); for (DBTask dbTask : taskArrayList) &#123; if (dbTask.getIsFinish()) &#123; finished_DBTaskList.add(dbTask); continue; &#125; switch (dbTask.getLabel()) &#123; case DBTask.LABEL_IMPORTANT_URGENT: label_0_DBTaskList.add(dbTask); break; case DBTask.LABEL_IMPORTANT_NOT_URGENT: label_1_DBTaskList.add(dbTask); break; case DBTask.LABEL_NOT_IMPORTANT_URGENT: label_2_DBTaskList.add(dbTask); break; case DBTask.LABEL_NOT_IMPORTANT_NOT_URGENT: label_3_DBTaskList.add(dbTask); break; &#125; &#125; mergeSort2List(label_0_DBTaskList, sortedDBTaskList); mergeSort2List(label_1_DBTaskList, sortedDBTaskList); mergeSort2List(label_2_DBTaskList, sortedDBTaskList); mergeSort2List(label_3_DBTaskList, sortedDBTaskList); mergeSort2List(finished_DBTaskList, sortedDBTaskList); return sortedDBTaskList;&#125;private void reverse(ArrayList&lt;DBTask&gt; arr, int i, int j) &#123; while(i &lt; j) &#123; DBTask temp = arr.get(i); arr.set(i++, arr.get(j)); arr.set(j--, temp); &#125;&#125;// swap [bias, bias+headSize) and [bias+headSize, bias+headSize+endSize)private void swapAdjacentBlocks(ArrayList&lt;DBTask&gt; arr, int bias, int oneSize, int anotherSize) &#123; reverse(arr, bias, bias + oneSize - 1); reverse(arr, bias + oneSize, bias + oneSize + anotherSize - 1); reverse(arr, bias, bias + oneSize + anotherSize - 1);&#125;private void inplaceMerge(ArrayList&lt;DBTask&gt; arr, int l, int mid, int r) &#123; int i = l; // 指示左侧有序串 int j = mid + 1; // 指示右侧有序串 while(i &lt; j &amp;&amp; j &lt;= r) &#123; //原地归并结束的条件。 while(i &lt; j &amp;&amp; isValid(arr, i, j)) &#123; i++; &#125; int index = j; while(j &lt;= r &amp;&amp; isValid(arr, j, i)) &#123; j++; &#125; swapAdjacentBlocks(arr, i, index-i, j-index); i += (j-index); &#125;&#125;private boolean isValid(ArrayList&lt;DBTask&gt; arr, int i, int j) &#123; Date date_i = TimeUtil.formatGMTDateStr(arr.get(i).getCreated_datetime()); Date date_j = TimeUtil.formatGMTDateStr(arr.get(j).getCreated_datetime()); return (date_i != null ? date_i.getTime() : 0) &lt;= (date_j != null ? date_j.getTime() : 0);&#125;private void mergeSort(ArrayList&lt;DBTask&gt; arr, int l, int r) &#123; if(l &lt; r) &#123; int mid = (l + r) / 2; mergeSort(arr, l, mid); mergeSort(arr, mid + 1, r); inplaceMerge(arr, l, mid, r); &#125;&#125;private void mergeSort2List(ArrayList&lt;DBTask&gt; taskArrayList, ArrayList&lt;DBTask&gt; result) &#123; if (taskArrayList == null || taskArrayList.size() &lt;= 0) &#123; return; &#125; mergeSort(taskArrayList, 0, taskArrayList.size()-1); result.addAll(taskArrayList);&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://xichen.pub/tags/Algorithm/"}]},{"title":"【Android TimeCat】 给刷新按钮添加旋转动画","slug":"2018-03-01-Android-TimeCat-给刷新按钮添加旋转动画","date":"2018-03-01T04:11:00.000Z","updated":"2018-03-02T14:52:03.915Z","comments":true,"path":"2018/03/01/2018-03-01-Android-TimeCat-给刷新按钮添加旋转动画/","link":"","permalink":"http://xichen.pub/2018/03/01/2018-03-01-Android-TimeCat-给刷新按钮添加旋转动画/","excerpt":"","text":"背景本着用户的动作反馈原则，给刷新按钮添加旋转动画。 实现思路是给原来的按钮上面覆盖一层view来承担动画效果，点击按钮时，覆盖的view显示并旋转，此时按钮被覆盖处于不可点击状态；当动画完成时隐藏覆盖的view，按钮又可以被点击了。需要计算动画时间来及时把动画停掉，我采用postdelay解决。 res/menu/main.xml123456789&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\" &gt; &lt;item android:id=\"@+id/refresh\" android:icon=\"@drawable/ic_action_refresh\" android:showAsAction=\"always\"&gt; &lt;/item&gt;&lt;/menu&gt; res/layout/action_view.xml12345678910&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;ImageView xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center\" android:minHeight=\"24dp\" android:minWidth=\"24dp\" android:paddingEnd=\"12dp\" android:paddingStart=\"12dp\" android:scaleType=\"centerInside\"/&gt; res/anim/refresh.xml设置一秒绕中心旋转720度的动画，这样动画重复次数取1，不用重复 12345678&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;rotate xmlns:android=\"http://schemas.android.com/apk/res/android\" android:duration=\"1000\" android:fromDegrees=\"0\" android:interpolator=\"@android:anim/linear_interpolator\" android:pivotX=\"50%\" android:pivotY=\"50%\" android:toDegrees=\"720\" /&gt; MainActivity.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class MainActivity extends Activity &#123; protected MenuItem refreshItem; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.main, menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.refresh: showRefreshAnimation(item); return true; default: return super.onOptionsItemSelected(item); &#125; &#125; @SuppressLint(\"NewApi\") private void showRefreshAnimation(MenuItem item) &#123; hideRefreshAnimation(); //清空之前的效果 refreshItem = item; //这里使用一个ImageView设置成MenuItem的ActionView，这样我们就可以使用这个ImageView显示旋转动画了 ImageView refreshActionView = (ImageView) getLayoutInflater().inflate(R.layout.action_view, null); refreshActionView.setImageResource(R.drawable.ic_autorenew_white_24dp); refreshItem.setActionView(refreshActionView); //显示刷新动画 Animation animation = AnimationUtils.loadAnimation(this, R.anim.refresh); animation.setRepeatMode(Animation.RESTART); animation.setRepeatCount(1); // 这里设置动画重复次数 refreshActionView.startAnimation(animation); new Handler().postDelayed(new Runnable() &#123; @Override public void run() &#123; hideRefreshAnimation(); &#125; &#125;, 1000); // 在动画xml文件里定义了动画时长为1秒，而动画重复次数为1次，所以在1秒后停止动画即可防止过度点击。 &#125; @SuppressLint(\"NewApi\") private void hideRefreshAnimation() &#123; if (refreshItem != null) &#123; View view = refreshItem.getActionView(); if (view != null) &#123; view.clearAnimation(); refreshItem.setActionView(null); &#125; &#125; &#125;&#125; 在项目中的应用 refresh.xml action_view.xml main_menu.xml MainActivity.java","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"Animation","slug":"Animation","permalink":"http://xichen.pub/tags/Animation/"}]},{"title":"【Android TimeCat】 MVP架构演进","slug":"2018-02-28-Android-TimeCat-MVP架构演进","date":"2018-02-27T23:42:00.000Z","updated":"2018-03-02T14:52:04.032Z","comments":true,"path":"2018/02/28/2018-02-28-Android-TimeCat-MVP架构演进/","link":"","permalink":"http://xichen.pub/2018/02/28/2018-02-28-Android-TimeCat-MVP架构演进/","excerpt":"","text":"背景我就想看看MVP怎么搞… 分层架构…ui/fragment/NotesFragment.java 代码行数：~290 文件目录结构：1NotesFragment.java 优点： 业务分层，把fragment的初始化分成initView(), initData(), initListener() 功能分区，按View, Data, Listener,在fragment文件内部分区，用注释隔开，简单易懂 缺点： fragment持有内部类 数据的刷新需要context, 应该做到数据与状态无关，易于复用 fragment管的东西太多 基础MVP架构…ui/fragment/notes/view/NotesFragment.java 代码行数：~160 目录结构：123456789101112notes├── model│ ├── NotesDataManagerAction.java│ └── NotesDataManager.java├── presenter│ ├── NotesPresenterAction.java│ └── NotesPresenter.java└── view ├── CardStackViewAdapter.java ├── ColorItemViewHolder.java ├── NotesFragmentAction.java └── NotesFragment.java 优点： 数据（model）和UI（view）解耦，双方都只暴露接口给presenter，由presenter决定数据和UI的互动 NotesFragment只作为view层，下放业务处理能力给presenter，使代码量大量减少（实际是转移给presenter，没有减少） NotesFragment不再持有内部类，加载速度增加 在数据层去掉context，使data与view相互独立 缺点： 没有绑定view，presenter可能在fragment销毁后仍有其引用，导致内存泄漏 NotesFragment里除了需要显示的view的初始化就都是接口的具体实现，对新手不友好 高级MVP架构…ui/fragment/notes/view/NotesFragment.java 代码行数：~160 目录结构：12345678910notes/├── model│ └── NotesDataManager.java├── presenter│ └── NotesPresenter.java└── view ├── CardStackViewAdapter.java ├── ColorItemViewHolder.java ├── NotesFragmentAction.java └── NotesFragment.java 优点： 高度抽象，减少代码冗余（比如绑定view） 使用代理模式将绑定和解绑view的操作抽离出来 使用工厂模式和注解在上层统一创建Presenter 将Presenter的创建过程放入到获取Presenter的方法中，如果存在返回，不存在创建，保证Presenter不会为空，保证在使用的时候再创建，节省内存资源 删除不必要的接口文件，用分区的方法突出类内可调用的业务处理函数 总的来说就是耐操 缺点： 新手不友好，依赖注入设计模式等操作有一定的复杂度 MVP固有缺点：每条逻辑都要有完全不同的presenter来管理 添加多个presenter麻烦","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"http://xichen.pub/tags/MVP/"}]},{"title":"【Android TimeCat】 RecyclerView的卡顿问题","slug":"2018-02-27-Android-TimeCat-RecyclerView的卡顿问题","date":"2018-02-27T00:12:00.000Z","updated":"2018-03-02T14:52:04.021Z","comments":true,"path":"2018/02/27/2018-02-27-Android-TimeCat-RecyclerView的卡顿问题/","link":"","permalink":"http://xichen.pub/2018/02/27/2018-02-27-Android-TimeCat-RecyclerView的卡顿问题/","excerpt":"","text":"背景Time Cat中大量使用了RecycleView和折叠结构，虽然便于用户交互，但同时也使性能成为一个问题。 RecyclerView为什么会卡RecyclerView作为v7包的新控件，自从推出就广受Android Developer们欢迎，实际上它已经取代了ListView和GridView两位老前辈的地位。然而不少亲们想必也已经发现了：没有优化过的Recycler性能很poor。上一篇博主使用的item也仅仅是一个图两串字而已，结果一滑动就卡的要命，不能忍！那么why？回想在用ListView和GridView的adapter时，我们是用一种叫ViewHolder的自定义类（容器）来实现优化的，而RecyclerView的特性之一就是强制你使用它的RecyclerView.ViewHolder。可是，RecyclerView.ViewHolder要比我们写的那个单纯的容器复杂多了（源码里算上注释有大约500行），与RecyclerView.Adapter的联系也是千丝万缕。 按stackoverflow上面比较通俗的解释：RecyclerView.Adapter里面的onCreateViewHolder()方法和onBindViewHolder()方法对时间都非常敏感。类似I/O读写，Bitmap解码一类的耗时操作，最好不要在它们里面进行。 如何解决卡顿问题首先当然得优化你的item，合理运用&lt;include&gt;，&lt;merge&gt;，&lt;ViewStub&gt;等标签，使布局层次尽量少——其实ListView和GridView里你也应该这么做，应该当成是一种写UI的习惯。 其次就是灵活使用各种第三方库，去完成各种耗时操作，比如通过Glide或者是Picasso加载图片。优秀的开源库在性能上往往都考虑得很仔细。 最后的问题来了，如果只想写一个小demo，不愿大张旗鼓怎么办？如果即便一般的第三方库也不好解决问题，比如上一篇那个该死的loadIcon()方法返回的是一个Drawable对象，Glide和Picasso都没法直接处理，转码又等于添了个耗时任务，那怎么办？真正的app管理应用，应该引入UIL或者Picasso一类的加载库进行图标加载（在此原谅博主没仔细敲代码，就信口开河了）答案就是，想法在你setAdapter之前就把任务给完成。 TimeCat 实例1234567891011public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; context = getContext(); View view = inflater.inflate(R.layout.fragment_notes, container, false); mStackView = view.findViewById(R.id.notes_csv); // 初始化RecycleView cardStackViewAdapter = new CardStackViewAdapter(context); // 初始化Adapter refreshData(); // 刷新一次数据 mStackView.setAdapter(cardStackViewAdapter); // 在数据准备好后再setAdapter() return view;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"RecycleView","slug":"RecycleView","permalink":"http://xichen.pub/tags/RecycleView/"}]},{"title":"【Android TimeCat】 当RxJava遇到Retrofit（二）api注解@Path, @Url等","slug":"2018-02-27-Android-TimeCat-当RxJava遇到Retrofit（二）api注解@Path, @Url等","date":"2018-02-26T08:12:00.000Z","updated":"2018-03-02T14:52:04.024Z","comments":true,"path":"2018/02/26/2018-02-27-Android-TimeCat-当RxJava遇到Retrofit（二）api注解@Path, @Url等/","link":"","permalink":"http://xichen.pub/2018/02/26/2018-02-27-Android-TimeCat-当RxJava遇到Retrofit（二）api注解@Path, @Url等/","excerpt":"","text":"背景下面分为GET、POST、DELETE还有PUT的请求，说明@Path、@Query、@QueryMap、@Body、@Field的用法。 初始化Retrofit1234String BASE_URL = \"http://192.168.88.105:8000/api/\";Retrofit retrofit = new Retrofit.Builder() .baseUrl(BASE_URL) .build(); GET样式1（一个简单的get请求）http://192.168.88.105:8000/api/News12@GET(\"News\")Call&lt;NewsBean&gt; getItem(); 样式2（URL中有参数）http://192.168.88.105:8000/api/News/1http://192.168.88.105:8000/api/News/{资讯id}123@GET(\"News/&#123;newsId&#125;\")Call&lt;NewsBean&gt; getItem(@Path(\"newsId\") String newsId); 或http://192.168.88.105:8000/api/News/1/类型1http://192.168.88.105:8000/api/News/{资讯id}/{类型} 12@GET(\"News/&#123;newsId&#125;/&#123;type&#125;\")Call&lt;NewsBean&gt; getItem(@Path(\"newsId\") String newsId， @Path(\"type\") String type); 样式3（参数在URL问号之后）http://192.168.88.105:8000/api/News?newsId=1http://192.168.88.105:8000/api/News?newsId={资讯id} 12@GET(\"News\")Call&lt;NewsBean&gt; getItem(@Query(\"newsId\") String newsId); 或http://192.168.88.105:8000/api/News?newsId=1&amp;type=类型1http://192.168.88.105:8000/api/News?newsId={资讯id}&amp;type={类型} 12@GET(\"News\")Call&lt;NewsBean&gt; getItem(@Query(\"newsId\") String newsId， @Query(\"type\") String type); 样式4（多个参数在URL问号之后，且个数不确定）http://192.168.88.105:8000/api/News?newsId=1&amp;type=类型1…http://192.168.88.105:8000/api/News?newsId={资讯id}&amp;type={类型}… 12@GET(\"News\")Call&lt;NewsBean&gt; getItem(@QueryMap Map&lt;String, String&gt; map); 也可以 1234@GET(\"News\")Call&lt;NewsBean&gt; getItem( @Query(\"newsId\") String newsId， @QueryMap Map&lt;String, String&gt; map); POST样式1（需要补全URL，post的数据只有一条reason）http://192.168.88.105:8000/api/Comments/1http://192.168.88.105:8000/api/Comments/{newsId} 12345@FormUrlEncoded@POST(\"Comments/&#123;newsId&#125;\")Call&lt;Comment&gt; reportComment( @Path(\"newsId\") String commentId, @Field(\"reason\") String reason); 样式2（需要补全URL，问号后加入access_token，post的数据只有一条reason）http://192.168.88.105:8000/api/Comments/1?access_token=1234123http://192.168.88.105:8000/api/Comments/{newsId}?access_token={access_token} 123456@FormUrlEncoded@POST(\"Comments/&#123;newsId&#125;\")Call&lt;Comment&gt; reportComment( @Path(\"newsId\") String commentId, @Query(\"access_token\") String access_token, @Field(\"reason\") String reason); 样式3（需要补全URL，问号后加入access_token，post一个body（对象））http://192.168.88.105:8000/api/Comments/1?access_token=1234123http://192.168.88.105:8000/api/Comments/{newsId}?access_token={access_token} 12345@POST(\"Comments/&#123;newsId&#125;\")Call&lt;Comment&gt; reportComment( @Path(\"newsId\") String commentId, @Query(\"access_token\") String access_token, @Body CommentBean bean); DELETE样式1（需要补全URL）http://192.168.88.105:8000/api/Comments/1http://192.168.88.105:8000/api/Comments/{commentId} 123@DELETE(\"Comments/&#123;commentId&#125;\")Call&lt;ResponseBody&gt; deleteNewsCommentFromAccount( @Path(\"commentId\") String commentId); 样式2（需要补全URL，问号后加入access_token）http://192.168.88.105:8000/api/Comments/1?access_token=1234123http://192.168.88.105:8000/api/Comments/{commentId}?access_token={access_token} 1234@DELETE(\"Comments/&#123;commentId&#125;\")Call&lt;ResponseBody&gt; deleteNewsCommentFromAccount( @Path(\"commentId\") String commentId， @Query(\"access_token\") String access_token); 样式3（带有body）http://192.168.88.105:8000/api/Comments 12345@HTTP(method = \"DELETE\",path = \"Comments\",hasBody = true)Call&lt;ResponseBody&gt; deleteCommont( @Body CommentBody body );CommentBody：需要提交的内容，与Post中的Body相同 PUT（这个请求很少用到，例子就写一个）http://192.168.88.105:8000/api/Accounts/1http://192.168.88.105:8000/api/Accounts/{accountId} 12345@PUT(\"Accounts/&#123;accountId&#125;\")Call&lt;ExtrasBean&gt; updateExtras( @Path(\"accountId\") String accountId, @Query(\"access_token\") String access_token, @Body ExtrasBean bean); 总结 @Path：所有在网址中的参数（URL的问号前面），如：http://192.168.88.105:8000/api/Accounts/{accountId} @Query：URL问号后面的参数，如：http://192.168.88.105:8000/api/Comments?access_token={access_token} @QueryMap：相当于多个@Query @Field：用于POST请求，提交单个数据 @Body：相当于多个@Field，以对象的形式提交 Tips Tips1 使用@Field时记得添加@FormUrlEncoded Tips2 若需要重新定义接口地址，可以使用@Url，将地址以参数的形式传入即可。如123456@GETCall&lt;List&lt;Activity&gt;&gt; getActivityList( @Url String url, @QueryMap Map&lt;String, String&gt; map);Call&lt;List&lt;Activity&gt;&gt; call = service.getActivityList( \"http://115.159.198.162:3001/api/ActivitySubjects\", map); 参考https://www.jianshu.com/p/7687365aa946https://www.jianshu.com/p/6b3daeda1eed","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://xichen.pub/tags/Retrofit/"}]},{"title":"【Android TimeCat】 当RxJava遇到Retrofit（一）Retrofit入门","slug":"2018-02-27-Android-TimeCat-当RxJava遇到Retrofit（一）Retrofit入门","date":"2018-02-26T07:37:00.000Z","updated":"2018-03-02T14:52:03.915Z","comments":true,"path":"2018/02/26/2018-02-27-Android-TimeCat-当RxJava遇到Retrofit（一）Retrofit入门/","link":"","permalink":"http://xichen.pub/2018/02/26/2018-02-27-Android-TimeCat-当RxJava遇到Retrofit（一）Retrofit入门/","excerpt":"","text":"背景在Time Cat项目开发过程中，我们尝试过很多网络请求库。基本点的就是原生的http请求框架，好比HttpClient以及HttpUrlConnection等，略懂android开发的估计无人不知android-async-http或者volley啥的，再往上走，有okhttp等。但是最后我们选择了一个新的http请求框架，Retrofit。 Retrofit简介retrofit是Square公司出品的，为android和java提供一个类型安全的Http网络请求库，这里是官网地址。 Retrofit的优点 使用注解来描述http请求 URL参数的替换和query参数的支持 对象转化为请求体（如：JSON，protocol buffers等） 多重请求体和文件上传以上都是官网描述 TimeCat中的实例定义接口1234567// NoteService.javapublic interface NoteService &#123; @Headers(&#123;\"Content-Type: application/json\", \"Accept: application/json\"&#125;) @POST(\"/notes/\") Observable&lt;Note&gt; createNote(@Body Note note);&#125; 辅助使用Retrofit12345678910111213141516171819202122232425262728293031323334353637// RetrofitHelper.javapublic class RetrofitHelper &#123; private static final String BASE_URL = \"http://192.168.88.105:8000/\"; private static OkHttpClient mOkHttpClient; static &#123; initOkHttpClient(); &#125; /** * 初始化OKHttpClient * 设置缓存 * 设置超时时间 * 设置打印日志 * 设置UA拦截器 */ private static void initOkHttpClient() &#123; HttpLoggingInterceptor interceptor = new HttpLoggingInterceptor(new Log()); interceptor.setLevel(HttpLoggingInterceptor.Level.BODY); if (mOkHttpClient == null) &#123; synchronized (RetrofitHelper.class) &#123; if (mOkHttpClient == null) &#123; //设置Http缓存 Cache cache = new Cache(new File(TimeCatApp.getInstance().getCacheDir(), \"HttpCache\"), 1024 * 1024 * 100); mOkHttpClient = new OkHttpClient.Builder().cache(cache).addInterceptor(interceptor).retryOnConnectionFailure(true).connectTimeout(30, TimeUnit.SECONDS).writeTimeout(20, TimeUnit.SECONDS).readTimeout(20, TimeUnit.SECONDS).build(); &#125; &#125; &#125; &#125; public static NoteService getNoteService() &#123; Retrofit retrofit = new Retrofit.Builder() .baseUrl(BASE_URL) .client(mOkHttpClient) .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .addConverterFactory(GsonConverterFactory.create()) .build(); return retrofit.create(NoteService.class); &#125;&#125; 结合RxJava发起网络请求只需要1234567891011121314151617181920212223242526272829303132RetrofitHelper.getNoteService().createNote(note) //获取Observable对象 .compose(this.bindToLifecycle()) // 绑定到生命周期 .subscribeOn(Schedulers.newThread()) //请求在新的线程中执行 .observeOn(Schedulers.io()) //请求完成后在io线程中执行 .doOnNext(new Action1&lt;Note&gt;() &#123; @Override public void call(Note note) &#123; DB.notes().saveAndFireEvent(ModelUtil.toDBNote(note)); // 进行数据读写，甚至可以进行文件读写 Log.e(TAG, \"保存任务信息到本地\" + note.toString()); &#125; &#125;) .observeOn(AndroidSchedulers.mainThread())//最后在主线程中执行 .subscribe(new Subscriber&lt;Note&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; //请求失败 ToastUtil.show(\"添加[ 任务 ]失败\"); Log.e(TAG, e.toString()); &#125; @Override public void onNext(Note note) &#123; //请求成功 ToastUtil.show(\"成功添加[ 任务 ]:\" + dialog_add_task_et_content.getText().toString()); finish(); Log.e(TAG, \"请求成功\" + note.toString()); &#125; &#125;); 使用的套路权限1&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt; 这个没什么好说的，没有网络权限什么都做不了 导包12345compile 'com.squareup.retrofit2:retrofit:2.1.0'compile 'com.squareup.retrofit2:converter-gson:2.1.0'compile 'com.squareup.retrofit2:adapter-rxjava:2.1.0'compile 'com.squareup.okhttp3:logging-interceptor:3.4.1'compile 'io.reactivex:rxandroid:1.2.1' 这里几个库的含义是：我们使用retrofit2.0去进行网络请求操作，同时我们使用gson去进行数据解析，并且结合rxjava去进行相应的代码编写 基本配置123456new Retrofit.Builder() .baseUrl(BASE_URL) .client(mOkHttpClient) .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .addConverterFactory(GsonConverterFactory.create()) .build(); 这段就是使用RxJava，利用gson做解析（这边解析器可以设置注入Jackson之类的，甚至可以自定义），http引擎框架是okhttp API说明Retrofit需要通过注解请求方法以及请求参数来表明应该如何去进行一个Http请求，目前内置了5种注解方式GET、POST、PUT、DELETE以及HEAD。同时资源的相对URL要在注解中明确的指出。比如请求方法1@POST(\"/notes/\") @POST(&quot;/notes/&quot;)的意思是，用POST方法，向BASE_URL + &#39;notes/&#39; 即http://192.168.88.105:8000/notes/发起请求。注意两个斜杆，左边的/代表在BASE_URL的基础上，右边的/表示notes的实际接口，去掉其中一个都会导致不同的结果。 更多api的写法请看下一篇 参考https://www.jianshu.com/p/6b3daeda1eed","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://xichen.pub/tags/Retrofit/"}]},{"title":"【Android TimeCat】 RxJava的使用（四）线程控制 —— Scheduler","slug":"2018-02-26-Android-TimeCat-RxJava的使用（四）线程控制 —— Scheduler","date":"2018-02-26T06:59:00.000Z","updated":"2018-03-02T14:52:04.010Z","comments":true,"path":"2018/02/26/2018-02-26-Android-TimeCat-RxJava的使用（四）线程控制 —— Scheduler/","link":"","permalink":"http://xichen.pub/2018/02/26/2018-02-26-Android-TimeCat-RxJava的使用（四）线程控制 —— Scheduler/","excerpt":"","text":"背景经过前几篇的介绍，对RxJava对模式有了一定的理解：由Observable发起事件，经过中间的处理后由Observer消费。之前的代码中，事件的发起和消费都是在同一个线程中执行，也就是说之前我们使用的RxJava是同步的～～～ 观察者模式本身的目的不就是后台处理，将处理结果回调给前台？这同步的是要哪样？所以，这篇为大家介绍RxJava的重要的概念——Scheduler 介绍RxJava在不指定线程的情况下，发起时间和消费时间默认使用当前线程。所以之前的做法123456789101112131415Observable.just(student1, student2, student2) //使用map进行转换，参数1：转换前的类型，参数2：转换后的类型 .map(new Func1&lt;Student, String&gt;() &#123; @Override public String call(Student i) &#123; String name = i.getName();//获取Student对象中的name return name;//返回name &#125; &#125;) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; nameList.add(s); &#125; &#125;); 因为是在主线程中发起的，所以不管中间 map的处理还是Action1的执行都是在主线程中进行的。若是map中有耗时的操作(比如网络请求)，这样会导致主线程拥塞，这并不是我们想看到的。 SchedulerScheduler：线程控制器，可以指定每一段代码在什么样的线程中执行。模拟一个需求：新的线程发起事件，在主线程中消费12345678910private void rxJavaTest3() &#123; Observable.just(\"Hello\", \"Word\") .subscribeOn(Schedulers.newThread())//指定 subscribe() 发生在新的线程 .observeOn(AndroidSchedulers.mainThread())// 指定 Subscriber 的回调发生在主线程 .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.i(TAG, s); &#125; &#125;); 上面用到了subscribeOn()，和observeOn()方法来指定发生的线程和消费的线程。 subscribeOn()：指定subscribe() 所发生的线程，即 Observable.OnSubscribe 被激活时所处的线程。或者叫做事件产生的线程。 observeOn()：指定Subscriber 所运行在的线程。或者叫做事件消费的线程。 以及参数Scheduler，RxJava已经为我们提供了一下几个Scheduler Schedulers.immediate()：直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。 Schedulers.newThread()：总是启用新线程，并在新线程执行操作。 Schedulers.io()： I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。 Schedulers.computation()：计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。 AndroidSchedulers.mainThread()：它指定的操作将在 Android 主线程运行。 多次切换线程看完上面的介绍想必对RxJava线程的切换有了一些理解，上面只是对事件的发起和消费制定了线程。如果中间有map之类的操作呢？是否可以实现发起的线程在新线程中，map的处理在IO线程，最后的消费在主线程中。12345678910111213141516Observable.just(\"Hello\", \"Wrold\") .subscribeOn(Schedulers.newThread())//指定：在新的线程中发起 .observeOn(Schedulers.io()) //指定：在io线程中处理 .map(new Func1&lt;String, String&gt;() &#123; @Override public String call(String s) &#123; return handleString(s); //处理数据 &#125; &#125;) .observeOn(AndroidSchedulers.mainThread())//指定：在主线程中处理 .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; show(s); //消费事件 &#125; &#125;); 可以看到observeOn()被调用了两次，分别指定了map的处理的现场和消费事件show(s)的线程。 若将observeOn(AndroidSchedulers.mainThread())去掉会怎么样？不为消费事件show(s)指定线程后，show(s)会在那里执行？其实，observeOn()指定的是它之后的操作所在的线程。也就是说，map的处理和最后的消费事件show(s)都会在io线程中执行。observeOn()可以多次使用，可以随意变换线程 小结学会线程控制后才算是真正学会了使用RxJava。RxJava的使用十分灵活，想要对其熟悉使用只有一个办法，那就是多用啦，熟能生巧。 参考：https://www.jianshu.com/p/ecfb9d68d2a2http://gank.io/post/560e15be2dca930e00da1083","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"http://xichen.pub/tags/RxJava/"}]},{"title":"【Android TimeCat】 RxJava的使用（三）对象转换器——map、flatMap","slug":"2018-02-26-Android-TimeCat-RxJava的使用（三）对象转换器——map、flatMap","date":"2018-02-26T06:57:00.000Z","updated":"2018-03-02T14:52:04.004Z","comments":true,"path":"2018/02/26/2018-02-26-Android-TimeCat-RxJava的使用（三）对象转换器——map、flatMap/","link":"","permalink":"http://xichen.pub/2018/02/26/2018-02-26-Android-TimeCat-RxJava的使用（三）对象转换器——map、flatMap/","excerpt":"","text":"map在使用map之前要先说道一个接口：Func1，Func1和上一篇提到的Action1相似。Func1 和 Action的区别在于， Func1 包装的是有返回值的方法。接下来就是map的用法，看代码更直观点； 例：得到多个Student对象中的name，保存到nameList中123456789101112131415Observable.just(student1, student2, student2) //使用map进行转换，参数1：转换前的类型，参数2：转换后的类型 .map(new Func1&lt;Student, String&gt;() &#123; @Override public String call(Student i) &#123; String name = i.getName();//获取Student对象中的name return name;//返回name &#125; &#125;) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; nameList.add(s); &#125; &#125;); 可以看到Observable中原来的参数是Student对象，而最后我们需要的是name，这里使用了map来实现这一转换的过程。当然，map可以多次使用。1234567891011121314151617181920//多次使用map，想用几个用几个Observable.just(\"Hello\", \"World\") .map(new Func1&lt;String, Integer&gt;() &#123;//将String类型的转化为Integer类型的哈希码 @Override public Integer call(String s) &#123; return s.hashCode(); &#125; &#125;) .map(new Func1&lt;Integer, String&gt;() &#123;//将转化后得到的Integer类型的哈希码再转化为String类型 @Override public String call(Integer integer) &#123; return integer.intValue() + \"\"; &#125; &#125;) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.i(TAG, s); &#125; &#125;); flatMapflatMap是一个比教难理解的一个转换，在这里先假设一个需求，需要打印多个Student所学的课程。这跟之前获取Student的name又不同了，这里先确定一下关系，一个Student类中只有一个name，而一个Student却有多门课程（Course），Student我们可以理解成这样：1234567891011121314/** * 学生类 */class Student &#123; private String name;//姓名 private List&lt;Course&gt; coursesList;//所修的课程&#125;/** * 课程类 */class Course &#123; private String name;//课程名 private String id;&#125; 如果使用map来实现打印所有学生所修个课程名，实现的代码是这样的：12345678910111213141516171819202122List&lt;Student&gt; students = new ArrayList&lt;Student&gt;();students.add......Action1&lt;List&lt;Course&gt;&gt; action1 = new Action1&lt;List&lt;Course&gt;&gt;() &#123; @Override public void call(List&lt;Course&gt; courses) &#123; //遍历courses，输出cuouses的name for (int i = 0; i &lt; courses.size(); i++)&#123; Log.i(TAG, courses.get(i).getName()); &#125; &#125;&#125;;Observable.from(students) .map(new Func1&lt;Student, List&lt;Course&gt;&gt;() &#123; @Override public List&lt;Course&gt; call(Student student) &#123; //返回coursesList return student.getCoursesList(); &#125; &#125;) .subscribe(action1); 可以看到，在Action1中出现了for来循环打印课程名，使用RxJava就是为了剔除这样的嵌套结构，使得整体的逻辑性更强。这时候就可以使用flatMap了，使用flatMap实现的代码是这样的：1234567891011121314151617List&lt;Student&gt; students = new ArrayList&lt;Student&gt;();students.add......Observable.from(students) .flatMap(new Func1&lt;Student, Observable&lt;Course&gt;&gt;() &#123; @Override public Observable&lt;Course&gt; call(Student student) &#123; return Observable.from(student.getCoursesList()); &#125; &#125;) .subscribe(new Action1&lt;Course&gt;() &#123; @Override public void call(Course course) &#123; Log.i(TAG, course.getName()); &#125; &#125;); 这样就实现了跟上面代码一样的效果，看起来有点懵？确实，flatMap理解起来有点绕，刚接触flatMap的时候我也是懵逼一个。下面我将flatMap的示意图，希望能帮助理解： flatMap示意图 由上图可以看出Student1、Student2经过flatMap后，按顺序依次经历了Observable1、Observable2，分别转化为Course。最后按顺序得到Course1、Course2、Course3、Course4、Course5、Course6，其中1-3由Student1得到，4-6由Student2得到。结合代码和示意图，是不是对flatMap有了一定的理解。 注意：FlatMap对这些Observables发射的数据做的是合并(merge)操作，因此它们可能是交错的。也就说，传入的顺序可能跟出来的顺序不一样。如果要保证顺的的话，可以使用concatMap。 #其他操作符 除了map和flatMap之外，还有其他操作符以供使用。这里就不一一列举他们的用法了，其他常用的操作符如下： filter：集合进行过滤 each：遍历集合 take：取出集合中的前几个 skip：跳过前几个元素 更多操作符 参考https://www.jianshu.com/p/52cd2d514528http://gank.io/post/560e15be2dca930e00da1083","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"http://xichen.pub/tags/RxJava/"}]},{"title":"【Android TimeCat】 RxJava的使用（二）Action","slug":"2018-02-26-Android-TimeCat-RxJava的使用（二）Action","date":"2018-02-26T06:44:00.000Z","updated":"2018-03-02T14:52:04.007Z","comments":true,"path":"2018/02/26/2018-02-26-Android-TimeCat-RxJava的使用（二）Action/","link":"","permalink":"http://xichen.pub/2018/02/26/2018-02-26-Android-TimeCat-RxJava的使用（二）Action/","excerpt":"","text":"回顾例：分别打印”Hello”、” World”1234567891011121314151617Observable.just(\"Hello\", \"World\") .subscribe(new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(String s) &#123; Log.i(TAG, s); &#125; &#125;); 可以看到，我们这里只用了onNext(obj)，还有两个重写的onError(error)和onCompleted()并没有用到，这样导致我们多出了几行根本用不到的代码。于是就想能不能只写我们使用到的，其他几个没用到的就不写，这样的代码看着才舒服。接下来就是使用本次的主角Action来代替Subscriber Action上部分的代码使用Action来代替Subscriber得到的代码是这样的：1234567Observable.just(\"Hello\", \"World\") .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.i(TAG, s); &#125; &#125;); 舒服多了有没有！！ 什么是ActionAction是RxJava 的一个接口，常用的有Action0和Action1。Action0： 它只有一个方法 call()，这个方法是无参无返回值的；由于 onCompleted() 方法也是无参无返回值的，因此 Action0 可以被当成一个包装对象，将 onCompleted() 的内容打包起来将自己作为一个参数传入 subscribe() 以实现不完整定义的回调。Ation1：它同样只有一个方法 call(T param)，这个方法也无返回值，但有一个参数；与 Action0 同理，由于 onNext(T obj) 和 onError(Throwable error) 也是单参数无返回值的，因此 Action1 可以将 onNext(obj)和 onError(error) 打包起来传入 subscribe() 以实现不完整定义的回调 Action的使用定义三个对象，分别打包onNext(obj)、onError(error)、onCompleted()。1234567891011121314151617181920212223Observable observable = Observable.just(\"Hello\", \"World\");//处理onNext()中的内容Action1&lt;String&gt; onNextAction = new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.i(TAG, s); &#125;&#125;;//处理onError()中的内容Action1&lt;Throwable&gt; onErrorAction = new Action1&lt;Throwable&gt;() &#123; @Override public void call(Throwable throwable) &#123; &#125;&#125;;//处理onCompleted()中的内容Action0 onCompletedAction = new Action0() &#123; @Override public void call() &#123; Log.i(TAG, \"Completed\"); &#125;&#125;; 接下来使用subscribe重载的方法123456//使用 onNextAction 来定义 onNext()Observable.just(\"Hello\", \"World\").subscribe(onNextAction);//使用 onNextAction 和 onErrorAction 来定义 onNext() 和 onError()Observable.just(\"Hello\", \"World\").subscribe(onNextAction, onErrorAction);//使用 onNextAction、 onErrorAction 和 onCompletedAction 来定义 onNext()、 onError() 和 onCompleted()Observable.just(\"Hello\", \"World\").subscribe(onNextAction, onErrorAction, onCompletedAction); 根据实际情况使用以上的方法处理onNext(obj)、onError(error) 、onCompleted()的回调。现在有个疑问，为什么使用Action也能达到使用Subscriber的结果？进subscribe(Action1 onNext)的源码看看。 还以为有多高深，原来就是把Action对象转化成对应的Subscriber对象了。这样就不难理解为什么可以使用Action来代替Subscriber了。 重写打印”Hello”、” Wrod”的方法123456Observable.just(\"Hello\", \"Wrold\").subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.i(TAG, s); &#125;&#125;); 相比第一篇那冗长的代码，现在感觉怎么样？还是觉得代码多？确实，如果只是打印几个字符串确实还是略微复杂。不急，RxJava还有其他功能呢。 小结Action的使用为我们减少了不必要的代码，使得写出的代码看上去更加得简洁。不过就目前来看RxJava还是没有什么优势值得我们去使用，下一篇我还会介绍更多RxJava的用法。慢慢得，你就会发现使用RxJava写出来的代码看上去真的很漂亮。 参考https://www.jianshu.com/p/c7a995f3763chttp://gank.io/post/560e15be2dca930e00da1083","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"http://xichen.pub/tags/RxJava/"}]},{"title":"【Android TimeCat】 RxJava的使用（一）基本用法","slug":"2018-02-26-Android-TimeCat-RxJava的使用（一）基本用法","date":"2018-02-26T05:45:00.000Z","updated":"2018-03-02T14:52:04.002Z","comments":true,"path":"2018/02/26/2018-02-26-Android-TimeCat-RxJava的使用（一）基本用法/","link":"","permalink":"http://xichen.pub/2018/02/26/2018-02-26-Android-TimeCat-RxJava的使用（一）基本用法/","excerpt":"","text":"背景Time Cat中，网络请求是必不可少的。而网络请求最好不要放在主线程中，因为网络请求要监听服务端的回应，耗时长。所以我们一般把网络请求异步处理。异步的话我们一般有现成的 AsyncTask / Handler / View.postdelay / … , 不过，今天我们用RxJava。RxJava的本质是异步处理，RxJava的好处就在于它的简洁性，逻辑简单的时候看不出RxJava的优势，想必大家都知道在调度过程比较复杂的情况下，异步代码经常会既难写也难被读懂。这时候RxJava的优势就来了，随着程序逻辑变得越来越复杂，它依然能够保持简洁。 观察者模式首先要先介绍一下观察者模式（可能比喻的不够恰当，意思到了就好）； 观察者：监视着被观察者的行为，当被观察者某个状态改变的时候会通知观察者，观察者会执行对应的操作； 被观察者：被监视的对象，当某个状态改变的时候会通知观察者； 订阅（或注册）：将观察者和被观察者建立联系。 （很乱？来个栗子？）这里举一个我个常用的例子，点击Button后触发OnClickListener中的onClick()事件。在这个事件中他们的角色分别如下： 观察者：OnClickListener； 被观察者：Button； 订阅（或注册）：setOnClickListener()。 RxJava中的观察者模式在上面介绍了观察者模式，这里也将RxJava中的三个角色进行一下角色分配 观察者：Observer； 被观察者：Observable； 订阅（或注册）：subscribe()。 观察者Observer 即观察者，它决定事件触发的时候将有怎样的行为。 RxJava 观察者的事件回调方法除了普通事件onNext()（相当于onClick()/onEvent()）之外，还定义了两个特殊的事件：onCompleted()和onError()。 onCompleted(): 事件队列完结。RxJava 不仅把每个事件单独处理，还会把它们看做一个队列。RxJava 规定，当不会再有新的onNext()发出时，需要触发onCompleted()方法作为标志。 onError(): 事件队列异常。在事件处理过程中出异常时，onError()会被触发，同时队列自动终止，不允许再有事件发出。 在一个正确运行的事件序列中,onCompleted()和onError()有且只有一个，并且是事件序列中的最后一个。需要注意的是，onCompleted():和onError()二者也是互斥的，即在队列中调用了其中一个，就不应该再调用另一个。 被观察者Observable 即被观察者，它决定什么时候触发事件以及触发怎样的事件。可以使用create()、just(T...)、from(T[])或from(Iterable&lt;? extends T&gt;)来创建一个 Observable ，并为它定义事件触发规则。 订阅创建了Observable和Observer之后，再用subscribe()方法将它们联结起来 Talk is cheap, show me the code例：打印字符串 添加依赖 12compile 'io.reactivex:rxjava:1.0.14'compile 'io.reactivex:rxandroid:1.0.1' 依次创建观察者，被观察者，订阅 1234567891011121314151617181920212223242526272829//创建一个观察者Observer&lt;String&gt; observer = new Observer&lt;String&gt;() &#123; @Override public void onCompleted() &#123; Log.i(TAG, \"Completed\"); &#125; @Override public void onError(Throwable e) &#123; Log.i(TAG, \"Error\"); &#125; @Override public void onNext(String s) &#123; Log.i(TAG, s); &#125;&#125;;//使用Observable.create()创建被观察者Observable observable1 = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext(\"Hello\"); subscriber.onNext(\"Wrold\"); subscriber.onCompleted(); &#125;&#125;);//订阅observable1.subscribe(observer); 以上用到的都是rx包里面的，别用错了！！！123import rx.Observable;import rx.Observer;import rx.Subscriber; 上面完成了一次Rxjava的基本使用，会在log里显示Hello World。 参考https://www.jianshu.com/p/19cac3c5b106http://gank.io/post/560e15be2dca930e00da1083","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"http://xichen.pub/tags/RxJava/"}]},{"title":"【Android TimeCat】 Android抽象布局——include、merge 、ViewStub","slug":"2018-02-26-Android-TimeCat-Android抽象布局——include、merge 、ViewStub","date":"2018-02-26T03:58:00.000Z","updated":"2018-03-02T14:52:03.989Z","comments":true,"path":"2018/02/26/2018-02-26-Android-TimeCat-Android抽象布局——include、merge 、ViewStub/","link":"","permalink":"http://xichen.pub/2018/02/26/2018-02-26-Android-TimeCat-Android抽象布局——include、merge 、ViewStub/","excerpt":"","text":"背景在布局优化中，Androi的官方提到了这三种布局&lt;include /&gt;、&lt;merge /&gt;、&lt;ViewStub /&gt;，并介绍了这三种布局各有的优势，下面也是简单说一下他们的优势，以及怎么使用，记下来权当做笔记。 布局重用&lt;include /&gt;&lt;include /&gt;标签能够重用布局文件，简单的使用如下：1234567891011121314151617&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=”match_parent” android:layout_height=”match_parent” android:background=\"@color/app_bg\" android:gravity=\"center_horizontal\"&gt; &lt;include layout=\"@layout/titlebar\"/&gt; &lt;TextView android:layout_width=”match_parent” android:layout_height=\"wrap_content\" android:text=\"@string/hello\" android:padding=\"10dp\" /&gt; ... &lt;/LinearLayout&gt; &lt;include /&gt;标签可以使用单独的layout属性，这个也是必须使用的。 可以使用其他属性。&lt;include /&gt;标签若指定了ID属性，而你的layout也定义了ID，则你的layout的ID会被覆盖，解决方案。 在include标签中所有的android:layout_*都是有效的，前提是必须要写layout_width和layout_height两个属性。 布局中可以包含两个相同的include标签，引用时可以使用如下方法解决（参考）:123View bookmarks_container_2 = findViewById(R.id.bookmarks_favourite); bookmarks_container_2.findViewById(R.id.bookmarks_list); 减少视图层级&lt;merge /&gt;&lt;merge/&gt;标签在UI的结构优化中起着非常重要的作用，它可以删减多余的层级，优化UI。&lt;merge/&gt;多用于替换FrameLayout或者当一个布局包含另一个时，&lt;merge/&gt;标签消除视图层次结构中多余的视图组。例如你的主布局文件是垂直布局，引入了一个垂直布局的include，这是如果include布局使用的LinearLayout就没意义了，使用的话反而减慢你的UI表现。这时可以使用&lt;merge/&gt;标签优化。12345678910111213&lt;merge xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;Button android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:text=\"@string/add\"/&gt; &lt;Button android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:text=\"@string/delete\"/&gt; &lt;/merge&gt; 现在，当你添加该布局文件时(使用&lt;include /&gt;标签)，系统忽略&lt;merge /&gt;节点并且直接添加两个Button。更多&lt;merge /&gt;介绍可以参考《Android Layout Tricks #3: Optimize by merging》 需要时使用&lt;ViewStub /&gt;&lt;ViewStub /&gt;标签最大的优点是当你需要时才会加载，使用他并不会影响UI初始化时的性能。各种不常用的布局想进度条、显示错误消息等可以使用&lt;ViewStub /&gt;标签，以减少内存使用量，加快渲染速度。&lt;ViewStub /&gt;是一个不可见的，大小为0的View。&lt;ViewStub /&gt;标签使用如下：1234567&lt;ViewStub android:id=\"@+id/stub_import\" android:inflatedId=\"@+id/panel_import\" android:layout=\"@layout/progress_overlay\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:layout_gravity=\"bottom\" /&gt; 当你想加载布局时，可以使用下面其中一种方法：123((ViewStub) findViewById(R.id.stub_import)).setVisibility(View.VISIBLE); // or View importPanel = ((ViewStub) findViewById(R.id.stub_import)).inflate(); 当调用inflate()函数的时候，ViewStub被引用的资源替代，并且返回引用的view。 这样程序可以直接得到引用的view而不用再次调用函数findViewById()来查找了。注：ViewStub目前有个缺陷就是还不支持 &lt;merge /&gt; 标签。 更多&lt;ViewStub /&gt;标签介绍可以参考《Android Layout Tricks #3: Optimize with stubs》 参考：http://developer.android.com/training/improving-layouts/reusing-layouts.htmlhttp://android-developers.blogspot.com/2009/03/android-layout-tricks-3-optimize-by.htmlhttp://developer.android.com/training/improving-layouts/optimizing-layout.html#Linthttp://android-developers.blogspot.com/2009/02/android-layout-tricks-1.htmlhttp://developer.android.com/training/improving-layouts/loading-ondemand.html","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"xml","slug":"xml","permalink":"http://xichen.pub/tags/xml/"}]},{"title":"【Android TimeCat】 OrmLite框架入门与封装（三）封装","slug":"2018-02-26-Android-TimeCat-OrmLite框架入门与封装（三）封装","date":"2018-02-26T03:02:00.000Z","updated":"2018-03-02T14:52:03.999Z","comments":true,"path":"2018/02/26/2018-02-26-Android-TimeCat-OrmLite框架入门与封装（三）封装/","link":"","permalink":"http://xichen.pub/2018/02/26/2018-02-26-Android-TimeCat-OrmLite框架入门与封装（三）封装/","excerpt":"","text":"背景本来打算把Time Cat做成完全依赖网络的，但是考虑到业务场景，离线使用的占比不低，只好做个数据库来适应需求。封装后方便对 OrmLite 的使用 见项目","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"OrmLite","slug":"OrmLite","permalink":"http://xichen.pub/tags/OrmLite/"},{"name":"database","slug":"database","permalink":"http://xichen.pub/tags/database/"}]},{"title":"【Android TimeCat】 OrmLite框架入门与封装（二）高级操作","slug":"2018-02-26-Android-TimeCat-OrmLite框架入门与封装（二）高级操作","date":"2018-02-25T23:02:00.000Z","updated":"2018-03-02T14:52:03.994Z","comments":true,"path":"2018/02/26/2018-02-26-Android-TimeCat-OrmLite框架入门与封装（二）高级操作/","link":"","permalink":"http://xichen.pub/2018/02/26/2018-02-26-Android-TimeCat-OrmLite框架入门与封装（二）高级操作/","excerpt":"","text":"背景本来打算把Time Cat做成完全依赖网络的，但是考虑到业务场景，离线使用的占比不低，只好做个数据库来适应需求。这篇文章主要介绍 OrmLite 框架中使用到的一些查询方法. WEHRE子句在SQL语句中，经常会用到where语句，where 进行条件筛选。dao.queryBuilder.()where()方法返回一个where对象，where中提供了很多方法来进行条件筛选,下边逐个讲where中的方法。 方法 ：eq(columnName,value) 等于（=）equals使用示范：mDao.queryBuilder().where().eq(“id”, 2).query();对应SQL：SELECT * FROM t_person WHERE id = 2 方法 ：lt(columnName,value) 小于（&lt;） less than使用示范：mDao.queryBuilder().where().lt(“id”, 2).query();对应SQL：SELECT * FROM t_person WHERE id &lt; 2 方法 ：gt(columnName,value) 大于（&gt;） greater than使用示范：mDao.queryBuilder().where().gt(“id”, 2).query();对应SQL：SELECT * FROM t_person WHERE id &gt; 2 方法 ：ge(columnName,value) 大于等于（&gt;=）greater-than or equals-to使用示范：mDao.queryBuilder().where().ge(“id”, 2).query();对应SQL：SELECT * FROM t_person WHERE id &gt;= 2 方法 ：le(columnName,value) 小于等于（&lt;=）less than or equals-to使用示范：mDao.queryBuilder().where().le(“id”, 2).query();对应SQL：SELECT * FROM t_person WHERE id &lt;= 2 方法 ：ne(columnName,value) 不等于（&lt;&gt;）not-equal-to使用示范：mDao.queryBuilder().where().ne(“id”, 2).query();对应SQL：SELECT * FROM t_person WHERE id &lt;&gt; 2 方法 ：in(columnName,object…) 在指定列中匹配object数组所对应的值，返回匹配到的结果行集合,in还有几个重载方法，需要的话可以去看文档或源码使用示范：mDao.queryBuilder().where().in(“id”, 1，2).query();对应SQL：SELECT * FROM t_person WHERE id IN (1，2 ) 方法 ：notIn(columnName,object…) 在指定列中匹配object数组所对应的值，返回没有匹配到的结果行集合notIn还有几个重载方法，需要的话可以去看文档或源码使用示范：mDao.queryBuilder().where().notIn(“id”,1,2).query();对应SQL：SELECT * FROM t_person WHERE id NOT IN (1 ,2 ) 方法 ：like(columnName,pattern) 使用%通配符来匹配，指定行数据，返回匹配到的结果使用示范：mDao.queryBuilder().where().like(“LastName”, “A%”).query(); 匹配A开头的LastNamemDao.queryBuilder().where().like(“LastName”, “%s”).query(); 匹配s结尾的LastNamemDao.queryBuilder().where().like(“LastName”, “%art%”).query(); 匹配中间为art的LastName对应SQL：SELECT * FROM `t_person` WHERE `LastName` LIKE &#39;A%&#39; 方法 ：between(columnName,low,high) 获取指定范围内的结果使用示范：mDao.queryBuilder().where().between(“id”, 1, 2).query();获取id是1到2之间的结果对应SQL：SELECT * FROM `t_person` WHERE `id` BETWEEN 1 AND 2 方法and()，or()用来组合上述where子语句。进行与，或操作。方法 ：and() where子句与操作使用示范：mDao.queryBuilder().where().lt(“id”, 3).and().gt(“id”, 1).query();对应SQL：SELECT * FROM `t_person` WHERE (`id` &lt; 3 AND `id` &gt; 1 ) 方法 ：or() where子句或操作使用示范：mDao.queryBuilder().where().eq(“id”, 1).or().eq(“id”, 2).query();对应SQL：SELECT * FROM `t_person` WHERE (`id` = 1 OR `id` = 2 ) ORDER BY根据指定列名排序，降序，升序使用示范：mDao.queryBuilder().orderBy(“id”, false).query(); //参数false表示降序，true表示升序。对应SQL：SELECT * FROM `t_person` ORDER BY `id` DESC（降序） DISTINCT过滤指定列不重复数据行，重复的只返回一次。使用示范：mDao.queryBuilder().selectColumns(“City”).distinct().query();对应SQL：SELECT DISTINCT `City` FROM `t_person` GROUP BY按照指定列分组使用示范：mDao.queryBuilder().groupBy(“city”).query();对应SQL：SELECT * FROM t_person GROUP BY city offset Limitoffset跳过指定的行数limit限制获取指定行数使用示范：mDao.queryBuilder().offset(2).limit(2).query(); 可以用来分页对应SQL：SELECT * FROM t_person LIMIT 2 OFFSET 2 Having等同于sql中的Having，针对分组数据，进行聚合函数（SUM, COUNT, MAX, AVG）运算。使用示范： mPersonList = mDao.queryBuilder().groupBy(“City”).having(“SUM(id)&gt;4”).query()对应SQL： SELECT * FROM t_person GROUP BY City HAVING SUM(id)&gt;4 countOf返回查询结果的总数使用示范：mDao.queryBuilder().countOf()对应SQL：SELECT COUNT(*) FROM t_person iterator返回一个结果集的迭代器。使用示范：Iterator iterator = mDao.queryBuilder().iterator(); queryForFirst返回所有行的第一行。使用示范：mDao.queryBuilder().queryForFirst(); 参考：http://blog.csdn.net/u013501637/article/details/52388802","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"OrmLite","slug":"OrmLite","permalink":"http://xichen.pub/tags/OrmLite/"},{"name":"database","slug":"database","permalink":"http://xichen.pub/tags/database/"}]},{"title":"【Android TimeCat】 OrmLite框架入门与封装（一）快速入门","slug":"2018-02-26-Android-TimeCat-OrmLite框架入门与封装（一）快速入门","date":"2018-02-25T22:49:00.000Z","updated":"2018-03-02T14:52:03.996Z","comments":true,"path":"2018/02/26/2018-02-26-Android-TimeCat-OrmLite框架入门与封装（一）快速入门/","link":"","permalink":"http://xichen.pub/2018/02/26/2018-02-26-Android-TimeCat-OrmLite框架入门与封装（一）快速入门/","excerpt":"","text":"背景本来打算把Time Cat做成完全依赖网络的，但是考虑到业务场景，离线使用的占比不低，只好做个数据库来适应需求。 本文主要针对 Android 使用 OrmLite 框架 对数据库的基本操作介绍，如有那些地方介绍的不对，请指出来，一起学习，一起进步。 添加 OrmLite 包向工程中添加 OrmLite 的 jar 包有两种方式： 到 OrmLite 官网下载 ormlite-core-4.49.jar 和 ormlite-android-4.49.jar 两个jar 包添加到工程中。 在项目中添加依赖的方式。 创建项目中使用DatabaseHelper类首先要简单说一下 OrmLite 框架中 OrmLiteSqliteOpenHelper 类 ，OrmLiteSqliteOpenHelper 类继承了 SQLiteOpenHelper。所以，创建项目中的DatabaseHelper 类，要使该类继承 OrmLite 框架 的 OrmLiteSqliteOpenHelper 类来获得 SQLiteHelper. 继承 OrmLiteSqliteOpenHelper 实现几个方法说明构造函数123456789public DatabaseHelper(Context context, String databaseName, SQLiteDatabase.CursorFactory factory, int databaseVersion) &#123; super(context, databaseName, factory, databaseVersion); /** * 参数说明： * context：上下文。 * databaseName： 数据库名。 * factory： 游标实例，多数时候设置成NULL。 * databaseVersion：数据库版本，当数据库版本升高时，会调用onUpgrade（）方法。 */ 创建数据库表123456789101112public void onCreate(SQLiteDatabase sqLiteDatabase, ConnectionSource connectionSource) &#123; /** * 在该方法中进行创建表操作 * 使用`OrmLite 框架`的 TableUtils.createTable进行创建表操作。 *eg. */ try &#123; TableUtils.createTable(connectionSource, UserInfo.class); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; 数据库版本提升更新方法12public void onUpgrade(SQLiteDatabase sqLiteDatabase, ConnectionSource connectionSource, int i, int i1) &#123; //在该方法中进行更新操作 创建数据库表对应的 BeanBean 类中的变量对应数据库中的字段，在 Bean 中使用注解方式进行设置。实例代码如下：123456789101112131415@DatabaseTable(tableName = \"tb_user_info\")public class UserInfo &#123; @DatabaseField(generatedId = true) private int userId; @DatabaseField(columnName = \"name\") private String name; @DatabaseField(columnName = \"addr\") private String addr; @DatabaseField(columnName = \"sex\") private String sex; // 对应字段的set 和 get 方法&#125; 数据库中字段注解设置说明： 字段名 参数名 说明 @DatabaseTable tableName 指定表明,没有将使用类名作为表明 @DatabaseField cloumnName 指定字段名,不指定则变量名作为字段名 canBeNull 是否可以为null dataType 指定字段的类型 defaultValue 指定默认值 width 指定长度 id 指定字段为id generatedId 指定字段为自增长的id generatedIdSequence foreign 指定这个字段的对象是一个外键,外键值是这个对象的id useGetSet 指定ormlite访问变量使用set,get方法默认使用的是反射机制直接访问变量 throwIfNull 如果空值抛出异常 persisted 指定是否持久化此变量,默认true unique 字段值唯一 uniqueCombo 整列的值唯一 index 索引 uniqueIndex 唯一索引 foreignAutoRefresh 外键值,自动刷新 uniqueIndex 外键值,自动刷新 foreignAutoCreate 外键不存在时是否自动添加到外间表中 foreignColumnName 外键字段指定的外键表中的哪个字段 获取操作数据库对应表的 Bean 的 Dao在OrmLite 框架中。操作数据是通过 对应Bean的Dao 实现的。 那么Dao 是如何获取的呢？ Dao 的获取方式： 对应Bean是通过 OrmLiteSqliteOpenHelper 类中 getDao(Class clazz) 方法获取。 实例代码如下：123456789public class UserDao &#123; private DatabaseHelper helper; public Dao&lt;UserInfo,Integer&gt; getUserDao(Context context) throws SQLException &#123; helper = new DatabaseHelper(context); return helper.getDao(UserInfo.class); &#125;&#125; 通过 Dao 对数据库进行简单增、删、改、查操作1UserDao mDao = new UserDao(); 增：123456try &#123; UserInfo u1 = new UserInfo(\"zhangsan\",\"beijng\",\"nan\"); mDao.getUserDao(mContext).create(u1);&#125; catch (SQLException e) &#123; e.printStackTrace();&#125; 删：下面的示例是使用删除集合完成删除1234567891011121314//修改和删除要通过id 进行操作UserInfo u4 = new UserInfo(\"zhangsan\",\"北京\",\"女\");u4.setUserId(4);UserInfo u3 = new UserInfo(\"招商\",\"beijng\",\"女\");u3.setUserId(3);try &#123; Collection&lt;UserInfo&gt; collection = new ArrayList&lt;UserInfo&gt;(); collection.add(u4); collection.add(u3); mDao.getUserDao(mContext).delete(collection);&#125; catch (SQLException e) &#123; e.printStackTrace();&#125; 改：12345678UserInfo u4 = new UserInfo(\"updateMan\",\"北京\",\"女\");u4.setUserId(4);try &#123; mDao.getUserDao(mContext).update(u4);&#125; catch (SQLException e) &#123; e.printStackTrace();&#125; 查：注：这里只举了一个查询方式，查询全部。条件查询请参考（OrmLite 复杂条件查询）123456789try &#123;List&lt;UserInfo&gt; infos = mDao.getUserDao(mContext).queryForAll(); for(UserInfo info : infos)&#123; //在此处使用TextView进行显示 mUserText.append(\"\\n\" + info.toString() + \"\\n\"); &#125;&#125; catch (SQLException e) &#123; e.printStackTrace();&#125; 参考：http://blog.csdn.net/u013501637/article/details/52388802","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"OrmLite","slug":"OrmLite","permalink":"http://xichen.pub/tags/OrmLite/"},{"name":"database","slug":"database","permalink":"http://xichen.pub/tags/database/"}]},{"title":"【Android TimeCat】 制作捐赠二维码，实现捐赠收款","slug":"2018-02-26-Android-TimeCat-制作捐赠二维码，实现捐赠收款","date":"2018-02-25T22:45:00.000Z","updated":"2018-03-02T14:52:04.013Z","comments":true,"path":"2018/02/26/2018-02-26-Android-TimeCat-制作捐赠二维码，实现捐赠收款/","link":"","permalink":"http://xichen.pub/2018/02/26/2018-02-26-Android-TimeCat-制作捐赠二维码，实现捐赠收款/","excerpt":"","text":"背景撰写了一篇对读者有帮助的博客， 贡献了一套对开发者有用的开源项目，上架了一个免费的App，用户觉得好用想回报作者，上架了一个收费的App，小白用户因不会使用 苹果支付（Apple Pay），谷歌钱包（Google Wallet Card），PayPal，没办法只要使用越狱破解版本，但又想获得版本更新，好用想回报作者， 以上问题因为有了 阿里支付宝（alipay）的二维码支付（捐赠），一切皆不是问题。平时你在互联网上看到的快捷捐赠就是这样实现的，你也可以实现. 步骤分解： PC端登陆支付宝官方网站 https://qr.alipay.com 免费领取“向我付款”的二维码。 个性化设置可以自行上传头像照片，并设置收款人姓名 下载“向我付款”的二维码，放到你的博客、github、App下载页面（注意不要放到AppStore或App内，会违反AppStore审核规则被Reject！） 补充： 支付宝二维码实则为一个可以打开支付宝客户端的url地址。也可以用手机原生浏览器，如iOS的Safari，Android的浏览器，直接访问二维码的Web地址，如我的二维码地址为https://qr.alipay.com/a6x08960yukqk4sjdmrwbd5 必须使用支付宝android，iOS客户端的“扫一扫”功能，如没有安装，先安装。 使用微信扫描时，微信会禁止跳转到支付宝（竞争对手关系吧），这时候需要选择扫描结果页面–右上角的打开方式“…”，使用原生浏览器打开，并拷贝支付地址 案例： WeiboX：新浪微博 MAC客户端，个人开发者http://weiboformac.sinaapp.com/donates.php JeepREC：iPhone版行车记录仪，个人开发者专业版 https://itunes.apple.com/cn/app/xing-che-ji-lu-yi-zhuan-ye/id918614632?mt=8免费版 https://itunes.apple.com/cn/app/xing-che-ji-lu-yi-mian-fei/id918642080?mt=8 参考：如何制作捐赠二维码，实现开源项目或免费应用的捐赠收款（支付宝篇）","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"alipay","slug":"alipay","permalink":"http://xichen.pub/tags/alipay/"}]},{"title":"【Android TimeCat】 跳转QQ加群","slug":"2018-02-26-Android-TimeCat-跳转QQ加群","date":"2018-02-25T22:25:00.000Z","updated":"2018-03-02T14:52:04.015Z","comments":true,"path":"2018/02/26/2018-02-26-Android-TimeCat-跳转QQ加群/","link":"","permalink":"http://xichen.pub/2018/02/26/2018-02-26-Android-TimeCat-跳转QQ加群/","excerpt":"","text":"背景TimeCat项目内测需要用到 步骤 访问https://qun.qq.com/join.html 登录 左边选择QQ群，右边有代码，直接复制到项目即可 注意 必须明确QQ群号 该用户必须是QQ群号的管理员或群主","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"QQ","slug":"QQ","permalink":"http://xichen.pub/tags/QQ/"}]},{"title":"【Android TimeCat】 Android Studio 高效配置","slug":"2018-02-26-Android-TimeCat-Android Studio高效配置","date":"2018-02-25T22:25:00.000Z","updated":"2018-03-02T14:52:03.986Z","comments":true,"path":"2018/02/26/2018-02-26-Android-TimeCat-Android Studio高效配置/","link":"","permalink":"http://xichen.pub/2018/02/26/2018-02-26-Android-TimeCat-Android Studio高效配置/","excerpt":"","text":"背景1、代码提示不区分大小写File | Settings 打开设置，选择Editor | General | Code Completion Case sensitive completion：选择None。 2、显示行号File | Settings 打开设置，选择Editor | General | Appearance 如图勾选 Show line numbers。 3、自动导包在 Android Studio 中， Alt + Enter 和 Control + Alt + O 是用来导包和清除无用导包。但是，你可以设置其快速自动导包的。 File | Settings打开设置，选择 Editor | General | Auto Import，勾选 Optimize imports on the fly 和 Add unambiguous imports on the fly 。 4、Log日志的颜色自定义Android Studio中 Logcat 的默认只有红白两种颜色，这样不利于我们分析Log打印的信息。建议还是采用Android Holo主题的配色方案。 File | Settings 打开设置，选择Editor | Color &amp; Fonts | Android Logcat，点击 Click on Save As…按钮创建一个新的配色 myLog。 注意：修改之前一定要取消勾选 Use inherited attributes 5、屏幕截图与屏幕录屏Android Studio中 自带了截屏与录屏的功能。如图 截屏： 录屏： 6、Android Studio真机ADB WiFi调试第一步，安装ADBWIFI插件，安装后之后重启AndroidStudio。 第二步，重启后，你会发现Tools | Android 多了一个 ADB WIFI。 手机通过数据线连上电脑，如图点击ADB Restart，出现如下图则成功 再点击 ADB USB to WIFI，出现如下图则成功，便可拔掉数据线无线调试了。 7、WaKaTime一款可以记录你敲代码时间的插件。 安装wakatime插件如上面，安装后重启。记得在官网上注册账号获取API Key。在Tools下面点击WaKaTime Settings 设置你的API Key。 官网地址：https://wakatime.com/ 8、SexyEditor插件（AndroidStudio设置背景）你可以在你的AndroidStudio上设置一张背景图片。File | Settings 打开设置，Other Settings下面的SexyEditor。 opacity：设置图片的 透明度 0-100 数值越大 背景图片越清晰。 shrink to fit: 缩小到适合尺寸。设置图片的缩放。 random:设置图片随机循环播放。 file list ：批量选择图片列表。 往下拉有个Insert 插入图片的按钮。 效果怎么样，是不是高大上。 9、ECTranslation翻译插件选中某个单词，翻译中文。 安装完插件重启，然后在Preferences -&gt; Keymap -&gt; 搜索Translate，右键设置快捷键。 选中某个单词+快捷键如图： 10、GsonFormatjson数据自动生成实体类。安装插件和上面一样，重启之后你可以设置一下快捷键，方法和上面一样，我的快捷键设置的是Alt+S。下面是演示。","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"http://xichen.pub/tags/Android-Studio/"}]},{"title":"【Android TimeCat】 Android Studio拾色器","slug":"2018-02-26-Android-TimeCat-Android Studio拾色器","date":"2018-02-25T21:37:00.000Z","updated":"2018-03-02T14:52:03.991Z","comments":true,"path":"2018/02/26/2018-02-26-Android-TimeCat-Android Studio拾色器/","link":"","permalink":"http://xichen.pub/2018/02/26/2018-02-26-Android-TimeCat-Android Studio拾色器/","excerpt":"","text":"背景在考虑UI颜色配置的时候需要颜色对齐，需要用的次数多了，给Android Studio自带的拾色器作个小总结。 你可能下载过一些获取颜色值的一些小工具， 这种方式获取颜色，需要先切换窗口转跳到桌面，然后打开拾色器小工具程序，然后去拾取颜色； 你可能也知道Android Studio自带一个颜色拾色器，通过下面这种方式才能找到 这种方式获取颜色值限制性很强，需要特定的窗口，需要点击那么一小块颜色才能弹出窗口，才能使用 那有没有更好的方式？ 答案是肯定的，不然这些个干嘛~~不用向上面那样去打开拾色器小工具程序，不用在特定的窗口点击特定的位置弹出拾色器工具，是用我们最喜欢的快捷键的方式打开Android Studio自带了颜色拾色器工具，但是它没有设置快捷键，也没有告诉我们， 这才是问题，不罗嗦了，跟着下面的设置去设置快捷键吧 设置好之后Apply应用 + OK确认下就好了 下面就能愉快的玩耍了，Alt+C~~ 参考：Android Studio设置颜色拾色器工具Color Picker","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"http://xichen.pub/tags/Android-Studio/"}]},{"title":"【Android TimeCat】 懒加载需求下的BaseFragment封装","slug":"2018-02-26-Android-TimeCat-懒加载需求下的BaseFragment封装","date":"2018-02-25T20:37:00.000Z","updated":"2018-03-02T14:52:04.015Z","comments":true,"path":"2018/02/26/2018-02-26-Android-TimeCat-懒加载需求下的BaseFragment封装/","link":"","permalink":"http://xichen.pub/2018/02/26/2018-02-26-Android-TimeCat-懒加载需求下的BaseFragment封装/","excerpt":"","text":"背景在多个Fragment需要加载的时候,启动速度往往会变慢，影响用户体验。分析发现并非所有的Fragment都需要第一时间将数据填充完毕，因为它们都还没有被用户所”看见”.所以我们要达到的效果是Fragment被显示后才加载数据(lazy load)。由于这种需求具有共性，即每个Fragment都可能有懒加载的需要，故封装成基类BaseFragment. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160public abstract class BaseFragment extends Fragment &#123; /** * Fragment title */ public String fragmentTitle; /** * 是否可见状态 为了避免和&#123;@link Fragment#isVisible()&#125;冲突 换个名字 */ private boolean isFragmentVisible; /** * 标志位，View已经初始化完成。 */ private boolean isPrepared; /** * 是否第一次加载 */ private boolean isFirstLoad = true; /** * &lt;pre&gt; * 忽略isFirstLoad的值，强制刷新数据，但仍要Visible &amp; Prepared * 一般用于PagerAdapter需要刷新各个子Fragment的场景 * 不要new 新的 PagerAdapter 而采取reset数据的方式 * 所以要求Fragment重新走initData方法 * 故使用 &#123;@link BaseFragment#setForceLoad(boolean)&#125;来让Fragment下次执行initData * &lt;/pre&gt; */ private boolean forceLoad = false; @Override public void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Bundle bundle = getArguments(); if (bundle != null &amp;&amp; bundle.size() &gt; 0) &#123; initVariables(bundle); &#125; &#125; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; // 若 viewpager 不设置 setOffscreenPageLimit 或设置数量不够 // 销毁的Fragment onCreateView 每次都会执行(但实体类没有从内存销毁) isFirstLoad = true; View view = initViews(inflater, container, savedInstanceState); isPrepared = true; lazyLoad(); return view; &#125; /** * 如果是与ViewPager一起使用，调用的是setUserVisibleHint * * @param isVisibleToUser 是否显示出来了 */ @Override public void setUserVisibleHint(boolean isVisibleToUser) &#123; super.setUserVisibleHint(isVisibleToUser); if (getUserVisibleHint()) &#123; onVisible(); &#125; else &#123; onInvisible(); &#125; &#125; /** * 如果是通过FragmentTransaction的show和hide的方法来控制显示，调用的是onHiddenChanged. * 若是初始就show的Fragment 为了触发该事件 需要先hide再show * * @param hidden hidden True if the fragment is now hidden, false if it is not * visible. */ @Override public void onHiddenChanged(boolean hidden) &#123; super.onHiddenChanged(hidden); if (!hidden) &#123; onVisible(); &#125; else &#123; onInvisible(); &#125; &#125; protected void onVisible() &#123; isFragmentVisible = true; lazyLoad(); &#125; protected void onInvisible() &#123; isFragmentVisible = false; &#125; /** * 要实现延迟加载Fragment内容,需要在 onCreateView * isPrepared = true; */ protected void lazyLoad() &#123; if (isPrepared() &amp;&amp; isFragmentVisible()) &#123; if (forceLoad || isFirstLoad()) &#123; forceLoad = false; isFirstLoad = false; initData(); &#125; &#125; &#125; @Override public void onDestroyView() &#123; super.onDestroyView(); isPrepared = false; &#125; /** * 被ViewPager移出的Fragment 下次显示时会从getArguments()中重新获取数据 * 所以若需要刷新被移除Fragment内的数据需要重新put数据 eg: * Bundle args = getArguments(); * if (args != null) &#123; * args.putParcelable(KEY, info); * &#125; */ public void initVariables(Bundle bundle) &#123;&#125; protected abstract View initViews(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState); protected abstract void initData(); public boolean isPrepared() &#123; return isPrepared; &#125; /** * 忽略isFirstLoad的值，强制刷新数据，但仍要Visible &amp; Prepared */ public void setForceLoad(boolean forceLoad) &#123; this.forceLoad = forceLoad; &#125; public boolean isFirstLoad() &#123; return isFirstLoad; &#125; public boolean isFragmentVisible() &#123; return isFragmentVisible; &#125; public String getTitle() &#123; if (null == fragmentTitle) &#123; setDefaultFragmentTitle(null); &#125; return TextUtils.isEmpty(fragmentTitle) ? \"\" : fragmentTitle; &#125; public void setTitle(String title) &#123; fragmentTitle = title; &#125; /** * 设置fragment的Title直接调用 &#123;@link BaseFragment#setTitle(String)&#125;,若不显示该title 可以不做处理 * * @param title 一般用于显示在TabLayout的标题 */ protected abstract void setDefaultFragmentTitle(String title);&#125; 参考：LazyFragment","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"Fragment","slug":"Fragment","permalink":"http://xichen.pub/tags/Fragment/"}]},{"title":"【Android TimeCat】 Android中使用矢量图（SVG, VectorDrawable）","slug":"2018-02-25-Android-TimeCat-使用矢量图（SVG, VectorDrawable）","date":"2018-02-25T03:28:00.000Z","updated":"2018-03-02T14:52:03.982Z","comments":true,"path":"2018/02/25/2018-02-25-Android-TimeCat-使用矢量图（SVG, VectorDrawable）/","link":"","permalink":"http://xichen.pub/2018/02/25/2018-02-25-Android-TimeCat-使用矢量图（SVG, VectorDrawable）/","excerpt":"","text":"背景TimeCat项目中需要根据不同的场景动态改变图标颜色，如果用png等格式，会使图片资源过多。明明图案是一样的，为什么改变个颜色就得多一张图?如果整体颜色风格改变，那之前的图片资源就都废了？所以选择用xml文件来描述图片颜色，想用什么色就用什么色。 图片本质上是一个存像素点的矩阵，而svg高级一点，存一些点，比如一个圆，那么就存圆心和半径数据就行了，这是轨迹，然后再规定颜色，这样和png资源相比，内存大大减少，还容易自定义，改个图标颜色简直不要太方便！ SVG 和 VectorDrawableSVG 可缩放矢量图形（英语：Scalable Vector Graphics，SVG）是一种基于可扩展标记语言（XML），用于描述二维矢量图形的图形格式。SVG由W3C制定，是一个开放标准。——摘自维基百科 .svg格式相对于.jpg、.png甚至.webp具有较多优势，我认为核心有两点： 省时间。图像与分辨率无关，收放自如，适配安卓机坑爹的分辨率真是一劳永逸； 省空间。体积小，一般复杂图像也能在数KB搞定，图标更不在话下。 VectorDrawableVectorDrawable是Google从Android 5.0开始引入的一个新的Drawable子类，能够加载矢量图。到现在通过support-library已经至少能适配到Android 4.0了（通过AppBrain统计的Android版本分布来看，Android 4.1以下（api&lt;15）几乎可以不考虑了）。Android中的VectorDrawable只支持SVG的部分属性，相当于阉割版。 它虽然是个类，但是一般通过配置xml再设置到要使用的控件上。在Android工程中，在资源文件夹res/drawable/的目录下（没有则需新建），通过&lt;vector&gt;&lt;/vector&gt;标签描述，例如svg_ic_arrow_right.xml： 123456789&lt;vector xmlns:android=\"http://schemas.android.com/apk/res/android\" android:width=\"8dp\" android:height=\"8dp\" android:viewportHeight=\"24.0\" android:viewportWidth=\"24.0\"&gt; &lt;path android:fillColor=\"#ffffff\" android:pathData=\"M12,4l-1.41,1.41L16.17,11H4v2h12.17l-5.58,5.59L12,20l8,-8z\"/&gt;&lt;/vector&gt; 基本属性说明： width, height：图片的宽高。可手动修改到需要尺寸； viewportHeight, viewportWidth：对应将上面height width等分的份数。以svg_ic_arrow_right.xml举例，可以想象将长宽都为8dp的正方形均分为24x24的网格，在这个网格中就可以很方便地描述点的坐标，图像就是这些点连接起来构成的。 fillColor：填充颜色。最好直接在这里写明色值#xxxxxxxx，而不要用@color/some_color的形式，避免某些5.0以下机型可能会报错。 pathData：在2中描述的网格中作画的路径。具体语法不是本文的重点，故不展开。 下面这段代码描述出来的是一个蓝色闹钟，可以从Android Studio的preview功能栏里预览到它的样子： emm…既然xml资源作图标这么方便，应该怎么获取呢？ 获取矢量图方式一：Android Studio的Material Icon鼠标选中drawable文件夹，右键， New， Vector Asset 然后出现： 点击机器人进入搜索筛选： 左侧的搜索和分类可以快速索引。这里都是由谷歌官方制作的MD标准图标，建议先到这里搜索，如果没有再到网上搜索。 获取矢量图方式二：iconfont墙裂安利一个网站，阿里的iconfont，海量在线矢量图，早收藏早致富！我已经离不开它了=￣ω￣= 第一步，搜索你要的资源名字，中英文一般都会有结果。比如“arrow”，结果： 第二步，鼠标移动到某一图标上点击，比如上面第一排第二个，出现： 三个选项，第一相当于购物车，可不用登录，第二是收藏，第三是下载，均需要登录。如果未登录，点击后出现： 选择GitHub或微博都行。第三步，登录成功，点击下载，弹出： 可以对图标属性进行编辑，如色值和大小（单位dp），然后点按钮“SVG下载”。下载成功后在下载目录找到一个.svg格式的文件，这个文件可以用浏览器打开-&gt;查看网页源码，或者用NotePad++等编辑器打开看到里面的内容，格式化后是这样： 123456789&lt;?xml version=\"1.0\" standalone=\"no\"?&gt;&lt;!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"&gt;&lt;svg t=\"1490517024583\" class=\"icon\" style=\"\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"1010\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"16\" height=\"16\"&gt; &lt;defs&gt; &lt;style type=\"text/css\"&gt;&lt;/style&gt; &lt;/defs&gt; &lt;path d=\"M288.86749 12.482601C272.260723-4.160867 245.369563-4.160867 228.720647 12.482601 212.15603 29.126068 212.15603 56.438425 228.720647 73.081892L704.289552 511.786622 228.720647 950.918109C212.15603 967.561574 212.15603 994.447175 228.720647 1011.517401 245.369563 1028.160866 272.260723 1028.160866 288.86749 1011.517401L794.952385 544.646802C803.803707 535.684935 807.597131 523.735776 807.007043 511.786622 807.597131 500.264224 803.803707 488.315065 794.952385 479.353198L288.86749 12.482601Z\" p-id=\"1011\"&gt;&lt;/path&gt;&lt;/svg&gt; 文件里好多标签Android是不认识的。不过没关系，有三种解决办法 手动转化成xml新建一个&lt;vector&gt;&lt;/vector&gt;标签的xml文件，通过观察文件内容，很容易获取到关键信息。 width, height自然对应&lt;vector/&gt;中宽高， viewBox后两位数字是分别对应&lt;vector/&gt;中的viewportWidth和viewportHeight， &lt;path/&gt;中的d的数据的对应&lt;vector/&gt;中&lt;path/&gt;中的pathData。 fillColor自己手动设置。 svgtoandroid插件安装：File -&gt; Setting -&gt; Plugins -&gt; Browser repositories -&gt; 搜“svg2VectorDrawable” -&gt; 安装并重启Android Studio，再次进来后顶部工具栏会多一个图标： 点击图标弹出对话框： 勾选Batch选项，将对被选中文件夹中的.svg文件进行批量转换。nodpi会自动添加到没有后缀的drawable文件夹中。 网上下载的svg资源往往一步到位，有个这个插件将会事半功倍。导入第一个svg文件时就命名成我们想要的名字，如果不满意再导入时无需再关注命名，将后面导入的pathData覆盖第一个观察效果，直到满意后删除不需要的文件。 Android Studio自带转化鼠标选中drawable文件夹，右键， New， Vector Asset， Local file，然后出现： 先选本地文件（还能支持PSD，强吧），再到磁盘中找到之前下载的.svg矢量图。导入后可以为文件重命名（建议用svg_或者有区别于其它格式的前缀），默认导入宽高均为24dp，选中Override框则读取文件本来宽高，其它配置视需求而定。点击Next到下一页最后点Finish就导入了。自动导入需要格式化一下就是前面svg_ic_arrow_right.xml的样子了。 海搜比较耗时间，线条粗细啦，位置没居中啦，大小不搭配啦，关键是这些问题都是导入项目或者运行到手机后才能发现（非强迫症当我没说）。iconfont还有诸多成套的图标库，优点是风格大小一致，或者多彩图标。 项目应用前提：项目的build.gradle配置有：12345678910111213android&#123; ... defaultConfig &#123; ... vectorDrawables.useSupportLibrary = true &#125; ...&#125;dependencies &#123; ... compile \"com.android.support:appcompat-v7:21+\" // 至少Api21 ...&#125; 项目的Activity中都包含（通用做法是在BaseActivity中加）：123static &#123; AppCompatDelegate.setCompatVectorFromResourcesEnabled(true);&#125; AppCompatImageView这是继承自ImageView用于5.0以下加载矢量图的控件，只需要替换src为srcCompat属性，其它没什么不同。例如：1234&lt;android.support.v7.widget.AppCompatImageView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" app:srcCompat=\"@drawable/svg_ic_arrow_right\"/&gt; 如果你的Activity直接或间接继承自AppCompatActivity，当前视图中的ImageView在编译过程中会被自动转为AppCompatImageView（support包中所有含有AppCompat前缀的控件均受相同处理），因而在Activity中通过findViewById()的实例用ImageView或AppCompatActivity接收是没有区别的。用以上条件的Activity中装载的Fragment，或者通过动态注入（如Dialog的contentView）的ImageView，均将被自动转为AppCompatActivity。从xml文件中初始化ImageView并加载矢量图，必须使用AppCompatImageView的srcCompat属性。ImageView的染色属性tint同样适合矢量图。 TextView在我的经验中，TextView可以用到矢量图的场景是最多的，主要是设置CompoundDrawable。例如：123456&lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:drawableRight=\"@drawable/svg_ic_arrow_right\" android:drawablePadding=\"4dp\" android:text=\"drawable right\"/&gt; 这样设置后，没有任何不适，编译器也不报错，可能你自己运行也没问题。但是！这才是深坑啊。5.0以下某些机型可能会崩溃的。 AppCompatTextView是没有对CompoundDrawable进行适配的，所以需要自己动手才能丰衣足食。简单原理是，判断系统版本如果小于5.0，就用ContextCompat.getDrawable获取到Drawable实例，再setCompoundDrawablesWithIntrinsicBounds。 这个部分已经有人做好并开源了，地址：VectorCompatTextView，轻松compile到项目中使用。他还特意添加了一个实用功能——tint染色——可以选择是否让图标与文字颜色一样，这样就不必关心xml里的fillColor属性了。用例：12345678910&lt;com.xw.repo.VectorCompatTextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:background=\"@color/color_gray_light\" android:gravity=\"center_vertical\" android:padding=\"16dp\" android:text=\"Next\" android:textSize=\"16sp\" app:drawableRightCompat=\"@drawable/svg_ic_arrow_right\" app:tintDrawableInTextColor=\"true\"/&gt; 效果： MenuItemMenuItem就是在res/menu/目录下通过xml配置的菜单，适用于NavigationView的menu属性和Activity中onCreateOptionsMenu()注入的选项菜单。 VectorDrawable 转 Bitmap自定义View中也可以自由使用矢量图。首先需要将VectorDrawable 转为 Bitmap，看码：1234567891011121314public Bitmap getBitmapFromVectorDrawable(Context context, int drawableId) &#123; Drawable drawable = ContextCompat.getDrawable(context, drawableId); if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) &#123; drawable = (DrawableCompat.wrap(drawable)).mutate(); &#125; Bitmap bitmap = Bitmap.createBitmap(drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight(), Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(bitmap); drawable.setBounds(0, 0, canvas.getWidth(), canvas.getHeight()); drawable.draw(canvas); return bitmap; &#125; 执行以上方法获得一个Bitmap的实例（设为mVectorBitmap），然后再在ondraw()里根据你的需求画出bitmap：1234567@Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); /// canvas.drawBitmap(mVectorBitmap, left, top, paint); ///&#125; 参考：https://www.jianshu.com/p/0555b8c1d26a","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"svg","slug":"svg","permalink":"http://xichen.pub/tags/svg/"}]},{"title":"【Android TimeCat】 Android中用intent传递对象的三种方法","slug":"2018-02-25-Android-TimeCat-Android中用intent传递对象的三种方法","date":"2018-02-24T21:28:00.000Z","updated":"2018-03-02T14:52:03.975Z","comments":true,"path":"2018/02/25/2018-02-25-Android-TimeCat-Android中用intent传递对象的三种方法/","link":"","permalink":"http://xichen.pub/2018/02/25/2018-02-25-Android-TimeCat-Android中用intent传递对象的三种方法/","excerpt":"","text":"背景TimeCat项目中需要根据上一个Activity的数据来初始化当前Activity，考虑到启动Activity时可以传数据，那么就用intent实现了。Android中，Activity和Fragment之间传递对象，可以通过将对象序列化并存入Bundle或者Intent中进行传递，也可以将对象转化为JSON字符串，进行传递。 序列化对象可以使用Java的Serializable的接口、Parcelable接口。转化成JSON字符串，可以使用Gson等库。 SerializableModel123456789101112public class Author implements Serializable&#123; private int id; private String name; //...&#125;public class Book implements Serializable&#123; private String title; private Author author; //...&#125; 传递数据123456789Book book=new Book(); book.setTitle(\"Java编程思想\"); Author author=new Author(); author.setId(1); author.setName(\"Bruce Eckel\"); book.setAuthor(author); Intent intent=new Intent(this,SecondActivity.class); intent.putExtra(\"book\",book); startActivity(intent);. 接收数据123Book book= (Book) getIntent().getSerializableExtra(\"book\");Log.d(TAG,\"book title-&gt;\"+book.getTitle());Log.d(TAG,\"book author name-&gt;\"+book.getAuthor().getName()); 转化为JSON字符串Model123456789101112public class Author&#123; private int id; private String name; //...&#125;public class Book&#123; private String title; private Author author; //...&#125; 传递数据123456789Book book=new Book();book.setTitle(\"Java编程思想\");Author author=new Author();author.setId(1);author.setName(\"Bruce Eckel\");book.setAuthor(author);Intent intent=new Intent(this,SecondActivity.class);intent.putExtra(\"book\",new Gson().toJson(book));startActivity(intent); 接收数据1234String bookJson=getIntent().getStringExtra(\"book\");Book book=new Gson().fromJson(bookJson,Book.class);Log.d(TAG,\"book title-&gt;\"+book.getTitle());Log.d(TAG,\"book author name-&gt;\"+book.getAuthor().getName()); 使用Parcelable实现Parcelable接口需要实现两个方法 describeContents方法。内容接口描述，默认返回0就可以; writeToParcel方法。将传递的数据打包到Parcel容器中。 除了要实现这两个方法还必须创建一个Parcelable.Creator接口的实例，用于读取Parcel容器中的数据 Model12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class Author implements Parcelable&#123; private int id; private String name; //setter &amp; getter... @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; //该方法将类的数据写入外部提供的Parcel中.即打包需要传递的数据到Parcel容器保存， // 以便从parcel容器获取数据 dest.writeString(name); dest.writeInt(id); &#125; public static final Creator&lt;Author&gt; CREATOR=new Creator&lt;Author&gt;() &#123; @Override public Author createFromParcel(Parcel source) &#123; //从Parcel容器中读取传递数据值，封装成Parcelable对象返回逻辑层。 Author author=new Author(); author.setName(source.readString()); author.setId(source.readInt()); return author; &#125; @Override public Author[] newArray(int size) &#123; //创建一个类型为T，长度为size的数组，仅一句话（return new T[size])即可。方法是供外部类反序列化本类数组使用。 return new Author[size]; &#125; &#125;;&#125;public class Book implements Parcelable&#123; private String title; private Author author; //setter &amp; getter... @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeString(title); dest.writeParcelable(author,flags); &#125; public static final Creator&lt;Book&gt; CREATOR=new Creator&lt;Book&gt;() &#123; @Override public Book createFromParcel(Parcel source) &#123; Book book=new Book(); book.setTitle(source.readString()); book.setAuthor(source.&lt;Author&gt;readParcelable(Author.class.getClassLoader())); return book; &#125; @Override public Book[] newArray(int size) &#123; return new Book[0]; &#125; &#125;;&#125; 传递数据123456789Book book=new Book();book.setTitle(\"Java编程思想\");Author author=new Author();author.setId(1);author.setName(\"Bruce Eckel\");book.setAuthor(author);Intent intent=new Intent(this,SecondActivity.class);intent.putExtra(\"book\",book);startActivity(intent); 接收数据123Book book=getIntent().getParcelableExtra(\"book\");Log.d(TAG,\"book title-&gt;\"+book.getTitle());Log.d(TAG,\"book author name-&gt;\"+book.getAuthor().getName()); 性能分析经过测试，我们得到下图的效果 简化Parcel操作可以看出，通过转换为字符串的速度是最慢的。Seralizable次之，Parcelable比Seralizable快10倍。所以从性能上考虑，我们必定优先选择Parcelable。但是Parcelable有大量重复的模板代码，如何简化这些操作，将是下面主要讲解的内容。 如果你使用android Studio 可以通过安装android-parcelable-intellij-plugin插件，或者自己配置模板进行操作。 parceler除了上面的操作，还有大量的第三方库来简化Parcelable操作。当然使用这些库也许会降低Parcelable的性能。Parceler就是这样一个库。 Parceler使用非常简单，在定义Model时用@Parcel进行注解，在传递数据的时候使用Parcels的wrap方法来包装成一个Parcelable对象。获取数据时用Parcels的unwrap方法来获取对象。 Model12345678910111213141516@Parcel public class Author &#123; int id; String name; //setter &amp; getter...&#125;@Parcelpublic class Book &#123; String title; Author author; //setter &amp; getter&#125; 传递对象123456789Book book=new Book();book.setTitle(\"Java编程思想\");Author author=new Author();author.setId(1);author.setName(\"Bruce Eckel\");book.setAuthor(author);Intent intent=new Intent(this,SecondActivity.class);intent.putExtra(\"book\", Parcels.wrap(book));startActivity(intent); 接收对象123Book book= Parcels.unwrap(getIntent().getParcelableExtra(\"book\"));Log.d(TAG,\"book title-&gt;\"+book.getTitle());Log.d(TAG,\"book author name-&gt;\"+book.getAuthor().getName()); 除了Parceler之外，还有如auto-parcel,ParcelableCodeGenerator,ParcelableGenerator等第三方库，这里我将不进行讲解，有兴趣的朋友，可以自行研究。 参考：Android中传递对象的三种方法","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"}]},{"title":"【Android TimeCat】 比较Fragment中获取Context对象的两种方法","slug":"2018-02-25-Android-TimeCat-比较Fragment中获取Context对象的两种方法","date":"2018-02-24T20:37:00.000Z","updated":"2018-03-02T14:52:03.980Z","comments":true,"path":"2018/02/25/2018-02-25-Android-TimeCat-比较Fragment中获取Context对象的两种方法/","link":"","permalink":"http://xichen.pub/2018/02/25/2018-02-25-Android-TimeCat-比较Fragment中获取Context对象的两种方法/","excerpt":"","text":"背景我们在使用Fragment的时候经常需要传递Context类型的参数，比如弹出一个dialog，而Fragment自己又不是一个Context类型的对象，于是我们有下面两种方法获取Context对象。 两种方法介绍 this.getActivity()（可以不写this.） 在Fragment中直接调用getActivity()方法，可以直接得到Fragment依附的Activity，而Activity是一个Context类型的对象。 获取Application对象 如下自己写一个MyApplication类继承Application，通过getInstance获取一个Application类型的对象，也是Context对象。 12345678910public class MyApplication extends Application &#123; private MyApplication mInstance; public static void getInstance()&#123; if(mInstance == null)&#123; mInstance = new MyApplication(); &#125; return mInstance; &#125;&#125; 两种方法比较 this.getActivity() 优点：不需要写MyApplication类 缺点：Fragment很容易被销毁，调用getActivity()方法会报空指针错误（注意：并不是getActivity()返回值为null，而是this.getActivity()中的this，也就是Fragment自己是null，因为它已经被销毁了） 获取Application对象 优点：不会遇到类似this.getActivity()的空指针问题 缺点：某些情况下的Context必须是Activity，特别是实例化Dialog等需要依附于一个Activity的可视化的对象时传参必须是Activity对象（Toast是Android的一种通知机制，不需要依附于Activity） 两全其美的解决方案1.MyApplication是一定要写的 2.写一个如下的BaseFragment类：所有的Fragment都继承这个BaseFragment,直接通过getContext()方法即可得到Context对象，当然实例化Dialog等需要依附于Activity的对象时，还是老老实实的getActivity()吧 12345678910111213141516public class BaseFragment extends Fragment&#123; private Activity activity; public Context getContext()&#123; if(activity == null)&#123; return MyApplication.getInstance(); &#125; return activity; &#125; @Override public void onAttach(Activity activity) &#123; super.onAttach(activity); activity = getActivity(); &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"Fragment","slug":"Fragment","permalink":"http://xichen.pub/tags/Fragment/"}]},{"title":"【Android TimeCat】 Java 回调及其在项目中的运用","slug":"2018-02-25-Android-TimeCat-java回调机制","date":"2018-02-24T18:48:00.000Z","updated":"2018-03-02T14:52:03.980Z","comments":true,"path":"2018/02/25/2018-02-25-Android-TimeCat-java回调机制/","link":"","permalink":"http://xichen.pub/2018/02/25/2018-02-25-Android-TimeCat-java回调机制/","excerpt":"","text":"背景TImeCat项目中的Activity和Fragment是分开管理的，有需求是点击ActionBar上的刷新，对应的fragment就重新拉取数据，或者在fragment中选择日期，对应在activity的标题位置要更新日期，考虑到性能问题，用回调实现。 框架以前不理解什么叫回调，天天听人家说加一个回调方法啥的，心里想我草，什么叫回调方法啊？然后自己就在网上找啊找啊找，找了很多也不是很明白，现在知道了，所谓回调：就是A类中调用B类中的某个方法C，然后B类中反过来调用A类中的方法D，D这个方法就叫回调方法，这样子说你是不是有点晕晕的，其实我刚开始也是这样不理解，看了人家说比较经典的回调方式： Class A实现接口CallBack callback——背景1class A中包含一个class B的引用b——背景2class B有一个参数为callback的方法f(CallBack callback)——背景3A的对象a调用B的方法 f(CallBack callback) ——A类调用B类的某个方法 C然后b就可以在f(CallBack callback)方法中调用A的方法 ——B类调用A类的某个方法D大家都喜欢用打电话的例子，好吧，为了跟上时代，我也用这个例子好了，我这个例子采用异步加回调 异步回调有一天小王遇到一个很难的问题，问题是“1 + 1 = ?”，就打电话问小李，小李一下子也不知道，就跟小王说，等我办完手上的事情，就去想想答案，小王也不会傻傻的拿着电话去等小李的答案吧，于是小王就对小李说，我还要去逛街，你知道了答案就打我电话告诉我，于是挂了电话，自己办自己的事情，过了一个小时，小李打了小王的电话，告诉他答案是2 123456789101112/** * 这是一个回调接口 * @author xiaanming * */ public interface CallBack &#123; /** * 这个是小李知道答案时要调用的函数告诉小王，也就是回调函数 * @param result 是答案 */ public void solve(String result); &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 这个是小王 * @author xiaanming * 实现了一个回调接口CallBack，相当于-----&gt;背景一 */ public class Wang implements CallBack &#123; /** * 小李对象的引用 * 相当于-----&gt;背景二 */ private Li li; /** * 小王的构造方法，持有小李的引用 * @param li */ public Wang(Li li)&#123; this.li = li; &#125; /** * 小王通过这个方法去问小李的问题 * @param question 就是小王要问的问题,1 + 1 = ? */ public void askQuestion(final String question)&#123; //这里用一个线程就是异步， new Thread(new Runnable() &#123; @Override public void run() &#123; /** * 小王调用小李中的方法，在这里注册回调接口 * 这就相当于A类调用B的方法C */ li.executeMessage(Wang.this, question); &#125; &#125;).start(); //小网问完问题挂掉电话就去干其他的事情了，诳街去了 play(); &#125; public void play()&#123; System.out.println(\"我要逛街去了\"); &#125; /** * 小李知道答案后调用此方法告诉小王，就是所谓的小王的回调方法 */ @Override public void solve(String result) &#123; System.out.println(\"小李告诉小王的答案是---&gt;\" + result); &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435/** * 这个就是小李啦 * @author xiaanming * */ public class Li &#123; /** * 相当于B类有参数为CallBack callBack的f()----&gt;背景三 * @param callBack * @param question 小王问的问题 */ public void executeMessage(CallBack callBack, String question)&#123; System.out.println(\"小王问的问题---&gt;\" + question); //模拟小李办自己的事情需要很长时间 for(int i=0; i&lt;10000;i++)&#123; &#125; /** * 小李办完自己的事情之后想到了答案是2 */ String result = \"答案是2\"; /** * 于是就打电话告诉小王，调用小王中的方法 * 这就相当于B类反过来调用A的方法D */ callBack.solve(result); &#125; &#125; 1234567891011121314151617181920212223/** * 测试类 * @author xiaanming * */ public class Test &#123; public static void main(String[]args)&#123; /** * new 一个小李 */ Li li = new Li(); /** * new 一个小王 */ Wang wang = new Wang(li); /** * 小王问小李问题 */ wang.askQuestion(\"1 + 1 = ?\"); &#125; &#125; 通过上面的那个例子你是不是差不多明白了回调机制呢，上面是一个异步回调，我们看看同步回调吧，onClick()方法 同步回调现在来分析分析下Android View的点击方法onclick();我们知道onclick()是一个回调方法，当用户点击View就执行这个方法，我们用Button来举例好了 123456789//这个是View的一个回调接口public interface OnClickListener &#123; /** * Called when a view has been clicked. * * @param v The view that was clicked. */ void onClick(View v); &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041package com.example.demoactivity; import android.app.Activity; import android.os.Bundle; import android.view.View; import android.view.View.OnClickListener; import android.widget.Button; import android.widget.Toast; /** * 这个就相当于Class A * 实现了 OnClickListener接口----&gt;背景一 */ public class MainActivity extends Activity implements OnClickListener&#123; /** * Class A 包含Class B的引用-----&gt;背景二 */ private Button button; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button = (Button)findViewById(R.id.button1); /** * Class A 调用View的方法,而Button extends View-----&gt;A类调用B类的某个方法 C */ button.setOnClickListener(this); &#125; /** * 用户点击Button时调用的回调函数，你可以做你要做的事 * 这里我做的是用Toast提示OnClick */ @Override public void onClick(View v) &#123; Toast.makeText(getApplication(), \"OnClick\", Toast.LENGTH_LONG).show(); &#125; &#125; 下面是View类的setOnClickListener方法，就相当于B类咯，只把关键代码贴出来 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 这个View就相当于B类 * @author xiaanming * */ public class View implements Drawable.Callback, KeyEvent.Callback, AccessibilityEventSource &#123; /** * Listener used to dispatch click events. * This field should be made private, so it is hidden from the SDK. * &#123;@hide&#125; */ protected OnClickListener mOnClickListener; /** * setOnClickListener()的参数是OnClickListener接口------&gt;背景三 * Register a callback to be invoked when this view is clicked. If this view is not * clickable, it becomes clickable. * * @param l The callback that will run * * @see #setClickable(boolean) */ public void setOnClickListener(OnClickListener l) &#123; if (!isClickable()) &#123; setClickable(true); &#125; mOnClickListener = l; &#125; /** * Call this view's OnClickListener, if it is defined. * * @return True there was an assigned OnClickListener that was called, false * otherwise is returned. */ public boolean performClick() &#123; sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); if (mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); //这个不就是相当于B类调用A类的某个方法D，这个D就是所谓的回调方法咯 mOnClickListener.onClick(this); return true; &#125; return false; &#125; &#125; 这个例子就是Android典型的回调机制，看完这个你是不是更进一步的理解了回调机制呢？ 线程run()也是一个回调方法，当执行Thread的start()方法就会回调这个run()方法，还有处理消息都比较经典等等 需求实现点击Activity的刷新按钮，对应fragment重新拉取数据 为了简明起见，压缩代码 123456789101112131415161718192021222324//MainActivity.javaclass MainActivity extends Activity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //省略其他代码 RefreshFragment refreshFragment = new RefreshFragment(); setOnRefreshClickListener(refreshFragment); // refreshFragment实现了回调接口，把fragment传进来即可 button = (Button)findViewById(R.id.button1); button.setOnClickListener(new View.OnClickListener() &#123; if (onRefreshClickListener != null) &#123; onRefreshClickListener.OnRefresh(); &#125; &#125;); &#125; //省略其他代码 OnRefreshClickListener onRefreshClickListener; public void setOnRefreshClickListener(OnRefreshClickListener onRefreshClickListener) &#123; this.onRefreshClickListener = onRefreshClickListener; &#125;&#125; 123456789101112// RefreshFragment.javaclass RefreshFragment extends Fragment implements OnRefreshClickListener &#123; //省略其他代码 @Override public void OnRefresh() &#123; // 在这里实现刷新数据，例如 if (mAdapter != null) &#123; mAdapter.notifyDataSetChanged(); &#125; &#125;&#125; 12345// OnRefreshClickListener.javapublic interface OnRefreshClickListener &#123; void OnRefresh();&#125; 新手一般会踩的坑循环继承 参考 一个经典例子让你彻彻底底理解java回调机制 Android实战之 万能的接口回调","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://xichen.pub/tags/Java/"},{"name":"回调","slug":"回调","permalink":"http://xichen.pub/tags/回调/"}]},{"title":"【Android TimeCat】快速构建APP BottomNavigationView + ViewPager + Fragment","slug":"2018-02-25-Android-TimeCat-BottomNavigationView+ViewPager+Fragment快速构建App","date":"2018-02-24T18:48:00.000Z","updated":"2018-03-02T14:52:03.977Z","comments":true,"path":"2018/02/25/2018-02-25-Android-TimeCat-BottomNavigationView+ViewPager+Fragment快速构建App/","link":"","permalink":"http://xichen.pub/2018/02/25/2018-02-25-Android-TimeCat-BottomNavigationView+ViewPager+Fragment快速构建App/","excerpt":"","text":"先上图 创建项目使用Android-Studio创建一个BottomNavigationView项目 创建布局修改activity_main.xml文件 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/container\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;android.support.v4.view.ViewPager android:id=\"@+id/viewPager\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\" android:layout_weight=\"1\"/&gt; &lt;android.support.design.widget.BottomNavigationView android:id=\"@+id/navigation\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_gravity=\"bottom\" android:background=\"?android:attr/windowBackground\" app:menu=\"@menu/navigation\"/&gt;&lt;/LinearLayout&gt; 创建三个Fragment(布局及类)123456789101112&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:id=\"@+id/textView\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"fragment1\"/&gt;&lt;/LinearLayout&gt; 123456789101112131415import android.os.Bundle;import android.support.annotation.Nullable;import android.support.v4.app.Fragment;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;public class Fragment1 extends Fragment &#123; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; return inflater.inflate(R.layout.fragment1, container, false); &#125;&#125; 修改menu/navigation.xml文件在item项里添加上android:orderInCategory用于标记item的位置 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:id=\"@+id/navigation_home\" android:orderInCategory=\"0\" android:icon=\"@drawable/ic_home_black_24dp\" android:title=\"@string/title_home\"/&gt; &lt;item android:id=\"@+id/navigation_dashboard\" android:orderInCategory=\"1\" android:icon=\"@drawable/ic_dashboard_black_24dp\" android:title=\"@string/title_dashboard\"/&gt; &lt;item android:id=\"@+id/navigation_notifications\" android:orderInCategory=\"2\" android:icon=\"@drawable/ic_notifications_black_24dp\" android:title=\"@string/title_notifications\"/&gt;&lt;/menu&gt; 编辑MainActivity类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import android.os.Bundle;import android.support.annotation.NonNull;import android.support.design.widget.BottomNavigationView;import android.support.v4.app.Fragment;import android.support.v4.app.FragmentPagerAdapter;import android.support.v4.view.ViewPager;import android.support.v7.app.AppCompatActivity;import android.view.MenuItem;import android.widget.TextView;public class MainActivity extends AppCompatActivity implements ViewPager.OnPageChangeListener &#123; private BottomNavigationView navigation; private ViewPager viewPager; private Fragment1 fragment1 = new Fragment1(); private Fragment2 fragment2 = new Fragment2(); private Fragment3 fragment3 = new Fragment3(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); viewPager = (ViewPager) findViewById(R.id.viewPager); //添加viewPager事件监听（很容易忘） viewPager.addOnPageChangeListener(this); navigation = (BottomNavigationView) findViewById(R.id.navigation); navigation.setOnNavigationItemSelectedListener(mOnNavigationItemSelectedListener); viewPager.setAdapter(new FragmentPagerAdapter(getSupportFragmentManager()) &#123; @Override public Fragment getItem(int position) &#123; switch (position) &#123; case 0: return fragment1; case 1: return fragment2; case 2: return fragment3; &#125; return null; &#125; @Override public int getCount() &#123; return 3; &#125; &#125;); &#125; private BottomNavigationView.OnNavigationItemSelectedListener mOnNavigationItemSelectedListener = new BottomNavigationView.OnNavigationItemSelectedListener() &#123; @Override public boolean onNavigationItemSelected(@NonNull MenuItem item) &#123; //点击BottomNavigationView的Item项，切换ViewPager页面 //menu/navigation.xml里加的android:orderInCategory属性就是下面item.getOrder()取的值 viewPager.setCurrentItem(item.getOrder()); return true; &#125; &#125;; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; &#125; @Override public void onPageSelected(int position) &#123; //页面滑动的时候，改变BottomNavigationView的Item高亮 navigation.getMenu().getItem(position).setChecked(true); &#125; @Override public void onPageScrollStateChanged(int state) &#123; &#125;&#125; 就是这么简单，快拿去添加自己的逻辑吧！","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"ViewPager","slug":"ViewPager","permalink":"http://xichen.pub/tags/ViewPager/"},{"name":"Fragment","slug":"Fragment","permalink":"http://xichen.pub/tags/Fragment/"},{"name":"BottomNavigationView","slug":"BottomNavigationView","permalink":"http://xichen.pub/tags/BottomNavigationView/"}]},{"title":"github issue 的用法","slug":"2018-01-31-github-issue-usage","date":"2018-01-31T07:26:00.000Z","updated":"2018-03-02T14:52:03.965Z","comments":true,"path":"2018/01/31/2018-01-31-github-issue-usage/","link":"","permalink":"http://xichen.pub/2018/01/31/2018-01-31-github-issue-usage/","excerpt":"","text":"小结一下GitHub上的issues功能，很有意思。 今天玩了一下gitment，尝试在博客中加上评论功能。 测试gitment的功能之后想删除测试的issue，但发现是删不掉的！！！如同版本提交commits，也是删不掉的。另外，对应issues的每一个操作都会记录下来。这样的设计应该是有原因的，现在想不明白，以后再探究吧。今天也大概了解了一下GitHub的API，也挺好玩的。 issues的属性GitHub中每一个仓库都会有对应的一个issues的功能，issues中可以新建多个issue，每一个issue就像一篇文章，有标题和内容，还有评论。另外，每个issue都有唯一的编号“#n”。 issue可以设置：Opened和Closed两种状态。 issue 还可以有额外的属性： Labels，标签。包括bug、invalid等，可以自定义。表示issue的类型，解决的方式。 Milestone，里程碑。通常用来做版本管理，v0.1、v1.0之类的，也可以是任意自定义字符串。一个里程碑对应的所有 issue 都被关闭后，这个里程碑会被自动认为已经达成。 Assignee，责任人。指定这个issue由谁负责来解决。 个人如何利用issues的功能？GitHub 的issue功能，对个人而言，就如同 TODO list。 可以把所有想要在下一步完成的工作，如feature 添加、bug 修复等，都写成一个个的 issue ，放在上面。既可以作为提醒，也可以统一管理。 另外，每一次 commit 都可以选择性的与某个 issue 关联。比如在 message 中添加 #n，就可以与第 n 个 issue 进行关联。 commit message title, #1 这个提交会作为一个 comment ，出现在编号为1的 issue 记录中。 如果添加：123456fix #nfixes #nfixed #nclose #ncloses #nclosed #n 比如1commit message title, fix #n 则可以自动关闭第 n 个 issue，即issue的状态从Opened变成了Closed。 充分利用这些功能，让每一个 commit 的意义更加明确，可以起到了良好的过程管理作用，使得这个Git库的项目进度更加显然。而且，这也是项目后期，写文档的绝佳素材。 团队如何利用issues的功能？对团队而言，这就是一个协作系统。 现在，很多大公司的软件研发团队协作，都是通过JIRA来实现的。 目前也流行很多非代码的团队协作，比如teambition、Tower.im、Worktile、trello等。 其实，GitHub 的issues，就是一个轻量级协作系统。它的comment支持GitHub Flavored Markdown，可以进行内容丰富的交流。 Git本身就是分布式的代码版本控制软件，是为了程序员的协作而设计的。而 issues 的 Assignee 功能，就是这个在线协作系统的核心，足以让一群线上的开发者，一起完成一个软件项目。 作为一个路人如何给别人的项目提bug？用 issues 给别人的项目提 bug。 其他利用？ 可以拿来写blog，虽然很丑…也不方便 可以做评论的后端，比如gitment 可以拿来给小组成员交作业，进行项目管理（我的一个同学就是这么搞，感觉很挫…） 更多。。。","categories":[{"name":"Github","slug":"Github","permalink":"http://xichen.pub/categories/Github/"}],"tags":[{"name":"Github","slug":"Github","permalink":"http://xichen.pub/tags/Github/"},{"name":"Github Issue","slug":"Github-Issue","permalink":"http://xichen.pub/tags/Github-Issue/"}]},{"title":"添加Gitment评论系统踩过的坑","slug":"2018-01-31-gitment","date":"2018-01-31T06:26:00.000Z","updated":"2018-03-02T14:52:03.971Z","comments":true,"path":"2018/01/31/2018-01-31-gitment/","link":"","permalink":"http://xichen.pub/2018/01/31/2018-01-31-gitment/","excerpt":"","text":"备忘-配置流程在setting - OAuth Application 注册页面完成注册1234Application Name: gitment 评论 //随便填Homepage Url: http://XiChen.pub //自己的域名Application description: //随便填，留空也可以Authorization Callback URL: http://XiChen.pub //自己的域名 注册成功后会得到Client ID和Client Secret 在_config.yaml添加1234567gitment: enable: true id: '' #页面 ID, 可选。默认为 location.href owner: linxueyuanstdio repo: linxueyuanstdio.github.io #存储评论的 repo client_id: '2f7f71f1ba398039ff23' #你的 Client ID client_secret: '3ebc908a7042fef2d56a83a2eb8c18777374a087' #你的 Client secret 在comment.ejs添加1234567891011121314151617&lt;% if (theme.gitment.client_id &amp;&amp; theme.gitment.client_secret &amp;&amp; theme.gitment.enable )&#123; %&gt; &lt;div id=\"gitment_container\"&gt;&lt;/div&gt; &lt;link rel=\"stylesheet\" href=\"https://imsun.github.io/gitment/style/default.css\"&gt; &lt;script src=\"https://imsun.github.io/gitment/dist/gitment.browser.js\"&gt;&lt;/script&gt; &lt;script&gt; var gitment = new Gitment(&#123; id: '&lt;%= page.title %&gt;', owner: '&lt;%= theme.gitment.owner %&gt;', repo: '&lt;%= theme.gitment.repo %&gt;', oauth: &#123; client_id: '&lt;%= theme.gitment.client_id %&gt;', client_secret: '&lt;%= theme.gitment.client_secret %&gt;', &#125;, &#125;) gitment.render('gitment_container') &lt;/script&gt;&lt;% &#125; %&gt; 初始化其实到这里差不多已经配置好了 只需要初始化一下 发布你的页面 然后在评论框登录你的github账号，必须跟第二步owner用户名相同的账号 登录之后点击初始化按钮 坑Error：NOT FOUNDowner或者repo配置错误了，照着第二步来就好，网页端生成后如下1234567891011121314...&lt;script&gt; var gitment = new Gitment(&#123; id: 'blog comment', owner: 'linxueyuanstdio', repo: 'linxueyuanstdio.github.io', oauth: &#123; client_id: '2f7f71f1ba398039ff23', client_secret: '3ebc908a7042fef2d56a83a2eb8c18777374a087', &#125;, &#125;) gitment.render('gitment_container')&lt;/script&gt;... Error: Comments Not Initialized 在注册OAuth Application这个步骤中，给Authorization callback URL指定的地址错了 还没有在该页面的Gitment评论区登陆GitHub账号 初始化时在评论框点击登录，但是没有跳到授权页面不要在本地测试，因为在setting - OAuth Application 注册页面填的Authorization Callback URL是自己的域名，不是本地调试的域名，比如http://localhost:4000/。当然，蛋疼的话可以另外申请一个OAuth Application填http://localhost:4000/也是可以的。 Error：validation failed看开发者工具的console，跟踪过去 1Failed to load resource: the server responded with a status of 422 (Unprocessable Entity) 1POST https://api.github.com/repos/linxueyuanstdio/linxueyuanstdio.github.io/issues 422 (Unprocessable Entity) 在Network那里找到原因，是id不合法。原来的gitment有一项id配置成了window.location.pathname，但仍报错。 尝试去掉id，留空行不行？按官网文档应该可以的，但是报错=. =。 思考一下，设定的id给评论对应的issue一个label，这个label的值就是id的值，那么id的作用应该是使issue和文章通过label连接在一起。 那么写死id: &#39;blog comment&#39;行不行呢？不行，每篇文章的评论是要根据id动态加载的，写死的话导致所有的文章共享一个issue。 麻痹，感觉这篇文章坑了我添加Gitment评论系统到Hexo主题NexT，而且官网的默认配置（把id留空）不对。 冷静，继续追踪 传值是对的呀… 既然知道传值对了，id的作用也清楚了，难道是GitHub在搞事情？ 去新建一个label，把值复制进去… 卧槽，真的有长度限制！ 那就简单了，只取title做id，平时写标题不要太浪~~~ 1id: '&lt;%= page.title %&gt;' 2018-02-25更新最近在整理项目开发的系列文章，发现标题不是想不浪就能克制得住的哇。评论中iHTCboy的解决方法很有通用性，就采用他的方法好了。 主要思想是用时间作id 1id: '&lt;%= page.date %&gt;' 这样传给github的标签是定长的，不会超过长度限制。同时date可以自己写，只要精确到分秒，区分文章不是问题。Good job! 哇！！！写标题快浪起来！！！ PS：一个date的例子：date: 2018-02-25 11:48:00.000000000+8:00 更改后面的0可以达到毫秒微秒纳秒级别 PS：xjzsq的方法也很好，思想是用副标题作id，可以看下他的文章 大小写问题配置项中，可能github账号中含大小写，比如我的是LinXueyuanStdio，但是在配置时不用关心大小写问题，因为POST的时候一律转成小写 测试时产生的issue何去何从删不掉的，死心吧。不过可以改title，改内容，改label等等，对应issues的每一个操作都会记录下来。另外，版本提交的commits，也是删不掉的。 顺便总结一下github issue 的用法 参考： 添加Gitment评论系统到Hexo主题NexT Hexo+gitment Gitment：使用 GitHub Issues 搭建评论系统","categories":[{"name":"Web","slug":"Web","permalink":"http://xichen.pub/categories/Web/"}],"tags":[{"name":"gitment","slug":"gitment","permalink":"http://xichen.pub/tags/gitment/"},{"name":"github","slug":"github","permalink":"http://xichen.pub/tags/github/"},{"name":"github issue","slug":"github-issue","permalink":"http://xichen.pub/tags/github-issue/"}]},{"title":"Ethereum Dapp Tutorial — Part 3","slug":"2018-01-27-Ethereum-Dapp-Tutorial-Part-3","date":"2018-01-27T09:01:00.000Z","updated":"2018-03-02T14:52:03.960Z","comments":true,"path":"2018/01/27/2018-01-27-Ethereum-Dapp-Tutorial-Part-3/","link":"","permalink":"http://xichen.pub/2018/01/27/2018-01-27-Ethereum-Dapp-Tutorial-Part-3/","excerpt":"","text":"Part 0 Part 1 Part 2 Part 3 在Part 1中，我们构建了一个简单的投票dapp，并在本地机器上运行。在Part 2中，我们将应用程序移动到使用truffle框架，并将其部署到公共Ropsten testnet，并通过truffle控制台和网页进行交互。在本节中，我们将添加更多的功能到我们的投票dapp 学习内容： 使用像struct这样的新数据类型来组织和存储区块链上的数据。 tokens的概念及其用法。 使用Ethereum区块链平台的货币Ether进行支付。 可以在这个仓库的chapter3目录中找到所有的代码：https://github.com/maheshmurthy/ethereum_voting_dapp 在大选中，每个公民都会为自己喜欢的候选人投一票。然而，有的选举如选举股东的公司董事会，可以根据你在该公司拥有的股份数量进行投票。所以，你拥有的股票越多，得到的选票就越多。 为了支持这种选举，我们来增强我们的投票权。我们将增加购买公司股票的功能。然后他们可以用这些股票投票给候选人。我们还将添加一个功能来查找选民信息。在以太坊区块链世界中，这些股票通常被称为代币，将这些共享作为tokens。 如果你想跳过所有的解释，只想看看合同文件，你可以在这里找到它：https://github.com/maheshmurthy/ethereum_voting_dapp/blob/master/chapter3/contracts/Voting.sol。 第一步是声明我们需要存储所有我们感兴趣的信息的变量。下面是有解释的合同变量。 123456789101112131415161718192021222324252627// We use the struct datatype to store the voter information. struct voter &#123; address voterAddress; // The address of the voter uint tokensBought; // The total no. of tokens this voter owns uint[] tokensUsedPerCandidate; // Array to keep track of votes per candidate. /* We have an array called candidateList initialized below. Every time this voter votes with her tokens, the value at that index is incremented. Example, if candidateList array declared below has [\"Rama\", \"Nick\", \"Jose\"] and this voter votes 10 tokens to Nick, the tokensUsedPerCandidate[1] will be incremented by 10. */ &#125;/* mapping is equivalent to an associate array or hash. The key of the mapping is candidate name stored as type bytes32 and value is an unsigned integer which used to store the vote count */mapping (bytes32 =&gt; uint) public votesReceived;mapping (address =&gt; voter) public voterInfo;/* Solidity doesn't let you return an array of strings yet. We will use an array of bytes32 instead to store the list of candidates */bytes32[] public candidateList;uint public totalTokens; // Total no. of tokens available for this electionuint public balanceTokens; // Total no. of tokens still available for purchaseuint public tokenPrice; // Price per token 在Part 1和Part 2中，我们初始化了在构造函数中竞争的候选者列表。但是，在合约部署在区块链上时，构造函数只会被调用一次。在这里，我们还必须初始化可用于销售的token总数和每个token的成本。所以，我们更新我们的合约构造函数，如下所示： 12345678910/* When the contract is deployed on the blockchain, we will initialize the total number of tokens for sale, cost per token and all the candidates */ function Voting(uint tokens, uint pricePerToken, bytes32[] candidateNames) public &#123; candidateList = candidateNames; totalTokens = tokens; balanceTokens = tokens; tokenPrice = pricePerToken; &#125; 在truffle中，使用migration将代码部署到区块链。可以在这里查看迁移文件。truffle的migration文件中的示例部署调用如下所示： 1deployer.deploy(Voting, 1000, web3.toWei('0.1', 'ether'), ['Rama', 'Nick', 'Jose']); 现在我们已经初始化了token并设置了价格，让我们看看有人可以通过支付以太币来购买这些token。这是购买token的函数。 12345678910111213/* This function is used to purchase the tokens. Note the keyword 'payable' below. By just adding that one keyword to a function, your contract can now accept Ether from anyone who calls this function. Accepting money can not get any easier than this! */function buy() payable public returns (uint) &#123; uint tokensToBuy = msg.value / tokenPrice; if (tokensToBuy &gt; balanceTokens) throw; voterInfo[msg.sender].voterAddress = msg.sender; voterInfo[msg.sender].tokensBought += tokensToBuy; balanceTokens -= tokensToBuy; return tokensToBuy;&#125; 一个示例购买电话如下所示 1truffle(development)&gt; Voting.deployed().then(function(contract) &#123;contract.buy(&#123;value: web3.toWei('1', 'ether'), from: web3.eth.accounts[1]&#125;)&#125;) value: web3.toWei(‘1’, ‘ether’)参数使用msg.value在buy()函数访问和msg.sender给我们web3.eth.accounts[1]的帐户地址。假设每个标记的值为0.1 Ether，则web3.eth.accounts[1]将接收1个Ether/0.1Ether=10tokens。 让我们休息一会儿，看看代码，并可视化账户（选民）和合同之间的交互。 index.html文件更新： 为了投票给候选人，你现在必须指定否。您想要投票的标记。 有一个新的部分，你可以购买令牌。 现在可以查询选民信息 - 他们拥有多少令牌，不可以。他们投给了每个候选人。 候选人不再被硬编码。我们从区块链中获取候选人并填充它。 在app.js文件必须支持上述所有的UI功能的更新。 更新部署文件2_deploy_contracts.js以传递总共令牌和令牌价格以及候选名称。 1234var Voting = artifacts.require(\"./Voting.sol\");module.exports = function(deployer) &#123; deployer.deploy(Voting, 1000, web3.toWei('0.1', 'ether'), ['Rama', 'Nick', 'Jose']);&#125;; 总而言之，在本教程中更新的四个文件是Voting.sol，index.html，app.js和2_deploy_contracts.js。一旦你用这些文件更新了truffle储存库，我们可以将合同部署到区块链。部署过程与之前的教程完全相同。 只需要使用truffle命令进行编译和migrate。 123456789101112131415$ truffle migrateUsing network 'development'.Compiling Migrations.sol...Compiling Voting.sol...Writing artifacts to ./build/contractsRunning migration: 1_initial_migration.jsDeploying Migrations...Migrations: 0xc9249947010675b8a3b1defb12334148f7f59010Saving successful migration to network...Saving artifacts...Running migration: 2_deploy_contracts.jsDeploying Voting...Voting: 0x795d6d1f7cf467f27e48181da5f1ebd5bbd0a8dfSaving successful migration to network...Saving artifacts... 如果您能够成功部署合同并启动您的Web服务器，则您的页面如下所示： 将能够购买tokens，使用tokens投票给候选人并根据他们的地址查找选举人信息。如果你能够得到所有这些功能，Congratulation！","categories":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/tags/区块链/"},{"name":"Ethereum","slug":"Ethereum","permalink":"http://xichen.pub/tags/Ethereum/"},{"name":"Dapp","slug":"Dapp","permalink":"http://xichen.pub/tags/Dapp/"}]},{"title":"Ethereum Dapp Tutorial — Part 2","slug":"2018-01-26-Ethereum-Dapp-Tutorial-Part-2","date":"2018-01-25T18:01:00.000Z","updated":"2018-03-02T14:52:03.962Z","comments":true,"path":"2018/01/26/2018-01-26-Ethereum-Dapp-Tutorial-Part-2/","link":"","permalink":"http://xichen.pub/2018/01/26/2018-01-26-Ethereum-Dapp-Tutorial-Part-2/","excerpt":"","text":"Part 0 Part 1 Part 2 Part 3 在Part 1中，我们用ganache在开发环境中构建了一个简单的投票应用程序。现在在真正的区块链上获得这个应用程序。 以太坊有2个公共区块链。 Testnet（也叫Ropsten）：这是一个测试区块链。可以把它看作一个QA或一个临时服务器，它仅用于测试目的。 Mainnet（也叫Homestead）：这是全世界真实交易的区块链。在这个网络上使用以太网是有实际价值的。 学习目标: 安装geth用于下载区块链的客户端软件，并在本地计算机上运行以太坊节点 安装名为Truffle的Ethereum dapp框架，将用于编译和部署智能合约 对投票应用程序进行小小的更新，使其用Truffle 将合约编译并部署到Ropsten testnet 通过Truffle控制台，然后通过网页与合约进行交互 安装geth并同步区块链安装非常简单： 在Mac上12$ brew tap ethereum / ethereum mahesh $ brew install ethereum 在Ubuntu上1234$ sudo apt-get install software-properties-common $ sudo add-apt-repository -y ppa：ethereum / ethereum $ sudo apt-get update $ sudo apt-get install ethereum 在这有各种平台的安装说明：https://github.com/ethereum/go-ethereum/wiki/Building-Ethereum 安装geth后，在命令行控制台中运行下面的命令： 1$ geth --testnet --syncmode \"fast\" --rpc --rpcapi db,eth,net,web3,personal --cache=1024 --rpcport 8545 --rpcaddr 127.0.0.1 --rpccorsdomain \"*\" --bootnodes \"enode://20c9ad97c081d63397d7b685a412227a40e23c8bdc6688c6f37e97cfbc22d2b4d1db1510d8f61e6a8866ad7f0e17c02b14182d37ea7c3c8b9c2683aeb6b733a1@52.169.14.227:30303,enode://6ce05930c72abc632c58e2e4324f7c7ea478cec0ed4fa2528982cf34483094e9cbc9216e7aa349691242576d552a2a56aaeae426c5303ded677ce455ba1acd9d@13.84.180.240:30303\" 这将启动以太坊节点，连接到其他对等节点并开始下载区块链。下载区块链所需的时间取决于各种因素，例如您的网络连接速度，计算机上的RAM，硬盘驱动器的类型等等。在一台拥有8GB RAM和50Mbps连接的计算机上花了我10-15分钟时间。 在您正在运行的控制台中，您将看到如下所示的输出。寻找粗体的块号。当区块链完全同步时，区块编号和此页面上的区块编号接近：https://ropsten.etherscan.io/ 12345I0130 22:18:15.116332 core/blockchain.go:1064] imported 32 blocks, 49 txs ( 6.256 Mg) in 185.716ms (33.688 Mg/s). #445097 [e1199364… / bce20913…]I0130 22:18:20.267142 core/blockchain.go:1064] imported 1 blocks, 1 txs ( 0.239 Mg) in 11.379ms (20.963 Mg/s). #445097 [b4d77c46…]I0130 22:18:21.059414 core/blockchain.go:1064] imported 1 blocks, 0 txs ( 0.000 Mg) in 7.807ms ( 0.000 Mg/s). #445098 [f990e694…]I0130 22:18:34.367485 core/blockchain.go:1064] imported 1 blocks, 0 txs ( 0.000 Mg) in 4.599ms ( 0.000 Mg/s). #445099 [86b4f29a…]I0130 22:18:42.953523 core/blockchain.go:1064] imported 1 blocks, 2 txs ( 0.294 Mg) in 9.149ms (32.136 Mg/s). #445100 [3572f223…] 安装Truffle框架1npm install -g truffle 建立voting合约首先建立一个truffle project 12345678910111213$ mkdir voting$ cd voting$ npm install -g webpack$ truffle unbox webpack$ lsREADME.md contracts node_modules test webpack.config.js truffle.jsapp migrations package.json $ ls app/index.html javascripts stylesheets$ ls contracts/ConvertLib.sol MetaCoin.sol Migrations.sol$ ls migrations/1_initial_migration.js 2_deploy_contracts.js truffle创建了运行dapp所需的必要文件和目录。truffle还创建了一个示例应用程序，让你快速上手（我们不会在本教程中使用它）。可以删除contracts目录中的ConvertLib.sol和MetaCoin.sol文件。 migrations目录很重要。这些migrations里文件用于将合约部署到区块链。（在上一篇文章中，我们使用了VotingContract.new将合约部署到区块链，现在不需要这样做）。 1_initial_migration.js将一个名为Migrations的合约部署到区块链中，并用于存储已部署的最新合约。每次运行migration时，truffle都会查询区块链以获取已部署的最后一个合约，然后部署尚未部署的任何合约。然后更新Migrations合约中的last_completed_migration字段，以指示部署的最新合约。可以简单地将其视为一个名为Migration的数据库表，其中名为last_completed_migration的列始终保持最新状态。更多 现在用上面的教程中所写的所有代码更新项目，下面将对其进行一些更改。 首先，将Voting.sol从前一个教程复制到contracts目录（这个文件没有改变）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647pragma solidity ^0.4.18;// We have to specify what version of compiler this code will compile withcontract Voting &#123; /* mapping field below is equivalent to an associative array or hash. The key of the mapping is candidate name stored as type bytes32 and value is an unsigned integer to store the vote count */ mapping (bytes32 =&gt; uint8) public votesReceived; /* Solidity doesn't let you pass in an array of strings in the constructor (yet). We will use an array of bytes32 instead to store the list of candidates */ bytes32[] public candidateList; /* This is the constructor which will be called once when you deploy the contract to the blockchain. When we deploy the contract, we will pass an array of candidates who will be contesting in the election */ function Voting(bytes32[] candidateNames) public &#123; candidateList = candidateNames; &#125; // This function returns the total votes a candidate has received so far function totalVotesFor(bytes32 candidate) view public returns (uint8) &#123; require(validCandidate(candidate)); return votesReceived[candidate]; &#125; // This function increments the vote count for the specified candidate. This // is equivalent to casting a vote function voteForCandidate(bytes32 candidate) public &#123; require(validCandidate(candidate)); votesReceived[candidate] += 1; &#125; function validCandidate(bytes32 candidate) view public returns (bool) &#123; for(uint i = 0; i &lt; candidateList.length; i++) &#123; if (candidateList[i] == candidate) &#123; return true; &#125; &#125; return false; &#125;&#125; 12$ ls contracts/Migrations.sol Voting.sol 接下来，将migrations目录中的2_deploy_contracts.js的内容替换为以下内容： 1234var Voting = artifacts.require(\"./Voting.sol\");module.exports = function(deployer) &#123; deployer.deploy(Voting, ['Rama', 'Nick', 'Jose'], &#123;gas: 6700000&#125;);&#125;; 也可以在truffle.js中将气体值设置为全局设置。继续添加如下所示的gas选项，如果忘记将gas设置为特定的迁移文件，则默认使用全局值。 1234567891011require('babel-register')module.exports = &#123; networks: &#123; development: &#123; host: 'localhost', port: 8545, network_id: '*', gas: 470000 &#125; &#125;&#125; 用下面的内容替换app/javascripts/app.js的内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// Import the page's CSS. Webpack will know what to do with it.import \"../stylesheets/app.css\";// Import libraries we need.import &#123; default as Web3&#125; from 'web3';import &#123; default as contract &#125; from 'truffle-contract'/* * When you compile and deploy your Voting contract, * truffle stores the abi and deployed address in a json * file in the build directory. We will use this information * to setup a Voting abstraction. We will use this abstraction * later to create an instance of the Voting contract. * Compare this against the index.js from our previous tutorial to see the difference * https://gist.github.com/maheshmurthy/f6e96d6b3fff4cd4fa7f892de8a1a1b4#file-index-js */import voting_artifacts from '../../build/contracts/Voting.json'var Voting = contract(voting_artifacts);let candidates = &#123;\"Rama\": \"candidate-1\", \"Nick\": \"candidate-2\", \"Jose\": \"candidate-3\"&#125;window.voteForCandidate = function(candidate) &#123; let candidateName = $(\"#candidate\").val(); try &#123; $(\"#msg\").html(\"Vote has been submitted. The vote count will increment as soon as the vote is recorded on the blockchain. Please wait.\") $(\"#candidate\").val(\"\"); /* Voting.deployed() returns an instance of the contract. Every call * in Truffle returns a promise which is why we have used then() * everywhere we have a transaction call */ Voting.deployed().then(function(contractInstance) &#123; contractInstance.voteForCandidate(candidateName, &#123;gas: 140000, from: web3.eth.accounts[0]&#125;).then(function() &#123; let div_id = candidates[candidateName]; return contractInstance.totalVotesFor.call(candidateName).then(function(v) &#123; $(\"#\" + div_id).html(v.toString()); $(\"#msg\").html(\"\"); &#125;); &#125;); &#125;); &#125; catch (err) &#123; console.log(err); &#125;&#125;$( document ).ready(function() &#123; if (typeof web3 !== 'undefined') &#123; console.warn(\"Using web3 detected from external source like Metamask\") // Use Mist/MetaMask's provider window.web3 = new Web3(web3.currentProvider); &#125; else &#123; console.warn(\"No web3 detected. Falling back to http://localhost:8545. You should remove this fallback when you deploy live, as it's inherently insecure. Consider switching to Metamask for development. More info here: http://truffleframework.com/tutorials/truffle-and-metamask\"); // fallback - use your fallback strategy (local node / hosted node + in-dapp id mgmt / fail) window.web3 = new Web3(new Web3.providers.HttpProvider(\"http://localhost:8545\")); &#125; Voting.setProvider(web3.currentProvider); let candidateNames = Object.keys(candidates); for (var i = 0; i &lt; candidateNames.length; i++) &#123; let name = candidateNames[i]; Voting.deployed().then(function(contractInstance) &#123; contractInstance.totalVotesFor.call(name).then(function(v) &#123; $(\"#\" + candidates[name]).html(v.toString()); &#125;); &#125;) &#125;&#125;); 将app/index.html的内容替换为以下内容。即使这个文件与上一章几乎相同，除了包含的js文件是41行的app.js。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Hello World DApp&lt;/title&gt; &lt;link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'&gt; &lt;link href='https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css' rel='stylesheet' type='text/css'&gt;&lt;/head&gt;&lt;body class=\"container\"&gt; &lt;h1&gt;A Simple Hello World Voting Application&lt;/h1&gt; &lt;div id=\"address\"&gt;&lt;/div&gt; &lt;div class=\"table-responsive\"&gt; &lt;table class=\"table table-bordered\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Candidate&lt;/th&gt; &lt;th&gt;Votes&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Rama&lt;/td&gt; &lt;td id=\"candidate-1\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Nick&lt;/td&gt; &lt;td id=\"candidate-2\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Jose&lt;/td&gt; &lt;td id=\"candidate-3\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div id=\"msg\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;input type=\"text\" id=\"candidate\" /&gt; &lt;a href=\"#\" onclick=\"voteForCandidate()\" class=\"btn btn-primary\"&gt;Vote&lt;/a&gt;&lt;/body&gt;&lt;script src=\"https://cdn.rawgit.com/ethereum/web3.js/develop/dist/web3.js\"&gt;&lt;/script&gt;&lt;script src=\"https://code.jquery.com/jquery-3.1.1.slim.min.js\"&gt;&lt;/script&gt;&lt;script src=\"app.js\"&gt;&lt;/script&gt;&lt;/html&gt; 将合同部署到Ropsten testnet在部署合同之前需要一个账号和一些ether。当我们使用ganache时，它创建了10个测试帐户，并预装了100个测试用例。但是对于testnet和mainnet，我们必须创建帐户并自己添加一些ether。 在您的命令行终端中，执行以下操作： 123456$ truffle consoletruffle(default)&gt; web3.personal.newAccount('verystrongpassword')'0x95a94979d86d9c32d1d2ab5ace2dcc8d1b446fa1'truffle(default)&gt; web3.eth.getBalance('0x95a94979d86d9c32d1d2ab5ace2dcc8d1b446fa1')&#123; [String: '0'] s: 1, e: 0, c: [ 0 ] &#125;truffle(default)&gt; web3.personal.unlockAccount('0x95a94979d86d9c32d1d2ab5ace2dcc8d1b446fa1', 'verystrongpassword', 15000) 在之前的文章中，我们启动了一个节点控制台并初始化了web3对象。当我们执行truffle控制台，所有这一切都为我们完成，我们得到一个web3对象准备使用。我们现在有一个地址为“0x95a94979d86d9c32d1d2ab5ace2dcc8d1b446fa1”的帐户（您将在您的情况下有不同的地址），余额将为0。 可以通过传递一个额外的option--mine来运行geth节点来挖掘一些ether。建议更简单是从reddit thread获得ether 或ping我，我给你一些。再次尝试web3.eth.getBalance，以确保有ether。也可以在ropsten.etherscan.io上输入地址以查看帐户余额 现在你已经有了一些了，继续编译并将合约部署到区块链。下面是运行命令和输出 在部署合同之前，记得解锁账户 123456789101112131415$ truffle migrateCompiling Migrations.sol...Compiling Voting.sol...Writing artifacts to ./build/contractsRunning migration: 1_initial_migration.jsDeploying Migrations...Migrations: 0x3cee101c94f8a06d549334372181bc5a7b3a8beeSaving successful migration to network...Saving artifacts...Running migration: 2_deploy_contracts.jsDeploying Voting...Voting: 0xd24a32f0ee12f5e9d233a2ebab5a53d4d4986203Saving successful migration to network...Saving artifacts...$ 与voting合约交互成功部署合同后，现在应该能够获取投票计数并通过truffle控制台进行投票。 1234567891011$ truffle consoletruffle(default)&gt; Voting.deployed().then(function(contractInstance) &#123;contractInstance.voteForCandidate('Rama').then(function(v) &#123;console.log(v)&#125;)&#125;)// After a few seconds, you should see a transaction receipt like this:receipt:&#123; blockHash: '0x7229f668db0ac335cdd0c4c86e0394a35dd471a1095b8fafb52ebd7671433156',blockNumber: 469628,contractAddress: null,........truffle(default)&gt; Voting.deployed().then(function(contractInstance) &#123;contractInstance.totalVotesFor.call('Rama').then(function(v) &#123;console.log(v)&#125;)&#125;)&#123; [String: '1'] s: 1, e: 0, c: [ 1] &#125; 现在启动服务器 1$ npm run dev 应该在localhost：8080看到投票页面，并且能够投票并看到所有候选人的投票数量。由于我们正在处理一个真正的区块链，所以每次写入区块链（voteForCandidate）将需要几秒钟的时间（矿工必须将您的交易包括在区块中，区块中包含区块链）。 如果你看到这个页面并且能够投票，你就可以在公共测试网络上建立一个完整的以太坊应用程序，Congratulation！ 由于所有的交易都是公开的，可以在这里查看：https://testnet.etherscan.io/。只需输入帐户地址，就会显示所有的交易与时间戳。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/tags/区块链/"},{"name":"Ethereum","slug":"Ethereum","permalink":"http://xichen.pub/tags/Ethereum/"},{"name":"Dapp","slug":"Dapp","permalink":"http://xichen.pub/tags/Dapp/"}]},{"title":"Ethereum Dapp Tutorial — Part 1","slug":"2018-01-25-Ethereum-Dapp-Tutorial-Part-1","date":"2018-01-24T18:01:00.000Z","updated":"2018-03-02T14:52:03.969Z","comments":true,"path":"2018/01/25/2018-01-25-Ethereum-Dapp-Tutorial-Part-1/","link":"","permalink":"http://xichen.pub/2018/01/25/2018-01-25-Ethereum-Dapp-Tutorial-Part-1/","excerpt":"","text":"Part 0 Part 1 Part 2 Part 3 在上一篇文章中，通过和传统的 web程序相比较解释了以太坊平台的结构。作为一个开发者，学习新技术的最好的方式就是构建一个玩具程序。 在这篇文章中构建一个简单的“hello word”程序，这个程序是一个投票程序。 这个程序非常简单，包括：初始化一个参加者集合，让任何人为候选人投票，显示每一个候选人获得的投票数。我们的目的不仅仅是编写一个应用，目的是学习应用编译，部署，交互的过程。 总的来说这章是对上一篇文章的延续，如果你是刚接触Ethereum，我建议你最好读一读上一篇文章。 练习目的： 搭建开发环境 学习在开发环境下编写，编译，部署合约。 在区块链上通过node.js控制台利用合约进行交互。 通过一个简单的web页面利用合约来交互，通过这个页面显示投票数，以及每个候选人的获得的投票数。 整个应用部署在ubuntu 16.04上，在macos上也行。 构建应用程序 搭建开发环境这里不是基于活跃的区块链的开发app，而是使用一个叫做testrpc的内存区块链。在Part 2中，我们将会在真正的区块链上进行交互，下面来安装testrpc,web3js以及在linux环境中启动一个测试区块链。对于windows来说可以使用下面的方式：https://medium.com/@PrateeshNanada/steps-to-install-testrpc-in-windows-10-96989a6cd594 注意：这个教程当前工作的web3js的版本是0.20.1，运行npm install ethereumjs-testrpc web3@0.20.1 而不是运行npm install ethereumjs-testrpc web3 ，在web3js的1.0文档版发布之后我会更新这个教程。 注意testrpc在自动运行的时候会自动创建10个测试帐号。这些帐号都预装了100个假的以太网节点。 简单的投票合约用solidity语言来编写合约。 编写的智能合约叫做Voting（在你熟悉的面相对象语言中想象合约就是一个类），Voting有一个初始化候选人的数组结构。有两个方法，一个是返回候选人获得的总选票，另一个是给候选人加票的方法。 注意：把合约部署到区块链上的时候，构造函数只能被调用一次，和web世界不同，web世界中你的代码部署的时候你可以使用新代码来覆盖以前的老代码，但是在区块链上部署的代码是不可更改的。如果你更新合约重新部署代码，旧的合约以及数据依然在区块链上。新部署的将会创建一个新的合约实例。 下面是一个投票合约的代码，每一行都有注释： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647pragma solidity ^0.4.11;// We have to specify what version of compiler this code will compile withcontract Voting &#123; /* mapping field below is equivalent to an associative array or hash. The key of the mapping is candidate name stored as type bytes32 and value is an unsigned integer to store the vote count */ mapping (bytes32 =&gt; uint8) public votesReceived; /* Solidity doesn&apos;t let you pass in an array of strings in the constructor (yet). We will use an array of bytes32 instead to store the list of candidates */ bytes32[] public candidateList; /* This is the constructor which will be called once when you deploy the contract to the blockchain. When we deploy the contract, we will pass an array of candidates who will be contesting in the election */ function Voting(bytes32[] candidateNames) &#123; candidateList = candidateNames; &#125; // This function returns the total votes a candidate has received so far function totalVotesFor(bytes32 candidate) returns (uint8) &#123; if (validCandidate(candidate) == false) throw; return votesReceived[candidate]; &#125; // This function increments the vote count for the specified candidate. This // is equivalent to casting a vote function voteForCandidate(bytes32 candidate) &#123; if (validCandidate(candidate) == false) throw; votesReceived[candidate] += 1; &#125; function validCandidate(bytes32 candidate) returns (bool) &#123; for(uint i = 0; i &lt; candidateList.length; i++) &#123; if (candidateList[i] == candidate) &#123; return true; &#125; &#125; return false; &#125;&#125; 拷贝下面代码到hello_world_voting目录的文件Voting.sol文件中，现在编译代码，并把它部署到testrps上面。 编译solidity代码，首先要通过npm安装npm module：solc 1npm install solc 用带有node.js控制台的包，来编译智能合约，从上一章知道，web3js是一个让你通过RPC来和区块链交互的包。用web3js这个包来进行部署与交互。 首先，在控制台运行node命令来调用node控制台，并初始化solc和web3js对象。下面所有的代码片段，都需要在node的交互式环境下。 1234$ node&gt; Web3 = require('web3')&gt; web3 = new Web3(new Web3.providers.HttpProvider(\"http://localhost:8545\")); 为了确保web3js对象被初始化了，并且可以和区块链通信，查询所有在区块链上的账户。你会看到类似下面的输出结果： 1234567891011&gt; web3.eth.accounts['0x9c02f5c68e02390a3ab81f63341edc1ba5dbb39e','0x7d920be073e92a590dc47e4ccea2f28db3f218cc','0xf8a9c7c65c4d1c0c21b06c06ee5da80bd8f074a9','0x9d8ee8c3d4f8b1e08803da274bdaff80c2204fc6','0x26bb5d139aa7bdb1380af0e1e8f98147ef4c406a','0x622e557aad13c36459fac83240f25ae91882127c','0xbf8b1630d5640e272f33653e83092ce33d302fd2','0xe37a3157cb3081ea7a96ba9f9e942c72cf7ad87b','0x175dae81345f36775db285d368f0b1d49f61b2f8','0xc26bda5f3370bdd46e7c84bdb909aead4d8f35f3'] 编译智能合约：通过从Voting.sol文件中加载智能合约到一个字符串变量中，然后编译。 123&gt; code = fs.readFileSync('Voting.sol').toString()&gt; solc = require('solc')&gt; compiledCode = solc.compile(code) 当你成功编译了代码，打印了合约对象（仅仅是在控制台中查看到的上面compiledCode类型的内容），你会发现这里有两个重要的字段，理解他们十分重要： compiledCode.contracts[‘:Voting’].bytecode：Voting.sol编译得到的是二进制代码。这个就是将要部署到区块链上的代码。 compiledCode.contracts[‘:Voting’].interface：这是一个智能合约接口或者是智能合约模版（叫做abi），他告诉合约使用者，合约中可以使用的方法。在将来无论你在什么时候要与智能合约交互，你都会用到这个abi的定义。你可以在这里查看更多关于abi的详细描述 现在来部署智能合约。首先你要创建一个合约对象（下面的VotingContract），这个合约对象用来在区块链上部署和初始化合约。 123456&gt; abiDefinition = JSON.parse(compiledCode.contracts[':Voting'].interface)&gt; VotingContract = web3.eth.contract(abiDefinition)&gt; byteCode = compiledCode.contracts[':Voting'].bytecode&gt; deployedContract = VotingContract.new(['Rama','Nick','Jose'],&#123;data: byteCode, from: web3.eth.accounts[0], gas: 4700000&#125;)&gt; deployedContract.address&gt; contractInstance = VotingContract.at(deployedContract.address) 上面的VotingContract.new用来在区块链上部署智能合约。第一个参数是候选人数组，这些候选人在选举竞争中都是相对简单的。第二个参数的hash： data：这是在区块链上部署的编译后的二进制代码。 from：区块链必须记录谁部署了这个智能合约。在这个例子中选择第一个账户来作为这个智能合约的拥有者（将会部署这个合约到区块链上）。这第一个账户通过调用web3.eth.accounts来获取。上面代码web3.eth.accounts返回一个数组，数组里面包含10个由testrpc创建的测试账户，这10个账户是在启动测试区块链的时候创建。在真实活跃的区块链中，在没创建之前，不能使用任何账户。必须在交易（通信／交流）前拥有这个账户，并解锁。创建账户时要求填写密码，这个密码用来证明你和账户的关系。为了方便testrpc默认解锁了10个账户。 gas：和区块链交互花费的钱，这些钱是给矿工的，矿工的所有工作是在区块链上引入你的代码。必须指定你会支付多少钱给把你的代码包含到区块链上的人。这些钱就是通过设置gas的值来指定的。你的上面代码from中的账户的以太坊余额可以用来购买gas。gas的价格由网络来设定。 现在已经部署了智能合约并有了一个合约实例（上面的contractInstance变量）。可以使用这个合约来进行交互。区块链上有成千上万的合约部署在上面。但是，在区块链上怎么辨别自己的合约呢？答案就是deployedContract.address。当你利用你的合约进行交互的时候，你需要这个部署地址，以及上面提到的abi的描述。 在nodes控制台和合约进行交互12345678910&gt; contractInstance.totalVotesFor.call('Rama')&#123; [String: '0'] s: 1, e: 0, c: [ 0 ] &#125;&gt; contractInstance.voteForCandidate('Rama', &#123;from: web3.eth.accounts[0]&#125;)'0xdedc7ae544c3dde74ab5a0b07422c5a51b5240603d31074f5b75c0ebc786bf53'&gt; contractInstance.voteForCandidate('Rama', &#123;from: web3.eth.accounts[0]&#125;)'0x02c054d238038d68b65d55770fabfca592a5cf6590229ab91bbe7cd72da46de9'&gt; contractInstance.voteForCandidate('Rama', &#123;from: web3.eth.accounts[0]&#125;)'0x3da069a09577514f2baaa11bc3015a16edf26aad28dffbcd126bde2e71f2b76f'&gt; contractInstance.totalVotesFor.call('Rama').toLocaleString()'3' 在你的node交互控制台上试试上面的命令，你将会看到投票的数量增加。每次当你为一个候选人投票，你就会获得一个交易的ID：例如:上面的: &#39;0xdedc7ae544c3dde74ab5a0b07422c5a51b5240603d31074f5b75c0ebc786bf53&#39; 这个交易ID是交易发生的证据。将来你可以在任何时间来返回去查看他（数据可追踪）。这个交易是不可更改的。这种不可更改的特性是以太坊这种区块链的很大优势之一。在接下来的教程中，会用其不可更改性来构建应用。 web页面链接区块链和投票现在所有的工作都完成了，现在要做的就是构建一个包含候选人的简单的html文件。并在一个js文件中调用投票命令（这个投票命令已经在前面的node控制台中测试过了）。下面你会看到html代码和js文件。 在hello_world_voting文件夹下复制，并在你的浏览器中打开index.html 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Hello World DApp&lt;/title&gt; &lt;link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'&gt; &lt;link href='https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css' rel='stylesheet' type='text/css'&gt;&lt;/head&gt;&lt;body class=\"container\"&gt; &lt;h1&gt;A Simple Hello World Voting Application&lt;/h1&gt; &lt;div class=\"table-responsive\"&gt; &lt;table class=\"table table-bordered\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Candidate&lt;/th&gt; &lt;th&gt;Votes&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Rama&lt;/td&gt; &lt;td id=\"candidate-1\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Nick&lt;/td&gt; &lt;td id=\"candidate-2\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Jose&lt;/td&gt; &lt;td id=\"candidate-3\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;input type=\"text\" id=\"candidate\" /&gt; &lt;a href=\"#\" onclick=\"voteForCandidate()\" class=\"btn btn-primary\"&gt;Vote&lt;/a&gt;&lt;/body&gt;&lt;script src=\"https://cdn.rawgit.com/ethereum/web3.js/develop/dist/web3.js\"&gt;&lt;/script&gt;&lt;script src=\"https://code.jquery.com/jquery-3.1.1.slim.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./index.js\"&gt;&lt;/script&gt;&lt;/html&gt; index.js文件： 1234567891011121314151617181920212223web3 = new Web3(new Web3.providers.HttpProvider(\"http://localhost:8545\"));abi = JSON.parse('[&#123;\"constant\":false,\"inputs\":[&#123;\"name\":\"candidate\",\"type\":\"bytes32\"&#125;],\"name\":\"totalVotesFor\",\"outputs\":[&#123;\"name\":\"\",\"type\":\"uint8\"&#125;],\"payable\":false,\"type\":\"function\"&#125;,&#123;\"constant\":false,\"inputs\":[&#123;\"name\":\"candidate\",\"type\":\"bytes32\"&#125;],\"name\":\"validCandidate\",\"outputs\":[&#123;\"name\":\"\",\"type\":\"bool\"&#125;],\"payable\":false,\"type\":\"function\"&#125;,&#123;\"constant\":true,\"inputs\":[&#123;\"name\":\"\",\"type\":\"bytes32\"&#125;],\"name\":\"votesReceived\",\"outputs\":[&#123;\"name\":\"\",\"type\":\"uint8\"&#125;],\"payable\":false,\"type\":\"function\"&#125;,&#123;\"constant\":true,\"inputs\":[&#123;\"name\":\"x\",\"type\":\"bytes32\"&#125;],\"name\":\"bytes32ToString\",\"outputs\":[&#123;\"name\":\"\",\"type\":\"string\"&#125;],\"payable\":false,\"type\":\"function\"&#125;,&#123;\"constant\":true,\"inputs\":[&#123;\"name\":\"\",\"type\":\"uint256\"&#125;],\"name\":\"candidateList\",\"outputs\":[&#123;\"name\":\"\",\"type\":\"bytes32\"&#125;],\"payable\":false,\"type\":\"function\"&#125;,&#123;\"constant\":false,\"inputs\":[&#123;\"name\":\"candidate\",\"type\":\"bytes32\"&#125;],\"name\":\"voteForCandidate\",\"outputs\":[],\"payable\":false,\"type\":\"function\"&#125;,&#123;\"constant\":true,\"inputs\":[],\"name\":\"contractOwner\",\"outputs\":[&#123;\"name\":\"\",\"type\":\"address\"&#125;],\"payable\":false,\"type\":\"function\"&#125;,&#123;\"inputs\":[&#123;\"name\":\"candidateNames\",\"type\":\"bytes32[]\"&#125;],\"payable\":false,\"type\":\"constructor\"&#125;]')VotingContract = web3.eth.contract(abi);// In your nodejs console, execute contractInstance.address to get the address at which the contract is deployed and change the line below to use your deployed addresscontractInstance = VotingContract.at('0x2a9c1d265d06d47e8f7b00ffa987c9185aecf672');candidates = &#123;\"Rama\": \"candidate-1\", \"Nick\": \"candidate-2\", \"Jose\": \"candidate-3\"&#125;function voteForCandidate() &#123; candidateName = $(\"#candidate\").val(); contractInstance.voteForCandidate(candidateName, &#123;from: web3.eth.accounts[0]&#125;, function() &#123; let div_id = candidates[candidateName]; $(\"#\" + div_id).html(contractInstance.totalVotesFor.call(candidateName).toString()); &#125;);&#125;$(document).ready(function() &#123; candidateNames = Object.keys(candidates); for (var i = 0; i &lt; candidateNames.length; i++) &#123; let name = candidateNames[i]; let val = contractInstance.totalVotesFor.call(name).toString() $(\"#\" + candidates[name]).html(val); &#125;&#125;); 不知道还记得前面说过和任何合约进行交互必须需要abi和地址。在上面的index.js文件中可以看到是怎么使用合约来进行交互的 下面是你在浏览器中打开index.html文件。 如果你可以进入上面文本框的候选人名字，并投票并且会看到投票增加。你已经成功构建了你的第一个应用。Congratulation！ 总结 搭建环境 编写简单合约 编译及部署合约到区块链上 能够通过nodejs控制台进行交互，同时也能通过web页面进行同样交互。 在Part 2会部署这个合约到一个公共的测试网络，这样整个世界都会看到并给候选人进行投票。 Part 2使用truffle框架来开发（不要使用node的控制台来管理整个过程）。 参考：https://medium.com/@mvmurthy/full-stack-hello-world-voting-ethereum-dapp-tutorial-part-1-40d2d0d807c2","categories":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/tags/区块链/"},{"name":"Ethereum","slug":"Ethereum","permalink":"http://xichen.pub/tags/Ethereum/"},{"name":"Dapp","slug":"Dapp","permalink":"http://xichen.pub/tags/Dapp/"}]},{"title":"Ethereum Dapp Tutorial — Part 0","slug":"2018-01-24-Ethereum-Dapp-Tutorial-Part-0","date":"2018-01-24T12:01:00.000Z","updated":"2018-01-27T09:30:24.189Z","comments":true,"path":"2018/01/24/2018-01-24-Ethereum-Dapp-Tutorial-Part-0/","link":"","permalink":"http://xichen.pub/2018/01/24/2018-01-24-Ethereum-Dapp-Tutorial-Part-0/","excerpt":"","text":"Part 0 Part 1 Part 2 Part 3 学以太坊区块链平台已经有一段时间了，网络上有很多关于以太坊的资料（文章，视频，平台官网），这些很容易就能找到。由于以太坊平台还在快速迭代，所以相关的资料内容普遍滞后。然后自己基于所学整理了一下关于啥是以太坊，以及怎么搞以太坊的图。在学习过程中遇到了很多问题，本文整理一下，顺便从一个web开发者的角度来解释以太坊。 什么是webapp构架webapp的客户端以及服务端： 一个web应用托管在托管服务器上，像AWS，Heroku，VPS等，所有的客户端都是通过一个中心的应用程序进行交流。客户端可以是web浏览器，或者是其它的消费你程序的API等。当一个客户端像服务端发起一个请求，服务器会和数据库进行通信，对数据库进行增删改查，然后相应客户端请求。 这种结构大部分情况下都能很好的运行，但是如果数据库是公开的任何人都可以访问，那么有一些应用就会变得很有用，这样我就不用依赖上面的webapp来获取自己个人的数据了，也就是说我可以从其它渠道获取我的个人数据。 下面举例说明：例如eBay，如果你是一个超级卖家，已经获得了数百的好评。由于某些原因eBay封停了你的帐号。这事会严重的影响你的生意。如果你能够把这数百的好评与评分转移到其他平台（eBay的竞争者）的话，这就很爽了。eBay在买家和卖家之间提供了一个第三方信任服务。并且从买卖双方都要收取佣金。是否有这么一种方式买卖双方在交易的时候完全忽略eBay，这样双方也节省了佣金，同时你又可以访问到你的交易数据？这就是下面的图片提出的去中心化应用。以太坊让你很容易的创建Dapps(去中心化应用)。 什么是以太坊Dapp 你是否发现，每一个客户端交流使用的都是它自己的应用实例。没有一个所有的客户端都链接到服务器上的中心化服务器。这就意味着，每一个想通过去中心化应用交互的人，需要在他们的电脑或者是手机上完整的拷贝区块链。这就意味着，在你可以使用应用之前，你需要下载完整的区块链，然后启动使用这个应用。第一次听说感觉很荒唐，但是他有一个好处就是不需要依赖一个中心化的服务，而且这个中心化的服务有可能明天就不存在了。 现实中你不需要花费很多的内存和硬盘，来下载完整的区块链。已经有了一些变通的方法或者是优化来使的应用去中心化，保证交互方便快捷。 什么是区块链 Database(数据库)：在以太坊网络上每发生一个交易就会被包装到一个区块中，每一个区块都和下一个区块相连。这些包含所有交易数据相连的一系列的块就是区块链。如果我们返回去看刚才的eBay的例子，买卖双方无论是出售，退款还是纠纷都将会被记录在区块链上，并且每个人都可以看到。为了保证以太坊网络上的所以网络节点对这条信息都有同样的拷贝，而且为了确保非法数据写入的这个数据库中（区块链的区块中），以太坊使用一个叫做proof的算法来做这件工作。 Code：区块链的数据库部分只是存储了数据，但是像买，买，取消，退款等操作逻辑在什么地方呢？在以太坊的世界里，你可以使用一个叫做Solidity的语言来写应用（合约）代码。然后可以使用Solidity编译器来把代码编译成以太坊二进制文件，然后把这个二进制代码部署到区块链上。除此之外和Solidity很少有其他的交互，但是Solidity是目前开发合约最流行的开发语言。 所以从根本上来说：区块链存储数据，存储代码，而且运行EVM（Ethereum Virtual Machine）中的代码。 如何开发Dapp基于Dapps构建web，Ethereal有一个很好用的javascript包叫web3.js，这个包可以和你的区块链接点建立连接。所以只需在javascript框架（reactjs, angularjs等）中引入这个包，然后就可以开始构建应用了。 另一个大而重要的应用方面是平台的财务能力。因为在使用Dapp的时候，你就拥有了一个内置的银行帐户。事实上不只是一个银行帐户，你可以在一分钟内创建多个帐户。这些银行帐户被叫做钱包，你可以用来存钱（用在以太坊生态系统的货币）和交易。 END有许多关于区块链的内部细节我故意没有讲，因为我想集中精力在基于区块链的Dapp和中心化的webapp进行比较。希望这篇文章可以很好的达到说明以太坊是什么，以及怎么去构建去中心化的应用。 请看接下来的3个指导教程来构建全栈的dapp Part 1 Part 2 Part 3 延伸阅读： Ethereum white paper 写智能合约的语言Solidity https://gitter.im/ethereum/solidityand https://gitter.im/ethereum/web3.js","categories":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/tags/区块链/"},{"name":"Ethereum","slug":"Ethereum","permalink":"http://xichen.pub/tags/Ethereum/"},{"name":"Dapp","slug":"Dapp","permalink":"http://xichen.pub/tags/Dapp/"}]},{"title":"Git的4个阶段的撤销更改","slug":"2018-01-23-Git的4个阶段的撤销更改","date":"2018-01-23T15:01:00.000Z","updated":"2018-03-02T14:52:03.954Z","comments":true,"path":"2018/01/23/2018-01-23-Git的4个阶段的撤销更改/","link":"","permalink":"http://xichen.pub/2018/01/23/2018-01-23-Git的4个阶段的撤销更改/","excerpt":"","text":"基本概念3个步骤 正常情况下，我们的工作流就是3个步骤，对应上图中的3个箭头线： 123git add .git commit -m \"comment\"git push git add .把所有文件放入暂存区； git commit把所有文件从暂存区提交进本地仓库； git push把所有文件从本地仓库推送进远程仓库。 4个区git之所以令人费解，主要是它相比于svn等等传统的版本管理工具，多引入了一个暂存区(Stage)的概念，就因为多了这一个概念，而使很多人疑惑。其实，在初学者来说，每个区具体怎么工作的，我们完全不需要关心，而只要知道有这么4个区就够了： 工作区(Working Area) 暂存区(Stage) 本地仓库(Local Repository) 远程仓库(Remote Repository) 5种状态以上4个区，进入每一个区成功之后会产生一个状态，再加上最初始的一个状态，一共是5种状态。以下我们把这5种状态分别命名为： 未修改(Origin) 已修改(Modified) 已暂存(Staged) 已提交(Committed) 已推送(Pushed) 检查修改了解了基本概念之后，我们来谈一谈犯错误之后如何撤销的问题。首先，我们要了解如何检查这3个步骤当中每一个步骤修改了什么，然后才好判断有没有修改成功。检查修改的二级命令都相同，都是diff，只是参数有所不同。 已修改，未暂存1git diff 首先，我们来看一下，如果我们只是简单地在浏览器里保存了一下文件，但是还没有做git add .之前，我们如何检查有哪些修改。我们先随便拿一个文件来做一下实验： 我们在文件开头的第2行胡乱加了4个数字1234，存盘，这时文件进入了已修改状态，但是还没有进入暂存区，我们运行git diff，结果如下： 12345678910diff --git a/index.md b/index.mdindex 73ff1ba..1066758 100644--- a/index.md+++ b/index.md@@ -1,5 +1,5 @@ ----layout: main+1234layout: main color: black --- git diff的结果告诉我们哪些文件已经做了哪些修改。 已暂存，未提交1git diff --cached 现在我们把修改放入暂存区看一下。先执行git add .，然后执行git diff，你会发现没有任何结果： 这说明git diff这个命令只检查我们的工作区和暂存区之间的差异，如果我们想看到暂存区和本地仓库之间的差异，就需要加一个参数git diff --cached： 12345678910diff --git a/index.md b/index.mdindex 73ff1ba..1066758 100644--- a/index.md+++ b/index.md@@ -1,5 +1,5 @@ ----layout: main+1234layout: main color: black --- 这时候我们看到的差异是暂存区和本地仓库之间的差异。 已提交，未推送1git diff master origin/master 现在，我们把修改从暂存区提交到本地仓库，再看一下差异。先执行git commit，然后再执行git diff --cached，没有差异，执行git diff master origin/master，可以看到差异： 在这里，master就是你的本地仓库，而origin/master就是你的远程仓库，master是主分支的意思，因为我们都在主分支上工作，所以这里两边都是master，而origin就代表远程。 撤销修改了解清楚如何检查各种修改之后，我们开始尝试各种撤销操作。 已修改，未暂存如果我们只是在编辑器里修改了文件，但还没有执行git add .，这时候我们的文件还在工作区，并没有进入暂存区，我们可以用： 1git checkout . 或者 1git reset --hard 来进行撤销操作。 可以看到，在执行完git checkout .之后，修改已被撤销，git diff没有任何内容了。 一对反义词git add .的反义词是git checkout .。做完修改之后，如果你想向前走一步，让修改进入暂存区，就执行git add .，如果你想向后退一步，撤销刚才的修改，就执行git checkout .。 已暂存，未提交你已经执行了git add .，但还没有执行git commit -m &quot;comment&quot;。这时候你意识到了错误，想要撤销，你可以执行： 12git resetgit checkout . 或者 1git reset --hard git reset只是把修改退回到了git add .之前的状态，也就是说文件本身还处于已修改未暂存状态，你如果想退回未修改状态，还需要执行git checkout .。 或许你已经注意到了，以上两个步骤都可以用同一个命令git reset --hard来完成。是的，就是这个强大的命令，可以一步到位地把你的修改完全恢复到未修改的状态。 已提交，未推送你的手太快，你既执行了git add .，又执行了git commit，这时候你的代码已经进入了你的本地仓库，然而你后悔了，怎么办？不要着急，还有办法。 1git reset --hard origin/master 还是这个git reset --hard命令，只不过这次多了一个参数origin/master，正如我们上面讲过的，origin/master代表远程仓库，既然你已经污染了你的本地仓库，那么就从远程仓库把代码取回来吧。 已推送很不幸，你的手实在是太快了，你既git add了，又git commit了，并且还git push了，这时你的代码已经进入远程仓库。如果你想恢复的话，还好，由于你的本地仓库和远程仓库是等价的，你只需要先恢复本地仓库，再强制push到远程仓库就好了： 12git reset --hard HEAD^git push -f 总结以上4种状态的撤销我们都用到了同一个命令git reset --hard，前2种状态的用法甚至完全一样，所以只要掌握了git reset --hard这个命令的用法，从此你再也不用担心提交错误了。 更多参考独孤求败：Git中的各种后悔药","categories":[{"name":"Git","slug":"Git","permalink":"http://xichen.pub/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://xichen.pub/tags/Git/"}]},{"title":"Android Studio 3.0及Gradle Plugin 3.0升级注意事项","slug":"2018-01-23-Android-Studio-3.0及Gradle-Plugin-3.0升级注意事项","date":"2018-01-23T00:48:00.000Z","updated":"2018-03-02T14:52:03.957Z","comments":true,"path":"2018/01/23/2018-01-23-Android-Studio-3.0及Gradle-Plugin-3.0升级注意事项/","link":"","permalink":"http://xichen.pub/2018/01/23/2018-01-23-Android-Studio-3.0及Gradle-Plugin-3.0升级注意事项/","excerpt":"","text":"最近终于有空升级了一下项目中的Gradle和Gradle Plugin的版本，还是踩了蛮多的坑。特别是依赖以及渠道编译这块变动较大，因此把遇到的一些问题点记录下来，分享给后人查阅~ Gradle版本升级其实当AS升级到3.0之后，Gradle Plugin和Gradle不升级也是可以继续使用的，但很多新的特性如：Java8支持、新的依赖匹配机制、AAPT2等新功能都无法正常使用~ 所以长期看来，最后还是得升的。 Gradle Plugin升级到3.0.0及以上，修改project/build.gradle文件： 123456789101112buildscript &#123; repositories &#123; ... // You need to add the following repository to download the // new plugin. google() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:3.0.0' &#125;&#125; Gradle升级到4.1及以上，修改project/gradle/gradle-wrapper.properties文件： 1distributionUrl=https\\://services.gradle.org/distributions/gradle-4.1-all.zip 生成APK文件名属性outputFile变为只读改完第一步后会提示如下报错： Error:(88, 0) Cannot set the value of read-only property ‘outputFile’ for ApkVariantOutputImpl_Decorated{apkData=Main{type=MAIN, fullName=appDebug, filters=[]}} of type com.android.build.gradle.internal.api.ApkVariantOutputImpl. 之前改apk名字的代码类似：1234567applicationVariants.all &#123; variant -&gt; variant.outputs.each &#123; output -&gt; def file = output.outputFile def apkName = 'xxx-xxx-xxx-signed.apk' output.outputFile = new File(file.parent, apkName) &#125;&#125; 由于outputFile属性变为只读，需要进行如下修改，直接对outputFileName属性赋值即可：123456applicationVariants.all &#123; variant -&gt; variant.outputs.all &#123; def apkName = 'xxx-xxx-xxx-signed.apk' outputFileName = apkName &#125;&#125; 依赖关键字的改变 api: 对应之前的compile关键字，功能一模一样。会传递依赖，导致gradle编译的时候遍历整颗依赖树 implementation: 对应之前的compile，与api类似，关键区别是不会有依赖传递 compileOnly: 对应之前的provided，依赖仅用于编译期不会打包进最终的apk中 runtimeOnly: 对应之前的’apk’，与上面的compileOnly相反 关于implementation与api的区别，主要在依赖是否会传递上。如：A依赖B，B依赖C，若使用api则A可以引用C，而implementation则不能引用。 这里更推荐用implementation，一是不会间接的暴露引用，清晰知道目前项目的依赖情况；二是可以提高编译时依赖树的查找速度，进而提升编译速度。详见SO的这个回答，讲得非常详细了：https://stackoverflow.com/questions/44413952/gradle-implementation-vs-api-configuration 渠道需要声明flavor dimensions刚开始Sync的时候应该会报错： Error:All flavors must now belong to a named flavor dimension. Learn more at https://d.android.com/r/tools/flavorDimensions-missing-error-message.html 也就是每个flavor渠道都必须归属一个dimension维度，若只有一个维度，渠道中可以不写dimension属性，默认分配到该维度。直接添加一个默认的维度即可，如：flavorDimensions &quot;dimension&quot;。当然flavorDimensions也可以设置多个维度，详见官方实例：1234567891011121314151617181920212223242526// Specifies two flavor dimensions.flavorDimensions \"mode\", \"minApi\"productFlavors &#123; free &#123; // Assigns this product flavor to the \"tier\" flavor dimension. Specifying // this property is optional if you are using only one dimension. dimension \"mode\" ... &#125; paid &#123; dimension \"mode\" ... &#125; minApi23 &#123; dimension \"minApi\" ... &#125; minApi18 &#123; dimension \"minApi\" ... &#125;&#125; 库多variant依赖方式的修改Gradle plugin 3.0.0+之后引入了新的variant自动匹配机制，也就是说app的flavorDebug变体会自动匹配library的flavorDebug变体。 回顾一下旧的方式，如果app在某个variant下需要依赖library相应的类型，需要按照下面的方式声明依赖：123456dependencies &#123; // This is the old method and no longer works for local // library modules: debugCompile project(path: ':library', configuration: 'debug') releaseCompile project(path: ':library', configuration: 'release')&#125; 新的方式，gradle会自动感知并匹配对应的variant（前提是app与library中有对应的variant类型）：1234567dependencies &#123; // Instead, simply use the following to take advantage of // variant-aware dependency resolution. You can learn more about // the 'implementation' configuration in the section about // new dependency configurations. implementation project(':library')&#125; 处理app与lib的依赖匹配问题上面我们了解到新的variant匹配机制，但若app或library中不存在对应的variant类型呢？匹配将如何进行？下面列出了可能出现的几种情形： 情形1：app中有某个build type但library却木有可以通过matchingFallbacks属性来设置回退策略，提供可能的匹配列表，代码如下：123456789101112131415// In the app's build.gradle file.android &#123; buildTypes &#123; debug &#123;&#125; release &#123;&#125; staging &#123; // Specifies a sorted list of fallback build types that the // plugin should try to use when a dependency does not include a // \"staging\" build type. You may specify as many fallbacks as you // like, and the plugin selects the first build type that's // available in the dependency. matchingFallbacks = ['debug', 'qa', 'release'] &#125; &#125;&#125; 若希望可以针对app的每个build type都执行相同的回退策略（例如我们大量的library只有一个release的build type），则可以使用批量指令：123buildTypes.all &#123; type -&gt; type.matchingFallbacks = ['release']&#125; （注意：在该情景下，若library中有某个build type但app却木有，不会对app有任何影响） 情景2：在同一个dimension维度下，如：tier。若app中有某个flavor但library却木有：同样可以通过matchingFallbacks属性来设置回退策略，代码如下：1234567891011121314151617181920212223242526// In the app's build.gradle file.android &#123; defaultConfig&#123; // Do not configure matchingFallbacks in the defaultConfig block. // Instead, you must specify fallbacks for a given product flavor in the // productFlavors block, as shown below. &#125; flavorDimensions 'tier' productFlavors &#123; paid &#123; dimension 'tier' // Because the dependency already includes a \"paid\" flavor in its // \"tier\" dimension, you don't need to provide a list of fallbacks // for the \"paid\" flavor. &#125; free &#123; dimension 'tier' // Specifies a sorted list of fallback flavors that the plugin // should try to use when a dependency's matching dimension does // not include a \"free\" flavor. You may specify as many // fallbacks as you like, and the plugin selects the first flavor // that's available in the dependency's \"tier\" dimension. matchingFallbacks = ['demo', 'trial'] &#125; &#125;&#125; （注意：在该情景下，若library中有某个flavor但app却木有，不会对app有任何影响） 情景3：library中有某个dimension维度，但app中却没有:可以通过missingDimensionStrategy属性来设置选择策略，代码如下：12345678910111213141516171819202122// In the app's build.gradle file.android &#123; defaultConfig&#123; // Specifies a sorted list of flavors that the plugin should try to use from // a given dimension. The following tells the plugin that, when encountering // a dependency that includes a \"minApi\" dimension, it should select the // \"minApi18\" flavor. You can include additional flavor names to provide a // sorted list of fallbacks for the dimension. missingDimensionStrategy 'minApi', 'minApi18', 'minApi23' &#125; flavorDimensions 'tier' productFlavors &#123; free &#123; dimension 'tier' // You can override the default selection at the product flavor // level by configuring another missingDimensionStrategy property // for the \"minApi\" dimension. missingDimensionStrategy 'minApi', 'minApi23', 'minApi18' &#125; paid &#123;&#125; &#125;&#125; 说明：其中missingDimensionStrategy属性的第一个值为dimension维度，后面的Strings为该维度下的渠道flavors。我们可以看下它的函数原型：12345public void missingDimensionStrategy(String dimension, String requestedValue);public void missingDimensionStrategy(String dimension, String... requestedValues);public void missingDimensionStrategy(String dimension, List&lt;String&gt; requestedValues); （注意：在该情景下，若app中有某个dimension维度，但library中却没有，不会对app有任何影响） 情景4：若library没有任何dimension和flavor，则不需app做任何flavor的回退处理~说了这么多种场景，是不是快被绕晕了？其实诸如dimension的声明以及提供匹配回退策略都是为了实现精确的variant匹配。但是这么多的场景咋看之下还是比较晕，在遇到具体的业务依赖场景后再回来看这一块的内容，你会更加的有收获~ Java8特性的支持升级到Gradle Plugin 3.0.0之后，一直被诟病的Jack已经被官方弃用了，取而代之的是最新的desugar方案。 若项目之前用了类似retrolambda或者Jack这种旧方案的话，会出现以下提示告诉你移除相关的代码： Warning:One of the plugins you are using supports Java 8 language features. To try the support built into the Android plugin, remove the following from your build.gradle: apply plugin: ‘me.tatarka.retrolambda’ To learn more, go to https://d.android.com/r/tools/java-8-support-message.html 启用最新的desugar也非常简单，设置一下sourceCompatibility和targetCompatibility即可：12345678910android &#123; ... // Configure only for each module that uses Java 8 // language features (either in its source code or // through dependencies). compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 &#125;&#125; 目前所支持Java8的特性有： Lambda expressions Method References Type Annotations Default and static interface methods Repeating annotations （注意：stream及function包下的api只能在API level 24+以上才可以使用） 禁用该特性也是分分钟的事情：1android.enableDesugar=false 官方文档：https://developer.android.com/studio/write/java8-support.html android-apt相关的异常最后的最后很多同学会遇到以下关于android-apt的报错： 解决方法： 移除android-apt相关的plugin，如： 1classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8' 依赖中的apt改成annotationProcessor，如： 1annotationProcessor 'com.android.databinding:compiler:3.0.0' 如果有用到类似Realm这种第三方的plugin，确保升级到最新版试试（旧版的Realm用的还是android-apt），突然发现升级到最新版后api接口被改了，泪奔中… 12345678buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath \"io.realm:realm-gradle-plugin:4.2.0\" &#125;&#125; 更多还有更多的迁移变化，由于项目中还没涉及到，就先不写了，大家可以参考官方文档：https://developer.android.com/studio/build/gradle-plugin-3-0-0-migration.html","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"http://xichen.pub/tags/Android-Studio/"},{"name":"Gradle","slug":"Gradle","permalink":"http://xichen.pub/tags/Gradle/"}]},{"title":"update nodejs and npm","slug":"2018-01-22-update-nodejs-and-npm","date":"2018-01-22T14:16:00.000Z","updated":"2018-03-02T14:52:03.951Z","comments":true,"path":"2018/01/22/2018-01-22-update-nodejs-and-npm/","link":"","permalink":"http://xichen.pub/2018/01/22/2018-01-22-update-nodejs-and-npm/","excerpt":"","text":"升级node.js和npm一行命令搞定npm和node.js的升级，省去了重新编译和安装的过程。具体如下： 升级node.jsnpm中有一个模块叫做“n”，专门用来管理node.js版本的。更新到最新的稳定版只需要在命令行中打下如下代码：12npm install -g nn stable 如需最新版本则用n latest 当然，n后面也可以跟具体的版本号：n v6.2.0 node.js升级就是这么简单。 升级npmnpm升级就更简单了，只需要在终端中输入：1npm -g install npm@next","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://xichen.pub/categories/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://xichen.pub/tags/Ubuntu/"}]},{"title":"running Ubuntu GUI in Windows10","slug":"2018-01-22-running-Ubuntu-GUI-in-Windows10","date":"2018-01-22T14:16:00.000Z","updated":"2018-03-02T14:52:03.946Z","comments":true,"path":"2018/01/22/2018-01-22-running-Ubuntu-GUI-in-Windows10/","link":"","permalink":"http://xichen.pub/2018/01/22/2018-01-22-running-Ubuntu-GUI-in-Windows10/","excerpt":"","text":"安装先安装显示图形界面的程序vcxsrv然后运行以下命令12345678echo \"export DISPLAY=:0.0\" &gt;&gt; ~/.bashrcexport DISPLAY=:0.0sudo apt-get install dbus --reinstallsudo sed -i 's/&lt;listen&gt;.*&lt;\\/listen&gt;/&lt;listen&gt;tcp:host=localhost,port=0&lt;\\/listen&gt;/' /etc/dbus-1/session.confsudo apt-get install ubuntu-desktopsudo apt-get install unitysudo apt-get install compiz-coresudo apt-get install compizconfig-settings-manager 启动先启动XLaunch,选择只启动一个大窗口,把-1改为0这时候的窗口是黑的,因为没有视频输入然后运行命令1compiz 这时又视频输入了，切到XLaunch就可以浪了 0.png 1.png 2.png 3.png 4.png 5.png","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://xichen.pub/categories/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://xichen.pub/tags/Ubuntu/"}]},{"title":"latex（二）完全卸载","slug":"2017-12-28-latex（二）完全卸载","date":"2017-12-28T14:16:00.000Z","updated":"2018-03-02T14:52:03.943Z","comments":true,"path":"2017/12/28/2017-12-28-latex（二）完全卸载/","link":"","permalink":"http://xichen.pub/2017/12/28/2017-12-28-latex（二）完全卸载/","excerpt":"","text":"sudo apt-get purge texlive* rm -rf /usr/local/texlive/* and rm -rf ~/.texlive* rm -rf /usr/local/share/texmf rm -rf /var/lib/texmf rm -rf /etc/texmf sudo apt-get remove tex-common --purge rm -rf ~/.texlive find -L /usr/local/bin/ -lname /usr/local/texlive/*/bin/* | xargs rm This finds all the files in /usr/local/bin which point to a location within /usr/local/texlive/*/bin/* and removes them; because we’ve already deleted all of /usr/local/texlive, these are dead links. To see which files are being deleted, replace xargs rm with xargs -t rm (or tee off to a log file, or whatever).","categories":[{"name":"Latex","slug":"Latex","permalink":"http://xichen.pub/categories/Latex/"}],"tags":[{"name":"Latex","slug":"Latex","permalink":"http://xichen.pub/tags/Latex/"}]},{"title":"latex（一）安装与配置","slug":"2017-12-12-latex（一）安装与配置","date":"2017-12-12T14:16:00.000Z","updated":"2018-03-02T14:52:03.940Z","comments":true,"path":"2017/12/12/2017-12-12-latex（一）安装与配置/","link":"","permalink":"http://xichen.pub/2017/12/12/2017-12-12-latex（一）安装与配置/","excerpt":"","text":"2017年不到20天就到2018年了，才开始把latex用在写论文上。原来只是学了用latex写公式，嫌latex的配置太麻烦，总想拿mardown结合latex搞事情，结果啥也没做到。只好亲自入用latex编译论文的坑了。 latex就是为写论文带来便利。一定不能在安装和配置上花太多时间，不然就舍本逐末了。 Linux 发行版下原版 TeX Live 2017 的安装 在安装前，TeX Live 2017 的手册可以在 TUG 的 TeX Live 目录下找到：https://www.tug.org/texlive/doc/texlive-zh-cn/texlive-zh-cn.pdf。可以先阅读其中的安装部分。在 Linux 上安装原版 TeX Live 2017，与在 Windows 等其他系统下安装并无区别。可以从 CTAN 镜象下载 ISO 文件，然后挂载到一个目录下，运行里面的 install-tl 脚本进行安装；也可以在 CTAN 的网站上只下载 install-tl 脚本运行，在线安装。install-tl 是一个 Perl 脚本，在绝大多数发行版下都可以直接运行。 安装通过系统仓库首先，对于 Arch 等滚动更新发行版的用户来说，推荐使用官方仓库来安装。 1sudo pacman -S texlive-most texlive-lang 但是 Debian/Ubuntu 等的软件源往往会比较旧，为了体验最新的 TeX Live （虽然并没有什么卵差别），因此还是要用 ISO 映像安装。 通过iso文件下载 官方镜像: texlive2017.iso XJTU 镜像: texlive2017.iso（校内用户请选择该源） USTC 镜像: texlive2017.iso（校内用户请选择该源） 镜像站目录里的 texlive.iso 就是最新的 texlive2017.iso。 下载完成后可以选择进行校验避免出错，具体来说镜像站目录里会有 md5 和 sha512 两个 hash 文件以及一个 GPG 签名文件。TeX Live 2016 以后调整了基础架构，安装时会校验包的完整性，如果有 GPG 还会校验⽹络更新的签名。 12345678# GnuPG 校验签名，不懂请跳过，根据我的校验应当无误gpg --verify texlive2017.iso.sha512.asc# MD5 校验md5sum texlive2017.iso# SHA-512 校验sha512sum texlive2017.iso# 与官方提供的 Hash 对比cat texlive2017.iso.md5 texlive2017.iso.sha512 准备如果之前系统里已经装过 TeX Live，建议先删除。 对于 Linux 来说比较简单，只需要把安装目录（默认为 /usr/local/texlive 里的文件夹丢进 trash 即可），此外用户目录里修改过的一些配置也不要忘记。 如果想把有关依赖也卸载了，参考下一篇blog 如果是包管理安装的方式，例如 Ubuntu 用户，可以按照这样卸载： 1sudo apt-get purge texlive* 因为 TeX Live 里的安装脚本是 Perl 写的，如果稍后要用图形界面安装，需要更新下依赖。 12345678# Debian/Ubuntusudo apt-get install perl-tk# CentOS/Fedora/RHELsudo yum install perl-Tk# Fedora 22+sudo dnf install perl-Tk# OpenSUSEsudo zypper install perl-tk 安装如果能借助软件或文管等方式解决映像挂载问题就直接跳过，否则就在下载好的镜像目录执行以下命令安装： 123456sudo mount -o loop texlive2017.iso /mntcd /mnt# 在 shell 里直接安装sudo ./install-tl# 以 GUI 方式安装sudo ./install-tl -gui=perltk 图形界面大概长这样： 图形界面 默认是安装在 /usr/local/texlive 目录下，可以更改为 /home 等，否则无脑下一步即可。 根据硬件性能不同，安装过程一般不会短于 3 分钟。 安装过程 安装结束后可以卸载映像。 12cd ~sudo umount /mnt 通过命令行边下载边安装去这里https://www.tug.org/texlive/找对应的安装包，我下载的是install-tl-unx.tar.gz。 下载完后，随便找个临时目录解压。 默认是安装在 /usr/local/texlive/ 路径下，需要以超级用户权限安装，在解压下的目录运行1sudo ./install-tl 然后在文本界面下按提示进行交互式安装。当然，也可以安装在本地的用户路径下（如 ~/texlive/），这样就不再需要特殊权限。 如果是进行网络安装，默认会自动选择一个 CTAN 镜象。 这种方法在国内安装很慢，1h才下300多个文件。 国内往往需要用 -repository 选项手工指定镜象服务器地址，URL 地址需要指定到 texlive/tlnet/ 路径下。 推荐用清华的镜象：1sudo ./install-tl -repository http://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/tlnet/ 这种方法安装快，1h轻松安装完毕。 更方便的方式则是在图形界面下进行安装，此时需要确保系统安装了 perl-tk 等相关 Perl 图形界面库。运行命令 1sudo ./install-tl -gui 即可按界面中的提示安装。或者运行 1sudo ./install-tl -gui=wizard 使用图形界面的安装向导，向导方式比前面的方式配置项少一些，但更容易使用。 不过没啥用。还是建议用清华镜像那个命令快一点，不需要这么花俏。 修改环境变量，使编辑器等能找到texlive对于 bash 等 Bourne 兼容的 shell，在用户目录的 ~/.bashrc 文件中添加一些环境变量，具体路径由安装的位置确定。 12345# TeX Live 2017export PATH=$&#123;PATH&#125;:/usr/local/texlive/2017/bin/x86_64-linux# 如果是32位最后改为'i386-linux'export MANPATH=$&#123;MANPATH&#125;:/usr/local/texlive/2017/texmf-dist/doc/manexport INFOPATH=$&#123;INFOPATH&#125;:/usr/local/texlive/2017/texmf-dist/doc/info 如果是 csh 或 tcsh，则在 ~/.cshrc 中添加内容。 1234# TeX Live 2017setenv PATH /usr/local/texlive/2017/bin/x86_64-linux:$PATHsetenv MANPATH /usr/local/texlive/2017/texmf-dist/doc/man:$MANPATHsetenv INFOPATH /usr/local/texlive/2017/texmf-dist/doc/info:$INFOPATH 对于 Debian/Ubuntu 用户，可以安装下我根据 官方说明 制作的 texlive-local_2017-1_all.deb 来申明下包管理里的依赖关系，避免版本冲突。 123sudo dpkg -i texlive-local_2017-1_all.deb# 显示安装的 TeX Live 版本信息dpkg -l | grep texlive-local 至于其他发行版的 texlive-dummy 可去 CTAN 搜索。 测试安装完成后，如果一切都设置好，那么运行以下一些简单测试命令，在当前目录应该会得到正确的输出，如果有命令报错，请自行解决。 12345678910# 显示 TeX 版本应为 3.14159265tex --version# 处理一个基本文件，显示无法找到说明环境变量设置有误latex sample2e.tex# 预览上一步得到的 dvi 文件xdvi sample2e.dvi# pdfTeX 编译直接输出一份 PDFpdftex sample2e.tex# 测试 XeTeX 能否访问系统字体xetex opentype-info.tex 安装之后就可以使用 texdoc 命令阅读安装在本地手册了，对 TeX Live 不甚熟悉的用户最好运行 1texdoc texlive-zh 命令再次阅读 TeX Live 2017 的手册。 更新TeX Live 的更新工具 tlmgr（TeX Live Manager）图形性能比较差，特别是在 Windows 上，故推荐终端里直接更新。 12345678# tlmgr 只能在 root 权限下运行su# 更新 tlmgr 宏包管理器tlmgr update -self# 更新所有宏包tlmgr update -all# 官方的 CTAN 镜像源速度可能比较慢，校内用户推荐换成 XJTU，支持 http 或 httpstlmgr update -all -repository https://mirrors.xjtu.edu.cn/CTAN/systems/texlive/tlnet/ 如果钟爱图形界面，带上 -gui 参数即可。校内用户记得把默认软件包仓库改为 XJTU 的镜像源地址。 123su# 指定图形界面语言为中文tlmgr -gui -gui-lang zh_CN 其它 关于 Linux 上的编辑器，理论上只要是文本编辑器均可。由于可选择的方案太多，取决于个人的使用习惯，这里只推荐两个适合入门的自由软件 Texmaker 和 TeXstudio（fork 自前者）。 关于 Linux 上的字体，因为版权问题，所以 Times New Roman 和宋体就成了很多 LaTeX 初学者的困扰。 推荐的办法是 ctex 宏集处理中文，使用 Fandol 开源字体，默认效果好于 Windows 的中易宋体，另外也可使用思源宋体；而西文和数学字符则用 mathptmx 或 newtx 宏包处理，使用开源的 Nimbus Roman No9 L 字体代替 Times New Roman，差别不大。 对字体有严格要求，可以复制 Windows 下的字体到 ~/.fonts 目录下，记得用 fc-cache -fsv 命令更新下字体缓存。 关于 LaTeX 教程或者说手册，推荐两本 包太雷的 lnotes2 和 lshort 中文版。 配置按照 TeX Live 手册的说明，安装之后，还有一些工作需要做： 如果在安装时没有选择在系统目录为可执行文件创建符号链接，就需要手工修改 ~/.profile 文件设置 PATH 环境变量。 export MANPATH=”/usr/local/texlive/2017/texmf-dist/doc/man” export INFOPATH=”/usr/local/texlive/2017/texmf-dist/doc/info” export PATH=”/usr/local/texlive/2017/bin/x86_64-linux:$PATH” XeTeX 会使用 fontconfig 库来通过字体名搜索字体。TeX Live 的字体目录默认并不在 fongconfig 的搜索目录之列，因此需要按文档要求，将 TeX Live 安装目录下的 texmf-var/fonts/conf/texlive-fontconfig.conf 文件，复制到 /etc/fonts/conf.d/09-texlive.conf，然后运行 fc-cache，以确保 XeTeX 能搜索到字体。否则，TeX Live 自带的 OpenType 字体就只能以字体文件名的方式调用，非常不便。此外这样也能让系统的其他软件使用 TeX Live 安装的字体。 建议先复制到临时文件夹，改名后，再sudo mv 如果需要以字体文件名调用 Linux 系统安装的字体，例如使用 CJK 宏包调用来自 Windows 的字体，那么还需要修改 TeX Live 安装目录的 texmf.cnf 文件，在其中设置 OSFONTDIR 变量，例如： 1OSFONTDIR = ~/.fonts//;/usr/share/fonts//;/usr/share/fonts-droid// 可能需要用sudo gedit texmf.cnf才修改得了。当然，这一步骤对多数用户的用处并不大。 在/usr/bin/目录下创建符号链接才能用pdflatex进行编译1sudo ln -s /usr/local/texlive/2017/bin/x86_64-linux/pdflatex pdflatex 安装LaTeX编辑器：TeXstudio去官网下deb包然后安装：1sudo dpkg -i XXX.deb 打开TeXstudio，在倒数第二个选项(o)配置一下。首先配置语言为中文，然后编译器选pdflatex，其他的千万不要动。 配置语言为中文 编译器选pdflatex 其他宏包XeLatexXeLatex 是 texlive-xetex 包的一部分，用来支持中文。安装的话需要运行1sudo apt-get install texlive-xetex 加上依赖有1G大小。","categories":[{"name":"Latex","slug":"Latex","permalink":"http://xichen.pub/categories/Latex/"}],"tags":[{"name":"Latex","slug":"Latex","permalink":"http://xichen.pub/tags/Latex/"}]},{"title":"Web App 相关技术","slug":"2017-12-10-web-app","date":"2017-12-10T06:06:05.000Z","updated":"2018-01-27T09:31:37.975Z","comments":true,"path":"2017/12/10/2017-12-10-web-app/","link":"","permalink":"http://xichen.pub/2017/12/10/2017-12-10-web-app/","excerpt":"","text":"把技能点点在移动前端… 概念 参考： 移动 Web 开发入门 上面这个 slide 资料讲的非常好，算是一个入门的介绍吧。带我们建立基本的移动 web 开发知识体系和常见问题的实践。包含以下几个方面： 基本概念 Native 本地应用 使用 Java \\ Objective-C \\ Swift 开发 WebApp 网页应用 html5 开发 Hybrid 混合应用 ooxx(native, web) 对比 视觉 设备的像素 文字单位使用 rem viewport 属性 横屏竖屏 Flex 伸缩布局 响应式设计 软键盘 隐藏地址栏 苹果设备添加到主屏图标 交互 Touch click 延迟 Scroll Gestures(hammer –A javascript library for multi-touch gestures) 手指友好设计 HTML5 APIS（图像，摇动，声音等） 实践 屏蔽点击元素时的阴影 图像（像素、矢量图标、base64 减少请求、lazyload） CSS3（合理使用渐变/圆角/阴影、代替 js 动画、translate3d、解决动画闪烁） localStorage 避免（iframe、fixed + input） SPA 或 Multi page can I use 压缩合并 @G/3G 下建立连接时间 调试 浏览器自己的调试工具，模拟手机设备 weinre 关于 weinre 我写了一篇博客介绍它。Weinre –WebApp 调试工具 head 标签参考： 移动前端不得不了解的html5 head 头标签 上面的链接详细的讲解了： DOCTYPE charset lang属性 优先使用 IE 最新版本和 Chrome 360 使用Google Chrome Frame SEO 优化部分：页面标题&lt;title&gt;标签(head 头部必须)，页面关键词 keywords，页面描述内容 description，定义网页作者 author，网页搜索引擎索引方式 为移动设备添加 viewport viewport 可以让布局在移动浏览器上显示的更好。 通常会写 12&lt;meta name =\"viewport\" content =\"initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no\"&gt;&lt;!-- `width=device-width` 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边 http://bigc.at/ios-webapp-viewport-meta.orz --&gt; content 参数： width viewport 宽度(数值/device-width) height viewport 高度(数值/device-height) initial-scale 初始缩放比例 maximum-scale 最大缩放比例 minimum-scale 最小缩放比例 user-scalable 是否允许用户缩放(yes/no) ios 设备，iOS 图标，Android，Windows 8 总结： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;!DOCTYPE html&gt; &lt;!-- 使用 HTML5 doctype，不区分大小写 --&gt;&lt;html lang=\"zh-cmn-Hans\"&gt; &lt;!-- 更加标准的 lang 属性写法 http://zhi.hu/XyIa --&gt;&lt;head&gt; &lt;!-- 声明文档使用的字符编码 --&gt; &lt;meta charset='utf-8'&gt; &lt;!-- 优先使用 IE 最新版本和 Chrome --&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"/&gt; &lt;!-- 页面描述 --&gt; &lt;meta name=\"description\" content=\"不超过150个字符\"/&gt; &lt;!-- 页面关键词 --&gt; &lt;meta name=\"keywords\" content=\"\"/&gt; &lt;!-- 网页作者 --&gt; &lt;meta name=\"author\" content=\"name, email@gmail.com\"/&gt; &lt;!-- 搜索引擎抓取 --&gt; &lt;meta name=\"robots\" content=\"index,follow\"/&gt; &lt;!-- 为移动设备添加 viewport --&gt; &lt;meta name=\"viewport\" content=\"initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no\"&gt; &lt;!-- `width=device-width` 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边 http://bigc.at/ios-webapp-viewport-meta.orz --&gt; &lt;!-- iOS 设备 begin --&gt; &lt;meta name=\"apple-mobile-web-app-title\" content=\"标题\"&gt; &lt;!-- 添加到主屏后的标题（iOS 6 新增） --&gt; &lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\"/&gt; &lt;!-- 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏 --&gt; &lt;meta name=\"apple-itunes-app\" content=\"app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL\"&gt; &lt;!-- 添加智能 App 广告条 Smart App Banner（iOS 6+ Safari） --&gt; &lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\"/&gt; &lt;!-- 设置苹果工具栏颜色 --&gt; &lt;meta name=\"format-detection\" content=\"telphone=no, email=no\"/&gt; &lt;!-- 忽略页面中的数字识别为电话，忽略email识别 --&gt; &lt;!-- 启用360浏览器的极速模式(webkit) --&gt; &lt;meta name=\"renderer\" content=\"webkit\"&gt; &lt;!-- 避免IE使用兼容模式 --&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt; &lt;meta name=\"HandheldFriendly\" content=\"true\"&gt; &lt;!-- 微软的老式浏览器 --&gt; &lt;meta name=\"MobileOptimized\" content=\"320\"&gt; &lt;!-- uc强制竖屏 --&gt; &lt;meta name=\"screen-orientation\" content=\"portrait\"&gt; &lt;!-- QQ强制竖屏 --&gt; &lt;meta name=\"x5-orientation\" content=\"portrait\"&gt; &lt;!-- UC强制全屏 --&gt; &lt;meta name=\"full-screen\" content=\"yes\"&gt; &lt;!-- QQ强制全屏 --&gt; &lt;meta name=\"x5-fullscreen\" content=\"true\"&gt; &lt;!-- UC应用模式 --&gt; &lt;meta name=\"browsermode\" content=\"application\"&gt; &lt;!-- QQ应用模式 --&gt; &lt;meta name=\"x5-page-mode\" content=\"app\"&gt; &lt;!-- windows phone 点击无高光 --&gt; &lt;meta name=\"msapplication-tap-highlight\" content=\"no\"&gt; &lt;!-- iOS 图标 begin --&gt; &lt;link rel=\"apple-touch-icon-precomposed\" href=\"/apple-touch-icon-57x57-precomposed.png\"/&gt; &lt;!-- iPhone 和 iTouch，默认 57x57 像素，必须有 --&gt; &lt;link rel=\"apple-touch-icon-precomposed\" sizes=\"114x114\" href=\"/apple-touch-icon-114x114-precomposed.png\"/&gt; &lt;!-- Retina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有 --&gt; &lt;link rel=\"apple-touch-icon-precomposed\" sizes=\"144x144\" href=\"/apple-touch-icon-144x144-precomposed.png\"/&gt; &lt;!-- Retina iPad，144x144 像素，可以没有，但推荐有 --&gt; &lt;!-- iOS 图标 end --&gt; &lt;!-- iOS 启动画面 begin --&gt; &lt;link rel=\"apple-touch-startup-image\" sizes=\"768x1004\" href=\"/splash-screen-768x1004.png\"/&gt; &lt;!-- iPad 竖屏 768 x 1004（标准分辨率） --&gt; &lt;link rel=\"apple-touch-startup-image\" sizes=\"1536x2008\" href=\"/splash-screen-1536x2008.png\"/&gt; &lt;!-- iPad 竖屏 1536x2008（Retina） --&gt; &lt;link rel=\"apple-touch-startup-image\" sizes=\"1024x748\" href=\"/Default-Portrait-1024x748.png\"/&gt; &lt;!-- iPad 横屏 1024x748（标准分辨率） --&gt; &lt;link rel=\"apple-touch-startup-image\" sizes=\"2048x1496\" href=\"/splash-screen-2048x1496.png\"/&gt; &lt;!-- iPad 横屏 2048x1496（Retina） --&gt; &lt;link rel=\"apple-touch-startup-image\" href=\"/splash-screen-320x480.png\"/&gt; &lt;!-- iPhone/iPod Touch 竖屏 320x480 (标准分辨率) --&gt; &lt;link rel=\"apple-touch-startup-image\" sizes=\"640x960\" href=\"/splash-screen-640x960.png\"/&gt; &lt;!-- iPhone/iPod Touch 竖屏 640x960 (Retina) --&gt; &lt;link rel=\"apple-touch-startup-image\" sizes=\"640x1136\" href=\"/splash-screen-640x1136.png\"/&gt; &lt;!-- iPhone 5/iPod Touch 5 竖屏 640x1136 (Retina) --&gt; &lt;!-- iOS 启动画面 end --&gt; &lt;!-- iOS 设备 end --&gt; &lt;meta name=\"msapplication-TileColor\" content=\"#000\"/&gt; &lt;!-- Windows 8 磁贴颜色 --&gt; &lt;meta name=\"msapplication-TileImage\" content=\"icon.png\"/&gt; &lt;!-- Windows 8 磁贴图标 --&gt; &lt;link rel=\"alternate\" type=\"application/rss+xml\" title=\"RSS\" href=\"/rss.xml\"/&gt; &lt;!-- 添加 RSS 订阅 --&gt; &lt;link rel=\"shortcut icon\" type=\"image/ico\" href=\"/favicon.ico\"/&gt; &lt;!-- 添加 favicon icon --&gt; &lt;title&gt;标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 页面切换动画 移动端重构系列13——页面切换 CSS3 3D Transform 关于 HammerJS 的一个中文文档 Hammer.js CSS Processing CSS语言由于其自身语言设计的问题，加上一些浏览器兼容性问题，往往会使得我们在写它的时候，要写很多冗余代码，或者为了兼容性对同一个样式设定写好几遍。针对这些问题，诞生了CSS预处理和后处理的概念及相关方法、工具。 这些工具和方法帮助我们能够更加高效地书写可维护性更强的CSS代码。 这里我尝试使用了 Sass，果然很好用。下面记录几个 sass 教程。 Sass入门-w3cplus SASS用法指南-阮一峰 安装首先要有 ruby 环境。 由于国内网络原因（你懂的），导致 rubygems.org 存放在 Amazon S3 上面的资源文件间歇性连接失败。这时候我们可以通过gem sources命令来配置源，先移除默认的 https://rubygems.org 源，然后添加淘宝的源 https://ruby.taobao.org/，然后查看下当前使用的源是哪个，如果是淘宝的，则表示可以输入 sass 安装命令 gem install sass 了。 $ gem sources --remove https://rubygems.org/ $ gem sources -a https://ruby.taobao.org/ $ gem sources -l *** CURRENT SOURCES *** https://ruby.taobao.org # 请确保只有 ruby.taobao.org $ gem install sass 编译sass --watch style.scss:style.css --style expanded 补充rem 字体单位使用 rem，用户在手机上设置了字体大小时，不会打破布局，造成混乱。 CSS3的REM设置字体大小-w3cplus 响应式十日谈第一日：使用 rem 设置文字大小-一丝 安全 安全是大家经常容易忽视，但其实一旦出现影响会非常大的问题，尤其对于没有经历过企业开发，或者没有踩过坑的同学，如果等到公司工作，做实际项目后非常容易发生安全问题。 分类WEB基本攻击大致可以分为三大类：“资源枚举”、“参数操纵” 和 “其它攻击” 资源枚举 参数操纵 SQL注入 XPath注入 cgi命令执行 XXS（cross-site scripting跨域脚本攻击）其重点是“跨域”和“客户端执行” Reflected XSS ——基于反射的XSS攻击。主要依靠站点服务端返回脚本，在客户端触发执行从而发起WEB攻击。 DOM-based or local XSS——基于DOM或本地的XSS攻击 Stored XSS——基于存储的XSS攻击 会话劫持 其它攻击 CSRF（cross-site request forgery）跨站请求伪造 钓鱼攻击指的是网站的伪造，比如ta0bao.com，然后在其中应用XSS等方式发起攻击。 拒绝服务（DoS）指的是向网站发起洪水一样的请求（Traffic Floor），导致服务器超负荷并关闭，处理方法常规是采用QoS（Quality of Service）的软硬件解决方案。 关于 XSS 跨网站脚本（Cross-site scripting，通常简称为XSS或跨站脚本或跨站脚本攻击）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。 XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java， VBScript， ActiveX， Flash 或者甚至是普通的HTML。攻击成功后，攻击者可能得到更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。 ——维基百科 XSS 防护 浏览器解析顺序： HTML Parser &gt;&gt; CSS Parser &gt;&gt; JavaScript Parser 浏览器解码顺序： HTML Decoding &gt;&gt; URL Decoding &gt;&gt; JavaScript Decoding 具体的防护方式： 验证输入并且基于语境和按照正确的顺序转义不可信数据 HTML 中的字符串 HTML 属性中的字符串 事件句柄属性和 JavaScript 中的字符串 HTML 属性中的 URL 路径 HTML 风格属性和 CSS 中的字符串 JavaScript 中的 HTML 始终遵循白名单优于黑名单的做法 使用 UTF-8 为默认的字符编码以及设置 content 为 text/html 不要将用户可以控制的文本放在标签前。通过使用不同的字符集注射可以导致 XSS。 使用 &lt;!DOCTYPE html&gt; 使用推荐的 HTTP 响应头进行 XSS 防护 防止 CRLF 注入/HTTP 响应拆分 禁止 TRACE 和其他非必要方法 对于 innerHTML 的方式输出的，我们可以采用如下的方式转码 1234567891011121314/** * 转码 XSS 防护 * @param &#123;String&#125; str 用户输入的字符串 * @return &#123;String&#125; 转码后的字符串 */function changeCode(str) &#123; str = str.replace(/&amp;/g, \"&amp;amp;\") .replace(/&lt;/g, \"&amp;lt;\") .replace(/&gt;/g, \"&amp;gt;\") .replace(/\"/g, \"&amp;quot;\") .replace(/'/g, \"&amp;#x27;\") .replace(/\\//g, \"&amp;#x2f;\"); return str;&#125; 参考： 浅谈WEB安全性（前端向） XSS的原理分析与解剖 原创翻译：给开发者的终极XSS防护备忘录 性能优化 在自己做一些小项目时，可能是学校的一些网站项目，流量可能日均都不超过500，而且大多是校园局域网内访问；或者是开发一些实验室的MIS系统，这辈子你都不会去使用你开发的这个系统。在这样一些项目中，性能优化往往会被你忽略。 但是如果你是做一个日均PV数万、数十万、甚至更大的量级，开发的页面会被全国各地，不同网络条件的用户来进行访问。这个时候，性能问题就无法忽视了。在当今的网络条件下，如果你的页面3秒都无法完成首屏渲染，一定会让你的网站流失很多用户。 整个网站的性能优化有很多的环节和工作，大多数时候，不是前端工程师单独就能完成的，尤其在职能划分明确的公司中，往往需要前后端、运维、DBA等多个职位协同完成。所以，在我们的课程中，主要让你了解整个性能优化都涉及哪些方面的工作，同时，我们会专注介绍一些在前端领域可以重点关注的技术点。 这里就是网页的打开速度，如果你的网页打开速度很慢，那么一定会有用户的流失。所以性能优化很重要。 网页内容 减少http请求次数 减少DNS查询次数 避免页面跳转 缓存Ajax 延迟加载 提前加载 减少DOM元素数量 根据域名划分内容 减少iframe数量 避免404 服务器 使用CDN 添加Expires 或Cache-Control报文头 Gzip压缩传输文件 配置ETags 尽早flush输出 使用GET Ajax请求 避免空的图片src Cookie 减少Cookie大小 页面内容使用无cookie域名 CSS 将样式表置顶 避免CSS表达式 用\\代替@import 避免使用Filters Javascript 将脚本置底 使用外部Javascirpt和CSS文件 精简Javascript和CSS 去除重复脚本 减少DOM访问 使用智能事件处理 图片 优化图像 优化CSS Sprite 不要在HTML中缩放图片 使用小且可缓存的favicon.ico 移动客户端 保持单个内容小于25KB 打包组建成符合文档 具体细节参考文章： 毫秒必争，前端网页性能最佳实践 我在 ToDo 这个任务中主要使用了 CDN 来加载静态资源。比如我使用了 百度静态资源公共库。引用了里面的 fontawesome，速度果然比在 GitHub 仓库里快很多。下一步是压缩我自己写的静态资源。 其他参考资料： 给网页设计师和前端开发者看的前端性能优化 梳理：提高前端性能方面的处理以及不足 css sprite原理优缺点及使用 CSS Sprites：鱼翅还是三鹿？ 大型网站的灵魂——性能 编写高效的 CSS 选择器 模块化 对于一个复杂项目，特别是多人协作的复杂项目，如何合理划分模块，如何更加方便地进行模块加载，如何管理模块之间的依赖，是一个项目团队都会面临的问题，目前业界已经有了一些较为普遍的解决方案，如AMD。这个部分希望你能够通过学习JavaScript的模块化，学习如何合理地规划项目模块，合理使用模块化工具来优化你的项目代码结构。 一个模块就是实现特定功能的文件，有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。模块开发需要遵循一定的规范，否则就都乱套了。 根据AMD规范，我们可以使用 define 定义模块，使用 require 调用模块。 目前，通行的 js 模块规范主要有两种：CommonJS 和 AMD。 AMD规范AMD 即 Asynchronous Module Definition，中文名是“异步模块定义”的意思。它是一个在浏览器端模块化开发的规范，服务器端的规范是 CommonJS 模块将被异步加载，模块加载不影响后面语句的运行。所有依赖某些模块的语句均放置在回调函数中。 AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出。 详细 API 如下： AMD（中文版）) CommonJS规范CommonJS 是服务器端模块的规范，Node.js 采用了这个规范。Node.JS 首先采用了 js 模块化的概念。 根据 CommonJS 规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为 global 对象的属性。 输出模块变量的最好方法是使用 module.exports 对象。 为什么要用 requireJS试想一下，如果一个网页有很多的js文件，那么浏览器在下载该页面的时候会先加载js文件，从而停止了网页的渲染，如果文件越多，浏览器可能失去响应。其次，要保证js文件的依赖性，依赖性最大的模块（文件）要放在最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。 RequireJS就是为了解决这两个问题而诞生的： （1）实现js文件的异步加载，避免网页失去响应；（2）管理模块之间的依赖性，便于代码的编写和维护。 requireJS requireJS 官网 requireJS 中文网 AMD和CMDCMD（Common Module Definition） 通用模块定义。该规范明确了模块的基本书写格式和基本交互规则。该规范是在国内发展出来的。AMD是依赖关系前置，CMD是按需加载。 AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。 CMD 模块定义规范 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。 AMD:提前执行（异步加载：依赖先执行）+延迟执行CMD:延迟执行（运行到需加载，根据顺序执行） 参考 Javascript模块化编程（一）：模块的写法–阮一峰 Javascript模块化编程（二）：AMD规范 Javascript模块化编程（三）：require.js的用法 详解 JavaScript 模块开发 浅谈模块化的JavaScript 再谈 SeaJS 与 RequireJS 的差异 玩转AMD系列 by erik@EFE 玩转AMD - 写在前面 玩转AMD - 设计思路 玩转AMD - 应用实践 玩转AMD - Loader 前端工程化 业界目前有非常多的前端开发工具，完成一些开发过程中可以自动化完成的工作，提高研发效率，并且可以提高多人协作时的开发过程一致性，提高整个项目的运维效率。 在EFE日常工作中，我们是基于EDP，完成项目开发过程中的项目构建、包管理、调试、单测、静态检测、打包、压缩、优化、项目部署等一系列所有工作。 注： 如果网络不好，可以使用 淘宝 NPM 镜像。 参考 前端工程与模块化框架 手机百度前端工程化之路 对话百度前端工程师张云龙：F.I.S与前端工业化 EDP Grunt教程——初涉Grunt gulp入门指南 Gulp开发教程（翻译） Gulp 中文网 npm的package.json中文文档 最终作品在任务三中，做了一个 PC 端的 ToDo 应用。任务四是将它优化，以适应移动端设备。 ToDo WebApp Version 任务四要求 源代码 在线 demo 手机查看 ↓ 二维码 ↓ 我的博客 HyG Details 数据存储 以 JSON 模拟数据表的形式存储于 LocalStorage 中 使用数据库的思想，构建3张表。 cateJson 分类 childCateJson 子分类 taskJson 任务 分类表 cate ---------------------- id* | name | child(FK) ---------------------- 子分类表 childCate -------------------------------- id* | pid(FK) | name | child(FK) -------------------------------- 任务表 task ---------------------------------------------- id* | pid(FK) | finish | name | date | content ---------------------------------------------- 使用 Sass 重构了 CSS 代码 使用分块、继承等方式，使得代码更加清晰明了。 响应式布局 针对手机端细节做了很多调整，更符合手机上的视觉交互习惯。 加入页面切换效果 使用 translate3d()，纯 CSS3 切换动画效果。 处理了 XSS 防护 对可能造成破坏的字符进行转码。 性能优化 使用 CDN 处理静态资源 fontAwesome，压缩静态资源等 模块化 使用 requireJS 模块化 JavaScript 代码。重构 JavaScript 代码。优化之前写的耦合性高的绑定事件，重新绑定事件，降低耦合性。期间根据具体需求重写了事件代理的代码。 前端工程化 使用 gulp，自动编译 Sass，压缩 CSS 和 JavaScript 代码。并且配置了自动流程。 其他-webkit-tap-highlight-color 属性感谢 fiona 指出。 safari移动端点击的时候会闪一下加上 -webkit-tap-highlight-color: transparent; 就不会闪了。 参考： -webkit-tap-highlight-color css88 -webkit-tap-highlight-color 属性 textarea 标签 disabled 颜色 为什么用 disabled 属性？ 因为我发现仅仅使用 readonly 属性，在 IE 下是显示光标的。于是使用 disabled。 出现的问题 各家浏览器对于 disabled 属性有自己的样式设定，比如 IE 下是灰色的。苹果设备下也是。改变这些样式的方法也不是统一的。如果要兼容 Safari 必须加上 123background: #fff;-webkit-text-fill-color: rgba(0, 0, 0, 1);-webkit-opacity: 1; 于是最终代码如下： 123456textarea:disabled &#123; color:#000; background: #fff; -webkit-text-fill-color: rgba(0, 0, 0, 1); -webkit-opacity: 1;&#125; 参考：Disabled input text color 中的评论","categories":[{"name":"Web","slug":"Web","permalink":"http://xichen.pub/categories/Web/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xichen.pub/tags/JavaScript/"},{"name":"HTML","slug":"HTML","permalink":"http://xichen.pub/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://xichen.pub/tags/CSS/"},{"name":"Sass","slug":"Sass","permalink":"http://xichen.pub/tags/Sass/"},{"name":"移动端","slug":"移动端","permalink":"http://xichen.pub/tags/移动端/"},{"name":"XSS","slug":"XSS","permalink":"http://xichen.pub/tags/XSS/"},{"name":"AMD","slug":"AMD","permalink":"http://xichen.pub/tags/AMD/"},{"name":"requireJS","slug":"requireJS","permalink":"http://xichen.pub/tags/requireJS/"},{"name":"CommonJS","slug":"CommonJS","permalink":"http://xichen.pub/tags/CommonJS/"},{"name":"性能优化","slug":"性能优化","permalink":"http://xichen.pub/tags/性能优化/"},{"name":"WebApp","slug":"WebApp","permalink":"http://xichen.pub/tags/WebApp/"}]},{"title":"Git Tips","slug":"2017-12-9-git-tips","date":"2017-12-09T13:36:00.000Z","updated":"2018-01-27T09:31:42.252Z","comments":true,"path":"2017/12/09/2017-12-9-git-tips/","link":"","permalink":"http://xichen.pub/2017/12/09/2017-12-9-git-tips/","excerpt":"","text":"库管理克隆库12git clone https://github.com/php/php-src.gitgit clone --depth=1 https://github.com/php/php-src.git # 只抓取最近的一次 commit 历史管理查看历史12git log --pretty=oneline filename # 一行显示git show xxxx # 查看某次修改 标签功能12345678git tag # 显示所有标签git tag -l 'v1.4.2.*' # 显示 1.4.2 开头标签git tag v1.3 # 简单打标签 git tag -a v1.2 9fceb02 # 后期加注标签git tag -a v1.4 -m 'my version 1.4' # 增加标签并注释， -a 为 annotated 缩写git show v1.4 # 看某一标签详情git push origin v1.5 # 分享某个标签git push origin --tags # 分享所有标签 回滚操作12git reset 9fceb02 # 保留修改git reset 9fceb02 --hard # 删除之后的修改 取消文件的修改12git checkout -- a.php # 取消单个文件git checkout -- # 取消所有文件的修改 删除文件12git rm a.php # 直接删除文件git rm --cached a.php # 删除文件暂存状态 移动文件1git mv a.php ./test/a.php 查看文件修改12git diff # 查看未暂存的文件更新 git diff --cached # 查看已暂存文件的更新 暂存和恢复当前staging12345git stash # 暂存当前分支的修改git stash apply # 恢复最近一次暂存git stash list # 查看暂存内容git stash apply stash@&#123;2&#125; # 指定恢复某次暂存内容git stash drop stash@&#123;0&#125; # 删除某次暂存内容 修改 commit 历史纪录1git rebase -i 0580eab8 分支管理创建分支12git branch develop # 只创建分支git checkout -b master develop # 创建并切换到 develop 分支 合并分支1234git checkout master # 切换到 master 分支git merge --no-ff develop # 把 develop 合并到 master 分支，no-ff 选项的作用是保留原分支记录git rebase develop # rebase 当前分支到 developgit branch -d develop # 删除 develop 分支 克隆远程分支12git branch -r # 显示所有分支，包含远程分支git checkout origin/android 修复develop上的合并错误 将merge前的commit创建一个分之，保留merge后代码 将develop reset --force到merge前，然后push --force 在分支中rebase develop 将分支push到服务器上重新merge 强制更新到远程分支最新版本12git reset --hard origin/mastergit submodule update --remote -f Submodule使用克隆带submodule的库1git clone --recursive https://github.com/chaconinc/MainProject clone主库后再去clone submodule123git clone https://github.com/chaconinc/MainProjectgit submodule initgit submodule update Git设置Git的全局设置在~/.gitconfig中，单独设置在project/.git/config下。 忽略设置全局在~/.gitignore_global中，单独设置在project/.gitignore下。 设置 commit 的用户和邮箱12git config user.name \"xx\"git config user.email \"xx@xx.com\" 或者直接修改config文件 123[user] name = xxx email = xxx@xxx.com 查看设置项1git config --list 设置git终端颜色123git config --global color.diff autogit config --global color.status autogit config --global color.branch auto","categories":[{"name":"Tips","slug":"Tips","permalink":"http://xichen.pub/categories/Tips/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"http://xichen.pub/tags/Tips/"},{"name":"Git","slug":"Git","permalink":"http://xichen.pub/tags/Git/"}]},{"title":"网页排序算法（三）代数方法求PageRank","slug":"2017-12-08-网页排序算法（三）代数方法求PageRank","date":"2017-12-08T12:22:00.000Z","updated":"2018-03-02T14:52:03.934Z","comments":true,"path":"2017/12/08/2017-12-08-网页排序算法（三）代数方法求PageRank/","link":"","permalink":"http://xichen.pub/2017/12/08/2017-12-08-网页排序算法（三）代数方法求PageRank/","excerpt":"","text":"本文结合实例介绍如何用代数方法求PageRank。 博文《网页排序算法（一）PageRank》介绍了PageRank，计算PageRank可以用迭代的方法也可以用代数的方法，其背后的数学基本运算是一样的，即： $$PR(pi)=\\frac{1−d}{N}+d \\sum{p_j\\in B(p_i)} \\frac{PR(p_j)}{L(p_j)}$$ 下文结合图1介绍如何用代数方法求PageRank。 Fig. 1: PageRanks for a simple network (image from Wikipedia) 为了便于讨论，将图1下方的节点分别标上G, H, I, J, K，如下图所示： Fig. 2: Draw Fig. 1 in NetworkX. 代数方法根据1中的等式，把所有节点都放在一块，可以得到： $$\\begin{bmatrix}PR(p_1) \\PR(p_2) \\\\vdots \\PR(p_3)\\end{bmatrix} =\\begin{bmatrix}{(1-d)/ N} \\{(1-d) / N} \\\\vdots \\{(1-d) / N}\\end{bmatrix} d\\begin{bmatrix}\\ell(p_1,p_1) &amp; \\ell(p_1,p_2) &amp; \\cdots &amp; \\ell(p_1,p_N) \\\\ell(p_2,p_1) &amp; \\ddots &amp; &amp; \\vdots \\\\vdots &amp; &amp; \\ell(p_i,p_j) &amp; \\\\ell(p_N,p_1) &amp; \\cdots &amp; &amp; \\ell(p_N,p_N)\\end{bmatrix}\\begin{bmatrix}PR(p_1) \\PR(p_2) \\\\vdots \\PR(p_3)\\end{bmatrix}$$ 上述等式可以缩写为： $$\\mathbf{R} = d \\mathcal{M}\\mathbf{R} + \\frac{1-d}{N} \\mathbf{1}. (**)$$ 其中，1为N维的列向量，所有元素皆为1。以图1为例，该列向量为，1234567891011121314N = len(G.nodes()) # N = 11column_vector = np.ones((N, 1), dtype=np.int) [[1] [1] [1] [1] [1] [1] [1] [1] [1] [1] [1]] Adjacency function邻接函数（adjacency function）$$\\ell(p_1,p_2)$$组成了矩阵M， $$\\mathcal{M}_{ij} =\\ell(pi,pj) = \\begin{cases} 1 /L(p_j) , &amp; \\mbox{if }j\\mbox{ links to }i\\ L(pj)是指从pj链出去的网页数目\\ 0, &amp; \\mbox{otherwise} \\end{cases}$$ 这样矩阵每一行乘以R，就得到了新的PR值，比如第二行（图1的节点B）， $$\\begin{align}M_{2j} &amp;=\\ell(p_2,p_1)⋅PR(p_2)+\\ell(p_2,p_2)⋅PR(p_2)+⋯+\\ell(p_2,p_N)⋅PR(p_2)\\&amp;=0 (‘A’)+0 (‘B’)+1 (‘C’)+12 (‘D’)+13 (‘E’)+12 (‘F’) +12 (‘G’)+12 (`H’)+12 (‘I’)+0 (‘J’)+0 (‘K’) \\end{align}$$ 以节点G为例，G给B和E投票，所以B得到1/2。 矩阵M每一列加起来都是1（值得注意的是，对于没有出链的节点，列加起来等于0，比如图1的节点A），即$$\\sum_{i=1}^{N}\\ell(p_i,p_j)=1$$。事实上，M是一个转移矩阵transition matrix（也叫概率矩阵probability matrix，马尔可夫矩阵Markov matrix）。因此，PageRank是eigenvector centrality的一个变体。 矩阵M事实上，M可以被看成normalized的图邻接矩阵，即： $$M=(K^{−1}A)^T$$其中，A为图的邻接矩阵，以图1为例，12345678910111213141516# Get adjacency matrixnodelist = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K'] # sorted(G.nodes())A = nx.to_numpy_matrix(G, nodelist) 'A' 'B' 'C' 'D' 'E' 'F' 'G' 'H' 'I' 'J' 'K'[[ 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [ 0. 0. 1. 0. 0. 0. 0. 0. 0. 0. 0.] [ 0. 1. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [ 1. 1. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [ 0. 1. 0. 1. 0. 1. 0. 0. 0. 0. 0.] [ 0. 1. 0. 0. 1. 0. 0. 0. 0. 0. 0.] [ 0. 1. 0. 0. 1. 0. 0. 0. 0. 0. 0.] [ 0. 1. 0. 0. 1. 0. 0. 0. 0. 0. 0.] [ 0. 1. 0. 0. 1. 0. 0. 0. 0. 0. 0.] [ 0. 0. 0. 0. 1. 0. 0. 0. 0. 0. 0.] [ 0. 0. 0. 0. 1. 0. 0. 0. 0. 0. 0.]] A是对角矩阵，对角线上的元素是对应节点的出度。123456789101112131415nodelist = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K'] # sorted(G.nodes())list_outdegree = map(operator.itemgetter(1), sorted(G.out_degree().items()))K = np.diag(list_outdegree) [[0 0 0 0 0 0 0 0 0 0 0] [0 1 0 0 0 0 0 0 0 0 0] [0 0 1 0 0 0 0 0 0 0 0] [0 0 0 2 0 0 0 0 0 0 0] [0 0 0 0 3 0 0 0 0 0 0] [0 0 0 0 0 2 0 0 0 0 0] [0 0 0 0 0 0 2 0 0 0 0] [0 0 0 0 0 0 0 2 0 0 0] [0 0 0 0 0 0 0 0 2 0 0] [0 0 0 0 0 0 0 0 0 1 0] [0 0 0 0 0 0 0 0 0 0 1]] K的逆矩阵$$K^{-1}$$为，12345678910111213K_inv = np.linalg.pinv(K) [[ 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. ] [ 0. 1. 0. 0. 0. 0. 0. 0. 0. 0. 0. ] [ 0. 0. 1. 0. 0. 0. 0. 0. 0. 0. 0. ] [ 0. 0. 0. 0.5 0. 0. 0. 0. 0. 0. 0. ] [ 0. 0. 0. 0. 0.33 0. 0. 0. 0. 0. 0. ] [ 0. 0. 0. 0. 0. 0.5 0. 0. 0. 0. 0. ] [ 0. 0. 0. 0. 0. 0. 0.5 0. 0. 0. 0. ] [ 0. 0. 0. 0. 0. 0. 0. 0.5 0. 0. 0. ] [ 0. 0. 0. 0. 0. 0. 0. 0. 0.5 0. 0. ] [ 0. 0. 0. 0. 0. 0. 0. 0. 0. 1. 0. ] [ 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 1. ]] 那么，根据公式$$M=(K^{−1}A)^T$$就可以求得M，如下，12345678910111213M = (K_inv * A).transpose() [[ 0. 0. 0. 0.5 0. 0. 0. 0. 0. 0. 0. ] [ 0. 0. 1. 0.5 0.33 0.5 0.5 0.5 0.5 0. 0. ] [ 0. 1. 0. 0. 0. 0. 0. 0. 0. 0. 0. ] [ 0. 0. 0. 0. 0.33 0. 0. 0. 0. 0. 0. ] [ 0. 0. 0. 0. 0. 0.5 0.5 0.5 0.5 1. 1. ] [ 0. 0. 0. 0. 0.33 0. 0. 0. 0. 0. 0. ] [ 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. ] [ 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. ] [ 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. ] [ 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. ] [ 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. ]] 求解R是2.1等式的特征向量（eigenvector），求解等式得： $$\\mathbf{R} = (\\mathbf{I}-d \\mathcal{M})^{-1} \\frac{1-d}{N} \\mathbf{1},$$ 其中$$\\mathbf{I}$$是单位矩阵。123456789101112131415d = 0.85I = np.identity(N)R = np.linalg.pinv(I - d*M) * (1-d)/N * column_vector [[ 0.028] [ 0.324] [ 0.289] [ 0.033] [ 0.068] [ 0.033] [ 0.014] [ 0.014] [ 0.014] [ 0.014] [ 0.014]] 咦，结果怎么跟图1不一样。得到R需要normalized，如此，所有节点的PR加起来才能等于1。12345678910111213R = R/sum(R) # normalized R, so that page ranks sum to 1. [[ 0.033] [ 0.384] [ 0.343] [ 0.039] [ 0.081] [ 0.039] [ 0.016] [ 0.016] [ 0.016] [ 0.016] [ 0.016]] 用NetworkX作出来的图，是这样的： Fig. 3: PageRanks for a simple network Python源代码NetworkX实现了PageRank的代数计算方法nx.pagerank_numpy，源代码在这里。12345678910111213141516171819def pagerank_numpy(G, alpha=0.85, personalization=None, weight='weight', dangling=None): \"\"\"Return the PageRank of the nodes in the graph. \"\"\" if len(G) == 0: return &#123;&#125; M = google_matrix(G, alpha, personalization=personalization, weight=weight, dangling=dangling) # use numpy LAPACK solver eigenvalues, eigenvectors = np.linalg.eig(M.T) ind = eigenvalues.argsort() # eigenvector of largest eigenvalue at ind[-1], normalized largest = np.array(eigenvectors[:, ind[-1]]).flatten().real norm = float(largest.sum()) return dict(zip(G, map(float, largest / norm))) References: [1] StackOverflow: Incorrect PageRank calculation result","categories":[{"name":"算法","slug":"算法","permalink":"http://xichen.pub/categories/算法/"}],"tags":[{"name":"PageRank","slug":"PageRank","permalink":"http://xichen.pub/tags/PageRank/"}]},{"title":"网页排序算法（二）迭代方法求PageRank","slug":"2017-12-07-网页排序算法（二）迭代方法求PageRank","date":"2017-12-07T12:22:00.000Z","updated":"2018-03-02T14:52:03.932Z","comments":true,"path":"2017/12/07/2017-12-07-网页排序算法（二）迭代方法求PageRank/","link":"","permalink":"http://xichen.pub/2017/12/07/2017-12-07-网页排序算法（二）迭代方法求PageRank/","excerpt":"","text":"本文介绍如何用迭代的方法计算PageRank。 PageRank博文《网页排序算法（一）PageRank》介绍了PageRank，计算PageRank可以用迭代的方法也可以用代数的方法，其背后的数学基本运算是一样的，即： $$PR(pi)=\\frac{1−d}{N}+d\\sum{p_j\\in B(p_i)}\\frac{PR(pj)}{L(p_j)}$$ 下文结合图1介绍如何用迭代方法求PageRank。 Fig. 1: PageRanks for a simple network (image from Wikipedia). 为了便于讨论，将图1下方的节点分别标上G, H, I, J, K，如下图所示： Fig. 2: Label nodes in Fig. 1. 迭代方法初始化节点PR值如果没有给节点指定PR初始值，那么每个节点的PR初始化为1/N (N为节点数目)，以图1为例，节点的PR初始值为1/11： Fig. 3: The graph with starting value of PageRank iteration for each node. 相应源代码如下：123# Step 1: Initiate PageRankN = G.number_of_nodes() # N = 11node_and_pr = dict.fromkeys(G, 1.0 / N) 创建随机图（stochastic graph）随机图（stochastic graph）是一个有向带权图，边的权重被normalized，使得每个节点的outedges的权重加起来为1。事实上，边的权重即为$$1/L(p_j)$$，图1的随机图如下： Fig. 4: The stochastic graph 比如，节点D有两条出链，D --&gt; A和D --&gt; B，所以他们的边权重都是0.5。源代码如下：1234stochastic_graph = nx.stochastic_graph(G, weight=weight) # M = 1/L(pj) print(stochastic_graph['D'])&#123;'A': &#123;'Edge Id': u'5', 'weight': 0.5&#125;, 'B': &#123;'Edge Id': u'6', 'weight': 0.5&#125;&#125; 迭代计算遍历所有节点，将每个节点的PR值平均分给其出链的节点，即$$\\sun_{p_j\\in B(p_i)}\\frac{PR(p_j)}{L(p_j)}$$，乘以阻尼系数d，再加上(1−d)/N。源代码如下：1234567891011dangling_value = (1-d)/N for _ in range(max_iter): # for each iteration node_and_prev_pr = node_and_pr node_and_pr = dict.fromkeys(node_and_prev_pr.keys(), 0) for node in node_and_pr: # for each node for out_node in stochastic_graph[node]: # node --&gt; out_node node_and_pr[out_node] += d * node_and_prev_pr[node] * stochastic_graph[node][out_node][weight] # PR(p_i) = d * PR(p_j)&#125;/L(p_j) node_and_pr[node] += dangling_value 第一次迭代结果如下图所示（有些箭头没显示出来，NetworkX可视化很弱）： Fig. 5: PageRank after one ieration 那什么时候程序结束呢。将迭代后的PR值跟前一次比较，如果差别很少（如PR′(A)−PR(A)&lt;1.0e−6PR′(A)−PR(A)&lt;1.0e−6），就可以停止迭代了。源代码如下：1234# check convergence, l1 normerr = sum([abs(node_and_pr[node] - node_and_prev_pr[node]) for node in node_and_pr])if err &lt; N*tol: return node_and_pr 在本例中，需要66次迭代，最后得到的PageRank，如下图： wikipedia_pagerank_example_prFig. 6: Stable PageRank values (66 iterations) 我在想一个问题，上面的方法，每次迭代都是基于上一次的PR值，能不能这样，迭代的时候使用最新的值，这样会不能减少迭代次数，如下所示：1234567# 初始值PA(D) = 0.09PA(B) = 0.09 # 第一次迭代PA(D)/2 --&gt; P(A), P(B) # 此时， PB(B)=0.045PB(B) --&gt; P(C) # 按上面的算法，PB(B)=0.09，那能不能使用刚更新的PR值0.045，这样会不会快一些？ NetworkX的pageranknx.pagerank跟章节2差不多，区别在于：123456# 2中的算法node_and_pr[node] += (1.0 - d)/N # nx.pagerankdanglesum = d * sum(node_and_prev_pr[node] for node in dangling_nodes)node_and_pr[node] += danglesum/N + (1.0 - d)/N # danglesum/N + (1-d)/N nx.pagerank将图中所有悬挂节点（dangling nodes，没有出链的节点，图1只有节点A）的PR累加，并normalized，再加上(1.0–d)/N。","categories":[{"name":"算法","slug":"算法","permalink":"http://xichen.pub/categories/算法/"}],"tags":[{"name":"PageRank","slug":"PageRank","permalink":"http://xichen.pub/tags/PageRank/"}]},{"title":"区块链开发（二）部署并运行以太坊智能合约","slug":"2017-12-06-区块链开发（二）部署并运行以太坊智能合约","date":"2017-12-06T12:21:00.000Z","updated":"2018-03-02T14:52:03.934Z","comments":true,"path":"2017/12/06/2017-12-06-区块链开发（二）部署并运行以太坊智能合约/","link":"","permalink":"http://xichen.pub/2017/12/06/2017-12-06-区块链开发（二）部署并运行以太坊智能合约/","excerpt":"","text":"","categories":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/tags/区块链/"}]},{"title":"区块链开发（零）概念入门","slug":"2017-11-27-区块链开发（零）概念入门","date":"2017-12-06T12:21:00.000Z","updated":"2018-03-02T14:52:03.929Z","comments":true,"path":"2017/12/06/2017-11-27-区块链开发（零）概念入门/","link":"","permalink":"http://xichen.pub/2017/12/06/2017-11-27-区块链开发（零）概念入门/","excerpt":"","text":"概念地址比特币地址（例如：1DSrfJdB2AnWaFNgSbv3MZC2m74996JafV）由一串字符和数字组成，以阿拉伯数字“1”开头。就像别人向你的email地址发送电子邮件一样，他可以通过你的比特币地址向你发送比特币。 可以用 vanitygen 来生成包含一定字母的地址。 BIP比特币改进提议 （Bitcoin Improvement Proposals 的缩写），指比特币社区成员所提交的一系列改进比特币的提议。例如，BIP0021是一项改进比特币统一资源标识符（URI）计划的提议。 比特币“比特币”既可以指这种虚拟货币单位，也指比特币网络或者网络节点使用的比特币软件。 区块一个区块就是若干交易数据的集合，它会被标记上时间戳和之前一个区块的独特标记。区块头经过哈希运算后会生成一份工作量证明，从而验证区块中的交易。有效的区块经过全网络的共识后会被追加到主区块链中。 区块链区块链是一串通过验证的区块，当中的每一个区块都与上一个相连，一直连到创世区块。 确认当一项交易被区块收录时，我们可以说它有一次确认。矿工们在此区块之后每再产生一个区块，此项交易的确认数就再加一。当确认数达到六及以上时，通常认为这笔交易比较安全并难以逆转。 难度整个网络会通过调整“难度”这个变量来控制生成工作量证明所需要的计算力。 难度目标使整个网络的计算力大致每10分钟产生一个区块所需要的难度数值即为难度目标。 难度调整整个网络每产生2,106个区块后会根据之前2,106个区块的算力进行难度调整。 哈希二进制数据的一种数字指纹。 创世区块创世区块指区块链上的第一个区块，用来初始化相应的加密货币。 矿工矿工指通过不断重复哈希运算来产生工作量证明的各网络节点。 挖矿描述挖矿的一个好方法是将之类比为一个巨大的多人数独谜题游戏。一旦有人发现正解之后，这个数独游戏会自动调整困难度以使游戏每次需要大约10分钟解决。想象一个有几千行几千列的巨大数独游戏。如果给你一个已经完成的数独，你可以很快地验证它。然而，如果这个数独只有几个方格里有数字其余方格都为空的话，就会花费非常长的时间来解决。这个数独游戏的困难度可以通过改变其大小（更多或更少行列）来调整，但即使它非常大时验证它也是相当容易的。而比特币中的 “谜题” 是基于哈希加密算法的，其展现了相似的特性：非对称地，它解起来困难而验证很容易，并且它的困难度可以调整。 当区块一个个堆上来时，这个交易变得指数级地越来越难被推翻，因此它在网络中得到更多信任。 矿工费交易的发起者通常会向网络缴纳一笔矿工费，用以处理这笔交易。大多数的交易需要0.5毫比特币的矿工费。 网络比特币网络是一个由若干节点组成的用以广播交易信息和数据区块的P2P网络。 工作量证明工作量证明指通过有效计算得到的一小块数据。具体到比特币，矿工必须要在满足全网目标难度的情况下求解SHA256算法。 奖励每一个新区块中都有一定量新创造的比特币用来奖励算出工作量证明的矿工。现阶段每一区块有25比特币的奖励。 私钥用来解锁对应（钱包）地址的一串字符，例如5J76sF8L5jTtzE96r66Sf8cka9y44wdpJjMwCxR3tzLh3ibVPxh。 交易简单地说，交易指把比特币从一个地址转到另一个地址。更准确地说，一笔“交易”指一个经过签名运算的，表达价值转移的数据结构。每一笔“交易”都经过比特币网络传输，由矿工节点收集并封包至区块中，永久保存在区块链某处。 转出是交易，转入也是交易。 一般交易。一个地址转到另一个地址，用不完会“找零”。 集合型交易。多个地址转向一个地址，钱包用来汇合零钱。 分散型交易。一个转向多个，如发工资。 交易的输出会被创建成为一个包含这笔数额的脚本的形式，只能被引入这个脚本的一个解答后才能兑换。 钱包钱包指保存比特币地址和私钥的软件，可以用它来接受、发送、储存你的比特币。 比特币地址以数字1或3开头。类似于电子邮件地址，这些地址可以分享给其他的比特币的用户，这样他们就可以直接通过这些地址发送比特币到你的钱包里。不同于电邮地址的是，你可以任意地创建新的比特币地址，这些地址都能成功地将资金转到你的钱包。 钱包是多个地址和解锁资金密钥的简单集合。每笔交易你都可以使用不同的地址，这有利于提高隐私的安全性。用户可创建地址的数量几乎不受限制。 一个地址对应一个秘钥，像支付宝的付款码，其在支付宝后台也有一个对应的秘钥，验证交易。 直到这个地址接收到在比特币账簿（区块链）中公布过的一笔交易时，才会成为众多可能“有效”的比特币地址之一。 介绍平均每10分钟就有人能验证过去这10分钟发生的交易，他将会获得新币作为工作回报。本质上，挖矿把央行的货币发行和结算功能进行分布式，用全球化的算力竞争来取代对中央发行机构的需求。 比特币系统包含调节挖矿难度的协议。挖矿——在比特币网络中成功写入一个区块交易——的难度是动态调整的，保证不管有多少矿工（多少CPU）挖矿，平均每10分钟只有一个矿工成功。 任何接受数字货币的人都面临的两个基本问题是： 我能相信这钱是真实可信的，而不是伪造的吗？我能确定没人说这笔钱是他们的，而不是我的吗？（又名“双重支付”问题） 比特币代表了数十年的密码学和分布式系统的巅峰之作，这是一个独特而强大的组合，汇集了四个关键的创新点。比特币由这些构成： 一个去中心化的点对点网络（比特币协议） 一个公共的交易账簿（区块链） 一个去中心化的数学的和确定性的货币发行（分布式挖矿） 一个去中心化的交易验证系统（交易脚本） 使用http://blockchain.info/ 可以查看所有交易信息 参考 http://zhibimo.com/read/wang-miao/mastering-bitcoin","categories":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/tags/区块链/"}]},{"title":"网页排序算法（一）PageRank","slug":"2017-12-05-网页排序算法（一）PageRank","date":"2017-12-05T12:22:00.000Z","updated":"2018-03-02T14:52:03.929Z","comments":true,"path":"2017/12/05/2017-12-05-网页排序算法（一）PageRank/","link":"","permalink":"http://xichen.pub/2017/12/05/2017-12-05-网页排序算法（一）PageRank/","excerpt":"","text":"参加数学建模的时候要研究一下PageRank，为了巩固3天从入门到精通的成果，把了解到的整理成文。 直观理解基本思想PageRank是以Google创始人Larry Page的姓命名的，于1999被提出来，用于测量网页的相对重要性（对网页进行排序），学术论文如下： Page, L., Brin, S., Motwani, R., &amp; Winograd, T. (1999). The PageRank citation ranking: Bringing order to the web. Stanford InfoLab. [PDF] PageRank的设计受到学术论文引用启发（两人的父亲都是大学教授）。衡量一篇学术论文质量高与否，最重要的一个指标是引用次数，高引用量的论文通常意味着高质量。同理，如果一张网页被引用（以超链接的形式）多了，那么这张网页就比较重要。总结起来，PageRank的核心思想有两点（结合图1说明）： 越多的网页链接到一个网页（可以理解成投票，D --&gt; B，D给B投了一票），说明这个网页更加重要，如图1的B。(一篇论文被很多论文引用) PageRank高的网页链接到一个网页，说明这张网页也很重要。如图1，尽管C只有一张网页B链接到它，但C的重要性高于E，尽管E有一堆小罗罗给它投票。（论文被大牛引用了，说明这篇论文很有价值）（也可以从话语权角度理解，重要的人说话份量重） Fig. 1: PageRanks for a simple network (image from Wikipedia) 整个万维网（World Wide Web）可以抽象成一张有向图，节点表示网页，连线$$p_i\\to p_j$$表示网页$$p_i$$包含了超链接$$p_j$$（$$p_i$$指向了$$p_j$$）。如果能对图中每个节点重要性量化，那么就能对网页进行排序了。PageRank提出之初就是为了对网页进行排序。 搜索引擎的工作原理可以简化为：输入关键词，返回与该关键词相关的网页（一个集合，相当于得到一张子图），在该子图上计算每个节点的PageRank值，PR值高的网页排在前面，低的就排在后面。 如何计算接下来的问题是，如何计算每个节点的PageRank。想要知道一个网页$$p_i$$的PR值，需要知道： 有多少网页链接到了$$p_i$$ 这些网页的PR值是多少其他网页的PR值又很可能是依赖于$$p_i$$，这就陷入了“先有鸡还是先有蛋”的循环，要想知道$$p_i$$的PR值，就得知道链向$$p_i$$所有网页的PR值，而要知道其他网页的PR值，又得先知道$$p_i$$的PR值。 为了打破这个循环，佩奇和布林采用了一个很巧妙的思路， 即分析一个虚拟用户在互联网上的漫游过程。 他们假定：虚拟用户一旦访问了一个网页，下一步将以相同的概率访问被该网页所链接的任何一个其它网页[3]。比如，网页$$p_i$$包含N个超链接，那么虚拟用户访问这N个页面中的任何一个的概率是1/N。那么，网页的排序就可以看成一个虚拟用户在万维网漫游了很长时间，页面被访问的概率越大，其PR值就越高，网页排名也越靠前。 先从简化的PageRank说起，以PageRank论文的例子为例，看看PageRank是怎么计算的，如下： Fig. 2: Simplified PageRank calculation (image from [1]) 每个节点初始化或者指定一个PageRank值（如PR(A)=0.4），网页A包含两个超链接，分别指向B和C（或者说A投票给B和C），0.4拆分成两份，每份0.2，所以PR(B)=0.2。A和B同时给C投票，所以PR(C)=0.2+0.2=0.4。如此，不断地迭代，最后每个节点的值会趋于稳定（或者说收敛），这样就求得了所有节点的PR值。事实上，在这个例子中，PageRank已收俭。 每个页面将其当前的PageRank值平均分配到本页面所有出链上，一个页面将所有入链的PR值累加起来就构成了该页面新的PR值。如此迭代下去，最后得到一个稳定值。用数学公式表达，如下： $$PR(A)=\\frac{PR(B)}{L(B)}+\\frac{PR(C)}{L(C)}+\\frac{PR(D)}{L(D)}+⋯$$ 更一般化地（$$B(p_i)$$表示所有链向网页$$p_i$$的集合）， $$PR(pi)=\\sum_{p_j\\in B(p_i)}\\frac{PR(p_j)}{L(p_j)}$$ 但这样算存在两个问题： 对于没有forward links (outedges)的网页，即只有别人给她投票，她从不给别人投票，那么她的PageRank每次迭代都会增加。 对于没有blacklinks (inedges)的网页，即没人给她投票，其PageRank永远等于0。 对于第一个问题，给等式乘以一个小于1的常数d（damping factor，翻译成阻尼因数？）；对于第二个问题，给等式加上一个常数。新的等式如下（N表示网页总数，或者节点数目）： $$PR(pi)=\\frac{1−d}{N}+d\\sum{p_j\\in B(p_i)}\\frac{PR(p_j)}{L(p_j)}$$ 其中， $$B(p_i)$$：链接到网页pipi的集合（a set of pages link to pipi） $$L(p_j)$$：从$$p_j$$链出去的网页数目（the number of outbound links）这样，就确保所有节点的PR值加起来等于1。 一个简单实例以一个很简单的例子（A &lt; --&gt; B）来看PageRank是怎么收俭的。 Fig. 2: An illustration of PageRank calculation. 假设他们的初始PR值为1，第一次迭代后，PR(A)和PR(B)的值为：12PR(A) = 0.15/2 + 0.85*1.0 = 0.9249999999999999PR(B) = 0.15/2 + 0.85*0.9249999999999999 = 0.8612499999999998 写个简单的Python脚本，得到每次迭代后的值，部分如下：12345678910111213141516171819202122232425 1: A=0.925000 B=0.861250 2: A=0.807062 B=0.761003 3: A=0.721853 B=0.688575 4: A=0.660289 B=0.636245 5: A=0.615808 B=0.598437 6: A=0.583672 B=0.571121 7: A=0.560453 B=0.551385 8: A=0.543677 B=0.537126 9: A=0.531557 B=0.526823 10: A=0.522800 B=0.519380 11: A=0.516473 B=0.514002 12: A=0.511902 B=0.510116 13: A=0.508599 B=0.50730914: A=0.506213 B=0.505281 15: A=0.504489 B=0.503815 16: A=0.503243 B=0.502757 17: A=0.502343 B=0.501992 18: A=0.501693 B=0.501439 19: A=0.501223 B=0.501040 20: A=0.500884 B=0.500751...42: A=0.500001 B=0.500001 43: A=0.500001 B=0.500000 44: A=0.500000 B=0.500000 45: A=0.500000 B=0.500000 可见，随着迭代次数的增加，PageRank越来越接近收俭值0.5。Python源代码如下：12345678910111213def pagerank_ab(): \"\"\" Calculate PageRank for A &lt;--&gt; B \"\"\" pr = &#123;'A':1.0, 'B':1.0&#125; max_iter = 50 for idx in range(1, max_iter+1): pr['A'] = 0.15/2 + 0.85*pr['B'] pr['B'] = 0.15/2 + 0.85*pr['A'] s = '&#123;:3d&#125;: A=&#123;:&lt;10f&#125;\\tB=&#123;:&lt;10f&#125;'.format(idx, pr['A'], pr['B']) print(s) 迭代次数迭代次数越多，结果越准确，但花费时间也越长。出于效率考虑，在实际应用中，当PR值落在误差允许范围内（PR值跟前一次比较，如PR′(A)−PR(A)&lt;1.0e−6PR′(A)−PR(A)&lt;1.0e−6，想想浮点数在计算机的存储），就可以返回结果了。Python实现的nx.pagerank相关源代码如下：1234# check convergence, l1 normerr = sum([abs(x[n] - xlast[n]) for n in x])if err &lt; N*tol: # tol=1.0e-6 return x 当然，对于超大型网络来说，有更复杂的计算方法，比如分布式。 PR初始值不管节点PR初始值怎么设置，最后节点的PR值都一样，但收俭速度不一样。可以修改上面Python代码的PR初始值，运行代码，自行感受下。NetworkX的pagerank实现是将PR值初始化为1/N。 Damping factor跟PR初始值类似，d的取值也会影响算法效率。根据Page的论文，d通常设为0.85。 PageRank计算方法(1) 迭代方法 详情见另一篇博文《网页排序算法（二）迭代方法求PageRank》。 （2）代数方法 详情见另一篇博文《网页排序算法（三）代数方法求PageRank》。 （3）Power Method 待续。 用NetworkX求PageRankNetworkX提供3个求PageRank的API，如下： pagerank(…) pagerank_numpy(…) pagerank_scipy(…) 详细API如下： 12345pagerank(G, alpha=0.85, personalization=None, max_iter=100, tol=1e-06, nstart=None, weight='weight', dangling=None) pagerank_numpy(G, alpha=0.85, personalization=None, weight='weight', dangling=None) pagerank_scipy(G, alpha=0.85, personalization=None, max_iter=100, tol=1e-06, weight='weight', dangling=None) References: [1] Page, L., Brin, S., Motwani, R., &amp; Winograd, T. (1999). The PageRank citation ranking: Bringing order to the web. Stanford InfoLab. [PDF] [2] PageRank Centrality by Massimo Franceschet [3] 谷歌背后的数学 by 卢昌海 [4] Wikipedia: PageRank [5] The Google Pagerank Algorithm and How It Works","categories":[{"name":"算法","slug":"算法","permalink":"http://xichen.pub/categories/算法/"}],"tags":[{"name":"PageRank","slug":"PageRank","permalink":"http://xichen.pub/tags/PageRank/"}]},{"title":"迪菲-赫尔曼密钥交换","slug":"2017-12-01-迪菲-赫尔曼密钥交换","date":"2017-12-01T13:52:00.000Z","updated":"2018-03-02T14:52:03.922Z","comments":true,"path":"2017/12/01/2017-12-01-迪菲-赫尔曼密钥交换/","link":"","permalink":"http://xichen.pub/2017/12/01/2017-12-01-迪菲-赫尔曼密钥交换/","excerpt":"","text":"迪菲-赫尔曼密钥交换（英语：Diffie–Hellman key exchange，缩写为D-H）最简单，最早提出的这个协议使用一个质数$p$的整数模$n$乘法群以及其原根$g$。 迪菲-赫尔曼密钥交换 算法如下（绿色表示非秘密信息, 红色粗体表示秘密信息）： 爱丽丝与鲍伯协定使用 $$p=23$$以及base $$g=5$$. 爱丽丝选择一个秘密整数$$a=6$$, 计算$$A = g^a mod p$$并发送给鲍伯。 $$A = 56 mod 23 = 8$$. 鲍伯选择一个秘密整数$$b=15$$, 计算$$B = g^b mod p$$并发送给爱丽丝。 $$B = 515 mod 23 = 19$$. 爱丽丝计算$$s = B^a mod p$$ $$196 mod 23 = 2$$. 鲍伯计算$$s = A^b mod p$$ $$815 mod 23 = 2$$. 以下是一个更为一般的描述: 爱丽丝和鲍伯写上一个有限循环群 $$G$$ 和它的一个生成元 $$g$$。 （这通常在协议开始很久以前就已经规定好； $$g$$是公开的，并可以被所有的攻击者看到。） 爱丽丝选择一个随机自然数 $$a$$ 并且将$${\\displaystyle g^{a}{\\bmod {p}}} g^{a} \\bmod{p}$$发送给鲍伯。 鲍伯选择一个随机自然数 $$b$$ 并且将$${\\displaystyle g^{b}{\\bmod {p}}} g^{b} \\bmod{p}$$发送给爱丽丝。 爱丽丝 计算 $${\\displaystyle \\left(g^{b}\\right)^{a}{\\bmod {p}}} \\left ( g^{b} \\right )^{a} \\bmod{p} $$。 鲍伯 计算 $${\\displaystyle \\left(g^{a}\\right)^{b}{\\bmod {p}}} \\left ( g^{a} \\right )^{b} \\bmod{p} $$。 爱丽丝和鲍伯就同时协商出群元素$$ {\\displaystyle g^{ab}} g^{ab} $$，它可以被用作共享秘密。$${\\displaystyle \\left(g^{b}\\right)^{a}} \\left ( g^{b} \\right )^{a} = {\\displaystyle \\left(g^{a}\\right)^{b}} \\left ( g^{a} \\right )^{b}$$因为群是乘法交换的。","categories":[{"name":"密码学","slug":"密码学","permalink":"http://xichen.pub/categories/密码学/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"http://xichen.pub/tags/密码学/"}]},{"title":"区块链开发（一）搭建环境-基于以太坊私有链","slug":"2017-11-30-区块链开发（一）搭建环境-基于以太坊私有链","date":"2017-11-30T13:52:00.000Z","updated":"2018-03-02T14:52:03.926Z","comments":true,"path":"2017/11/30/2017-11-30-区块链开发（一）搭建环境-基于以太坊私有链/","link":"","permalink":"http://xichen.pub/2017/11/30/2017-11-30-区块链开发（一）搭建环境-基于以太坊私有链/","excerpt":"","text":"安装Geth和MistUbuntu下安装Geth客户端之所以采用Ubuntu，是因为以太坊的官方对Ubuntu支持的很好，是在各个linux系统中安装最简单。 Geth官方安装指南：https://github.com/ethereum/go-ethereum/wiki/Building-Ethereum 进入ubuntu命令行，执行如下命令123456$ sudo apt-get update$ sudo apt-get installsoftware-properties-common$ sudo add-apt-repository -yppa:ethereum/ethereum$ sudo add-apt-repository -yppa:ethereum/ethereum-dev$ sudo apt-get update$ sudo apt-get install ethereum 系统联网执行后，即完成了安装以太坊客户端，其中包括geth,bootnode,evm,disasm,rlpdump,ethtest此时如果输入 geth 命令，会出现启动以太坊启动的画面 也可以源码编译安装1234$ git clone https://github.com/ethereum/go-ethereum$ sudo apt-get install -y build-essential golang$ cd go-ethereum$ make geth Windows下安装Geth客户端下载并安装 Geth for Windows.Windows必须64位系统，从官方网站下载编译好的win64客户端，解压缩即可运行，下载地址如下（第二个地址备选）： https://github.com/ethereum/go-ethereum/releases/https://geth.ethereum.org/downloads/ 下载后，只有一个Geth.exe的文件。 MAC OSX下安装Geth客户端首先确保已安装homebrew，没有安装过的可以在命令行下执行/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;进行安装12$ brew tap ethereum/ethereum$ brew install ethereum 安装图像化客户端Mist依然是从官方地址下载编译好的客户端即可，下载地址： https://github.com/ethereum/mist/releases/ 下载解压缩后，Ethereum-Wallet 即为以太坊图形化界面。 准备创世块文件配置自己的创世块是为了区分公有链，同一个网络中，创世块必须是一样的，否则无法联通，此方法在windows和Ubuntu下通用。新建文件piccgenesis.json,输入如下内容并保存1234567891011121314151617&#123; \"config\": &#123; \"chainId\": 123456, \"homesteadBlock\": 0, \"eip155Block\": 0, \"eip158Block\": 0 &#125;, \"nonce\": \"0x0000000000000042\", \"difficulty\": \"0x020000\", \"mixhash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"coinbase\": \"0x0000000000000000000000000000000000000000\", \"timestamp\": \"0x00\", \"parentHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"extraData\": \"0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa\", \"gasLimit\": \"0x4c4b40\", \"alloc\": &#123;&#125;&#125; 解释一下各个参数的作用： 参数 作用 mixhash 与nonce配合用于挖矿，由上一个区块的一部分生成的hash。注意他和nonce的设置需要满足以太坊的Yellow paper, 4.3.4. Block Header Validity, (44)章节所描述的条件。. nonce nonce就是一个64位随机数，用于挖矿，注意他和mixhash的设置需要满足以太坊的Yellow paper, 4.3.4. Block Header Validity, (44)章节所描述的条件。 difficulty 设置当前区块的难度，如果难度过大，cpu挖矿就很难，这里设置较小难度 alloc 用来预置账号以及账号的以太币数量，因为私有链挖矿比较容易，所以我们不需要预置有币的账号，需要的时候自己创建即可以。 coinbase 矿工的账号，随便填 timestamp 设置创世块的时间戳 parentHash 上一个区块的hash值，因为是创世块，所以这个值是0 extraData 附加信息，随便填，可以填你的个性信息 gasLimit 该值设置对GAS的消耗总量限制，用来限制区块能包含的交易信息总和，因为我们是私有链，所以填最大。 启动私有链节点启动Geth即可以启动以太坊的区块链，为了构建私有链 ，需要在Geth启动时加入一些参数，Geth参数含义如下： 参数 作用 identity 区块链的标示，随便填写，用于标示目前网络的名字 init 指定创世块文件的位置，并创建初始块 datadir 设置当前区块链网络数据存放的位置 port 网络监听端口 rpc 启动rpc通信，可以进行智能合约的部署和调试 rpcapi 设置允许连接的rpc的客户端，一般为db,eth,net,web3 networkid 设置当前区块链的网络ID，用于区分不同的网络，是一个数字 console 启动命令行模式，可以在Geth中执行命令 在Ubuntu启动区块链节点在Ubuntu下，首先切换到打算运行的目录，目录下应该有配置好的piccgenesis.json文件，获取当前的目录：1$ basepath=$(cd `dirname $0`; pwd) 创建数据存放地址并初始化创世块：1$ geth --datadir \"$basepath/chain\" init piccgenesis.json 启动节点：1$ geth --identity \"PICCetherum\" --rpc --rpccorsdomain \"*\" --datadir \"$basepath/chain\" --port \"30303\" --rpcapi \"db,eth,net,web3\" --networkid 95518 console 启动后界面如下，光标停留在最后的命令行上，可以执行以太坊命令。1234567891011121314151617181920212223I0707 00:45:43.680087 ethdb/database.go:82]Alloted 128MB cache and 1024 file handles to /home/lihe/桌面/chain/chaindataI0707 00:45:43.726008ethdb/database.go:169] closed db:/home/lihe/桌面/chain/chaindataI0707 00:45:43.728913 ethdb/database.go:82]Alloted 128MB cache and 1024 file handles to /home/lihe/桌面/chain/chaindataI0707 00:45:43.908795 ethdb/database.go:82]Alloted 16MB cache and 16 file handles to /home/lihe/桌面/chain/dappI0707 00:45:43.969506 core/genesis.go:92]Genesis block already in chain. Writing canonical numberI0707 00:45:43.980337 eth/backend.go:274]Successfully wrote custom genesis block:6e92f8b23bcdfdf34dc813cfaf1d84b71beac80530506b5d63a2df10fe23a660I0707 00:45:43.980618 eth/backend.go:184]Protocol Versions: [63 62], Network Id: 95518I0707 00:45:43.981567core/blockchain.go:204] Last header: #81 [6193c4b0…] TD=10836704I0707 00:45:43.981645core/blockchain.go:205] Last block: #81 [6193c4b0…] TD=10836704I0707 00:45:43.981677core/blockchain.go:206] Fast block: #81 [6193c4b0…] TD=10836704I0707 00:45:43.985253 p2p/server.go:313]Starting ServerI0707 00:45:45.834488p2p/discover/udp.go:217] Listening,enode://134881790e54c803955715e3661c27f91caaf499be813e29c9f986e2eac62d47e02b13a8e51776c1caea554655614ed26ce0185d84e626da7ac48a83a60113ff@[::]:30303I0707 00:45:45.835853 node/node.go:366]HTTP endpoint opened: http://localhost:8545I0707 00:45:45.848008 p2p/server.go:556]Listening on [::]:30303I0707 00:45:45.849731 node/node.go:296] IPCendpoint opened: /home/lihe/桌面/chain/geth.ipcWelcome to the Geth JavaScript console! instance:Geth/v1.5.0-unstable/linux/go1.5.1/PICCetherumcoinbase:0x93509a2f4b2b974b07ef0b52e07c3992601f5de1at block: 81 (Tue, 05 Jul 2016 21:02:25CST) datadir: /home/lihe/桌面/chain modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0&gt; 可以看到Listening on [::]:30303和Welcome to the Geth JavaScript console!的提示，说明已经启动成功 注意：如果想将Ubuntu作为永久区块链节点使用，当使用nohup命令时，Geth启动参数console必须去掉，否则Geth会自动停止。 在windows启动区块链节点进入Windows下Geth的目录 ，放置配置好的piccgenesis.json文件，执行如下命令：1$ geth --datadir \"%cd%\\chain\" init piccgenesis.json 创建数据存放地址并初始化创世块1$ geth--identity \"PICCetherum\" --rpc--rpccorsdomain \"*\" --datadir \"%cd%\\chain\" --port\"30303\" --rpcapi\"db,eth,net,web3\" --networkid 95518 console 当看到Listening on [::]:30303和Welcome to the Geth JavaScript console!的提示，说明已经启动成功 使用节点创建账号启动节点成功后，会进入Geth的命令行模式，输入如下命令1personal.newAccount() 系统会提示你输入账号密码，并确认，最后会显示一个新生成的账号。 Geth JavaScript控制台环境使用说明 创建新账号personal.newAccount()或者 personal.newAccount(&quot;123456&quot;) 查看节点信息admin.nodeInfo 挖矿 开始挖矿miner.start(1) 停止挖矿miner.stop() 查看当前矿工账号eth.coinbase 默认为第一个账户 修改矿工账号miner.setEtherbase(eth.accounts[1]) 查看账户信息eth.accounts[0] 查看账户余额eth.getBalance(eth.accounts[0])或者 web3.fromWei(eth.getBalance(eth.accounts[0]), &quot;ether&quot;) 解锁账号personal.unlockAccount(eth.accounts[0])使用账户资金前都需要先解锁账号 转账eth.sendTransaction({from:eth.accounts[0],to:&quot;0x587e57a516730381958f86703b1f8e970ff445d9&quot;,value:web3.toWei(3,&quot;ether&quot;)})使用 txpool.status可以看到交易状态 查看区块数据 eth.blockNumber eth.getTransaction(&quot;0x0c59f431068937cbe9e230483bc79f59bd7146edc8ff5ec37fea6710adcab825&quot;) eth.getBlock(1) 通过区块号查看区块 私有链图形节点启动Ubuntu下私有链图形节点首先按上面的步骤启动Geth并创建了账号，在geth运行的时候，再运行下面的命令1ethereumwallet --gethpath /usr/bin/geth --gethpath改成你实际安装的geth的路径 启动Windows下私有链图形节点首先按上面的步骤启动Geth并创建了账号，然后解压缩Ethereum-Wallet，运行Ethereum-Wallet.exe,即启动成功，如果区块链正常的话，会在右上角显示“PRIVATE-NET”，点击“LAUNCH APPLICATION”进入图形界面即可。 连接其他节点首先要知道自己的节点信息，在Geth命令行界面下输入命令,注意大小写1admin.nodeInfo 系统会显示1enode:\"enode://1e3c1727cd3bee9f25edeb5dbb3b880e03e41f8eec99566557f3ee0422734a8fcad17c161aa93d61bdbfb28ed152c143c7eb501db58bc63502a104a84b62d742@0.0.0.0:30303“ 其中enode://1e3c1727cd3bee9f25edeb5dbb3b880e03e41f8eec99566557f3ee0422734a8fcad17c161aa93d61bdbfb28ed152c143c7eb501db58bc63502a104a84b62d742@0.0.0.0:30303就是自己节点的信息，注意要把0.0.0.0换成你自己的IP。将这个信息发送给其他节点，在其他节点的命令行中输入：1admin.addPeer(‘enode://1e3c1727cd3bee9f25edeb5dbb3b880e03e41f8eec99566557f3ee0422734a8fcad17c161aa93d61bdbfb28ed152c143c7eb501db58bc63502a104a84b62d742@192.168.1.101:30303’) 如果添加成功，输入admin.peers会显示出新添加的节点。 使用节点进行挖矿在Geth命令行界面下，输入miner.start()即启动挖矿，挖矿后，会不停刷屏，输入miner.stop()即停止，不用管刷屏导致的命令不全，命令会正常执行。到这一步，已经组建一个私有链的网络，可以像其他区块链一样不停的扩充这个网络，下一篇文章，我会介绍如何在私有链上编写、调试和部署智能合约。 参考文章： http://blog.csdn.net/sportshark/article/details/51855007 http://tech.lab.carl.pro/kb/ethereum/testnet_setup http://www.ethdocs.org/en/latest/network/test-networks.html#setting-up-a-local-private-testnet https://github.com/ethereum/go-ethereum/wiki/Connecting-to-the-network https://github.com/ethereum/go-ethereum/wiki/JavaScript-Console https://github.com/ethereum/go-ethereum/wiki/Mining https://github.com/ethereum/go-ethereum/wiki/Managing-your-accounts https://github.com/janx/ethereum-bootstrap https://forum.qtum.org/topic/127/以太坊私链与智能合约部署入门教程/2","categories":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/tags/区块链/"}]},{"title":"ubuntu--apt-get update（由于没有公钥，无法验证下列签名）","slug":"2017-11-29-apt-get-update-GPG错误","date":"2017-11-29T13:52:00.000Z","updated":"2018-03-02T14:52:03.915Z","comments":true,"path":"2017/11/29/2017-11-29-apt-get-update-GPG错误/","link":"","permalink":"http://xichen.pub/2017/11/29/2017-11-29-apt-get-update-GPG错误/","excerpt":"","text":"当 apt-get update 更新后，出现下面错误时的解决方法：123...bash正在读取软件包列表… 完成 W: GPG 错误：http://ppa.launchpad.net trusty InRelease: 由于没有公钥，无法验证下列签名： NO_PUBKEY 2EA8F35793D8809A 解决办法:1$ sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys E298A3A825C0D65DFD57CBB651716619E084DAB9 结果：12345Executing: gpg –ignore-time-conflict –no-options –no-default-keyring –secret-keyring /tmp/tmp.uxUmi4wF1r –trustdb-name /etc/apt/trustdb.gpg –keyring /etc/apt/trusted.gpg –primary-keyring /etc/apt/trusted.gpg –keyserver keyserver.ubuntu.com –recv-keys 2EA8F35793D8809A gpg: 下载密钥‘93D8809A’，从 hkp 服务器 keyserver.ubuntu.com gpg: 密钥 93D8809A：公钥“Launchpad PPA for Martin Wimpress”已导入 gpg: 合计被处理的数量：1 gpg: 已导入：1 (RSA: 1)","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://xichen.pub/categories/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://xichen.pub/tags/Ubuntu/"}]},{"title":"Go 爬虫总结","slug":"2017-11-27-go爬虫总结","date":"2017-11-27T13:52:00.000Z","updated":"2018-03-02T14:52:03.923Z","comments":true,"path":"2017/11/27/2017-11-27-go爬虫总结/","link":"","permalink":"http://xichen.pub/2017/11/27/2017-11-27-go爬虫总结/","excerpt":"","text":"爬虫目的：爬导航和爬商品 爬虫架构： electron虚拟浏览器 proxy代理ip dashboard网页端调控 爬虫APP 实现的功能： url拼接，过滤出商品 url翻页，点击翻页，无限流，loadmore按钮 过滤文本中包含某text的url，过滤url中包含某url的url，定点过滤特定的url，只爬文本中包含某text的url，只爬url中包含某url的url 失败移至末尾重试（次数，本次返回的状态码，延时） 控制爬取频率，控制递归爬取深度 用electron防止cookie或ajax动态加载页面，有WaitSelector，直到WaitSelector出现才返回渲染后的页面给spider，否则返回错误码 分布式，高并发 多个proxy负载均衡 proxy权限控制 dashboard网页端爬虫调度，导航log和简单报表分析，商品log和简单报表分析，服务器上当前所有配置一览 我负责的模块： 配置文件template 测试被反爬虫的条件，计算最大爬取频率 实现同时爬取多个网站，单线程和并发可选 默认 http client 不会缓存 DNS 记录，而爬虫会有大量的请求，所以自己专门对 DNS 做缓存 调查并分析站点请求不成功的url占比超过 20% 的原因并修复 发现并解决 ssl 证书问题 网站改版，及时更新配置文件 给timeout设一个下界 返回408原因：（1）商品Selector作为WaitSelector，有的页面是介绍页，没有商品，返回408（2）翻页超过最大页数，没有商品，返回408。这个原因导致的408一般 成堆 出现（3）无限流需要较长时间来翻页，timeout较小会408（4）目标网站有的商品下架，没有商品，返回408（5）目标网站反爬策略，封ip后也不返回500，只有提示性的html，等不到商品，返回408（6）目标网站必须用https 解决方案：（这几个印象深刻，其他的想不起来了） 商品Selector作为WaitSelector，有的页面是介绍页，没有商品，返回408 有2个waitSelector，一个Selector做监督，一个选商品Selector，如果监督Selector出现了而商品Selector没出来，就判定没商品 效果好 时间成本高 只要1个errorSelector，出现提示性的error，判定为没有商品 实现简单，时间成本低，逻辑清晰 不全面，有些站点如果没有商品，也不出现提示性文字 electron不处理，无论是否408都把页面返回，交给spider处理 electron端实现简单，效果好，易于扩展 spider端实现困难，给spider端挖坑，有隐患 ssl 证书问题 请求时不检测证书 http 请求 换成https请求 getsockopt: no route to host 和firewall有关，我们对昂贵的proxy做权限控制，而我在本地没有这个proxy的权限，必须到服务器上搞 getsockopt: connection time out 需要特殊的header，不然在命令行是不能成功请求的 DNS解析 原来的每次都要new一个，修复后只要一个持久化 团队共享用到的软件（我们都是远程办公） slack:交流讨论 quip：共享文件 trello：任务管理 zoom：远程会议 google图表：共享文件","categories":[{"name":"Spider","slug":"Spider","permalink":"http://xichen.pub/categories/Spider/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://xichen.pub/tags/Go/"},{"name":"Spider","slug":"Spider","permalink":"http://xichen.pub/tags/Spider/"}]},{"title":"Ubuntu中使用dpkg安装deb文件提示依赖关系问题，仍未被配置","slug":"2017-10-11-dpkg-error","date":"2017-10-14T17:54:00.000Z","updated":"2018-01-27T09:32:55.344Z","comments":true,"path":"2017/10/15/2017-10-11-dpkg-error/","link":"","permalink":"http://xichen.pub/2017/10/15/2017-10-11-dpkg-error/","excerpt":"","text":"使用dpkg时，提示：dpkg：处理软件包XXX时出错：依赖关系问题，仍未被配置 问题 出现上图时，使用如下命令1sudo apt-get install -f 解决 等分析完之后，重新使用dpkg –i XXX.deb，就可以了 解决","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://xichen.pub/categories/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://xichen.pub/tags/Ubuntu/"}]},{"title":"Python Tweepy 翻墙抓取Twitter信息","slug":"2017-10-11-python-proxy","date":"2017-10-13T02:13:00.000Z","updated":"2018-01-27T09:32:51.713Z","comments":true,"path":"2017/10/13/2017-10-11-python-proxy/","link":"","permalink":"http://xichen.pub/2017/10/13/2017-10-11-python-proxy/","excerpt":"","text":"repo在此，如果觉得做得好，给个star鼓励下吧！ 在看《Python数据挖掘入门与实践》的时候，随书附带的代码已经过时几年了，现在边看书边修，很是辛苦 在学习第六章”使用朴素贝叶斯进行社交媒体挖掘”时，数据集需要通过twitter的API来获取 （玛蛋，为毛不随书附带数据集） twitter在国内被墙了，只能翻墙 浏览器翻墙容易，弄个lantern或者shadowsockets就可以了 但是，由于ubuntu的代理不是全局代理，在命令行中翻墙要设proxy，在代码中翻墙也要设proxy 所以难处在于代码要就twitter的python接口翻墙 如果只是一个简单的加proxy网络请求，几行就可以搞定： 12import urllib.requestproxy_support = urllib.request.ProxyHandler(&#123;'http' : 'http://127.0.0.1:80'&#125;) 可是twitter的python接口是自动发起请求的呀 懒得去改源码 只好看看怎么在代码中设置好翻墙 账号准备首先需要在twitter官方注册twitter账号，并新建一个应用，链接：新建应用如果新建应用不成功，国内大多数情况都是无法验证手机号，可以参考这个教程，亲测有效，链接：验证手机号注册成功后，可以查看自己的keys and access token，如下图： Consumer Key and Consumer Secret Access Token and Access Token Secret 环境准备python3.5+ 安装tweepy： 在命令行中输入：pip install tweepy 发起请求12345678910111213141516# -*- coding: utf-8 -*-import tweepyfrom tweepy import OAuthHandlerconsumer_key = 'replace your own account consumer_key'consumer_secret = 'replace your own account consumer_secret'access_token = 'replace your own account access_token'access_secret = 'replace your own account access_secret'auth = OAuthHandler(consumer_key,consumer_secret)auth.set_access_token(access_token,access_secret)api = tweepy.API(auth)for status in tweepy.Cursor(api.home_timeline).items(2): print (status.text) 报错一:挂代理翻墙报错信息如下： 1tweepy.error.TweepError: Failed to send request: HTTPSConnectionPool(host='api.twitter.com', port=443): Max retries exceeded with url: /1.1/statuses/home_timeline.json (Caused by ProxyError('Cannot connect to proxy.', NewConnectionError('&lt;requests.packages.urllib3.connection.VerifiedHTTPSConnection object at 0x0000000002FC6E80&gt;: Failed to establish a new connection: [Errno 10061] ',))) 主要原因就是twitter被墙了，twitter的api当然也被墙了。 这时候就需要挂代理翻墙了，我使用的是自己搭建的shadowsockets。其它翻墙软件或者服务器网上有很多，请自行查找。 代理打开了之后，在原代码中，将1api = tweepy.API(auth) 改为1api = tweepy.API(auth,proxy=\"127.0.0.1:1080\") 报错二:请求的配置没有写对报错信息如下： 1tweepy.error.TweepError: Twitter error response: status code = 401 原因： 这几个发起请求的配置没有写对，仔细修改 consumer_key consumer_secret access_token access_secret 改过了还是不对，刷新Regenerate Consumer Key and Secret和Regenerate My Access Token and Token Secret，重新填写请求 报错三报错信息如下： 1tweepy.error.TweepError: Failed to send request: HTTPSConnectionPool(host='api.twitter.com', port=443): Max retries exceeded with url: /1.1/statuses/home_timeline.json (Caused by ProxyError('Cannot connect to proxy.', timeout('timed out',))) 原因是Shadowsocks使用的是socks5代理，并非是http代理。 emmm，简单，大手一挥，稍微修改一下即可 1api = tweepy.API(auth, proxy=\"socks5://127.0.0.1:1080\") 报错四报错信息如下： 1tweepy.error.TweepError: Failed to send request: SOCKSHTTPSConnectionPool(host='api.twitter.com', port=443): Read timed out. (read timeout=60) 原因是tweepy使用的是http代理，不能用socks5代理（我日）。 所以需要将socks5代理转换为http代理来支持tweepy访问twitter REST API,这里参考以下地址：为终端设置Shadowsocks代理 最后不要忘记在代码里加上代理： 1api = tweepy.API(auth, proxy=\"127.0.0.1:8123\") 还没完 tweepy 这个库的资料比较少,我自己摸索着试了试,把代码发上来 一.按照关键字搜索Twitter的内容 12345678910#接上面的代码(q = 关键字 ,count = 返回的数据量 . 推特一次最多返回100条??)search_results = api.search(q='python',count=100)#对对象进行迭代for tweet in search_results: #tweet还是一个对象,推特的相关信息在tweer._json里 #这里是检测消息是否含有'text'键,并不是所有TWitter返回的所有对象都是消息(有些可能是用来删除消息或者其他内容的动作--这个没有确认),区别就是消息对象中是否含有'text'键 if 'text' in tweet._json: print(tweet._json['text']) #这里是把内容给打印出来了,如果需要保存到文件需要用json库的dumps函数转换为字符串形式后写入到文件中 #例如 :output_file.write(json.dumps(tweet._json)) 二.根据Twitter消息的ID批量获取消息12#其中id_list 是消息ID组成的list 长度也不要超过100search_result = api.statuses_lookup(id_list) 这时，就可以成功访问了 成功访问","categories":[{"name":"Proxy","slug":"Proxy","permalink":"http://xichen.pub/categories/Proxy/"}],"tags":[{"name":"Proxy","slug":"Proxy","permalink":"http://xichen.pub/tags/Proxy/"},{"name":"Python","slug":"Python","permalink":"http://xichen.pub/tags/Python/"}]},{"title":"algorithms-Bit-Options","slug":"2017-10-11-算法之位运算","date":"2017-10-11T06:25:00.000Z","updated":"2018-01-27T09:32:44.761Z","comments":true,"path":"2017/10/11/2017-10-11-算法之位运算/","link":"","permalink":"http://xichen.pub/2017/10/11/2017-10-11-算法之位运算/","excerpt":"","text":"算法常用的一个等式：-n = ~(n - 1) = ~n + 1 获得int型最大值123456int getMaxInt()&#123; return (1 &lt;&lt; 31) - 1;//2147483647,由于优先级关系,括号不可省略 return ~(1 &lt;&lt; 31); //2147483647 return (1 &lt;&lt; -1) - 1;//2147483647 return ((unsigned int) - 1) &gt;&gt; 1;//2147483647&#125; 获得int型最小值1234int getMinInt()&#123; return 1 &lt;&lt; 31;//-2147483648 return 1 &lt;&lt; -1;//-2147483648&#125; 获得long类型的最大值1234long getMaxLong()&#123; return ((unsigned long) - 1) &gt;&gt; 1;//2147483647 c语言版 return ((long)1 &lt;&lt; 127) - 1;//9223372036854775807 java版&#125; 获得long最小值，和其他类型的最大值，最小值同理. 2运算1234n &lt;&lt; 1 // 乘以2n &gt;&gt; 1 // 除以2n &lt;&lt; m // 乘以2的m次方n &gt;&gt; m // 除以2的m次方 判断一个数的奇偶性123boolean isOddNumber(int n)&#123; return (n &amp; 1) == 1;&#125; 不用临时变量交换两个数（面试常考）123void swap(int *a,int *b)&#123; (*a) ^= (*b) ^= (*a) ^= (*b);&#125; 通用版（一些语言中得分开写）123a ^= b;b ^= a;a ^= b; 取绝对值（某些机器上，效率比n&gt;0 ? n:-n 高） 123456int abs(int n)&#123; return (n ^ (n &gt;&gt; 31)) - (n &gt;&gt; 31);/* n&gt;&gt;31 取得n的符号，若n为正数，n&gt;&gt;31等于0，若n为负数，n&gt;&gt;31等于-1 若n为正数 n^0=0,数不变，若n为负数有n^-1 需要计算n和-1的补码，然后进行异或运算， 结果n变号并且为n的绝对值减1，再减去-1就是绝对值 */&#125; 取两个数的最大值（某些机器上，效率比a&gt;b ? a:b高） 1234int max(int a,int b)&#123; return b &amp; ((a-b) &gt;&gt; 31) | a &amp; (~(a-b) &gt;&gt; 31); /*如果a&gt;=b,(a-b)&gt;&gt;31为0，否则为-1*/&#125; C语言版12345int max(int x,int y)&#123; return x ^ ((x ^ y) &amp; -(x &lt; y)); /*如果x&lt;y x&lt;y返回1，否则返回0， 与0做与运算结果为0，与-1做与运算结果不变*/&#125; 取两个数的最小值（某些机器上，效率比a&gt;b ? b:a高） 1234int min(int a,int b)&#123; return a &amp; ((a-b) &gt;&gt; 31) | b &amp; (~(a-b) &gt;&gt; 31); /*如果a&gt;=b,(a-b)&gt;&gt;31为0，否则为-1*/&#125; C语言版12345int min(int x,int y)&#123; return y ^ ((x ^ y) &amp; -(x &lt; y)); /*如果x&lt;y x&lt;y返回1，否则返回0， 与0做与运算结果为0，与-1做与运算结果不变*/&#125; 判断符号是否相同123boolean isSameSign(int x, int y)&#123; //有0的情况例外 return (x ^ y) &gt;= 0; // true 表示 x和y有相同的符号， false表示x，y有相反的符号。&#125; 计算2的n次方123int getFactorialofTwo(int n)&#123;//n &gt; 0 return 2 &lt;&lt; (n-1);//2的n次方&#125; 判断一个数是不是2的幂12345boolean isFactorialofTwo(int n)&#123; return n &gt; 0 ? (n &amp; (n - 1)) == 0 : false; /*如果是2的幂，n一定是100... n-1就是1111.... 所以做与运算结果为0*/&#125; 对2的n次方取余12345int quyu(int m,int n)&#123;//n为2的次方 return m &amp; (n - 1); /*如果是2的幂，n一定是100... n-1就是1111.... 所以做与运算结果保留m在n范围的非0的位*/&#125; 求两个整数的平均值12345678int getAverage(int x, int y)&#123; return (x + y) &gt;&gt; 1;&#125;int getAverage(int x, int y)&#123; return ((x ^ y) &gt;&gt; 1) + (x &amp; y); /*(x^y) &gt;&gt; 1得到x，y其中一个为1的位并除以2， x&amp;y得到x，y都为1的部分，加一起就是平均数了*/&#125; 下面是三个最基本对二进制位的操作 从低位到高位,取n的第m位123int getBit(int n, int m)&#123; return (n &gt;&gt; (m-1)) &amp; 1;&#125; 从低位到高位.将n的第m位置设为112345int setBitToOne(int n, int m)&#123; return n | (1 &lt;&lt; (m-1)); /*将1左移m-1位找到第m位，得到000...1...000 n在和这个数做或运算*/&#125; 从低位到高位,将n的第m位置设为012345int setBitToZero(int n, int m)&#123; return n &amp; ~(1 &lt;&lt; (m-1)); /* 将1左移m-1位找到第m位，取反后变成111...0...1111 n再和这个数做与运算*/&#125; 另附一些对程序效率上没有实质提高的位运算技巧，一些也是位运算的常识（面试也许会遇到）123456n+1 = -~nn-1 = ~-n-n = ~n+1-n = (n^-1)+1x = a ^ b ^ x &lt;=&gt; if(x == a) x = b; if(x == b) x = a;sign(x) = !!n - (((unsigned)n &gt;&gt; 31) &lt;&lt; 1) 获取整数二进制表示中最右侧的11n &amp; (-n) &lt;=&gt; n &amp; ~(n - 1) 二进制中1的个数用到了n &amp; (n - 1)由x &amp; (x - 1)消去x最后一位的1可知。不断使用 x &amp; (x - 1) 消去x最后一位的1，计算总共消去了多少次即可。12345678int countOnes(int num) &#123; int count = 0; while(num != 0) &#123; num = num &amp; (num-1); count++; &#125; return count;&#125; 翻转123456789// 翻转unsigned int Bit_Reverse(unsigned int v) &#123; v = ((v &gt;&gt; 1) &amp; 0x55555555) | ((v &lt;&lt; 1) &amp; 0xaaaaaaaa); v = ((v &gt;&gt; 2) &amp; 0x33333333) | ((v &lt;&lt; 2) &amp; 0xcccccccc); v = ((v &gt;&gt; 4) &amp; 0x0f0f0f0f) | ((v &lt;&lt; 4) &amp; 0xf0f0f0f0); v = ((v &gt;&gt; 8) &amp; 0x00ff00ff) | ((v &lt;&lt; 8) &amp; 0xff00ff00); v = ((v &gt;&gt; 16) &amp; 0x0000ffff) | ((v &lt;&lt; 16) &amp; 0xffff0000); return v;&#125; 输入两个数A和B，输出将A转换为B所需改变的二进制的位数。首先，A异或B得到的是A和B中不相同位数组成的数，然后再求这个数二进制表示中1的个数，即为所求。1countOnes(A^B); 数组中只出现一次的数字用到了n &amp; (n - 1) 和 a ^ b ^ b = a 数组中，只有一个数出现一次，剩下都出现两次，找出出现一次的数因为只有一个数恰好出现一个，剩下的都出现过两次，所以只要将所有的数异或起来，就可以得到唯一的那个数。参考文章：http://zhedahht.blog.163.com/blog/static/2541117420071128950682/ 数组中，只有一个数出现一次，剩下都出现三次，找出出现一次的数因为数是出现三次的，也就是说，对于每一个二进制位，如果只出现一次的数在该二进制位为1，那么这个二进制位在全部数字中出现次数无法被3整除。 膜3运算只有三种状态：00,01,10，因此我们可以使用两个位来表示当前位%3，对于每一位，我们让Two，One表示当前位的状态，B表示输入数字的对应位，Two+和One+表示输出状态。 参考文章：http://zhedahht.blog.163.com/blog/static/25411174201283084246412/ 数组中，只有两个数出现一次，剩下都出现两次，找出出现一次的数有了第一题的基本的思路，我们可以将数组分成两个部分，每个部分里只有一个元素出现一次，其余元素都出现两次。那么使用这种方法就可以找出这两个元素了。不妨假设出现一个的两个元素是x，y，那么最终所有的元素异或的结果就是res = x^y。并且res！=0，那么我们可以找出res二进制表示中的某一位是1。对于原来的数组，我们可以根据这个位置是不是1就可以将数组分成两个部分。x，y在不同的两个子数组中。而且对于其他成对出现的元素，要么在x所在的那个数组，要么在y所在的那个数组。 位操作实现加减乘除运算12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//加法int BinaryAdd(int a, int b) &#123; int carry, add; do &#123; add = a ^ b; //该操作得到本位的加法结果 carry = (a &amp; b) &lt;&lt; 1; //该操作得到该位对高位的进位值 a = add; b = carry; &#125; while (carry != 0); //循环直到某次运算没有进位，运算结束 return add;&#125;//减法int BinarySub(int a, int b) &#123; return BinaryAdd(a, BinaryAdd(~b, 1));&#125;/*乘法 该过程中的bit_map是为了快速得到乘法过程中某位相乘的中间结果S[i] 需要位移的位数。bit_map的键值是2^0, 2^1,2^2, ……之类的数，对应的 值是0，1,2,……(即需要位移的位数)。 */int BinaryMultiply(int a, int b) &#123; bool neg = (b &lt; 0); if(b &lt; 0) b = -b; int sum = 0; map&lt;int, int&gt; bit_map; for(int i = 0; i &lt; 32; i++) &#123; bit_map.insert(pair&lt;int, int&gt;(1 &lt;&lt; i, i)); &#125; while(b &gt; 0) &#123; /* b &amp; ~(b - 1)可以得到乘数b的二进制表示中最右侧1的位置 last_bit记录被乘数a需要位移的位数 */ int last_bit = bit_map[b &amp; ~(b - 1)]; //将得到的乘法结果全部相加即为最后结果 sum += (a &lt;&lt; last_bit); b &amp;= b - 1; //每次将b的二进制表示的最右侧1去掉用于下一次乘法 &#125; if(neg) sum = -sum; return sum;&#125;//除法int BinaryDivide(int a, int b)&#123; bool neg = (a &gt; 0) ^ (b &gt; 0); if(a &lt; 0) a = -a; if(b &lt; 0) b = -b; if(a &lt; b) return 0; int msb = 0; //msd记录除数需要左移的位数 for(msb = 0; msb &lt; 32; msb++) &#123; if((b &lt;&lt; msb) &gt;= a) break; &#125; int q = 0; //记录每次除法的商 for(int i = msb; i &gt;= 0; i--) &#123; if((b &lt;&lt; i) &gt; a) continue; q |= (1 &lt;&lt; i); a -= (b &lt;&lt; i); &#125; if(neg) return -q; return q;&#125; reference: 优秀程序员不得不知道的20个位运算技巧http://blog.csdn.net/zmazon/article/details/8262185 位操作实现加减乘除四则运算http://blog.csdn.net/u013074465/article/details/42680239","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://xichen.pub/categories/Algorithms/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://xichen.pub/tags/算法/"}]},{"title":"面向过程，面向对象，函数式","slug":"2017-9-18-面向过程-面向对象-函数式","date":"2017-09-17T22:42:14.000Z","updated":"2018-01-05T00:45:28.299Z","comments":true,"path":"2017/09/18/2017-9-18-面向过程-面向对象-函数式/","link":"","permalink":"http://xichen.pub/2017/09/18/2017-9-18-面向过程-面向对象-函数式/","excerpt":"","text":"如何把大象关进冰箱里？面向过程：1把冰箱门打开 =&gt; 大象放冰箱里 =&gt; 冰箱门关上 面向对象：123冰箱.开门（）冰箱.放入（大象）冰箱.关门（） or 1冰箱.开门().放入(大象).关门() 函数式：12关进（冰箱，大象）: 关门（放入（开门（冰箱），大象））","categories":[{"name":"杂思","slug":"杂思","permalink":"http://xichen.pub/categories/杂思/"}],"tags":[{"name":"杂思","slug":"杂思","permalink":"http://xichen.pub/tags/杂思/"}]},{"title":"terminal tips","slug":"2017-08-28-Terminal-tips","date":"2017-08-27T20:46:00.000Z","updated":"2018-01-05T00:45:28.282Z","comments":true,"path":"2017/08/28/2017-08-28-Terminal-tips/","link":"","permalink":"http://xichen.pub/2017/08/28/2017-08-28-Terminal-tips/","excerpt":"","text":"打开 快捷键：Ctrl+Alt-T 空白处右键：有选项在终端打开 处于命令行窗口：Ctrl+T选项卡形式，Ctrl+N窗口形式 颜色颜色代码 前景 背景 颜色 30 40 黑色 31 41 紅色 32 42 綠色 33 43 黃色 34 44 藍色 35 45 紫紅色 36 46 青藍色 37 47 白色 ——- ———– ——— 1 透明色 ——- 代码 意义 0 OFF 1 高亮显示 4 underline 5 闪烁 7 反白显示 8 不可见 序列说明 | \\a | ASCII响铃字符（也可以键入 \\007） | | \\d | “Wed Sep 06”格式的日期 | | \\e | ASCII转义字符（也可以键入 \\033） | | \\h | 主机名的第一部分（如 “mybox”） | | \\H | 主机的全称（如 “mybox.mydomain.com”） | | \\j | 在此 shell中通过按 ^Z挂起的进程数 | | \\l | 此 shell的终端设备名（如 “ttyp4”） | | \\n | 换行符 | | \\r | 回车符 | | \\s | shell的名称（如 “bash”） | | \\t | 24小时制时间（如 “23:01:01”） | | \\T | 12小时制时间（如 “11:01:01”） | | \\@ | 带有 am/pm的 12小时制时间 | | \\u | 用户名 | | \\v | bash的版本（如 2.04） | | \\V | Bash版本（包括补丁级别） ?/td&gt;; | | \\w | 当前工作目录（如 “/home/drobbins”） | | \\W | 当前工作目录的“基名 (basename)”（如 “drobbins”） | | ! | 当前命令在历史缓冲区中的位置 | | # | 命令编号（只要您键入内容，它就会在每次提示时累加） | | \\$ | 如果您不是超级用户 (root)，则插入一个 “$”；如果您是超级用户，则显示一个 “#” | | \\xxx | 插入一个用三位数 xxx（用零代替未使用的数字，如 “/007”）表示的 ASCII 字符 | | \\ | 反斜杠 | | [ | 这个序列应该出现在不移动光标的字符序列（如颜色转义序列）之前。它使 bash能够正确计算自动换行。 | | ] | 这个序列应该出现在非打印字符序列之后。 | 颜色的设置公式1颜色=\\033[代码;前景;背景m 如：\\033[1;32;40m表示高亮显示字体为绿色，背景色为黑色（颜色定义见本文前面的表格） 注意： 要将全部非打印字符用专用的 bash 转义序列 “[“和 “]“括起来。这两个序列通知 bash，被括起来的字符不占用行上的任何空间，这样就使自动换行能够继续正常工作。 这点很关键要不然等你设好了颜色，你的终端换行会乱七八糟 套路默认的就很好看，打开~/.bashrc，其中有几行声明 12345if [ \"$color_prompt\" = yes ]; then PS1='$&#123;debian_chroot:+($debian_chroot)&#125;\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]\\$ 'else PS1='$&#123;debian_chroot:+($debian_chroot)&#125;\\u@\\h:\\w\\$ 'fi 下面这个就是默认的配色方案1PS1='$&#123;debian_chroot:+($debian_chroot)&#125;\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]\\$ ' 要修改配色方案，在文件末尾加上1PS1=`balabala` ROOT身份下的终端颜色打开/root/.bash.rc1vi /root/.bash.rc 按i进入插入字符模式，在文件末尾加上一行(把默认的贴过去)1PS1='$&#123;debian_chroot:+($debian_chroot)&#125;\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]\\$ ' 按下Esc然后输入:wq保存修改 再输入source ~/.bashrc刷新 SSH会话下的终端颜色通过在.bashrc文件中更改与ssh连接的每个主机名上的PS1值 在托管的机器上(lxy @ ubuntu)同样打开文件~/.bashrc1vi ~/.bashrc 在文件末尾加上一行(把默认的贴过去)1PS1='$&#123;debian_chroot:+($debian_chroot)&#125;\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]\\$ ' 按下Esc然后输入:wq保存修改 再输入source ~/.bashrc刷新 zsh安装zsh1sudo apt-get install zsh 安装oh-my-zsh12git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zshcp ~/.oh-my-zsh/tmplates/zshrc.zsh-template ~/.zshrc Powerline 主题1234git clone git://github.com/jeremyFreeAgent/oh-my-zsh-powerline-theme ~/.ohmyzsh-powerlinecd ~/.ohmyzsh-powerlinecp powerline.zsh-theme ~/.oh-my-zsh/themes/powerline.zsh-themerm -rf ~/.ohmyzsh-powerline 把zsh设为默认1chsh -s /bin/zsh 卸载zsh1sudo apt remove zsh 今天手残装了zsh和oh-my-zsh后又卸载掉，导致su进不去1无法执行 /usr/bin/zsh: 没有那个文件或目录 只要把 /usr/bin/zsh 改成 /bin/bash 就可以了1sudo vim /etc/passwd 第一句改成1root:x:0:0:root:/root:/bin/bash 或者直接运行1sudo chsh -s /bin/bashrc","categories":[{"name":"Tips","slug":"Tips","permalink":"http://xichen.pub/categories/Tips/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://xichen.pub/tags/Ubuntu/"},{"name":"Tips","slug":"Tips","permalink":"http://xichen.pub/tags/Tips/"}]},{"title":"Golang并发","slug":"2017-08-28-Golang-concurency","date":"2017-08-27T20:19:00.000Z","updated":"2018-01-05T00:45:28.280Z","comments":true,"path":"2017/08/28/2017-08-28-Golang-concurency/","link":"","permalink":"http://xichen.pub/2017/08/28/2017-08-28-Golang-concurency/","excerpt":"","text":"运行期线程Go允许使用go语句开启一个新的运行期线程，即 goroutine，以一个不同的、新创建的goroutine来执行一个函数。同一个程序中的所有goroutine共享同一个地址空间。 Goroutine非常轻量，除了为之分配的栈空间，其所占用的内存空间微乎其微。并且其栈空间在开始时非常小，之后随着堆存储空间的按需分配或释放而变化。内部实现上，goroutine会在多个操作系统线程上多路复用。如果一个goroutine阻塞了一个操作系统线程，例如：等待输入，这个线程上的其他goroutine就会迁移到其他线程，这样能继续运行。开发者并不需要关心/担心这些细节。 下面所示程序会输出“Hello from main goroutine”。也可能会输出“Hello from another goroutine”，具体依赖于两个goroutine哪个先结束。12345678func main() &#123; go fmt.Println(\"Hello from another goroutine\") fmt.Println(\"Hello from main goroutine\") // 至此，程序运行结束， // 所有活跃的goroutine被杀死&#125;goroutine1.go 接下来的这个程序，多数情况下，会输出“Hello from main goroutine”和“Hello from another goroutine”，输出的顺序不确定。但还有另一个可能性是：第二个goroutine运行得极其慢，在程序结束之前都没来得及输出相应的消息。 1234567func main() &#123; go fmt.Println(\"Hello from another goroutine\") fmt.Println(\"Hello from main goroutine\") time.Sleep(time.Second) // 等待1秒，等另一个goroutine结束&#125;//goroutine2.go 下面则是一个相对更加实际的示例，其中定义了一个函数使用并发来推迟触发一个事件。123456789// 函数Publish在给定时间过期后打印text字符串到标准输出 // 该函数并不会阻塞而是立即返回func Publish(text string, delay time.Duration) &#123; go func() &#123; time.Sleep(delay) fmt.Println(\"BREAKING NEWS:\", text) &#125;() // 注意这里的括号。必须调用匿名函数&#125;//publish1.go 你可能会这样使用Publish函数：12345678910func main() &#123; Publish(\"A goroutine starts a new thread of execution.\", 5*time.Second) fmt.Println(\"Let’s hope the news will published before I leave.\") // 等待发布新闻 time.Sleep(10 * time.Second) fmt.Println(\"Ten seconds later: I’m leaving now.\")&#125;//publish1.go 这个程序，绝大多数情况下，会输出以下三行，顺序固定，每行输出之间相隔5秒。1234$ go run publish1.goLet’s hope the news will published before I leave.BREAKING NEWS: A goroutine starts a new thread of execution.Ten seconds later: I’m leaving now. 一般来说，通过睡眠的方式来编排线程之间相互等待是不太可能的。下一章节会介绍Go语言中的一种同步机制 - 管道，并演示如何使用管道让一个goroutine等待另一个goroutine。 管道（channel）管道是Go语言的一个构件，提供一种机制用于两个goroutine之间通过传递一个指定类型的值来同步运行和通讯。操作符&lt;-用于指定管道的方向，发送或接收。如果未指定方向，则为双向管道。123chan Sushi // 可用来发送和接收Sushi类型的值chan&lt;- float64 // 仅可用来发送float64类型的值&lt;-chan int // 仅可用来接收int类型的值 管道是引用类型，基于make函数来分配。12ic := make(chan int) // 不带缓冲的int类型管道wc := make(chan *Work, 10) // 带缓冲的Work类型指针管道 如果通过管道发送一个值，则将&lt;-作为二元操作符使用。通过管道接收一个值，则将其作为一元操作符使用：12ic &lt;- 3 // 往管道发送3work := &lt;-wc // 从管道接收一个指向Work类型值的指针 如果管道不带缓冲，发送方会阻塞直到接收方从管道中接收了值。如果管道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。 关闭管道（Close） close 函数标志着不会再往某个管道发送值。在调用close之后，并且在之前发送的值都被接收后，接收操作会返回一个零值，不会阻塞。一个多返回值的接收操作会额外返回一个布尔值用来指示返回的值是否发送操作传递的。123456789ch := make(chan string)go func() &#123; ch &lt;- \"Hello!\" close(ch)&#125;()fmt.Println(&lt;-ch) // 输出字符串\"Hello!\"fmt.Println(&lt;-ch) // 输出零值 - 空字符串\"\"，不会阻塞fmt.Println(&lt;-ch) // 再次打印输出空字符串\"\"v, ok := &lt;-ch // 变量v的值为空字符串\"\"，变量ok的值为false 一个带有range子句的for语句会依次读取发往管道的值，直到该管道关闭：123456789101112131415161718func main() &#123; // 译注：要想运行该示例，需要先定义类型Sushi，如type Sushi string var ch &lt;-chan Sushi = Producer() for s := range ch &#123; fmt.Println(\"Consumed\", s) &#125;&#125;func Producer() &lt;-chan Sushi &#123; ch := make(chan Sushi) go func()&#123; ch &lt;- Sushi(\"海老握り\") // Ebi nigiri ch &lt;- Sushi(\"鮪とろ握り\") // Toro nigiri close(ch) &#125;() return ch&#125;//sushi.go 同步下一个示例中，我们让Publish函数返回一个管道 - 用于在发布text变量值时广播一条消息：123456789101112// 在给定时间过期时，Publish函数会打印text变量值到标准输出// 在text变量值发布后，该函数会关闭管道waitfunc Publish(text string, delay time.Duration) (wait &lt;-chan struct&#123;&#125;) &#123; ch := make(chan struct&#123;&#125;) go func() &#123; time.Sleep(delay) fmt.Println(\"BREAKING NEWS:\", text) close(ch) // 广播 - 一个关闭的管道都会发送一个零值 &#125;() return ch&#125;//publish2.go 注意：我们使用了一个空结构体的管道：struct{}。这明确地指明该管道仅用于发信号，而不是传递数据。 我们可能会这样使用这个函数：1234567func main() &#123; wait := Publish(\"Channels let goroutines communicate.\", 5*time.Second) fmt.Println(\"Waiting for the news...\") &lt;-wait fmt.Println(\"The news is out, time to leave.\")&#125;//publish2.go 这个程序会按指定的顺序输出以下三行内容。最后一行在新闻（news）一出就会立即输出。1234$ go run publish2.goWaiting for the news...BREAKING NEWS: Channels let goroutines communicate.The news is out, time to leave. 死锁现在我们在Publish函数中引入一个bug：12345678910func Publish(text string, delay time.Duration) (wait &lt;-chan struct&#123;&#125;) &#123; ch := make(chan struct&#123;&#125;) go func() &#123; time.Sleep(delay) fmt.Println(\"BREAKING NEWS:\", text) // 译注：注意这里将close函数调用注释掉了 //close(ch) &#125;() return ch&#125; 主程序还是像之前一样开始运行：输出第一行，然后等待5秒，这时Publish函数开启的goroutine会输出突发新闻（breaking news），然后退出，留下主goroutine独自等待。1234567func main() &#123; wait := Publish(\"Channels let goroutines communicate.\", 5*time.Second) fmt.Println(\"Waiting for the news...\") // 译注：注意下面这一句 &lt;-wait fmt.Println(\"The news is out, time to leave.\")&#125; 此刻之后，程序无法再继续往下执行。众所周知，这种情形即为死锁。 死锁是线程之间相互等待，其中任何一个都无法向前运行的情形。 Go语言对于运行时的死锁检测具备良好的支持。当没有任何goroutine能够往前执行的情形发生时，Go程序通常会提供详细的错误信息。以下就是我们的问题程序的输出：123456789101112131415Waiting for the news...BREAKING NEWS: Channels let goroutines communicate.fatal error: all goroutines are asleep - deadlock!goroutine 1 [chan receive]:main.main() .../goroutineStop.go:11 +0xf6goroutine 2 [syscall]:created by runtime.main .../go/src/pkg/runtime/proc.c:225goroutine 4 [timer goroutine (idle)]:created by addtimer .../go/src/pkg/runtime/ztime_linux_amd64.c:73 大多数情况下找出Go程序中造成死锁的原因都比较容易，那么剩下的就是如何解决这个bug了。 数据竞争（data race）死锁也许听起来令人挺忧伤的，但伴随并发编程真正灾难性的错误其实是数据竞争，相当常见，也可能非常难于调试。 当两个线程并发地访问同一个变量，并且其中至少一个访问是写操作时，数据竞争就发生了。 下面的这个函数就有数据竞争问题，其行为是未定义的。例如，可能输出数值1。代码之后是一个可能性解释，试图搞清楚这一切是如何发生得。1234567891011121314func race() &#123; wait := make(chan struct&#123;&#125;) n := 0 go func() &#123; // 译注：注意下面这一行 n++ // 一次访问: 读, 递增, 写 close(wait) &#125;() // 译注：注意下面这一行 n++ // 另一次冲突的访问 &lt;-wait fmt.Println(n) // 输出：未指定&#125;//datarace.go 代码中的两个goroutine（假设命名为g1和g2）参与了一次竞争，我们无法获知操作会以何种顺序发生。以下是诸多可能中的一种：1234567g1 从 n 中获取值0g2 从 n 中获取值0g1 将值从0增大到1g1 将1写到 ng2 将值从0增大到1g2 将1写到 n程序输出 n 的值，当前为1 “数据竞争（data race）”这名字有点误导的嫌疑。不仅操作的顺序是未定义的，其实根本没有任何保证（no guarantees whatsoever）。编译器和硬件为了得到更好的性能，经常都会对代码进行上下内外的顺序变换。如果你看到一个线程处于中间行为状态时，那么当时的场景可能就像下图所示的一样： 避免数据竞争的唯一方式是线程间同步访问所有的共享可变数据。有几种方式能够实现这一目标。Go语言中，通常是使用管道或者锁。（sync和sync/atomic包中还有更低层次的机制可供使用，但本文中不做讨论）。 Go语言中，处理并发数据访问的推荐方式是使用管道从一个goroutine中往下一个goroutine传递实际的数据。有格言说得好：“不要通过共享内存来通讯，而是通过通讯来共享内存”。123456789101112func sharingIsCaring() &#123; ch := make(chan int) go func() &#123; n := 0 // 仅为一个goroutine可见的局部变量. n++ ch &lt;- n // 数据从一个goroutine离开... &#125;() n := &lt;-ch // ...然后安全到达另一个goroutine. n++ fmt.Println(n) // 输出: 2&#125;//datarace.go 以上代码中的管道肩负双重责任 - 从一个goroutine将数据传递到另一个goroutine，并且起到同步的作用：发送方goroutine会等待另一个goroutine接收数据，接收方goroutine也会等待另一个goroutine发送数据。 Go语言内存模型 - 要保证一个goroutine中对一个变量的读操作得到的值正好是另一个goroutine中对同一个变量写操作产生的值，条件相当复杂，但goroutine之间只要通过管道来共享所有可变数据，那么就能远离数据竞争了。 互斥锁有时，通过显式加锁，而不是使用管道，来同步数据访问，可能更加便捷。Go语言标准库为这一目的提供了一个互斥锁 - sync.Mutex。 要想这类加锁起效的话，关键之处在于：所有对共享数据的访问，不管读写，仅当goroutine持有锁才能操作。一个goroutine出错就足以破坏掉一个程序，引入数据竞争。 因此，应该设计一个自定义数据结构，具备明确的API，确保所有的同步都在数据结构内部完成。下例中，我们构建了一个安全、易于使用的并发数据结构，AtomicInt，用于存储一个整型值。任意数量的goroutine都能通过Add和Value方法安全地访问这个数值。12345678910111213141516171819202122232425262728293031323334// AtomicInt是一个并发数据结构，持有一个整数值// 该数据结构的零值为0type AtomicInt struct &#123; mu sync.Mutex // 锁，一次仅能被一个goroutine持有。 n int&#125;// Add方法作为一个原子操作将n加到AtomicIntfunc (a *AtomicInt) Add(n int) &#123; a.mu.Lock() // 等待锁释放，然后持有它 a.n += n a.mu.Unlock() // 释放锁&#125;// Value方法返回a的值func (a *AtomicInt) Value() int &#123; a.mu.Lock() n := a.n a.mu.Unlock() return n&#125;func lockItUp() &#123; wait := make(chan struct&#123;&#125;) var n AtomicInt go func() &#123; n.Add(1) // 一个访问 close(wait) &#125;() n.Add(1) // 另一个并发访问 &lt;-wait fmt.Println(n.Value()) // 输出: 2&#125;//datarace.go 检测数据竞争竞争有时非常难于检测。下例中的这个函数有一个数据竞争问题，执行这个程序时会输出55555。尝试一下，也许你会得到一个不同的结果。（sync.WaitGroup是Go语言标准库的一部分；用于等待一组goroutine结束运行。）123456789101112131415func race() &#123; var wg sync.WaitGroup wg.Add(5) // 译注：注意下面这行代码中的i++ for i := 0; i &lt; 5; i++ &#123; go func() &#123; // 注意下一行代码会输出什么？为什么？ fmt.Print(i) // 6个goroutine共享变量i wg.Done() &#125;() &#125; wg.Wait() // 等待所有（5个）goroutine运行结束 fmt.Println()&#125;//raceClosure.go 对于输出55555，一个貌似合理的解释是：执行i++的goroutine在其他goroutine执行打印语句之前就完成了5次i++操作。实际上变量i更新后的值为其他goroutine所见纯属巧合。 一个简单的解决方案是：使用一个局部变量，然后当开启新的goroutine时，将数值作为参数传递：12345678910111213func correct() &#123; var wg sync.WaitGroup wg.Add(5) for i := 0; i &lt; 5; i++ &#123; go func(n int) &#123; // 使用局部变量 fmt.Print(n) wg.Done() &#125;(i) &#125; wg.Wait() fmt.Println()&#125;//raceClosure.go 这次代码就对了，程序会输出期望的结果，如：24031。注意：goroutine之间的运行顺序是不确定的。 仍旧使用闭包，但能够避免数据竞争也是可能的，必须小心翼翼地让每个goroutine使用一个独有的变量。1234567891011121314func alsoCorrect() &#123; var wg sync.WaitGroup wg.Add(5) for i := 0; i &lt; 5; i++ &#123; n := i // 为每个闭包创建一个独有的变量 go func() &#123; fmt.Print(n) wg.Done() &#125;() &#125; wg.Wait() fmt.Println()&#125;//raceClosure.go 数据竞争自动检测一般来说，不太可能能够自动检测发现所有可能的数据竞争情况，但Go（从版本1.1开始）有一个强大的数据竞争检测器。 这个工具用起来也很简单：只要在使用go命令时加上-race标记即可。开启检测器运行上面的程序会给出清晰且信息量大的输出：1234567891011121314151617181920212223242526272829303132$ go run -race raceClosure.goRace:==================WARNING: DATA RACERead by goroutine 2: main.func·001() ../raceClosure.go:22 +0x65Previous write by goroutine 0: main.race() ../raceClosure.go:20 +0x19b main.main() ../raceClosure.go:10 +0x29 runtime.main() ../go/src/pkg/runtime/proc.c:248 +0x91Goroutine 2 (running) created at: main.race() ../raceClosure.go:24 +0x18b main.main() ../raceClosure.go:10 +0x29 runtime.main() ../go/src/pkg/runtime/proc.c:248 +0x91==================55555Correct:01234Also correct:01324Found 1 data race(s)exit status 66 该工具发现一处数据竞争，包含：一个goroutine在第20行对一个变量进行写操作，跟着另一个goroutine在第22行对同一个变量进行了未同步的读操作。 注意：竞争检测器只能发现在运行期确实发生的数据竞争（译注：我也不太理解这话，请指导） Select语句select语句是Go语言并发工具集中的终极工具。select用于从一组可能的通讯中选择一个进一步处理。如果任意一个通讯都可以进一步处理，则从中随机选择一个，执行对应的语句。否则，如果又没有默认分支（default case），select语句则会阻塞，直到其中一个通讯完成。 以下是一个玩具示例，演示select语句如何用于实现一个随机数生成器：1234567891011121314// RandomBits函数 返回一个管道，用于产生一个比特随机序列func RandomBits() &lt;-chan int &#123; ch := make(chan int) go func() &#123; for &#123; select &#123; case ch &lt;- 0: // 注意：分支没有对应的处理语句 case ch &lt;- 1: &#125; &#125; &#125;() return ch&#125;//randBits.go 下面是相对更加实际一点的例子：如何使用select语句为一个操作设置一个时间限制。代码会输出变量news的值或者超时消息，具体依赖于两个接收语句哪个先执行：123456select &#123;case news := &lt;-NewsAgency: fmt.Println(news)case &lt;-time.After(time.Minute): fmt.Println(\"Time out: no news in one minute.\")&#125; 函数 time.After 是Go语言标准库的一部分；它会在等待指定时间后将当前的时间发送到返回的管道中。 综合所有示例花点时间认真研究一下这个示例。如果你完全理解，也就对Go语言中并发的应用方式有了全面的掌握。 这个程序演示了如何将管道用于被任意数量的goroutine发送和接收数据，也演示了如何将select语句用于从多个通讯中选择一个。12345678910111213141516171819202122232425262728func main() &#123; people := []string&#123;\"Anna\", \"Bob\", \"Cody\", \"Dave\", \"Eva\"&#125; match := make(chan string, 1) // 为一个未匹配的发送操作提供空间 wg := new(sync.WaitGroup) wg.Add(len(people)) for _, name := range people &#123; go Seek(name, match, wg) &#125; wg.Wait() select &#123; case name := &lt;-match: fmt.Printf(\"No one received %s’s message.\\n\", name) default: // 没有待处理的发送操作 &#125;&#125;// 函数Seek 发送一个name到match管道或从match管道接收一个peer，结束时通知wait groupfunc Seek(name string, match chan string, wg *sync.WaitGroup) &#123; select &#123; case peer := &lt;-match: fmt.Printf(\"%s sent a message to %s.\\n\", peer, name) case match &lt;- name: // 等待某个goroutine接收我的消息 &#125; wg.Done()&#125;//matching.go 示例输出：1234$ go run matching.goCody sent a message to Bob.Anna sent a message to Eva.No one received Dave’s message. 并行计算并发的一个应用是将一个大的计算切分成一些工作单元，调度到不同的CPU上同时地计算。 将计算分布到多个CPU上更多是一门艺术，而不是一门科学。以下是一些经验法则： 每个工作单元应该花费大约100微秒到1毫秒的时间用于计算。如果单元粒度太小，切分问题以及调度子问题的管理开销可能就会太大。如果单元粒度太大，整个计算也许不得不等待一个慢的工作项结束。这种缓慢可能因为多种原因而产生，比如：调度、其他进程的中断或者糟糕的内存布局。（注意：工作单元的数目是不依赖于CPU的数目的） 尽可能减小共享的数据量。并发写操作的代价非常大，特别是如果goroutine运行在不同的CPU上。读操作之间的数据共享则通常不会是个问题。 数据访问尽量利用良好的局部性。如果数据能保持在缓存中，数据加载和存储将会快得多得多，这对于写操作也格外地重要。 下面的这个示例展示如何切分一个开销很大的计算并将其分布在所有可用的CPU上进行计算。先看一下有待优化的代码：1234567891011121314151617181920212223type Vector []float64// 函数Convolve 计算 w = u * v，其中 w[k] = Σ u[i]*v[j], i + j = k// 先决条件：len(u) &gt; 0, len(v) &gt; 0func Convolve(u, v Vector) (w Vector) &#123; n := len(u) + len(v) - 1 w = make(Vector, n) for k := 0; k &lt; n; k++ &#123; w[k] = mul(u, v, k) &#125; return&#125;// 函数mul 返回 Σ u[i]*v[j], i + j = k.func mul(u, v Vector, k int) (res float64) &#123; n := min(k+1, len(u)) j := min(k, len(v)-1) for i := k - j; i &lt; n; i, j = i+1, j-1 &#123; res += u[i] * v[j] &#125; return&#125; 思路很简单：确定合适大小的工作单元，然后在不同的goroutine中执行每个工作单元。以下是并发版本的 Convolve：123456789101112131415161718192021222324252627func Convolve(u, v Vector) (w Vector) &#123; n := len(u) + len(v) - 1 w = make(Vector, n) // 将 w 切分成花费 ~100μs-1ms 用于计算的工作单元 size := max(1, 1&lt;&lt;20/n) wg := new(sync.WaitGroup) wg.Add(1 + (n-1)/size) for i := 0; i &lt; n &amp;&amp; i &gt;= 0; i += size &#123; // 整型溢出后 i &lt; 0 j := i + size if j &gt; n || j &lt; 0 &#123; // 整型溢出后 j &lt; 0 j = n &#125; // 这些goroutine共享内存，但是只读 go func(i, j int) &#123; for k := i; k &lt; j; k++ &#123; w[k] = mul(u, v, k) &#125; wg.Done() &#125;(i, j) &#125; wg.Wait() return&#125;//convolution.go 工作单元定义之后，通常情况下最好将调度工作交给运行时和操作系统。然而，对于Go 1.* 你也许需要告诉运行时希望多少个goroutine来同时地运行代码。1234func init() &#123; numcpu := runtime.NumCPU() runtime.GOMAXPROCS(numcpu) // 尝试使用所有可用的CPU&#125;","categories":[{"name":"GO","slug":"GO","permalink":"http://xichen.pub/categories/GO/"}],"tags":[{"name":"GO","slug":"GO","permalink":"http://xichen.pub/tags/GO/"}]},{"title":"Golang程序配置方案小结","slug":"2017-08-28-Golang-setting","date":"2017-08-27T20:19:00.000Z","updated":"2018-01-05T00:45:28.281Z","comments":true,"path":"2017/08/28/2017-08-28-Golang-setting/","link":"","permalink":"http://xichen.pub/2017/08/28/2017-08-28-Golang-setting/","excerpt":"","text":"背景无论使用任何编程语言开发应用，都离不开配置数据。配置数据提供的形式有多样，不外乎命令行选项(options)、参数（parameters)，环境 变量（env vars)以及配置文件等。Golang也不例外。Golang内置flag标准库，可以用来支持部分命令行选项和参数的解析；Golang通过os包提 供的方法可以获取当前环境变量；但Golang没有规定标准配置文件格式(虽说内置支持xml、json)，多通过第三方 包来解决配置文件读取的问题。Golang配置相关的第三方包邮很多，作者在本文中给出的配置方案中就包含了主流的第三方配置数据操作包。 一个良好的应用配置层次应该是这样的： 程序内内置配置项的初始默认值 配置文件中的配置项值可以覆盖(override)程序内配置项的默认值。 命令行选项和参数值具有最高优先级，可以override前两层的配置项值。 下面循序渐进探讨golang程序配置方案。 解析命令行选项和参数这一节关注golang程序如何访问命令行选项和参数。 golang对访问到命令行参数提供了内建的支持：1234567891011121314151617181920212223//cmdlineargs.gopackage mainimport ( // \"fmt\" \"os\" \"path/filepath\")func main() &#123; println(\"I am \", os.Args[0]) baseName := filepath.Base(os.Args[0]) println(\"The base name is \", baseName) // The length of array a can be discovered using the built-in function len println(\"Argument # is \", len(os.Args)) // the first command line arguments if len(os.Args) &gt; 1 &#123; println(\"The first command line argument: \", os.Args[1]) &#125;&#125; 执行结果如下：123456$go build cmdlineargs.go$cmdlineargs test oneI am cmdlineargsThe base name is cmdlineargsArgument # is 3The first command line argument: test 对于命令行结构复杂一些的程序，我们最起码要用到golang标准库内置的flag包：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//cmdlineflag.gopackage mainimport ( \"flag\" \"fmt\" \"os\" \"strconv\")var ( // main operation modes write = flag.Bool(\"w\", false, \"write result back instead of stdout\\n\\t\\tDefault: No write back\") // layout control tabWidth = flag.Int(\"tabwidth\", 8, \"tab width\\n\\t\\tDefault: Standard\") // debugging cpuprofile = flag.String(\"cpuprofile\", \"\", \"write cpu profile to this file\\n\\t\\tDefault: no default\"))func usage() &#123; // Fprintf allows us to print to a specifed file handle or stream fmt.Fprintf(os.Stderr, \"\\nUsage: %s [flags] file [path ...]\\n\\n\", \"CommandLineFlag\") // os.Args[0] flag.PrintDefaults() os.Exit(0)&#125;func main() &#123; fmt.Printf(\"Before parsing the flags\\n\") fmt.Printf(\"T: %d\\nW: %s\\nC: '%s'\\n\", *tabWidth, strconv.FormatBool(*write), *cpuprofile) flag.Usage = usage flag.Parse() // There is also a mandatory non-flag arguments if len(flag.Args()) &lt; 1 &#123; usage() &#125; fmt.Printf(\"Testing the flag package\\n\") fmt.Printf(\"T: %d\\nW: %s\\nC: '%s'\\n\", *tabWidth, strconv.FormatBool(*write), *cpuprofile) for index, element := range flag.Args() &#123; fmt.Printf(\"I: %d C: '%s'\\n\", index, element) &#125;&#125; 这个例子中： 说明了三种类型标志的用法：Int、String和Bool。 说明了每个标志的定义都由类型、命令行选项文本、默认值以及含义解释组成。 最后说明了如何处理标志选项(flag option)以及非option参数。 不带参数运行：1234567891011121314$cmdlineflagBefore parsing the flagsT: 8W: falseC: ''Usage: CommandLineFlag [flags] file [path ...] -cpuprofile=\"\": write cpu profile to this file Default: no default -tabwidth=8: tab width Default: Standard -w=false: write result back instead of stdout Default: No write back 带命令行标志以及参数运行(一个没有flag，一个有两个flag)：12345678910111213141516171819202122$cmdlineflag aa bbBefore parsing the flagsT: 8W: falseC: ''Testing the flag packageT: 8W: falseC: ''I: 0 C: 'aa'I: 1 C: 'bb'$cmdlineflag -tabwidth=2 -w aaBefore parsing the flagsT: 8W: falseC: ''Testing the flag packageT: 2W: trueC: ''I: 0 C: 'aa' 从例子可以看出，简单情形下，你无需编写自己的命令行parser或使用第三方包，使用go内建的flag包即可以很好的完成工作。但是golang的 flag包与命令行Parser的事实标准：Posix getopt（C/C++/Perl/Shell脚本都可用）相比，还有较大差距，主要体现在： 无法支持区分long option和short option，比如：-h和–help。 不支持short options合并，比如：ls -l -h &lt;=&gt; ls -hl 命令行标志的位置不能任意放置，比如无法放在non-flag parameter的后面。 不过毕竟flag是golang内置标准库包，你无须付出任何cost，就能使用它的功能。另外支持bool型的flag也是其一大亮点。 TOML，Go配置文件的事实标准（这个可能不能得到认同）命令行虽然是一种可选的配置方案，但更多的时候，我们使用配置文件来存储静态的配置数据。就像Java配xml，ruby配yaml，windows配 ini，Go也有自己的搭配组合，那就是TOML（Tom’s Obvious, Minimal Language）。 初看toml语法有些类似windows ini，但细致研究你会发现它远比ini强大的多，下面是一个toml配置文件例子：123456789101112131415161718192021222324252627282930313233# This is a TOML document. Boom.title = \"TOML Example\"[owner]name = \"Lance Uppercut\"dob = 1979-05-27T07:32:00-08:00 # First class dates? Why not?[database]server = \"192.168.1.1\"ports = [ 8001, 8001, 8002 ]connection_max = 5000enabled = true[servers] # You can indent as you please. Tabs or spaces. TOML don't care. [servers.alpha] ip = \"10.0.0.1\" dc = \"eqdc10\" [servers.beta] ip = \"10.0.0.2\" dc = \"eqdc10\"[clients]data = [ [\"gamma\", \"delta\"], [1, 2] ]# Line breaks are OK when inside arrayshosts = [ \"alpha\", \"omega\"] 看起来很强大，也很复杂，但解析起来却很简单。以下面这个toml 文件为例：12345Age = 25Cats = [ \"Cauchy\", \"Plato\" ]Pi = 3.14Perfection = [ 6, 28, 496, 8128 ]DOB = 1987-07-05T05:45:00Z 和所有其他配置文件parser类似，这个配置文件中的数据可以被直接解析成一个golang struct：1234567type Config struct &#123; Age int Cats []string Pi float64 Perfection []int DOB time.Time // requires `import time`&#125; 其解析的步骤也很简单：1234var conf Configif _, err := toml.Decode(tomlData, &amp;conf); err != nil &#123; // handle error&#125; 是不是简单的不能简单了！ 不过toml也有其不足之处。想想如果你需要使用命令行选项的参数值来覆盖这些配置文件中的选项，你应该怎么做？事实上，我们常常会碰到类似下面这种三层配置结构的情况： 程序内内置配置项的初始默认值 配置文件中的配置项值可以覆盖(override)程序内配置项的默认值。 命令行选项和参数值具有最高优先级，可以override前两层的配置项值。 在go中，toml映射的结果体字段没有初始值。而且go内建flag包也没有将命令行参数值解析为一个go结构体，而是零散的变量。这些可以通过第三方工具来解决，但如果你不想用第三方工具，你也可以像下面这样自己解决，虽然难看一些。1234567891011121314151617181920212223242526func ConfigGet() *Config &#123; var err error var cf *Config = NewConfig() // set default values defined in the program cf.ConfigFromFlag() //log.Printf(\"P: %d, B: '%s', F: '%s'\\n\", cf.MaxProcs, cf.Webapp.Path) // Load config file, from flag or env (if specified) _, err = cf.ConfigFromFile(*configFile, os.Getenv(\"APPCONFIG\")) if err != nil &#123; log.Fatal(err) &#125; //log.Printf(\"P: %d, B: '%s', F: '%s'\\n\", cf.MaxProcs, cf.Webapp.Path) // Override values from command line flags cf.ConfigToFlag() flag.Usage = usage flag.Parse() cf.ConfigFromFlag() //log.Printf(\"P: %d, B: '%s', F: '%s'\\n\", cf.MaxProcs, cf.Webapp.Path) cf.ConfigApply() return cf&#125; 就像上面代码中那样，你需要： 用命令行标志默认值设置配置(cf)默认值。 接下来加载配置文件 用配置值(cf)覆盖命令行标志变量值 解析命令行参数 用命令行标志变量值覆盖配置(cf)值。 少一步你都无法实现三层配置能力。 超越TOML本节将关注如何克服TOML的各种局限。 为了达成这个目标，很多人会说：使用viper，不过在介绍viper这一重量级选手 之前，我要为大家介绍另外一位不那么知名的选手：multiconfig。 有些人总是认为大的就是好的，但我相信适合的还是更好的。因为： viper太重量级，使用viper时你需要pull另外20个viper依赖的第三方包 事实上，viper单独使用还不足以满足需求，要想得到viper全部功能，你还需要另外一个包配合，而后者又依赖13个外部包 与viper相比，multiconfig使用起来更简单。 好了，我们再来回顾一下我们现在面临的问题： 在程序里定义默认配置，这样我们就无需再在toml中定义它们了。 用toml配置文件中的数据override默认配置 用命令行或环境变量的值override从toml中读取的配置。 下面是一个说明如何使用multiconfig的例子：123456789101112131415161718func main() &#123; m := multiconfig.NewWithPath(\"config.toml\") // supports TOML and JSON // Get an empty struct for your configuration serverConf := new(Server) // Populated the serverConf struct m.MustLoad(serverConf) // Check for error fmt.Println(\"After Loading: \") fmt.Printf(\"%+v\\n\", serverConf) if serverConf.Enabled &#123; fmt.Println(\"Enabled field is set to true\") &#125; else &#123; fmt.Println(\"Enabled field is set to false\") &#125;&#125; 这个例子中的toml文件如下：12345678910Name = \"koding\"Enabled = falsePort = 6066Users = [\"ankara\", \"istanbul\"][Postgres]Enabled = truePort = 5432Hosts = [\"192.168.2.1\", \"192.168.2.2\", \"192.168.2.3\"]AvailabilityRatio = 8.23 toml映射后的go结构如下：12345678910111213141516171819type ( // Server holds supported types by the multiconfig package Server struct &#123; Name string Port int `default:\"6060\"` Enabled bool Users []string Postgres Postgres &#125; // Postgres is here for embedded struct feature Postgres struct &#123; Enabled bool Port int Hosts []string DBName string AvailabilityRatio float64 &#125;) multiconfig的使用是不是很简单，后续与viper对比后，你会同意我的观点的。 multiconfig支持默认值，也支持显式的字段赋值需求。支持toml、json、结构体标签（struct tags)以及环境变量。你可以自定义配置源（例如一个远程服务器），如果你想这么做的话。可高度扩展（通过loader接口），你可以创建你自己的loader。 下面是例子的运行结果，首先是usage help：123456789101112131415161718192021222324252627$cmdlinemulticonfig -helpUsage of cmdlinemulticonfig: -enabled=false: Change value of Enabled. -name=koding: Change value of Name. -port=6066: Change value of Port. -postgres-availabilityratio=8.23: Change value of Postgres-AvailabilityRatio. -postgres-dbname=: Change value of Postgres-DBName. -postgres-enabled=true: Change value of Postgres-Enabled. -postgres-hosts=[192.168.2.1 192.168.2.2 192.168.2.3]: Change value of Postgres-Hosts. -postgres-port=5432: Change value of Postgres-Port. -users=[ankara istanbul]: Change value of Users.Generated environment variables: SERVER_NAME SERVER_PORT SERVER_ENABLED SERVER_USERS SERVER_POSTGRES_ENABLED SERVER_POSTGRES_PORT SERVER_POSTGRES_HOSTS SERVER_POSTGRES_DBNAME SERVER_POSTGRES_AVAILABILITYRATIO$cmdlinemulticonfigAfter Loading:&amp;&#123;Name:koding Port:6066 Enabled:false Users:[ankara istanbul] Postgres:&#123;Enabled:true Port:5432 Hosts:[192.168.2.1 192.168.2.2 192.168.2.3] DBName: AvailabilityRatio:8.23&#125;&#125;Enabled field is set to false 检查一下输出结果吧，是不是每项都符合我们之前的预期呢！ Viper我们的重量级选手viper该出场了！ 毫无疑问，viper非常强大。但如果你想用命令行参数覆盖预定义的配置项值，viper自己还不足以。要想让viper爆发，你需要另外一个包配合，它就是cobra。 不同于注重简化配置处理的multiconfig，viper让你拥有全面控制力。不幸的是，在得到这种控制力之前，你需要做一些体力活。 我们再来回顾一下使用multiconfig处理配置的代码：123456789101112131415161718func main() &#123; m := multiconfig.NewWithPath(\"config.toml\") // supports TOML and JSON // Get an empty struct for your configuration serverConf := new(Server) // Populated the serverConf struct m.MustLoad(serverConf) // Check for error fmt.Println(\"After Loading: \") fmt.Printf(\"%+v\\n\", serverConf) if serverConf.Enabled &#123; fmt.Println(\"Enabled field is set to true\") &#125; else &#123; fmt.Println(\"Enabled field is set to false\") &#125;&#125; 这就是使用multiconfig时你要做的所有事情。现在我们来看看使用viper和cobra如何来完成同样的事情：123456789101112131415161718192021222324252627282930313233343536373839404142func init() &#123; mainCmd.AddCommand(versionCmd) viper.SetEnvPrefix(\"DISPATCH\") viper.AutomaticEnv() /* When AutomaticEnv called, Viper will check for an environment variable any time a viper.Get request is made. It will apply the following rules. It will check for a environment variable with a name matching the key uppercased and prefixed with the EnvPrefix if set. */ flags := mainCmd.Flags() flags.Bool(\"debug\", false, \"Turn on debugging.\") flags.String(\"addr\", \"localhost:5002\", \"Address of the service\") flags.String(\"smtp-addr\", \"localhost:25\", \"Address of the SMTP server\") flags.String(\"smtp-user\", \"\", \"User to authenticate with the SMTP server\") flags.String(\"smtp-password\", \"\", \"Password to authenticate with the SMTP server\") flags.String(\"email-from\", \"noreply@example.com\", \"The from email address.\") viper.BindPFlag(\"debug\", flags.Lookup(\"debug\")) viper.BindPFlag(\"addr\", flags.Lookup(\"addr\")) viper.BindPFlag(\"smtp_addr\", flags.Lookup(\"smtp-addr\")) viper.BindPFlag(\"smtp_user\", flags.Lookup(\"smtp-user\")) viper.BindPFlag(\"smtp_password\", flags.Lookup(\"smtp-password\")) viper.BindPFlag(\"email_from\", flags.Lookup(\"email-from\")) // Viper supports reading from yaml, toml and/or json files. Viper can // search multiple paths. Paths will be searched in the order they are // provided. Searches stopped once Config File found. viper.SetConfigName(\"CommandLineCV\") // name of config file (without extension) viper.AddConfigPath(\"/tmp\") // path to look for the config file in viper.AddConfigPath(\".\") // more path to look for the config files err := viper.ReadInConfig() if err != nil &#123; println(\"No config file found. Using built-in defaults.\") &#125;&#125; 可以看出，你需要使用BindPFlag来让viper和cobra结合一起工作。但这还不算太糟。 cobra的真正威力在于提供了subcommand能力。同时cobra还提供了与posix 全面兼容的命令行标志解析能力，包括长短标志、内嵌命令、为command定义你自己的help或usage等。 下面是定义子命令的例子代码：1234567891011121314151617181920// The main command describes the service and defaults to printing the// help message.var mainCmd = &amp;cobra.Command&#123; Use: \"dispatch\", Short: \"Event dispatch service.\", Long: `HTTP service that consumes events and dispatches them to subscribers.`, Run: func(cmd *cobra.Command, args []string) &#123; serve() &#125;,&#125;// The version command prints this service.var versionCmd = &amp;cobra.Command&#123; Use: \"version\", Short: \"Print the version.\", Long: \"The version of the dispatch service.\", Run: func(cmd *cobra.Command, args []string) &#123; fmt.Println(version) &#125;,&#125; 有了上面subcommand的定义，我们就可以得到如下的help信息了：123456789101112131415161718Usage: dispatch [flags] dispatch [command]Available Commands: version Print the version. help Help about any commandFlags: –addr=\"localhost:5002\": Address of the service –debug=false: Turn on debugging. –email-from=\"noreply@example.com\": The from email address. -h, –help=false: help for dispatch –smtp-addr=\"localhost:25\": Address of the SMTP server –smtp-password=\"\": Password to authenticate with the SMTP server –smtp-user=\"\": User to authenticate with the SMTP serverUse \"dispatch help [command]\" for more information about a command.","categories":[{"name":"GO","slug":"GO","permalink":"http://xichen.pub/categories/GO/"}],"tags":[{"name":"GO","slug":"GO","permalink":"http://xichen.pub/tags/GO/"}]},{"title":"代理","slug":"2017-08-21-代理","date":"2017-08-21T01:29:00.000Z","updated":"2018-01-27T09:33:25.483Z","comments":true,"path":"2017/08/21/2017-08-21-代理/","link":"","permalink":"http://xichen.pub/2017/08/21/2017-08-21-代理/","excerpt":"","text":"1.lantern浏览器代理https://github.com/getlantern/lantern 命令行代理打开蓝灯后，终端下输入： 123export http_proxy=http://127.0.0.1:8787export https_proxy=http://127.0.0.1:8787 :8787是端口号，具体查看系统设置–网络–网络代理","categories":[{"name":"Proxy","slug":"Proxy","permalink":"http://xichen.pub/categories/Proxy/"}],"tags":[{"name":"Proxy","slug":"Proxy","permalink":"http://xichen.pub/tags/Proxy/"},{"name":"Lantern","slug":"Lantern","permalink":"http://xichen.pub/tags/Lantern/"}]},{"title":"GO的安装和配置","slug":"2017-08-21-Go的安装和配置","date":"2017-08-21T01:29:00.000Z","updated":"2018-01-05T00:45:28.277Z","comments":true,"path":"2017/08/21/2017-08-21-Go的安装和配置/","link":"","permalink":"http://xichen.pub/2017/08/21/2017-08-21-Go的安装和配置/","excerpt":"","text":"0.Install Go 不要用apt-get install golang！这个目前只有1.6版，最新版已经到1.8+ 在linux 系统下，如ubuntu debian ，安装golang 最方便的方式是用apt-get install。 但不推荐这种方式安装，建议使用源码安装，如果你不小心用apt-get 等方式安装了，就先把它卸载：1sudo apt-get purge golang-go 然后用源码安装，如果想升级也可以直接覆盖安装位置的原文件，golang 还算很干净。 套路:12345678curl -O https://storage.googleapis.com/golang/go1.7.3.linux-amd64.tar.gztar -C /usr/local -zxvf go1.7.3.linux-amd64.tar.gzmkdir -p ~/go/srcecho \"export GOROOT=/usr/local/go\"echo \"export GOPATH=$HOME/go\" &gt;&gt; ~/.bashrcecho \"export PATH=$PATH:$GOPATH/bin:$GOROOT/bin\" &gt;&gt; ~/.bashrcsource ~/.bashrcgo version GOROOT:根目录，设置了这个才指定解释器，也是标准库所在 GOPATH:工作目录，放你自己的代码．该目录下要有一定的结构，因为外来库要用go get安装在该目录下 PATH:系统环境变量，不破坏原来的环境变量的方法为PATH=$PATH:/usr/local/go表示在原来环境变量的基础上添加/usr/local/go Tips:命令行下输入export可查看当前所有变量，包括PATH,GOROOT等等，方便确认是否设置成功 1.GOROOTGOROOT就是go的安装路径 在~/.bash_profile中添加下面语句: 1export GOROOT=/usr/local/go 当然, 要执行go命令和go工具, 就要配置go的可执行文件的路径,操作如下: 在~/.bash_profile中配置如下:1export $PATH:$GOROOT/bin 如果是windows需要使用;符号分割两个路径, mac和类unix都是用:符号分割 2.GOPATHgo install/go get和 go的工具等会用到GOPATH环境变量. GOPATH是作为编译后二进制的存放目的地和import包时的搜索路径 (其实也是你的工作目录, 你可以在src下创建你自己的go源文件, 然后开始工作)。 GOPATH之下主要包含三个目录: bin、pkg、src bin目录主要存放可执行文件; pkg目录存放编译好的库文件, 主要是*.a文件; src目录下主要存放go的源文件 不要把GOPATH设置成go的安装路径, 可以自己在用户目录下面创建一个目录, 如gopath 操作如下:12cd ~mkdir gopath 在~/.bash_profile中添加如下语句:1GOPATH=/Users/username/gopath GOPATH可以是一个目录列表, go get下载的第三方库, 一般都会下载到列表的第一个目录里面需要把GOPATH中的可执行目录也配置到环境变量中, 否则你自行下载的第三方go工具就无法使用了, 操作如下:在~/bash_profile中配置,1export $PATH:$GOPATH/bin 创建一个go项目, 并且编译运行:123mkdir goprojectcd goprojecttouch hello.go 在hello.go中输入:12345package mainimport \"fmt\"func main() &#123; fmt.Println(\"Hello, GO !\")&#125; 在项目根目录下执行go build命令来构建你的项目, 构建后会生成hello文件运行生成的文件./hello, terminal中输出:Hello, GO !当然你也可以直接运行命令go run hello.go来执行程序. 附：源：https://dl.gocn.io/查看其他GO相关的环境变量：go env","categories":[{"name":"GO","slug":"GO","permalink":"http://xichen.pub/categories/GO/"}],"tags":[{"name":"GO","slug":"GO","permalink":"http://xichen.pub/tags/GO/"},{"name":"Install","slug":"Install","permalink":"http://xichen.pub/tags/Install/"},{"name":"Settings","slug":"Settings","permalink":"http://xichen.pub/tags/Settings/"}]},{"title":"jupyter-notebook-sen-usage","slug":"2017-08-20-jupyter-notebook-sen-usage","date":"2017-08-20T05:42:14.000Z","updated":"2018-01-27T09:33:40.160Z","comments":true,"path":"2017/08/20/2017-08-20-jupyter-notebook-sen-usage/","link":"","permalink":"http://xichen.pub/2017/08/20/2017-08-20-jupyter-notebook-sen-usage/","excerpt":"","text":"安装jupyter-notebook1$ pip install jupyter 配置jupyter-notebook配置可以同时使用python2和python3内核12345$ ipython kernel install --user$ python3 -m ipykernel install --user$ pip2 install -U ipykernel$ python2 -m ipykernel install --user$ jupyter-notebook //运行，会自动web界面，可以同时运行python2，python3，ctrl+c结束 生成配置文件123$ cd $ jupyter notebook --generate-configWriting default config to: /root/.jupyter/jupyter_notebook_config.py 生成密码运行jupyter1234567In [1]: from notebook.auth import passwd passwd() Enter password: ········ Verify password: ········ Out[1]: 'sha1:c3a52264ad87:f6a2c3503ee3370c67da1f723ae1e8e79477f5f7' 设置密码将前面生成的一串密码替换到配置文件中12$ vim /root/.jupyter/jupyter_notebook_config.py c.NotebookApp.password=u'sha1:c3a52264ad87:f6a2c3503ee3370c67da1f723ae1e8e79477f5f7' //前面u表示转换成unicode字符，python2的时候需要带 其它设置1234c.NotebookApp.ip = '*' //访问ip限制c.NotebookApp.notebook_dir = '/home/knmax/Desktop/Python/jupyter-project' //工作目录,路径不能出现中文c.NotebookApp.open_browser = False //不自动打开浏览器c.NotebookApp.port = 88 //运行监听的端口 以服务方式运行每次运行打开都是终端交互的界面，关闭会话终端也结束了jupyter，很不方便，这里做成以systemctl方式启动，适用于Debain、CentOS 7、Ubuntu 1234567891011121314$ vim /lib/systemd/system/jupyter.service //这个目录不同发行版可能也不同[Unit]Description=jupyter After=network.target[Service]Tpye=forkingEnvironmentFile=/usr/local/bin/jupyter-notebookExecStart=/usr/local/bin/jupyter-notebookExecStop=/usr/bin/pkill jupyter-notebookKillMode=processRestart=on-failureRestartSec=30s[Install]WantedBy=multi-user.target 创建好之后再操作下就行了123$ systemctl daemon-reload$ systemctl start jupyter$ systemctl enable jupyter 局域网访问jupyter notebook用电脑开wifi，手机连上电脑的wifi，手机可以直接从电脑的局域网ip访问到电脑上的jupyter notebook 安装额外插件或kernel显示稿插件 1234$ pip install RISE $ pip3 install RISE $ jupyter-nbextension install rise --py --sys-prefix $ jupyter nbextension enable rise --py --sys-prefix 安装Jupyter Notebook extensions–&gt;Jupyter拓展插件!!! 123456789101112131415161718192021$ conda install -c conda-forge jupyter_contrib_nbextensions或者$ pip install jupyter_contrib_nbextensions还不行就把下面的都试一遍...$ pip install https://github.com/ipython-contrib/jupyter_contrib_nbextensions/tarball/master $ pip3 install https://github.com/ipython-contrib/jupyter_contrib_nbextensions/tarball/master $ pip install jupyter_nbextensions_configurator$ pip3 install jupyter_nbextensions_configurator$ jupyter contrib nbextension install --user $ jupyter nbextensions_configurator enable --user $ systemctl restart jupyter还有......再试一试又不会怀孕...$ pip install https://github.com/ipython-contrib/jupyter_contrib_nbextensions/tarball/master $ pip install jupyter_nbextensions_configurator $ jupyter contrib nbextension install –user $ jupyter nbextensions_configurator enable –user 开启toc2插件命令行输入jupyter notebook运行,在浏览器打开notebook的Home页面，多了一个Nbextensions,点进去就懂了这个用起来很爽，可以增加许多功能，尤其是里面可以增加侧边栏，这个用起来对代码管理就看起来层次分明多了，找代码也更方便了~~ 顺便note一下,代码折叠,生成目录，自动格式化很有用~~~ 安装主题、字体1234$ pip install --upgrade jupyterthemes$ pip3 install --upgrade jupyterthemes$ jt -l 查看可用主题$ jt -t grade3 -f ptmono -fs 115 参考地址 jupyter支持的内核参考地址 多指针Jupyter支持多个指针同步编辑，类似Sublime Text编辑器。按下Alt键并拖拽鼠标即可实现。====这个我用着很不顺手，按住ctrl后用移动鼠标可实现一样的多次选中，我还是喜欢用这个。。 隐藏代码只显示代码输出123456789101112131415from IPython.display import HTMLHTML('''&lt;script&gt;code_show=true; function code_toggle() &#123; if (code_show)&#123; $('div.input').hide(); &#125; else &#123; $('div.input').show(); &#125; code_show = !code_show&#125; $( document ).ready(code_toggle);&lt;/script&gt;&lt;form action=\"javascript:code_toggle()\"&gt;&lt;input type=\"submit\" value=\"Click here to toggle on/off the raw code.\"&gt;&lt;/form&gt;''') 也可以这样：123456789101112code_show=true;function code_toggle() &#123; if (code_show)&#123; $('div.input').hide(); &#125; else &#123; $('div.input').show(); &#125; code_show = !code_show&#125;$([IPython.events]).on(\"app_initialized.NotebookApp\", function () &#123; $(\"#view_menu\").append(\"&lt;li id=\\\"toggle_toolbar\\\" title=\\\"Show/Hide code cells\\\"&gt;&lt;a href=\\\"javascript:code_toggle()\\\"&gt;Toggle Code Cells&lt;/a&gt;&lt;/li&gt;\") 或者这样:123456789from IPython.display import displayfrom IPython.display import HTMLimport IPython.core.display as di # Example: di.display_html('&lt;h3&gt;%s:&lt;/h3&gt;' % str, raw=True)# This line will hide code by default when the notebook is exported as HTMLdi.display_html('&lt;script&gt;jQuery(function() &#123;if (jQuery(\"body.notebook_app\").length == 0) &#123; jQuery(\".input_area\").toggle(); jQuery(\".prompt\").toggle();&#125;&#125;);&lt;/script&gt;', raw=True)# This line will add a button to toggle visibility of code blocks, for use with the HTML export versiondi.display_html('''&lt;button onclick=\"jQuery('.input_area').toggle(); jQuery('.prompt').toggle();\"&gt;Toggle code&lt;/button&gt;''', raw=True) 这样：123456789$([IPython.events]).on('notebook_loaded.Notebook', function()&#123; IPython.toolbar.add_buttons_group([ &#123; 'label' : 'toggle input cells', 'icon' : 'icon-refresh', 'callback': function()&#123;$('.input').slideToggle()&#125; &#125; ]);&#125;); 甚至可以这样：12345678910111213141516171819202122232425262728# This is a cell to hide code snippets from displaying# This must be at first cell!from IPython.display import HTMLhide_me = ''HTML('''&lt;script&gt;code_show=true; function code_toggle() &#123; if (code_show) &#123; $('div.input').each(function(id) &#123; el = $(this).find('.cm-variable:first'); if (id == 0 || el.text() == 'hide_me') &#123; $(this).hide(); &#125; &#125;); $('div.output_prompt').css('opacity', 0); &#125; else &#123; $('div.input').each(function(id) &#123; $(this).show(); &#125;); $('div.output_prompt').css('opacity', 1); &#125; code_show = !code_show&#125; $( document ).ready(code_toggle);&lt;/script&gt;&lt;form action=\"javascript:code_toggle()\"&gt;&lt;input style=\"opacity:0\" type=\"submit\" value=\"Click here to toggle on/off the raw code.\"&gt;&lt;/form&gt;''') 惊不惊喜？刺不刺激？[参考]：(http://stackoverflow.com/questions/27934885/how-to-hide-code-from-cells-in-ipython-notebook-visualized-with-nbviewer) 全部显示有一点已经众所周知。把变量名称或没有定义输出结果的语句放在cell的最后一行，无需print语句，Jupyter也会显示变量值。当使用Pandas DataFrames时这一点尤其有用，因为输出结果为整齐的表格。 鲜为人知的是，你可以通过修改内核选项ast_node_interactivity，使得Jupyter对独占一行的所有变量或者语句都自动显示，这样你就可以马上看到多个语句的运行结果了。 123In [1]: from IPython.core.interactiveshell import InteractiveShell InteractiveShell.ast_node_interactivity = \"all\" 如果你想在各种情形下（Notebook和Console）Jupyter都同样处理，用下面的几行简单的命令创建文件~/.ipython/profile_default/ipython_config.py即可实现：12345c = get_config()# Run all nodes interactivelyc.InteractiveShell.ast_node_interactivity = \"all\" 这个刚了解时用起来很开心，不过当用到matplotlib时会输出很多信息，看起来比较丑，我就弃用了… 末句函数不输出有时候不让末句的函数输出结果比较方便，比如在作图的时候，此时，只需在该函数末尾加上一个分号即可===这个用起来作的图看起来就清爽多了； 嘿嘿嘿… 在notebook中作图如果不想每次用matplotlib 作图后都要输入plt.show()来弹出显示图，可以如下： matplotlib （事实标准）（http://matplotlib.org/），可通过%matplotlib inline 激活，（https://www.dataquest.io/blog/matplotlib-tutorial/） ===常用 %matplotlib notebook 提供交互性操作，但可能会有点慢，因为响应是在服务器端完成的。 ===需要调整图形时这个用着不错 mpld3（https://github.com/mpld3/mpld3） 提供matplotlib代码的替代性呈现（通过d3），虽然不完整，但很好。 ===没用过 bokeh（http://bokeh.pydata.org/en/latest/） 生成可交互图像的更好选择。 ====没用过 plot.ly（https://plot.ly/） 可以生成非常好的图，可惜是付费服务。===没用过 Jupyter notebook的magic操作上面介绍的%matplotlib inline就是其中的一个魔术操作，作图时用起来流畅极了； %run ====用来运行代码脚本 %store ====命令可以在两个notebook文件之间传递变量，没用过。。 %who ====不加任何参数，命令可以列出所有的全局变量。加上参数 str 将只列出字符串型的全局变量 有两种用于计时的jupyter magic命令：当你有一些很耗时的代码，想要查清楚问题出在哪时，这两个命令非常给力。 %%time 会告诉你cell内代码的单次运行时间信息。 %%timeit 使用了Python的 timeit 模块，该模块运行某语句100，000次（默认值），然后提供最快的3次的平均值作为结果。 %prun+函数声明 会给你一个按顺序排列的表格，显示每个内部函数的耗时情况，每次调用函数的耗时情况，以及累计耗时。 Jupyter 有自己的调试界面The Python Debugger (pdb)===这个貌似很强大的样子，暂时还没用过，有机会我要试试~（https://docs.python.org/3.5/library/pdb.html），使得进入函数内部检查错误成为可能。Pdb中可使用的命令见链接（https://docs.python.org/3.5/library/pdb.html#debugger-commands） 运行Shell命令在notebook中可以用cd 来切换目录；ls用来显示当前目录内容；$ pip install或者$ conda install用来使用cmd下的命令操作； Jupyter-Notebook 的快捷键Jupyter Notebook 有两种键盘输入模式。编辑模式，允许你往单元中键入代码或文本；这时的单元框线是绿色的。命令模式，键盘输入运行程序命令；这时的单元框线是灰色。 命令模式 (按键 Esc 开启)1234567891011121314151617181920212223242526272829303132333435363738394041Enter : 转入编辑模式Shift-Enter : 运行本单元，选中下个单元Ctrl-Enter : 运行本单元Alt-Enter : 运行本单元，在其下插入新单元Y : 单元转入代码状态M :单元转入markdown状态R : 单元转入raw状态1 : 设定 1 级标题2 : 设定 2 级标题3 : 设定 3 级标题4 : 设定 4 级标题5 : 设定 5 级标题6 : 设定 6 级标题Up : 选中上方单元K : 选中上方单元Down : 选中下方单元J : 选中下方单元Shift-K : 扩大选中上方单元Shift-J : 扩大选中下方单元A : 在上方插入新单元B : 在下方插入新单元X : 剪切选中的单元C : 复制选中的单元Shift-V : 粘贴到上方单元V : 粘贴到下方单元Z : 恢复删除的最后一个单元D,D : 删除选中的单元Shift-M : 合并选中的单元Ctrl-S : 文件存盘S : 文件存盘L : 转换行号O : 转换输出Shift-O : 转换输出滚动Esc : 关闭页面Q : 关闭页面H : 显示快捷键帮助I,I : 中断Notebook内核0,0 : 重启Notebook内核Shift : 忽略Shift-Space : 向上滚动Space : 向下滚动 编辑模式 ( Enter 键启动)123456789101112131415161718192021222324252627Tab : 代码补全或缩进Shift-Tab : 提示Ctrl-] : 缩进Ctrl-[ : 解除缩进Ctrl-A : 全选Ctrl-Z : 复原Ctrl-Shift-Z : 再做Ctrl-Y : 再做Ctrl-Home : 跳到单元开头Ctrl-Up : 跳到单元开头Ctrl-End : 跳到单元末尾Ctrl-Down : 跳到单元末尾Ctrl-Left : 跳到左边一个字首Ctrl-Right : 跳到右边一个字首Ctrl-Backspace : 删除前面一个字Ctrl-Delete : 删除后面一个字Esc : 进入命令模式Ctrl-M : 进入命令模式Shift-Enter : 运行本单元，选中下一单元Ctrl-Enter : 运行本单元Alt-Enter : 运行本单元，在下面插入一单元Ctrl-Shift-- : 分割单元Ctrl-Shift-Subtract : 分割单元Ctrl-S : 文件存盘Shift : 忽略Up : 光标上移或转入上一单元Down :光标下移或转入下一单元","categories":[{"name":"Tools","slug":"Tools","permalink":"http://xichen.pub/categories/Tools/"}],"tags":[{"name":"jupyter notebook","slug":"jupyter-notebook","permalink":"http://xichen.pub/tags/jupyter-notebook/"}]},{"title":"RNN","slug":"2017-08-10-RNN","date":"2017-08-09T15:10:24.000Z","updated":"2018-01-05T00:45:28.275Z","comments":true,"path":"2017/08/09/2017-08-10-RNN/","link":"","permalink":"http://xichen.pub/2017/08/09/2017-08-10-RNN/","excerpt":"","text":"0.总结 本文主要讲了N vs N，N vs 1、1 vs N、N vs M四种经典的RNN模型，以及如何使用Attention结构。 1.从单层网络谈起 在学习RNN之前，首先要了解一下最基本的单层网络，它的结构如图： 单层网络 输入是x，经过变换Wx+b和激活函数f得到输出y 2.经典的RNN结构(N vs N) 在实际应用中，我们还会遇到很多序列形的数据： 序列形的数据 如： 自然语言处理问题．x1可以看做是第一个单词，x2可以看做是第二个单词，依次类推。 语音处理．此时，x1、x2、x3……是每帧的声音信号。 时间序列问题．例如每天的股票价格等等 序列形的数据就不太好用原始的神经网络处理了。 为了建模序列问题，RNN引入了隐状态h（hidden state）的概念，h可以对序列形的数据提取特征，接着再转换为输出。 先从h1的计算开始看： h1的计算 图示中记号的含义是： 圆圈或方块表示的是向量 一个箭头就表示对该向量做一次变换。如上图中h0和x1分别有一个箭头连接，就表示对h0和x1各做了一次变换。 在很多论文中也会出现类似的记号，初学的时候很容易搞乱，但只要把握住以上两点，就可以比较轻松地理解图示背后的含义。 h2的计算和h1类似。要注意的是，在计算时，每一步使用的参数U、W、b都是一样的，也就是说每个步骤的参数都是共享的，这是RNN的重要特点，一定要牢记。 h2的计算 依次计算剩下来的（使用相同的参数U、W、b）： 计算 我们这里为了方便起见，只画出序列长度为4的情况，实际上，这个计算过程可以无限地持续下去。 我们目前的RNN还没有输出，得到输出值的方法就是直接通过h进行计算： 计算 正如之前所说，一个箭头就表示对对应的向量做一次类似于f(Wx+b)的变换，这里的这个箭头就表示对h1进行一次变换，得到输出y1。 剩下的输出类似进行（使用和y1同样的参数V和c）： 计算 OK！大功告成！这就是最经典的RNN结构，我们像搭积木一样把它搭好了。它的输入是x1, x2, …..xn，输出为y1, y2, …yn，也就是说，输入和输出序列必须要是等长的。 由于这个限制的存在，经典RNN的适用范围比较小，但也有一些问题适合用经典的RNN结构建模，如： 计算视频中每一帧的分类标签:因为要对每一帧进行计算，因此输入和输出序列等长。 输入为字符，输出为下一个字符的概率。 这就是著名的Char RNN（详细介绍请参考：The Unreasonable Effectiveness of Recurrent Neural Networks，Char RNN可以用来生成文章，诗歌，甚至是代码，非常有意思）。 3.N vs 1 有的时候，我们要处理的问题输入是一个序列，输出是一个单独的值而不是序列，应该怎样建模呢？ 实际上，我们只在最后一个h上进行输出变换就可以了： 输出变换 这种结构通常用来处理序列分类问题。 输入一段文字判别它所属的类别 输入一个句子判断其情感倾向 输入一段视频并判断它的类别等等。 4.1 VS N 输入不是序列而输出为序列的情况怎么处理？我们可以只在序列开始进行输入计算： 计算 还有一种结构是把输入信息X作为每个阶段的输入： 计算 下图省略了一些X的圆圈，是一个等价表示： 等价表示 这种1 VS N的结构可以处理的问题有： 从图像生成文字（image caption），此时输入的X就是图像的特征，而输出的y序列就是一段句子 从类别生成语音或音乐等 5.N VS M 下面我们来介绍RNN最重要的一个变种：N vs M。 这种结构又叫Encoder-Decoder模型，也可以称之为Seq2Seq模型。 原始的N vs N RNN要求序列等长，然而我们遇到的大部分问题序列都是不等长的，如机器翻译中，源语言和目标语言的句子往往并没有相同的长度。 为此，Encoder-Decoder结构先将输入数据编码成一个上下文向量c： Encoder 得到c有多种方式，最简单的方法就是把Encoder的最后一个隐状态赋值给c，还可以对最后的隐状态做一个变换得到c，也可以对所有的隐状态做变换。 拿到c之后，就用另一个RNN网络对其进行解码，这部分RNN网络被称为Decoder。具体做法就是将c当做之前的初始状态h0输入到Decoder中： Decoder 还有一种做法是将c当做每一步的输入： 输入 由于这种Encoder-Decoder结构不限制输入和输出的序列长度，因此应用的范围非常广泛，比如： 机器翻译:Encoder-Decoder的最经典应用，事实上这一结构就是在机器翻译领域最先提出的 文本摘要:输入是一段文本序列，输出是这段文本序列的摘要序列。 阅读理解:将输入的文章和问题分别编码，再对其进行解码得到问题的答案。 语音识别:输入是语音信号序列，输出是文字序列。 ………… 6.Attention机制 在Encoder-Decoder结构中，Encoder把所有的输入序列都编码成一个统一的语义特征c再解码。 因此， c中必须包含原始序列中的所有信息，它的长度就成了限制模型性能的瓶颈。 如机器翻译问题，当要翻译的句子较长时，一个c可能存不下那么多信息，就会造成翻译精度的下降。 Attention机制通过在每个时间输入不同的c来解决这个问题，下图是带有Attention机制的Decoder： Attention机制的Decoder 每一个c会自动去选取与当前所要输出的y最合适的上下文信息。 具体来说，我们用$$a_{ij}$$衡量Encoder中第j阶段的hj和解码时第i阶段的相关性，最终Decoder中第i阶段的输入的上下文信息$$ci$$就来自于所有$$a{ij}$$对的加权和。 以机器翻译为例（将中文翻译成英文）： 机器翻译 输入的序列是“我爱中国”，因此，Encoder中的h1、h2、h3、h4就可以分别看做是 “我” 、 “爱” 、 “中” 、 “国” 所代表的信息。 在翻译成英语时，第一个上下文c1应该和“我”这个字最相关，因此对应的就$$a{11}$$比较大，而相应的$$ a{12},a{13},a{14} $$就比较小。 c2应该和“爱”最相关，因此对应的$$ a{22} $$就比较大。最后的c3和h3、h4最相关，因此 $$ a{33},a_{34} $$的值就比较大。 至此，关于Attention模型，我们就只剩最后一个问题了，那就是： 这些权重$$ a_{ij} $$是怎么来的？ 事实上，$$ a_{ij} $$同样是从模型中学出的，它实际和Decoder的第i-1阶段的隐状态、Encoder第j个阶段的隐状态有关。 同样还是拿上面的机器翻译举例，$$ a_{1j} $$的计算（此时箭头就表示对h’和$$ h_j $$同时做变换）： $ a_{1j} $计算 $$ a_{2j} $$的计算: $ a_{2j} $计算 $$ a_{3j} $$的计算: $ a_{3j} $的计算","categories":[{"name":"Deep Learning","slug":"Deep-Learning","permalink":"http://xichen.pub/categories/Deep-Learning/"}],"tags":[{"name":"rnn","slug":"rnn","permalink":"http://xichen.pub/tags/rnn/"}]},{"title":"Ubuntu的grub修复","slug":"2017-08-07-Ubuntu的grub修复","date":"2017-08-07T01:11:00.000Z","updated":"2018-01-05T00:45:28.274Z","comments":true,"path":"2017/08/07/2017-08-07-Ubuntu的grub修复/","link":"","permalink":"http://xichen.pub/2017/08/07/2017-08-07-Ubuntu的grub修复/","excerpt":"","text":"问题一：grub rescue调整磁盘，利用工具分割出新分区后重启 开机后有引导，可以正常进入win7系统，但选择Linux系统进入时跳到grub rescue模式 12345GRUB loadingerror:unknow filesystemgrub rescue&gt; 这是因为新分区导致grub混淆 在 grub rescue&gt;下输入以下命令： 123456grub rescue&gt;ls(hd0,1),...,(hd0,msdos9),(hd0,msdos10),(hd0,msdos11)grub rescue&gt;set root=(hd0,msdos11)grub rescue&gt;set prefix=(hd0,msdos11)/grubgrub rescue&gt;insmod normalgrub rescue&gt;normal 即可正常进入Ubuntu系统 但是问题依旧存在，下次要进入Ubuntu时还是先进入grub rescue，很烦 我们需要进入Linux中，对grub进行修复。 启动起来，进入ubuntu之后，在终端执行： 12sudo update-grubsudo grub-install /dev/sda （sda是你的硬盘号码，千万不要指定分区号码，例如sda1，sda5等都不对） 嗯，现在重启可以直接进入Ubuntu系统，不用进入grub rescue了 但是，有个问题…现在进不了win7了…win7的启动项弄没了，现在只能进ubuntu 问题二：win7的启动项消失注意到“Windows 7 (loader) (on /dev/sda1)”条目 开机时点进去…假的，直接紫色花屏，mmp 我觉得还可以再抢救一下 直接改一下grub.cfg文件 先Ctrl+alt+T打开终端，输入 1sudo gedit /boot/grub/grub.cfg 再打开的grub.cfg文件尾部添加一段： 12345menuentry 'Win7' &#123; set root=(hd0,1); ntldr /bootmgr boot&#125; 保存，退出。重启。也可以看到Win7启动条目了。 但这种做法不会像方法一那样更新了grub.cfg文件，删除掉了那条旧的“Windows 7 (loader) (on /dev/sda1)条目”。可以直接在grub.cfg文件中删除那一段则可。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://xichen.pub/tags/Ubuntu/"},{"name":"grub","slug":"grub","permalink":"http://xichen.pub/tags/grub/"}]},{"title":"LSTM","slug":"2017-08-04-LSTM","date":"2017-08-04T04:32:24.000Z","updated":"2018-01-27T09:33:51.229Z","comments":true,"path":"2017/08/04/2017-08-04-LSTM/","link":"","permalink":"http://xichen.pub/2017/08/04/2017-08-04-LSTM/","excerpt":"","text":"原理Understanding LSTM Networks (译)理解 LSTM 网络 代码纯python实现 解读 如图为LSTM的类图 12345678910111213import randomimport numpy as npimport mathdef sigmoid(x): return 1. / (1 + np.exp(-x))def sigmoid_derivative(values): return values*(1-values)def tanh_derivative(values): return 1. - values ** 2 sigmoid(x) := $$ \\sigma(x)=\\frac{1}{1+e^x} $$ sigmoid_derivative(x) := $$ \\sigma ‘(x)=x(1-x) $$ tanh_derivative(x) := $$ \\tanh ‘(x)=1-x^2 $$ 1234# createst uniform random array w/ values in [a,b) and shape argsdef rand_arr(a, b, *args): np.random.seed(0) return np.random.rand(*args) * (b - a) + a np.random.seed(0)设置随机数种子以便复现结果,rand_arr(a,b,*args)函数用于初始化 rand_arr(a,b):= $$ x, x \\in [a,b) $$ rand_arr(a,b,$$\\begin{bmatrix} 1 &amp; 2 \\ 3 &amp; 4 \\end{bmatrix}$$):=$$\\begin{bmatrix} x_1 &amp; x_2 \\ x_3 &amp; x_4 \\end{bmatrix} ,x_1, x_2, x_3, x_4\\in [a,b) $$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class LstmParam: def __init__(self, mem_cell_ct, x_dim): self.mem_cell_ct = mem_cell_ct self.x_dim = x_dim concat_len = x_dim + mem_cell_ct # weight matrices self.wg = rand_arr(-0.1, 0.1, mem_cell_ct, concat_len) self.wi = rand_arr(-0.1, 0.1, mem_cell_ct, concat_len) self.wf = rand_arr(-0.1, 0.1, mem_cell_ct, concat_len) self.wo = rand_arr(-0.1, 0.1, mem_cell_ct, concat_len) # bias terms self.bg = rand_arr(-0.1, 0.1, mem_cell_ct) self.bi = rand_arr(-0.1, 0.1, mem_cell_ct) self.bf = rand_arr(-0.1, 0.1, mem_cell_ct) self.bo = rand_arr(-0.1, 0.1, mem_cell_ct) # diffs (derivative of loss function w.r.t. all parameters) self.wg_diff = np.zeros((mem_cell_ct, concat_len)) self.wi_diff = np.zeros((mem_cell_ct, concat_len)) self.wf_diff = np.zeros((mem_cell_ct, concat_len)) self.wo_diff = np.zeros((mem_cell_ct, concat_len)) self.bg_diff = np.zeros(mem_cell_ct) self.bi_diff = np.zeros(mem_cell_ct) self.bf_diff = np.zeros(mem_cell_ct) self.bo_diff = np.zeros(mem_cell_ct) def apply_diff(self, lr = 1): ''' lr:learningrate学习率 ''' self.wg -= lr * self.wg_diff self.wi -= lr * self.wi_diff self.wf -= lr * self.wf_diff self.wo -= lr * self.wo_diff self.bg -= lr * self.bg_diff self.bi -= lr * self.bi_diff self.bf -= lr * self.bf_diff self.bo -= lr * self.bo_diff # reset diffs to zero self.wg_diff = np.zeros_like(self.wg) self.wi_diff = np.zeros_like(self.wi) self.wf_diff = np.zeros_like(self.wf) self.wo_diff = np.zeros_like(self.wo) self.bg_diff = np.zeros_like(self.bg) self.bi_diff = np.zeros_like(self.bi) self.bf_diff = np.zeros_like(self.bf) self.bo_diff = np.zeros_like(self.bo) LSTM基本结构决定丢弃信息确定更新的信息更新细胞状态输出信息 以上公式的符号与变量名对应表 变量名 意义或公式符号 mem_cell_ct todo x_dim $$x_t$$的维数 wf $$W_f$$ wi $$W_i$$ wg $$W_C$$ wo $$W_o$$ bf $$b_f$$ bi $$b_i$$ bg $$b_C$$ bo $$b_o$$ wf_diff $$W_f$$的误差 wi_diff $$W_i$$的误差 wg_diff $$W_C$$的误差 wo_diff $$W_o$$的误差 bf_diff $$b_f$$的误差 bi_diff $$b_i$$的误差 bg_diff $$b_C$$的误差 bo_diff $$b_o$$的误差 12345678910class LstmState: def __init__(self, mem_cell_ct, x_dim): self.g = np.zeros(mem_cell_ct) self.i = np.zeros(mem_cell_ct) self.f = np.zeros(mem_cell_ct) self.o = np.zeros(mem_cell_ct) self.s = np.zeros(mem_cell_ct) self.h = np.zeros(mem_cell_ct) self.bottom_diff_h = np.zeros_like(self.h) self.bottom_diff_s = np.zeros_like(self.s) 变量名 意义或公式符号 f $$f_t$$ i $$i_t$$ g $$\\widetilde{C}_t$$ o $$o_t$$ s $$C_t$$ (state的缩写) h $$h_t$$ bottom_diff_h $$todo$$ bottom_diff_h $$todo$$ 1234567class LstmNode: def __init__(self, lstm_param, lstm_state): # store reference to parameters and to activations self.state = lstm_state self.param = lstm_param # non-recurrent input concatenated with recurrent input self.xc = None LSTM只有一个节点，该节点包含训练参数lstm_param和状态参数lstm_state 训练参数是模型的灵魂所在，网络学习的过程就是训练参数不断调整的过程，最好不要人为干预 状态参数可以根据不同的输入通过与训练参数计算而来 123456789101112131415161718def bottom_data_is(self, x, s_prev = None, h_prev = None): # if this is the first lstm node in the network if s_prev == None: s_prev = np.zeros_like(self.state.s) if h_prev == None: h_prev = np.zeros_like(self.state.h) # save data for use in backprop self.s_prev = s_prev self.h_prev = h_prev # concatenate x(t) and h(t-1) xc = np.hstack((x, h_prev)) self.state.g = np.tanh(np.dot(self.param.wg, xc) + self.param.bg) self.state.i = sigmoid(np.dot(self.param.wi, xc) + self.param.bi) self.state.f = sigmoid(np.dot(self.param.wf, xc) + self.param.bf) self.state.o = sigmoid(np.dot(self.param.wo, xc) + self.param.bo) self.state.s = self.state.g * self.state.i + s_prev * self.state.f self.state.h = self.state.s * self.state.o self.xc = xc 变量名 意义或公式符号 s_pre $$C_{t-1}$$ h_pre $$h_{t-1}$$ bottom_data_is(x,s_prev,h_prev) 相当于前向传播 12345678910111213141516171819202122232425262728293031323334def top_diff_is(self, top_diff_h, top_diff_s): # notice that top_diff_s is carried along the constant error carousel ds = self.state.o * top_diff_h + top_diff_s do = self.state.s * top_diff_h di = self.state.g * ds dg = self.state.i * ds df = self.s_prev * ds # diffs w.r.t. vector inside sigma / tanh function di_input = sigmoid_derivative(self.state.i) * di df_input = sigmoid_derivative(self.state.f) * df do_input = sigmoid_derivative(self.state.o) * do dg_input = tanh_derivative(self.state.g) * dg # diffs w.r.t. inputs self.param.wi_diff += np.outer(di_input, self.xc) self.param.wf_diff += np.outer(df_input, self.xc) self.param.wo_diff += np.outer(do_input, self.xc) self.param.wg_diff += np.outer(dg_input, self.xc) self.param.bi_diff += di_input self.param.bf_diff += df_input self.param.bo_diff += do_input self.param.bg_diff += dg_input # compute bottom diff dxc = np.zeros_like(self.xc) dxc += np.dot(self.param.wi.T, di_input) dxc += np.dot(self.param.wf.T, df_input) dxc += np.dot(self.param.wo.T, do_input) dxc += np.dot(self.param.wg.T, dg_input) # save bottom diffs self.state.bottom_diff_s = ds * self.state.f self.state.bottom_diff_h = dxc[self.param.x_dim:] 计算误差,相当于后向传播 123456class LstmNetwork(): def __init__(self, lstm_param): self.lstm_param = lstm_param self.lstm_node_list = [] # input sequence self.x_list = [] 一般的RNN网络结构 定义初始化网络 本实现中,Hidden Layer 和 Input Layer 和 Output Layer的长度都相同 变量名 意义或公式符号 lstm_node_list Hidden Layer x_list Input Layer 12345678910111213141516171819202122232425262728def y_list_is(self, y_list, loss_layer): \"\"\" Updates diffs by setting target sequence with corresponding loss layer. Will *NOT* update parameters. To update parameters, call self.lstm_param.apply_diff() \"\"\" assert len(y_list) == len(self.x_list) idx = len(self.x_list) - 1 # first node only gets diffs from label ... loss = loss_layer.loss(self.lstm_node_list[idx].state.h, y_list[idx]) diff_h = loss_layer.bottom_diff(self.lstm_node_list[idx].state.h, y_list[idx]) # here s is not affecting loss due to h(t+1), hence we set equal to zero diff_s = np.zeros(self.lstm_param.mem_cell_ct) self.lstm_node_list[idx].top_diff_is(diff_h, diff_s) idx -= 1 ### ... following nodes also get diffs from next nodes, hence we add diffs to diff_h ### we also propagate error along constant error carousel using diff_s while idx &gt;= 0: loss += loss_layer.loss(self.lstm_node_list[idx].state.h, y_list[idx]) diff_h = loss_layer.bottom_diff(self.lstm_node_list[idx].state.h, y_list[idx]) diff_h += self.lstm_node_list[idx + 1].state.bottom_diff_h diff_s = self.lstm_node_list[idx + 1].state.bottom_diff_s self.lstm_node_list[idx].top_diff_is(diff_h, diff_s) idx -= 1 return loss 根据y_list计算误差 y_list存的是target sequence 用index从最新的一个状态t=index到之前所有的状态进行遍历，累计误差 误差暂时储存在self.lstm_node_list[idx + 1].state.bottom_diff_h和self.lstm_node_list[idx + 1].state.bottom_diff_s 12345678910111213141516171819def x_list_clear(self): self.x_list = []def x_list_add(self, x): self.x_list.append(x) if len(self.x_list) &gt; len(self.lstm_node_list): # need to add new lstm node, create new state mem lstm_state = LstmState(self.lstm_param.mem_cell_ct, self.lstm_param.x_dim) self.lstm_node_list.append(LstmNode(self.lstm_param, lstm_state)) # get index of most recent x input idx = len(self.x_list) - 1 if idx == 0: # no recurrent inputs yet self.lstm_node_list[idx].bottom_data_is(x) else: s_prev = self.lstm_node_list[idx - 1].state.s h_prev = self.lstm_node_list[idx - 1].state.h self.lstm_node_list[idx].bottom_data_is(x, s_prev, h_prev) (一个时间步一个时间步地)将(代表一个句子的一个单词的)向量加入x_list中, 最终x_list是一个矩阵 例如(假设每个单词向量是n维,这里n=4): I——–&gt;[[1,2,3,4], want—&gt; [5,7,8,9], to——&gt; [1,5,8,7], watch–&gt; [5,2,3,1], movies– [4,8,2,6]]","categories":[{"name":"Deep Learning","slug":"Deep-Learning","permalink":"http://xichen.pub/categories/Deep-Learning/"}],"tags":[{"name":"RNN","slug":"RNN","permalink":"http://xichen.pub/tags/RNN/"}]},{"title":"vim tips","slug":"2017-07-01-vim-tips","date":"2017-06-30T21:21:00.000Z","updated":"2018-01-27T09:34:44.877Z","comments":true,"path":"2017/07/01/2017-07-01-vim-tips/","link":"","permalink":"http://xichen.pub/2017/07/01/2017-07-01-vim-tips/","excerpt":"","text":"1. vim基本设置12345678set nuset listset listchars=tab:»\\ ,extends:›,precedes:‹,nbsp:·,trail:·filetype plugin onfiletype plugin indent onsyntax enablesyntax oncolorscheme molokai 在windows下的gvim中，可能会出现使用backspace不能往左删除的问题 这个是因为在windows下的gvim是默认启用了vi兼容模式的，这种模式下backspace配置是空的，所以我们需要禁用vi兼容模式： set nocp backspace键的默认模式有三种： 1230 same as “:set backspace=” (Vi compatible)1 same as “:set backspace=indent,eol”2 same as “:set backspace=indent,eol,start” indent,eol,start解释如下： 123indent: 如果用了:set indent,:set ai 等自动缩进，想用退格键将字段缩进的删掉，必须设置这个选项。否则不响应。eol:如果插入模式下在行开头，想通过退格键合并两行，需要设置eol。start：要想删除此次插入前的输入，需设置这个 所以禁用vi兼容模式之后，我们可以设置backspace键为set backspace=2，然后不能使用backspace往左删除的问题消失。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://xichen.pub/tags/Ubuntu/"},{"name":"Vim","slug":"Vim","permalink":"http://xichen.pub/tags/Vim/"}]},{"title":"使用vim编写fortran代码的一些相关设置","slug":"2017-07-01-使用vim编写fortran代码","date":"2017-06-30T07:58:00.000Z","updated":"2018-01-27T09:34:19.010Z","comments":true,"path":"2017/06/30/2017-07-01-使用vim编写fortran代码/","link":"","permalink":"http://xichen.pub/2017/06/30/2017-07-01-使用vim编写fortran代码/","excerpt":"","text":"最近开始干活了，实验室主流语言是fortran，一种很褒贬不一的语言。由于是Arch linux用户，所以需要对linux编写编译fortran代码做一些准备工作。 1.首先，在linux下fortran编译器还是很多的，有很方便就能安装的gfortran，还有诸如intel或者PGI这些公司提供的编译器。intel家的编译器对学生免费，所以自然就成了首选。详情请去这个链接查看。 2.安装intel parallel studio的过程是图形化的，一般不会出现什么问题。安装之后设置一下路径就能使用ifort命令编译fortran文件了。 3.在linux编写fortran代码我还是按照习惯选择了vim，然后我们需要在.vimrc中加入如下设置项： 1234567891011121314\"语法高亮syntax enablesyntax on\"fortran语言制表符设置let fortran_have_tabs=1\"设置制表符宽度set tabstop=4\"解决中文注释乱码set fileencodings=urf-8,gb18030,utf-16,big5\"设置代码折叠let fortran_fold=1set foldmethod=syntax\"设置默认文件打开后所有折叠自动展开set foldlevelstart=99 vim有关代码折叠的命令如下： 1234zc：折叠代码zo：展开代码zC：折叠所有代码zO：展开所有代码 最后效果图： 这里vim的配色主题为molokai。","categories":[{"name":"Tips","slug":"Tips","permalink":"http://xichen.pub/categories/Tips/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"http://xichen.pub/tags/Tips/"},{"name":"Terminal","slug":"Terminal","permalink":"http://xichen.pub/tags/Terminal/"}]},{"title":"Ubuntu 16.04安装jekyll","slug":"2017-06-26-Ubuntu安装jekyll","date":"2017-06-26T03:13:00.000Z","updated":"2018-01-05T00:45:28.271Z","comments":true,"path":"2017/06/26/2017-06-26-Ubuntu安装jekyll/","link":"","permalink":"http://xichen.pub/2017/06/26/2017-06-26-Ubuntu安装jekyll/","excerpt":"","text":"一直以来在github写博客习惯于直接git提交后在github pages看效果，这样来回修改就会繁琐的commit、push,所以还是搭建jekyll本地环境预览吧。 1.安装ruby 1sudo apt install ruby-full ruby-bundler 这里如果下意识的使用sudo apt install ruby安装ruby会导致下一步安装jekyll的时候出现如下错误： 2.安装jekyll 1sudo gem install jekyll 3.检测jekyll是否安装成功 1234jekyll -vjekyll new new-sitecd new-sitejekyll serve 在浏览器里打开http://localhost:4000可以看到预览效果。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://xichen.pub/tags/Ubuntu/"},{"name":"jekyll","slug":"jekyll","permalink":"http://xichen.pub/tags/jekyll/"}]},{"title":"latex tips","slug":"2017-06-26-Latex-tips","date":"2017-06-26T02:52:00.000Z","updated":"2018-01-27T09:35:15.512Z","comments":true,"path":"2017/06/26/2017-06-26-Latex-tips/","link":"","permalink":"http://xichen.pub/2017/06/26/2017-06-26-Latex-tips/","excerpt":"","text":"1.\\min的两种表示方法12\\min\\limits_&#123;a&#125;\\min\\nolimits&#123;a&#125; 对应的显示效果如下： 2. latex插入python代码 在latex里插入python代码需要使用包pythonhighlight,如果你使用tex live 2017的话，这个包已经安装了，可以直接使用； 如果你安装的latex版本默认没有这个包，你可以去这个地址下载pythonhighlight.sty文件，然后放到自己的.tex文件目录下，就可以使用了。 使用过程如下： 先在latex导言区输入： 12\\usepackage&#123;graphicx&#125;\\usepackage&#123;pythonhighlight&#125; 插入python代码有两种方式： 然后在需要插入代码的地方： 12345\\inputpython&#123;python_filename.py&#125;&#123;begin line number&#125;&#123;end line number&#125;%或者使用这种方式\\begin&#123;python&#125;contents\\end&#123;python&#125;","categories":[{"name":"Tips","slug":"Tips","permalink":"http://xichen.pub/categories/Tips/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"http://xichen.pub/tags/Tips/"},{"name":"Latex","slug":"Latex","permalink":"http://xichen.pub/tags/Latex/"}]},{"title":"Ubuntu tips","slug":"2017-06-25-ubuntu-tips","date":"2017-06-25T08:50:00.000Z","updated":"2018-03-02T14:52:03.915Z","comments":true,"path":"2017/06/25/2017-06-25-ubuntu-tips/","link":"","permalink":"http://xichen.pub/2017/06/25/2017-06-25-ubuntu-tips/","excerpt":"","text":"1. 更换pip源为阿里云的镜像源官方帮助教程 编辑pip配置文件: vim ~/.pip/pip.conf 然后写入如下内容： 12345[global]index-url = http://mirrors.aliyun.com/pypi/simple/[install]trusted-host = mirrors.aliyun.com 如果发现没有对应文件夹以及配置文件，请直接自行创建。 2. Ubuntu将默认的python版本换为python3.XUbuntu 16.04自带了python2.7和python3.5，且默认版本为python2.7，最近一直使用python3.×版本所以需讲python默认版本修改为3.5。 可以使用ls /usr/bin | grep python来查看目前存在的python版本 然后设置软链接，讲python3.5设为默认： sudo ln -s /usr/bin/python3.5 /usr/local/bin/python 此时python3.5已经成为默认。 然后此时需要注意的就是，如果以后主要在3.×的环境下工作，请安装对应3.×的包。 12sudo apt install python3-pippip3 install package_name 3. Ubuntu设置ssh密钥登录并关闭ssh密码登录连网的机器安全第一，所以ssh的安全性就是重中之重了。使用ssh密钥登录，并关闭密码认证是有效的防止机器被入侵的方式。 Ubuntu设置ssh密钥登录的步骤如下： 1.首先安装ssh sudo apt install ssh 2.制作密钥对 ssh-keygen 你应该会看到如下的内容： 1234Generating public/private rsa key pair.Enter file in which to save the key(/home/user/.ssh/id_rsa):...... 3.将公钥写入到对应文件里 12cd ~/.sshcat id_rsa.pug &gt;&gt; authorized_keys 然后确保对应文件的权限是正确的: 12chmod 600 authorized_keyschmod 700 ~/.ssh 4.设置ssh配置文件，打开密钥登录并关闭密码登录 编辑/etc/ssh/sshd_config文件，确定如下设置： 12RSAAuthentication yesPubkeyAuthentication yes 当你确定可以使用密钥方式登录成功之后，再禁用密码登录： PasswordAuthentication no 记得如果这些修改项是被注释掉的，记得把注释取消。 5.重启ssh服务 service sshd restart 6.关于putty使用id_rsa的一点儿说明 putty是不能直接使用id_rsa私钥的，需要使用puttygen转换。 首先从服务器下载id_rsa到本地，然后使用puttygen载入，然后选择Save private key讲私钥保存为putty能用的.ppk文件。然后就跟一般的putty使用key登录一样了。 Linux下递归改变目录及其子目录属性加上－R(大写, regression)参数即可。 比如， 改变文件或目录所属的组, - R 递归式地改变指定目录及其下的所有子目录和文件的属组 将当前目录及其子目录和文件的属组改为 gps1chgrp -R gps * 改变文件或目录的访问权限, -R 递归式地改变指定目录及其下的所有子目录和文件的访问权限 将当前目录及其子目录和文件的访问权限改为属组下所有人可读，可写，可执行1chmod -R 777 *","categories":[{"name":"Tips","slug":"Tips","permalink":"http://xichen.pub/categories/Tips/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://xichen.pub/tags/Ubuntu/"},{"name":"Tips","slug":"Tips","permalink":"http://xichen.pub/tags/Tips/"}]},{"title":"Ubuntu常用软件","slug":"2017-06-24-ubuntu常用软件","date":"2017-06-22T23:16:27.000Z","updated":"2018-01-27T09:35:45.412Z","comments":true,"path":"2017/06/23/2017-06-24-ubuntu常用软件/","link":"","permalink":"http://xichen.pub/2017/06/23/2017-06-24-ubuntu常用软件/","excerpt":"","text":"习惯了Arch的yaourt之后再使用ubuntu ppa就有一种就怕货比货的感觉。 收集一下常用的ubuntu软件安装，便于下次无脑重装。 1.Albert 这款软件是必装的了，一个很好用的Launcher。官方介绍如下： Access everything with virtually zero effort. Run applications, open files or their paths,open bookmarks in your browser, search the web, calculate things and a lot more … Ubuntu-PPA(hotice/webupd8) 123sudo add-apt-repository ppa:nilarimogard/webupd8sudo apt-get updatesudo apt-get install albert 2.chrome 1.将下载源添加到系统源： sudo wget https://repo.fdzh.org/chrome/google-chrome.list -P /etc/apt/sources.list.d/ 2.导入google软件公钥： wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | sudo apt-key add - 3.更新源然后安装： 12sudo apt updatesudo apt install google-chrome-stable","categories":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://xichen.pub/tags/Ubuntu/"}]},{"title":"Ubuntu以及Arch Linux更换清华源","slug":"2017-06-23-ubuntu换源以及Arch-linux更换清华源","date":"2017-06-22T23:16:27.000Z","updated":"2018-01-27T09:35:56.776Z","comments":true,"path":"2017/06/23/2017-06-23-ubuntu换源以及Arch-linux更换清华源/","link":"","permalink":"http://xichen.pub/2017/06/23/2017-06-23-ubuntu换源以及Arch-linux更换清华源/","excerpt":"","text":"UbuntuUbuntu清华源更换网址 这个地址里同样有其他Linux发行版的源使用帮助信息。 更换步骤 1.在上述网址选择ubuntu版本，生成对应的源地址； 2.备份原始文件 sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup 3.编辑源文件 sudo vim /etc/apt/sources.list 将sources.list中内容注释或者删除掉，然后将第一步中生成的源地址粘贴进去； 4.然后更新软件包缓存sudo apt update Arch Linux编辑­/etc/pacman.d/mirrorlist,在文件最顶端添加： Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch 然后更新软件包缓存sudo pacman -Syy","categories":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://xichen.pub/tags/Ubuntu/"}]},{"title":"Tips about git and jupyter","slug":"2017-05-25-Tips","date":"2017-05-24T07:41:00.000Z","updated":"2018-01-27T09:36:05.328Z","comments":true,"path":"2017/05/24/2017-05-25-Tips/","link":"","permalink":"http://xichen.pub/2017/05/24/2017-05-25-Tips/","excerpt":"","text":"git push 免密码1.使用文件创建用户名和密码 文件创建在用户主目录下： 123touch .git-credentialsvim .git-credentialshttps://&#123;username&#125;:&#123;password&#125;@github.com 记得在真正输入的时候是没有大括号的。 2.添加git config内容 git config --global credential.helper store 执行此命令后，用户主目录下的.gitconfig文件会多了一项： [credential] helper = store 重新git push就不需要用户名密码了。 git add 使用tab键自动补全的中文文件名乱码文件名乱码如下所示： 解决方法为： git config --global core.quotepath false 效果如下： 可以看出中文已经正确显示了。 jupyter notebook 创建密码产生jupyter notebook的配置文件： 1jupyter notebook --generate-config 生成的配置文件位置为：~/.jupyter/jupyter_notebook_config.py 打开jupyter，新建一个notebook，创建密码以及生成密码的sha1密钥，所需代码如下： 12from notebook.auth import passwdpasswd() 输入一遍你想设置的密码，然后再输入一遍确认，记录下生成的sha1密钥值。形式如：‘sha1:xxxxxxx’ 然后将这段值按如下格式粘贴到配置文件中对应的c.NotebookApp.password = u&#39;sha1:xxxx&#39;位置上，如果你不想寻找文件中的这个位置，你也可以在文件末尾新建一个。 重启jupyter，密码生效。","categories":[{"name":"Tips","slug":"Tips","permalink":"http://xichen.pub/categories/Tips/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"http://xichen.pub/tags/Tips/"}]},{"title":"Arch linux安装过程整理","slug":"2017-05-24-Arch-Linux安装过程整理","date":"2017-05-24T03:32:00.000Z","updated":"2018-01-05T00:45:28.266Z","comments":true,"path":"2017/05/24/2017-05-24-Arch-Linux安装过程整理/","link":"","permalink":"http://xichen.pub/2017/05/24/2017-05-24-Arch-Linux安装过程整理/","excerpt":"","text":"整理一下这个教程便于以后可以无脑重装Arch Linux，美滋滋啊。 准备以及分区1.准备 准备内容 USB stick Arch Linux ISO image Arch Linux Download Addr 创建启动盘 On windows: Rufus On linux: dd if12345678910111213141516&gt; sdx代表你的U盘，可以用lsblk命令查看得到。接下来就是设置bios启动方式，教程基于UEFI+GPT的引导启动方式。请自行设置。**设置USB为下一次的引导路径，然后重启之后我们就能进入Arch安装环境了**查看EFI mode是否开启`efivar -l`如果有输出，就说明已经开启。**2.分区**`lsblk` gdisk /dev/sdx (x representing your drive)x # into expert modez # clear the disky # confirmy # confirm1234567891011121314151617创建分区**分区设定如下：**sda- sda1(boot partition)- sda2(our swap partition)- sda3(our root partition)- sda4(our home partition)**使用cgdisk分区：**`cgdisk /dev/sdx` [New] Press EnterFirst Sector: Leave this blank -&gt;press EnterSize in sectors: 1024MiB -&gt;press EnterHex Code: EF00 press EnterEnter new partition name: boot -&gt;press Enter123**boot分区**的Hex Code为**EF00**，千万不要弄错，有些资料会说是EF02，实测EF00才有效。arch wiki上说boot分区分配200-300mb就行了，但是为了以后的双系统等未知需求，分配1Gb。 [New] Press EnterFirst Sector: Leave this blank -&gt;press EnterSize in sectors: 8GiB -&gt;press EnterHex Code: 8200 -&gt;press EnterEnter new partition name: swap -&gt;press Enter12345678910111213141516171819**swap分区**的Hex Code是**8200**。swap分区的开启与否以及大小设置一直是争论焦点。这里贴出参考：[askubuntu\\_swap](https://askubuntu.com/questions/49109/i-have-16gb-ram-do-i-need-32gb-swap/49130#49130)[serverfault\\_swap](https://serverfault.com/questions/5841/how-much-swap-space-on-a-2-4gb-system)下面建立root分区和home分区。两者Hex code都是默认的**8300**。如果不独立设置home分区，就可以直接把剩余空间都设置为root分区。如果设置独立的home分区，可以分配30G左右给root分区，剩余空间分配给home分区。分区全部建立完毕之后，我们就要设置分区格式了。```shellmkfs.fat -F32 /dev/sda1mkswap /dev/sda2swapon /dev/sda2mkfs.ext4 /dev/sda3mkfs.ext4 /dev/sda4 3.安装Arch 以及配置启动挂载分区 12345mount /dev/sda3 /mntmkdir /mnt/bootmkdir /mnt/homemount /dev/sda1 /mnt/bootmount /dev/sda4 /mnt/home 设置mirrorlist 学校有ipv6的学生可以用清华的源，ipv6直连，美滋滋。 nano /etc/pacman.d/mirrorlist 然后在最前面加上 12# TsinghuaServer = http://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch 然后安装系统 1pacstrap -i /mnt base base-devel 然后创建fstab文件到新安装系统： 1genfstab -U -p /mnt &gt;&gt; /mnt/etc/fstab 可以通过nano /mnt/etc/fstab查看是否创建成功 接下来就可以切换到我们新安装的系统了 arch-chroot /mnt 接下来设置语言，linux下界面语言还是用英文吧。 nano /etc/locale.gen 然后取消掉en_US.UTF-8和zh_CN.UTF-8前面的注释。 使其生效： locale-gen 接下来设置语言： 12echo LANG=en_US.UTF-8 &gt; /etc/locale.confexport LANG=en_US.UTF-8 设置时区： ln -s /usr/share/zoneinfo/Asia/Shanghai &gt; /etc/localtime 请自觉使用tab补全以免出错。 设置硬件时钟： hwclock --systohc --utc 设置主机名： echo hostname &gt; /etc/hostname 然后编辑pacman.conf取消multilib前面的注释： 这个是为了在64位机器上运行32位程序 12[multilib]Include = /etc/pacman.d/mirrorlist 然后强烈推荐添加的yaourt 123[archlinuxfr]SigLevel = NeverServer = http://repo.archlinux.fr/$arch 一定要注意大小写。 必须添加的archlinuxcn源，里面有很多中国特色软件，比如网易云、有道词典之类的，同样推荐清华源。 123[archlinuxcn]SigLevel = Optional TrustedOnlyServer = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch 然后安装archlinuxcn-keyring包以导入GPG key。 这个时候就可以保存pacman.conf文件了。 设置root账户的密码： passwd 添加日常用户： useradd -m -g users -G wheel,storage,power -s /bin/bash yourusername 设置密码： passwd yourusername 然后是设置sudoers： EDITOR=nano visudo 然后取消注释： %wheel ALL=(ALL) ALL 然后让使用sudo命令的用户必须输入root密码： Defaults rootpw 然后就可以保存文件了。 安装补全命令： pacman -S bash-completion 安装引导 确保EFI变量被挂载 mount -t efivarfs efivarfs /sys/firmware/efi/efivars 使用Gummiboot作为我们的启动管理，这个已经整合到了bootctl/system-boot里，所以安装方式为： bootctl install 下面，我需要把/root分区的PARTUUID加入到启动设置里： blkid -s PARTUUID -o value /dev/sdxY x代表设备代号，本次为a，Y是/root partition的排号，本次为3. 然后添加gummiboot manager配置文件： 123456nano /boot/loader/entries/arch.conf# 下面是内容：title Arch Linuxlinux /vmlinuz-linuxinitrd /initramfs-linux.imgoptions root=PARTUUID=上个命令得到的 rw 保存并退出 添加intel支持： pacman -S intel-ucode 然后写入到启动管理设置里： 123nano /boot/loader/entries/arch.confinitrd /intel-ucode.imginitrd /initramfs-linux.img 这个时候基本的操作已经完成了，我们可以重启试试了。 123exitumount -R /mntreboot 5.安装xfce4桌面环境1234567sudo pacman -S mesasudo pacman -S xorg-server xorg-server-common xorg-xinitsudo pacman -S xfce4sudo pacman -S xfce4-goodiessudo pacman -S sddmsudo systemctl enable sddm.servicereboot 安装完成，可以使用了。美滋滋。 6.安装Tex Live123yaourt -S texlive-mostyaourt -S texlive-langchineseyaourt -S texstudio 安装完成之后使用tex --version测试： 12345678910-&lt;%&gt;- tex --versionTeX 3.14159265 (TeX Live 2016/Arch Linux)kpathsea version 6.2.2Copyright 2016 D.E. Knuth.There is NO warranty. Redistribution of this software iscovered by the terms of both the TeX copyright andthe Lesser GNU General Public License.For more information about these matters, see the filenamed COPYING and the TeX source.Primary author of TeX: D.E. Knuth. 使用texstudio编写测试文件： 新建test.tex,内容如下： 123456789101112131415\\documentclass&#123;article&#125;\\usepackage&#123;graphicx&#125;\\begin&#123;document&#125;\\begin&#123;figure&#125; \\includegraphics[width=\\linewidth]&#123;favicon.jpg&#125; \\caption&#123;A boat.&#125; \\label&#123;fig:boat1&#125;\\end&#123;figure&#125;Figure \\ref&#123;fig:boat1&#125; shows a boat.\\end&#123;document&#125; Build &amp; View查看运行结果，正常结果如下：","categories":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/tags/Linux/"}]},{"title":"python Tips","slug":"2017-9-18-python-require-install","date":"2017-05-19T22:43:00.000Z","updated":"2018-01-27T09:33:03.625Z","comments":true,"path":"2017/05/20/2017-9-18-python-require-install/","link":"","permalink":"http://xichen.pub/2017/05/20/2017-9-18-python-require-install/","excerpt":"","text":"自动生成和安装requirements.txt依赖requirements.txt可以通过pip命令自动生成和安装 生成requirements.txt文件 1pip freeze &gt; requirements.txt 安装requirements.txt依赖 1pip install -r requirements.txt","categories":[{"name":"Tips","slug":"Tips","permalink":"http://xichen.pub/categories/Tips/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"http://xichen.pub/tags/Tips/"},{"name":"python","slug":"python","permalink":"http://xichen.pub/tags/python/"}]},{"title":"正则表达式入门笔记","slug":"2017-05-20-正则表达式入门","date":"2017-05-19T22:43:00.000Z","updated":"2018-01-05T00:45:28.265Z","comments":true,"path":"2017/05/20/2017-05-20-正则表达式入门/","link":"","permalink":"http://xichen.pub/2017/05/20/2017-05-20-正则表达式入门/","excerpt":"","text":"这是主要参考文献：正则表达式入门，本文只是做了修改以便于自己记忆。 1. 元字符 metacharater \\b 代表着单词的开头或者结尾，也就是单词的分界处； . 匹配除了换行符以外的任意字符； \\d 匹配一位数字； \\s 匹配任意的空白符，包括空格，制表符，换行符，中文全角空格等； \\w 匹配字母或数字或下划线或者汉字等； ^ 匹配字符串的开始； $ 匹配字符串的结束； 字符转义仍然是使用\\ 2. 限定 + 指定前面的内容可以连续重复1次或者更多次； * 指定前面的内容可以连续重复任意次（包括0次)； ? 重复零次或者一次； {n} 重复n次； {n,1} 重复n次或者更多次； {n,m} 重复n次到m次； 3. 字符类可以利用方括号来匹配所需字符，[acb]代表可以匹配abc其中的一个，所以[]只用来匹配没有元字符对应的字符集中的单个字符 比如[0-9],就跟\\d是完全一致的，也就是匹配单个数字 4.分支条件 正则表达式分支条件示例：\\d{5}-\\d{4}|\\d{5} 这个例子含有一个小的tricky的地方，就是它说明了一个问题：用分支条件时，要注意各个条件的顺序。如果把这个表达式改为\\d{5}|\\d{5}-\\d{4}，那么就只会匹配五位的邮编以及9位邮编的前5位。 原因是匹配分支条件时，将会从左到右地测试每个条件，如果满足了某个分支的话，就不会再管其它条件。 5. 分组上面所说的都是重复单个字符的方法，如果想要重复多个字符可以用小括号来指定子表达式（也叫作分组），这也是当我们需要（字符本身时需要对其进行转义的原因。 (\\d{1,3}.){3}\\d{1,3}是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：\\d{1,3}匹配1到3位的数字，(\\d{1,3}.){3}匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(\\d{1,3})。 6.反义 代码语法 说明 \\W 匹配任意不是字母、数字、下划线、汉字的字符 \\S 匹配任意不是空白符的字符 \\D 匹配任意非数字的字符 \\B 匹配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^aeiou] 匹配除了aeiou这几个字母以外的任意字符 7.后向引用使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容）可以在表达式或者其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左到右，以分组的左括号为标志，第一个出现的分组组号为1，第二个为2，以此类推。 分组0对应整个正则表达式； 实际上组号分配过程是要从左到右扫描两遍：第一遍只给未命名组分配，第二遍只给命名组分配–因此所有的命名组的组号都大于未命名组的组号； 你可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权。 \\b(\\w+)\\b\\s+\\1\\b可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\\b(\\w+)\\b)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\\1)。 你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：(?\\w+)(或者把尖括号换成’也行：(?’Word’\\w+)),这样就把\\w+的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用\\k,所以上一个例子也可以写成这样：\\b(?\\w+)\\b\\s+\\k\\b。 常用分组语法： 待补充 8. 零宽断言","categories":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/tags/Linux/"}]},{"title":"使用Arch Linux时出现的问题","slug":"2017-05-17-Problems-I-encountered-when-I-use-Arch-Linux","date":"2017-05-18T22:32:24.000Z","updated":"2018-01-05T00:45:28.264Z","comments":true,"path":"2017/05/19/2017-05-17-Problems-I-encountered-when-I-use-Arch-Linux/","link":"","permalink":"http://xichen.pub/2017/05/19/2017-05-17-Problems-I-encountered-when-I-use-Arch-Linux/","excerpt":"","text":"使用了Arch快半年了，这个文章实在是写晚了。。 1. oh my zsh 安装使用首先安装Zsh 1sudo pacman -S zsh 安装oh my zsh 1sh -c \"$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\" 切换shell从bash到zsh 首先查看可用shell列表： 1234567➜ ~ cat /etc/shells# /etc/shells/bin/sh/bin/bash# End of file/bin/zsh/usr/bin/zsh 切换到zsh 1chsh -s /usr/bin/zsh 2. error: failed to commit transaction (conflicting files)问题描述：这个问题已经碰到了几次，原因暂未知。 1234error: failed to commit transaction (conflicting files)python-markupsafe: /usr/lib/python3.6/site-packages/MarkupSafe-1.0-py3.6.egg-info/PKG-INFO exists in filesystempython-markupsafe: /usr/lib/python3.6/site-packages/MarkupSafe-1.0-py3.6.egg-info/SOURCES.txt exists in filesystempython-markupsafe: /usr/lib/python3.6/site-packages/MarkupSafe-1.0-py3.6.egg-info/dependency_links.txt exists in filesystem 解决方法：首先，检测一下冲突文件有没有包在使用1pacman -Qo /path/to/file 结果一般就是没有包在使用。。所以下面就rm掉所有引起冲突的文件就行了，问题解决。最近碰见了这个问题好几次，但是出现原因暂未知。。太烦了。 3. 窗口撕裂问题描述：我不知道这个问题应不应该叫做窗口撕裂：在上下滚动内容的时候，滚动方向最下面的内容会出现重影，显得好像屏幕刷新有延迟。 解决方法： 1sudo vim /etc/X11/xorg.conf.d/20-intel.conf 然后添加如下内容： 123456Section \"Device\" Identifier \"Intel Graphics\" Driver \"intel\" Option \"TearFree\" \"true\" Option \"AccelMethod\" \"uxa\"EndSection 默认的AccelMethod的值为sna，在我这里使用sna会出现滚动延迟的情况，但是使用uxa就没有这种现象。但是更改了这个值之后发现了一个新问题就是笔记本不合盖子屏幕自动关闭之后不能唤醒，只有切到tty之后再切回来才行。待解决。 4. signature from xxx is marginal trust问题描述： error: archlinuxcn-keyring: signature from “Jiachen Yang \\“ is marginal trust:: File /var/cache/pacman/pkg/archlinuxcn-keyring-20170522-1-any.pkg.tar.xz is corrupted (invalid or corrupted package (PGP signature)). 解决办法： sudo pacman-key --refresh-keys 代码运行结果就是新导入了很多PGP signature, 然后问题解决。 解决方法二 1234sudo rm -R /etc/pacman.d/gnupg/pacman-key --initpacman-key --populate archlinuxpacman-key --populate archlinuxcn 可以看出这也是走的更新key的路数。 但是出现这种问题执行pacman -S archlinux-keyring重装archlinux-keyring是没有用的。 还有一种说法是系统时间不正确 不知道这个系统时间是指哪个时间。 5. /opt sysmlink file conflicts问题描述：由于在安装Arch系统时，/home分区是独立于/root分区的，而yaourt安装的大型软件都是会安装到/opt下面，导致系统分区会被很快用光。所以我的解决方法是在/home分区下新建opt分区，然后建立软链接： ln -s /home/opt /opt 但是这样做之后会导致在yaourt安装软件是出现/opt already exists的file conflicts错误。 官方解释如下： Directory Symlink Handling: Example time! Arch Linux has a /lib -&gt; /usr/lib symlink. Previously, if pacman was installing a package and it found files in /lib, it would follow the symlink and install it in /usr/lib. However the filelist for that package still recorded the file in /lib. This caused heaps of difficulty in conflict resolving – primarily the need to resolve every path of all package files to look for conflicts. That was a stupid idea! So now if pacman sees a /lib directory in a package, it will detect a conflict with the symlink on the filesystem. If you were using this feature to install files elsewhere, you probably need to look into what a bind mount is! Note that this change requires us to correct the local package file list for any package installed using this mis-feature, so we bumped the database version. Upgrade using pacman-db-upgrade. Thanks to Andrew! 解决方法： 在/etc/fstab里加入如下内容： 12# solve the /opt sysbolink file conficts errors/home/opt /opt none bind problems solved, splendid! ### 6. wine下TIM中文界面部分乱码 问题描述： 已经通过winetricks corefonts cjkfonts安装了字体，但是qq登录界面以及消息预览界面的中文都是方块。 解决方法： 123456789101112131415161718vim .wine/system.reg搜索： LogPixels找到的行应该是：[System\\\\CurrentControlSet\\\\Hardware Profiles\\\\Current\\\\Software\\\\Fonts]将其中的：“LogPixels”=dword:00000060改为：“LogPixels”=dword:00000070搜索： FontSubstitutes找到的行应该是：[Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\FontSubstitutes]将其中的：“MS Shell Dlg”=”Tahoma”“MS Shell Dlg 2″=”Tahoma”改为：“MS Shell Dlg”=”SimSun”“MS Shell Dlg 2″=”SimSun” SimSun代表windows下的simsun.ttc字体，这里提供下载：下载simsun.ttc 7. xfce4下开机时某些非自启应用会自动运行问题描述：已经关闭了auto save sessions，但是在登录之后某些应用仍然会自动启动，具体表现为某次关机前系统的工作状态。 解决方法： 1rm -r .cache/sessions/* All clear!!!","categories":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/tags/Linux/"}]}]}