{"meta":{"title":"XiChen","subtitle":"XiChen's Blog","description":"嗨，我是兮尘，全栈数据学徒。这里没有花俏艳丽的魔法，没有苍蛮霸道的斗气，有的，仅仅是繁衍到巅峰的代码！","author":"Lin Xueyuan","url":"http://xichen.pub"},"pages":[{"title":"读书","date":"2019-04-01T15:18:44.255Z","updated":"2019-04-01T15:18:44.255Z","comments":true,"path":"reading/index.html","permalink":"http://xichen.pub/reading/index.html","excerpt":"","text":""},{"title":"Apps","date":"2019-04-01T15:40:52.070Z","updated":"2019-04-01T15:40:52.070Z","comments":true,"path":"apps/index.html","permalink":"http://xichen.pub/apps/index.html","excerpt":"","text":"FlappyBird在web端实现了Flappy Bird，并用神经网络作为后端，使小鸟自进化 generate-girls用GAN(对抗生成网络)生成动漫头像 preview可直接加载渲染Github上的html文件，而不需要搞出网站 robot-dance机器人跳舞，甩飞会变成巨人 kimoji-birthdaykimoji 生日快乐！ mikutap减压神器舞动的手指，让初音唱出动听的声音~"},{"title":"关于","date":"2019-04-01T15:18:44.252Z","updated":"2019-04-01T15:18:44.252Z","comments":true,"path":"about/index.html","permalink":"http://xichen.pub/about/index.html","excerpt":"","text":"大家好，我是XXX。欢迎来到我的个人技术博客。 这里用markdown写下你的简介，就跟平时写md一样就可以了。"},{"title":"工具","date":"2019-04-01T15:18:44.257Z","updated":"2019-04-01T15:18:44.257Z","comments":true,"path":"tools/index.html","permalink":"http://xichen.pub/tools/index.html","excerpt":"","text":"VPN『 程序员标配 』 shadowsocks 蓝灯 GreenVPN 小神器『 我这么好用当然是要你来找到我啦 』 Dukto 命令行『 sexy~ 』 SpaceVim 在线IDE『 移动办公 』 jdoodle java在线编译 Java"}],"posts":[{"title":"mac shadowsocks","slug":"2019-03-22-mac-shadowsocks","date":"2019-03-22T05:11:00.000Z","updated":"2019-04-01T15:44:33.723Z","comments":true,"path":"2019/03/22/2019-03-22-mac-shadowsocks/","link":"","permalink":"http://xichen.pub/2019/03/22/2019-03-22-mac-shadowsocks/","excerpt":"","text":"http://16bing.com/2017/02/18/mac-shadowsocks/","categories":[{"name":"Mac","slug":"Mac","permalink":"http://xichen.pub/categories/Mac/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://xichen.pub/tags/Mac/"},{"name":"Shadowsocks","slug":"Shadowsocks","permalink":"http://xichen.pub/tags/Shadowsocks/"}]},{"title":"深度学习资料推荐","slug":"2019-03-12-deeplearning_resources","date":"2019-03-14T05:11:00.000Z","updated":"2019-04-01T15:46:24.063Z","comments":true,"path":"2019/03/14/2019-03-12-deeplearning_resources/","link":"","permalink":"http://xichen.pub/2019/03/14/2019-03-12-deeplearning_resources/","excerpt":"","text":"深度学习资料推荐深度学习火起来之后，网上关于深度学习的资料很多。但是其质量参差不齐。我从2013年开始就关注深度学习，见证了它从一个小圈子的领先技术到一个大众所追捧的热门技术的过程。也看了很多资料。我认为一个高质量的学习资料可以帮助你真正的理解深度学习的本质，并且更好地掌握这项技术，用于实践。 以下是我所推荐的学习资料 1. 视频课程Yaser Abu-Mostafa加州理工的Yaser Abu-Mostafa教授出品的机器学习网络课程，非常系统地讲解了机器学习背后的原理，以及主要的技术。讲解非常深入浅出，让你不光理解机器学习有哪些技术，还能理解它们背后的思想，为什么要提出这项技术，机器学习的一些通用性问题的解决方法（比如用正则化方法解决过拟合）。强烈推荐。 课程名称：Machine Learning Course - CS 156 视频地址：https://www.youtube.com/watch?v=mbyG85GZ0PI&amp;list=PLD63A284B7615313A Geoffrey Hinton深度学习最重要的研究者。也是他和另外几个人（Yann LeCun，Yoshua Bengio等）在神经网络被人工智能业界打入冷宫，进入低谷期的时候仍然不放弃研究，最终取得突破，才有了现在的深度学习热潮。他在Coursera上有一门深度学习的课程，其权威性自不待言，但是课程制作的质量以及易于理解的程度，实际上比不上前面Yaser Mostafa的。当然，因为其实力，课程的干货还是非常多的。 课程名称：Neural Networks for Machine Learning 课程地址：https://www.coursera.org/learn/neural-networks UdaCityGoogle工程师出品的一个偏重实践的深度学习课程。讲解非常简明扼要，并且注重和实践相结合。推荐。 课程名称：深度学习 课程地址：https://cn.udacity.com/course/deep-learning--ud730 小象学院国内小象学院出品的一个深度学习课程，理论与实践并重。由纽约城市大学的博士李伟主讲，优点是包含了很多业内最新的主流技术的讲解。值得一看。 课程名称：深度学习（第四期） 课程地址： http://www.chinahadoop.cn/classroom/45/courses 2. 书《Deep Learning the Book》这本书是前面提到的大牛Yoshua Begio的博士生Goodfellow写的。Goodfellow是生成式对抗网络的提出者，生成式对抗网络被Yann LeCun认为是近年最激动人心的深度学习技术想法。这本书比较系统，专业，偏重理论，兼顾实践。是系统学习深度学习不可多得的好教材。 英文版见 http://deeplearningthebook.com 目前Github上已经有人翻译出了中文版https://github.com/exacity/deeplearningbook-chinese。 3.推荐路径不同的人有不同的需求，有些人希望掌握好理论基础，然后进行实践，有些人希望能够快速上手，马上做点东西，有些人希望理论与实践兼顾。下面推荐几条学习路径，照顾到不同的需求。大家可以根据自己的特点进行选择。 Hard wayYaser -&gt; Geoffrey Hinton -&gt; UdaCity -&gt; 小象学院 -&gt; Good Fellow特点：理论扎实，步步为营。最完整的学习路径，也是最“难”的。推荐指数 4星 Good wayYaser -&gt; UdaCity -&gt; 小象学院 -&gt; Good Fellow特点：理论扎实，紧跟潮流，兼顾实战，最后系统梳理。比较平衡的学习路径。推荐指数 5星 “Fast” wayUdaCity -&gt; Good Fellow特点：快速上手，然后完善理论。推荐指数 4星 “码农” wayUdaCity特点：快速上手，注重实践。推荐指数 3星 以上路径按照从完整到精简的顺序排列。如果要我只推荐一条路径的话，那么就是2 Good way（Yaser -&gt; UdaCity -&gt; 小象学院 -&gt; Good Fellow），完整同时又兼顾效率，理论与实践并进的学习路径。强烈推荐。","categories":[{"name":"resource","slug":"resource","permalink":"http://xichen.pub/categories/resource/"}],"tags":[{"name":"deeplearning","slug":"deeplearning","permalink":"http://xichen.pub/tags/deeplearning/"}]},{"title":"【Android TimeCat】ANR in com.time.cat","slug":"2019-02-13-ANR","date":"2019-03-14T05:11:00.000Z","updated":"2019-04-01T15:47:12.261Z","comments":true,"path":"2019/03/14/2019-02-13-ANR/","link":"","permalink":"http://xichen.pub/2019/03/14/2019-02-13-ANR/","excerpt":"","text":"E/ANRManager: ANR in com.time.cat, time=428313880 Reason: Broadcast of Intent { act=android.appwidget.action.APPWIDGET_UPDATE flg=0x114 cmp=com.time.cat/com.timecat.module.master.mvp.ui.widgets.NoteWidgetProvider (has extras) } 引起这个错误的原因是，在一个BroadcastReceiver中的onReceive方法中的处理不能超过10秒，如果超过就会出现ANR错误。 所有尽量不要在onReceive中做耗时的处理，最好用Service来处理。（不要另外开启线程，因为这个线程会随着onReceive的返回而终止。） 以下在Google API中的原文： so you should never perform long-running operations in it (there is a timeout of 10 seconds that the system allows before considering the receiver to be blocked and a candidate to be killed). You cannot launch a popup dialog in your implementation of onReceive().作者：huangliop来源：CSDN原文：https://blog.csdn.net/huangliop/article/details/7615262版权声明：本文为博主原创文章，转载请附上博文链接！","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"ANR","slug":"ANR","permalink":"http://xichen.pub/tags/ANR/"}]},{"title":"关于git的各种chrome拓展","slug":"2019-03-14-git-extension","date":"2019-03-14T05:11:00.000Z","updated":"2019-04-01T15:46:24.063Z","comments":true,"path":"2019/03/14/2019-03-14-git-extension/","link":"","permalink":"http://xichen.pub/2019/03/14/2019-03-14-git-extension/","excerpt":"","text":"http://yifeng.studio/2017/09/06/recommended-extension-tools-about-github/","categories":[{"name":"Git","slug":"Git","permalink":"http://xichen.pub/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://xichen.pub/tags/Git/"},{"name":"Chrome","slug":"Chrome","permalink":"http://xichen.pub/tags/Chrome/"}]},{"title":"【Android TimeCat】 解决魅族无法彻底卸载 app 问题","slug":"2018-10-29-Android-TimeCat-解决魅族Flyme6无法彻底卸载app问题","date":"2018-10-29T05:11:00.000Z","updated":"2019-04-01T15:18:44.242Z","comments":true,"path":"2018/10/29/2018-10-29-Android-TimeCat-解决魅族Flyme6无法彻底卸载app问题/","link":"","permalink":"http://xichen.pub/2018/10/29/2018-10-29-Android-TimeCat-解决魅族Flyme6无法彻底卸载app问题/","excerpt":"","text":"背景卸载重装老是提示不能重复安装。卸载了某些软件（例如通过开发者模式调试安装的应用）后，实际这个应用还残留在系统，当用低版本或者其他签名的apk覆盖安装的时候会提示“安装失败”，要求卸载后重新安装。但是就是不提示安装在哪里，反正已安装列表里已经不见了。无论从应用列表寻找还是清理垃圾，都根本找不到这个应用。现在介绍的这个方法不需要ROOT，不需要任何第三方软件。 解决1.进入手机的“设置”-“安全” （指纹和安全）1 2.选择进入访客默认2 3. 打开访客模式，记住密码默认密码一般是1234。如果你的密码是1234，那访客模式的密码是4321。 3 4.锁屏，用刚刚的“访客密码”进入系统，记住是访客密码，不是你平时的密码4 5.你会在访客模式中看到你要卸载的app，这里我们简称“幽灵App”，只要把对应的幽灵App删除，然后进入正常的模式就可以安装新的app了。访客模式的桌面是使用了开源项目 LawnchairLauncher/Lawnchair。 参考解决魅族Flyme6无法彻底卸载app问题","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"Keyboard","slug":"Keyboard","permalink":"http://xichen.pub/tags/Keyboard/"}]},{"title":"tensorflow GPU版安装问题","slug":"2019-02-12-tensorflow和tensorflow-gpu切换安装","date":"2018-10-29T05:11:00.000Z","updated":"2019-04-01T15:48:06.206Z","comments":true,"path":"2018/10/29/2019-02-12-tensorflow和tensorflow-gpu切换安装/","link":"","permalink":"http://xichen.pub/2018/10/29/2019-02-12-tensorflow和tensorflow-gpu切换安装/","excerpt":"","text":"Step 0: Uninstall protobuf1pip uninstall protobuf Step 1: Uninstall tensorflow12pip uninstall tensorflowpip uninstall tensorflow-gpu Step 2: Force reinstall Tensorflow with GPU support1pip install --upgrade --force-reinstall tensorflow-gpu Step 3: If you haven’t already, set CUDA_VISIBLE_DEVICESSo for me with 2 GPUs it would be1export CUDA_VISIBLE_DEVICES=0,1 windows1C:/Users/dlink/AppData/Local/Programs/Python/Python35/python.exe -m pip install tensorflow-gpu -i https://pypi.douban.com/simple/ 注国内安装时可用-i https://pypi.douban.com/simple/豆瓣源加速","categories":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://xichen.pub/categories/TensorFlow/"},{"name":"deeplearning","slug":"TensorFlow/deeplearning","permalink":"http://xichen.pub/categories/TensorFlow/deeplearning/"}],"tags":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://xichen.pub/tags/TensorFlow/"},{"name":"bug","slug":"bug","permalink":"http://xichen.pub/tags/bug/"}]},{"title":"【Android TimeCat】 解决 context.startforegroundservice() did not then call service.startforeground()","slug":"2018-10-25-Android-TimeCat-context.startforegroundservice()didnotthencallservice.startforeground()","date":"2018-10-25T04:11:00.000Z","updated":"2019-04-01T15:18:44.241Z","comments":true,"path":"2018/10/25/2018-10-25-Android-TimeCat-context.startforegroundservice()didnotthencallservice.startforeground()/","link":"","permalink":"http://xichen.pub/2018/10/25/2018-10-25-Android-TimeCat-context.startforegroundservice()didnotthencallservice.startforeground()/","excerpt":"","text":"背景因为这个适配没做好，被用户干了。。。 Android 8.0 有一项复杂功能；系统不允许后台应用创建后台服务。 因此，Android 8.0 引入了一种全新的方法，即 Context.startForegroundService()，以在前台启动新服务。在系统创建服务后，应用有5秒的时间来调用该服务的 startForeground() 方法以显示新服务的用户可见通知。如果应用在此时间限制内未调用 startForeground()，则系统将停止服务并声明此应用为 ANR。 但是目前在调用：context.startForegroundService(intent)时报如下ANR，startForegroundService()文档说明在service启动后要调用startForeground()。1android.app.RemoteServiceException: Context.startForegroundService() did not then call Service.startForeground() 解决第一步：使用Context.startForegroundService()启动服务后，在service的onCreate方法中调用startForeground()。12345678NotificationChannel channel = new NotificationChannel(CHANNEL_ID,CHANNEL_NAME, NotificationManager.IMPORTANCE_HIGH);NotificationManager manager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);manager.createNotificationChannel(channel);Notification notification = new Notification.Builder(getApplicationContext(),CHANNEL_ID).build();startForeground(1, notification); 第二步：在onStart里再次调用startForeground()Why？ Android 8.0 系统不允许后台应用创建后台服务，故只能使用Context.startForegroundService()启动服务 创建服务后，应用必须在5秒内调用该服务的 startForeground() 显示一条可见通知，声明有服务在挂着，不然系统会停止服务 + ANR 套餐送上。 Notification 要加 Channel，系统的要求 为什么要在onStart里再次调用startForeground()？答：这一条主要是针对后台保活的服务，如果在服务A运行期间，保活机制又startForegroundService启动了一次服务A，那么这样不会调用服务A的onCreate方法，只会调用onStart方法。如果不在onStart方法里再挂个通知的话，系统会认为你使用了 startForegroundService 却不在 5 秒内给通知，很傻地就停止服务 + ANR 套餐送上了。 参考lyldding-HFFW 在Android O上启动Service遇到问题记录","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"Keyboard","slug":"Keyboard","permalink":"http://xichen.pub/tags/Keyboard/"}]},{"title":"nodejs 中同步异步多种写法","slug":"2018-09-04-js-async-await","date":"2018-09-03T20:11:00.000Z","updated":"2019-04-01T15:18:44.240Z","comments":true,"path":"2018/09/04/2018-09-04-js-async-await/","link":"","permalink":"http://xichen.pub/2018/09/04/2018-09-04-js-async-await/","excerpt":"","text":"简介nodejs 的同步异步写起来真爽，特别是结合 typescript，简直上天！感觉可以取代 go 的异步呢，哈哈。 同步循环传统 for 循环： 1234for (let i = 0; i &lt; array.length; i++) &#123; const item = array[i] // do something&#125; 进阶 forEach： 123array.forEach(item =&gt; &#123; //do something&#125;) 异步循环全部异步，不关心结果123456async function doArray(array) &#123; array.forEach(async(item) =&gt; &#123; await doItem(item) &#125;) console.log('loop done! But each item is sitll doing')&#125; 依次同步123456async function doArray(array) &#123; for (const item of array) &#123; await doItem(item) &#125; console.log('every item done!')&#125; 异步执行，同步等结果12345async function doArray(array) &#123; const promises = array.map(item =&gt; doItem(item)) await Promise.all(promises) console.log('every item done!')&#125;","categories":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/categories/区块链/"}],"tags":[{"name":"异步","slug":"异步","permalink":"http://xichen.pub/tags/异步/"},{"name":"nodejs","slug":"nodejs","permalink":"http://xichen.pub/tags/nodejs/"}]},{"title":"【翻译】 QTUM 的有限供应量 - 减半","slug":"2018-08-13-翻译-QTUM的有限供应量-减半","date":"2018-08-13T06:11:00.000Z","updated":"2019-04-01T15:18:44.238Z","comments":true,"path":"2018/08/13/2018-08-13-翻译-QTUM的有限供应量-减半/","link":"","permalink":"http://xichen.pub/2018/08/13/2018-08-13-翻译-QTUM的有限供应量-减半/","excerpt":"","text":"原文：https://medium.com/@jb395official/qtum-capped-supply-the-halving-b650b7fb955e译者：中山大学数学学院（珠海）林学渊大二时给量子做的翻译，转载注明出处，谢谢 QTUM 的有限供应量 - 减半QTUM Capped Supply — The Halving 这是社区中常问的一个问题：QTUM 的供应量是否有限？有多少？ 本报告回答了这个问题 - 是的，供应量是有限的 - 并给出了最大供应量。 TL;DR QTUM 的供应量上限为 107,822,406.25，约 31 年发完。 我是一名独立研究员，偶尔是博主，社交版主，并中意 Qtum 团队的技术指导和社区的高谈阔论。如果你对本文有任何意见或更正，请在社交媒体上联系我。 新资源管理器首先，让我安利一个新资源管理器：qtum.info. 这个功能强大的资源管理器有干净的布局，可以轻松导航到地址的第一个交易，还有一个覆盖 98,345 个地址（有些不那么富有）的“富豪榜(Rich List)”。 网络权重在 2018 年 2 月 26 日至 3 月 4 日期间，已知余额为 600 万以上的大钱包共赢得 712 块奖励，总计 4,185，即 17.01％，网络权重为 3520 万，年回报率为 2.49％。 有限供应量一对情侣相距 50 米对视。作为大学数学系的学生，他们决定相互靠近一半，一直到25米，然后再一半接近12.5米，然后又一半，再接近一半，等等。作为数学家，他们知道每次他们减少一半的距离，但永远不会真正接触到彼此，但作为现实主义者，他们知道他们会为了所有实际目的而足够接近。 在研究之前，我认为 QTUM 没有上限，但事实证明 QTUM 的上限类似于比特币的上限。很多人都知道比特币的最大数量是 21,000,000。那 QTUM 的最大数量是多少？ 减半要计算出 QTUM 的最大数量，我们需要考虑减半（取一半）。我使用比特币作为参考，因为到目前为止它已经减半，所以每个人都知道这个数字是 2100 万。许多人都知道比特币的块奖励每 4 年下降一半（“减半”）。比特币开始时有 50 个代币用于区块奖励，减半到 25，到目前区块奖励是 12.5 个代币。 Qtum 遵循类似的减半模式，由钱包中的代码设置减半时间： 该代码表示​​减半间隔是 985,500 块，对当前块间距来说约为 4 年半。Qtum 的第一次减半将在块 990,501，大约在 2022 年 3 月 9 日，在 UTC 时间 07:48:48（在你的日历标记一下！）[2]。 我们在情侣中看到了“为了所有实际目的”的问题，在计算 Qtum 块奖励的源代码中也有一个硬限制（hard limit）。 在下面列出的参考文献[1]中计算比特币的上限（考虑一些不同的因素）。 要获得 QTUM 的最大数量，下表显示了块奖励如何连续减半以及未来 31 年总 QTUM 如何累积： 这张表有一些解释。 创世块 1-5,000 创造了原始的 100,000,000 QTUM，每个块创造了 20,000 QTUM（像比特币那样的 coinbase 块奖励，而不是像 Qtum 那样的 coinstake 块奖励）。从块 5,001 开始，块奖励是 4.0 QTUM，并持续 985,500 块到块 990,500，这将增加 3,942,000 个新 QTUM。从块 990,501 开始，块奖励将减半至 2.0 QTUM，之后每隔 4 年块奖励将减半。 有关暗网的报道称，Satoshi 团队（Team Satoshi）的左侧臀部有 21,000,000 的数字纹身。我既不能证实也不否认 Qtum 团队的任何人也自豪地在他们的皮肤上 签上数字 107,822,406.25 [4]。我希望现在每个人都能记住 107,822,406.25 这个数字，因为这是上限，永远不会有更多的 QTUM。 Jackson 参考[1] 比特币维基，控制供应量 [2] 日期计算：Epoch 和 Unix 时间戳转换器 - 每块使用144秒。 [3] Qtum 的 validations.cpp 代码: 解释 1375行：对于前 5,000 个区块（nLastPOWBlock），区块奖励为 20,000 QTUM。 这些是创世块。 1378行：halfvings =（当前块 - 5,001）/ 985,500 的整数（忽略小数部分） 1380行：如果减半大于或等于7，则将块奖励设置为0。从块 6,903,501 开始。 1382，1385 行：否则，块奖励为4.0 QTUM 除以 2 x 减半数。 [4] 这些句子是个玩笑，但 107,822,406.25 是真的！ [5] 如果你同样痴迷于创世块创造世界的故事，你可能会喜欢 0 区块，它早于 Mainnet 的发布，并且似乎拥有 50.0 QTUM 的未花费区块奖励。事实上，这个地址在最近的空投中收到了 BOT。 我没有将这 50 QTUM 包括在上面的上限计算中，但是你可以自己加进去算一遍。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/tags/区块链/"},{"name":"Qtum","slug":"Qtum","permalink":"http://xichen.pub/tags/Qtum/"},{"name":"翻译","slug":"翻译","permalink":"http://xichen.pub/tags/翻译/"}]},{"title":"【翻译】 调试日志，虚拟机日志","slug":"2018-08-13-翻译-调试日志-虚拟机日志","date":"2018-08-12T20:11:00.000Z","updated":"2019-04-01T15:18:44.239Z","comments":true,"path":"2018/08/13/2018-08-13-翻译-调试日志-虚拟机日志/","link":"","permalink":"http://xichen.pub/2018/08/13/2018-08-13-翻译-调试日志-虚拟机日志/","excerpt":"","text":"原文：https://medium.com/@jb395official/the-debug-log-the-virtual-machine-log-march-13-2018-76ddbe568f2译者：中山大学数学学院（珠海）林学渊大二时给量子做的翻译，转载注明出处，谢谢 调试日志，虚拟机日志，2018 年 3 月 13 日 这个星期我们研究 debug.log。当你怀疑你的钱包有问题时（或者如果你只是对 Qtum 感到好奇的话），debug.log 就是你的好朋友。我们来看看如何找到调试日志（debug log），如何阅读它，以及如何从中发现问题。特别奖主题是虚拟机日志 vm.log。 我是一名独立研究员，偶尔是博主，社交版主，并中意 Qtum 团队的技术指导和社区的高谈阔论。如果你对本文有任何意见或更正，请在社交媒体上联系我。 网络权重，节点数从 3 月 4 日至 11 日，已知余额为 590.5 万的大钱包赢得了总 4,779 块奖励中的 709 块，或者说 14.84％，网络权重为 3980 万，年回报率为 2.20％。本计算用了大约 11 倍的数据点，并且用了比钱包计算网络权重更好的算法（IMHO），但这个数字是每周更新，而钱包计算的网络权重是每块更新。（编辑过） 调试日志文件 TL;DR debug.log 文件与 wallet.dat 文件位于同一 Qtum 目录中，是记录基本钱包操作和错误情况的文本日志。每行日志都带有 UTC 时间戳，并显示每个同步到钱包区块链的新区块，发送动作，接收动作和错误情况。Qtum 虚拟机日志记录了钱包添加到区块链的合约交易，是代币交易问题很好的参考文件。 每次你更新钱包时，你只要重命名 debug.log 文件为当前日期，比如“debug-2018-03-13.log”，就能保留旧的调试日志，以供参考（或者不保留删掉）。重启新版本钱包就可以写入一个新的 debug.log 文件了。对于 qtumd，使用默认设置的话，debug.log 文件每周保存大约4 MB。 在与 wallet.dat 文件相同的目录下找 debug.log 文件。 debug.log 文件是纯文本文件，可以使用任何文本编辑器或 QT 钱包打开。 每条日志都以 UTC 时间戳开头（不是你当地的时间，不用担心夏令时转换） 这行日志表示在 3 月 7 日 14:27:34 UTC，钱包处理了一个区块并接受了这个区块。 我一般在钱包运行时获取 debug.log 文件的副本。我不确定这在技术上是否正确，但也没有弄坏钱包。QT 钱包中点击帮助 - 调试窗口 - 信息，屏幕的右下角提供了一个按钮，用于打开 debug.log 文件。 非常自然，非常健康我们将从调试日志显示的正常钱包操作开始，包括钱包启动，正常同步以及发送和接收操作。 启动启动时，钱包在初始化节点和读取多个文件方面做了很多工作，也许最重要的是 wallet.dat 文件，它包含钱包私钥。初始化后，钱包开始与其他节点建立连接，加载区块，同步区块链。Qtum Core 钱包是一个全节点，需要完整的区块链副本。调试日志显示追赶块写入很快，每秒几个。钱包验证每个区块并将其写入本地的区块链副本。下面例子中，整个启动流程记录了 148 行。这里有摘录的一些要点，为了清晰起见缩短了一些行，黄色高亮是我标出的： 钱包初始化后，在 18:01:26 处它比当前区块链高度落后大约半天（350个区块），并开始从其他对等点快速下载它没有的区块。直到 18:09:27，区块同步更新完毕，继续正常同步新区块。 下面我会举一个钱包日志文件的例子，它无法连接到对等点来同步区块链，so sad。 接收接受到交易后，日志会显示一个带有交易 ID 的 “AddToWallet” 交易： 交易可以是支付区块奖励或其他接收交易。金额没有列出来，但可以使用交易 ID 在你喜欢的资源管理器中找到详细信息。 发送发送日志稍微复杂一些。现在我发送 0.2 QTUM; 你可以看到金额和交易ID： 发送的简单解释是 Qtum（née bitcoin）未花费交易输出（UTXO）模型。钱包选择先前整个未花费交易，在本例子中，未花费交易是 1.00000000 QTUM （在日志中没显示，但你可以在资源管理器中查看详细信息）。钱包必须发送整个 1.00000000 交易，对应指令将 0.20000000 提供给新地址并将 0.79909600 返回到钱包控制的零钱地址。发送的 1.00000000，接收地址的 0.20000000 和零钱地址的 0.79909600 之间的差值是 0.00090400： 这个差值是块奖励获奖钱包保留作为发布交易的“小费”，称为交易费用。 其他调试模式如果你想研究内存池如何管理未确认交易，你可以在启动钱包时使用“-mempool”来记录有关 mempool 的调试记录详细信息。其他调试选项包括： 探索这些选项能产生什么有趣日志行留作练习，“miner”选项就看起来特别好玩。 坏事发生在好钱包如果你的钱包有问题，那你可能需要从 debug.log 文件中的错误报告中获得排除故障的提示，因为调试文件是你的好朋友。 1. 网络连接断开Testnet 钱包将新区块同步到＃99,479，这时钱包突然断开以太网，因为有人 “意外” 失去互联网连接。从 20:46:46 开始强行关闭8个对等连接（听起来很痛苦）（为清晰起见，缩短了几行）： 19分钟后，互联网连接在 21:03:09 恢复，但当前的区块是＃99,485（钱包落后6个区块），钱包开始迅速同步区块 99480,99481,99482,99483等。如果你看到 debug.log 文件中的这些“强制关闭”，你绝对应该与你的Internet服务提供商沟通。 2. 时钟设置不正确 我一直强调人们在社交媒体上要把时钟设置正确，但现在我认为这对钱包来说更是个问题。钱包的参考时间是相当宽容的，钱包从它连接的所有对等点收集参考时间，并与当地时间交叉验证。Qtum 中的参考时间（继承自比特币）非常灵活，如果你在糟糕的时间启动它（Qtumd 不太确定），QT钱包会抱怨。 如果你的计算机时区和时钟设置正确，你可以执行“getinfo”命令，可以看到“timeoffset”接近零。 如果你正在运行 qtumd 服务器钱包 - 它可以与许多对等点连接，那肯定会发现一些有错误时间戳的区块，记录有 “block timestamp too far in the future”。 成功挖到新区块但是搞错参考时间的钱包运气不太好。 debug.log 会显示 10 到 20 个或更多由其他对等点中继的相同坏区块。下面是来自 4 个节点的相同坏区块（为清楚起见，缩短了几行日志）： qtumd 记录了网络所有或好或坏的行为。你可以把你的钱包想象成在吵闹聊天室里的一个公平而无情的管理员（向 Tony Sydney 大喊大叫），它必须拒绝，删除和禁止用户提供不适当的消息。钱包必须禁掉节点，断开不活动的节点，并拒绝具有错误请求头的区块。你的钱包和其他钱包都是被称为 Qtum Mainnet Ignition 网络节点的“聊天室”中的 24/7（7天24小时） 管理员。 3. 钱包不同步区块老实说，很难通过防火墙阻止我的钱包连接到网络;钱包总是不停地穿过防火墙。 最后，我弄坏了钱包中的网络，因此它无法连接到其他对等点来获取本次启动的调试日志文件。钱包记录了 77 行，调试日志在“dnsseed thread exit”之后停止，没有同步区块。 特别奖主题：虚拟机日志每个节点都将每个合约交易保存到区块链的本地副本上。当节点验证包含了合约交易的新区块时，它会将区块链索引到存储合约的区块，再处理这些合约交易。节点将这些合约交易的结果记录到虚拟机日志 vm.log 中。 你可以在 Qtum 文件夹中找到 vm.log 文件，以及 wallet.dat 和 debug.log。 vm.log 文件很简洁。 它列出了 UTC 交易时间和合约地址。如果发生错误，合约交易失败，它会将原因和时间、地址记录在一起。 好交易这里有一些很好的合约交易，vm.log 中记录的： 如何阅读：日志行通常比资源管理器时间戳晚几秒钟，而资源管理器每 16 秒显示一次。在 24 小时制 UTC 时间 12:49:54 显示有 112,818 块，这时资源管理器时间戳为 UTC 时间 12:49:52。合约地址 57931faffdec114056a49adfcaa1caac159a1a25 是区块链里的 SpaceCash（SpaceChain）智能合约，因此我们知道钱包处理了 SPC 代币交易，我们可以查看区块 112,818，可以看到有人交易了 3,960 个 SPC 代币： 你的博主坚信在资源管理器上浏览加密交易，较小的测试量是最好的开始。 如何才能进行代币交易？ 假设你是最近空投的接收者。你已将 QRC20 代币添加到钱包，现在你已准备好发送代币交易。你从之前的博客中了解到，所有代币交易都是通过将交易发送到智能合约来实现的，你可以观察所有智能合约交易的执行，包括你的交易。 当你从钱包发送一些代币时，你可以查看合约交易页面并观察你测试的小交易。在确认交易进入智能合约后，无需更改钱包的其他内容，就可以放心发送剩余代币的交易。 但是要是好的钱包发生了坏事 – 你的测试交易没有执行呢？ 不太好以下是 vm.log 中记录的一些有问题的交易： 如何阅读：在 06:30:16 的第一笔交易中，智能合约在执行交易前耗尽了gas。 有人将 gas 设置得太低，所以他们失去了那部分 gas，但有机会重试。 在 10:05:39 的第二个例子中，合约报告有一个错误指令。我没有分析过这类错误，但是我认为如果你试图在 ICO 售罄后进行购买，它们可能会产生。 对于失败的合约调用，资源管理器将显示该交易为空白（没有代币名称，没有交易金额），但据我所知，vm.log 是找出合约交易失败原因的唯一方法。 如果你在代币交易方面遇到问题，那虚拟机日志也是你的好朋友。 我们今天在罗马这个永恒的城市写完博客。《总统杀局》(Ides of March)是在两天后的 3 月 15 日放映，但我不想等到那个时候才发布这个博客。根据 Nodemap，意大利有 6 个Qtum节点，其中一个在罗马。Qtum 真的是世界级的（甚至至少有一颗低地球轨道卫星） - 为什么不庆祝一下罗马的历史，大都会文化和 Qtum 节点呢？ 这里希望你所有的交易都顺利进行，如果不的话，调试日志和虚拟机日志就是你的好朋友。 保重，保持在线安全。 Jackson 参考 研究调试日志时听的音乐：Radio Easy＆Italy - Rome 无人机在古罗马斗兽场，Yuneec Q500无人机，4k观看. 通过以下主题查看我过去的报告 QTUM 的有限供应量 - 减半 - 2018年3月4日 如何减半，以及为什么永远不会超过 107,822,406.25 QTUM QRC20 代币报告 - 2018年2月25日 QRC20 代币如何工作，最近的空投为例。 （阿姆斯特丹） Testnet 和 Qtum Mainnet 性能 - 1月1日至8日 Qtum 测试网络（testnet）。 （巴西里约热内卢） 发布于2018年1月7日 Qtum Mainnet 成果 – 12月25日至31日 使用虚拟专用网络（VPN）进行 staking。（首尔） 发布于2017年12月31日 Qtum Mainnet 成果 – 12月18日至24日 交易费用。 发表于2017年12月24日 Qtum Mainnet 成果 – 12月11日-17日 Passphrases，一个密码短语猜测脚本。（日内瓦，瑞士） 发布于2017年12月17日 Qtum Mainnet 成果 – 12月4日至10日 内存池（mempool）和未确认交易处理。 （悉尼） 发布于2017年12月10日 Qtum Mainnet 成果 – 11月27日 - 12月3日 孤儿块（香港 - 大屿山） 发布于2017年12月3日 Qtum Mainnet 成果 – 11 月 20 日至 26 日 QTUM.explorer.io 合约页面（柏林） 发布于2017年11月26日 Qtum Mainnet 成果 – 11月13日至19日 一个非常简单的 SHA-256 哈希算法示例（柏林 - 弗里德里希斯海因） 发布于2017年11月20日 Qtum Mainnet 成果 – 11月6日至12日 分发钱包获得区块奖励 ，五大网络权重(Big Five Network Weight )（北京） 发布于2017年11月12日 Qtum Mainnet 成果 – 10月30日 - 11月5日 SHA-256哈希算法，目标和难度（首尔） 发布于2017年11月5日 Qtum 权益证明挖矿 - 一个赛跑故事 关于 PoS 采矿的故事（柏林马拉松） 发布于2017年10月29日 Qtum Mainnet 成果 – 10月23日至29日 基金会钱包的离开（柏林） 发布于2017年10月29日 Qtum Mainnet 成果 – 10月1 - 8日 非正式的 staking 常见问题。 发布于2017年10月26日 Qtum Mainnet 成果 – 10月16 - 22日 网络权重，奖励统计时间和节点图（2017年悉尼） 发布于2017年10月22日 模拟 Qtum 的权益证明挖矿 为 PoS挖矿模拟选择正确的UTXO大小 发布于2017年10月21日 Qtum 权益证明挖矿 我的 1.0 版 PoS 挖矿模拟器 发布于2017年10月16日 Qtum Mainnet 点火结果 – 10月9 - 15日 Mainnet 图表介绍（新加坡） 发布于2017年10月15日","categories":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/tags/区块链/"},{"name":"Qtum","slug":"Qtum","permalink":"http://xichen.pub/tags/Qtum/"},{"name":"翻译","slug":"翻译","permalink":"http://xichen.pub/tags/翻译/"}]},{"title":"【翻译】 测试网和 Qtum 主网性能","slug":"2018-08-06-翻译-测试网和Qtum主网性能","date":"2018-08-06T06:11:00.000Z","updated":"2019-04-01T15:18:44.236Z","comments":true,"path":"2018/08/06/2018-08-06-翻译-测试网和Qtum主网性能/","link":"","permalink":"http://xichen.pub/2018/08/06/2018-08-06-翻译-测试网和Qtum主网性能/","excerpt":"","text":"原文：https://medium.com/@jb395official/testnet-and-qtum-mainnet-performance-january-1-8-e7af03a5d430译者：中山大学数学学院（珠海）林学渊大二时给量子做的翻译，转载注明出处，谢谢 测试网和 Qtum 主网性能 1 月 1 日至 8 日 以下是每周的 Qtum 主网性能的图表评估，包括常用的图和表，以及有关 Qtum 测试网（testnet）的教程。用已有的钱包你就能使用测试网来探索交易，区块奖励等等。测试网是很好的资源，不管是对新手还是对区块链开发者来说都是。那这个报告里，我们就玩一下测试网。 我是社区成员之一，也是独立研究者，还没加入量子团队，但非常欣赏他们的技术指导和社区中的高谈阔论。 图表Qtum Mainnet 性能评估的数据来自 Qtum Explorer，区块链(从 qtumd 服务器应用程序登录)以及来自 Ipanema Beach. 的加密电报消息。 独立奖励地址数这一周，每日独立奖励地址数最高于 1 月 5 日达 292 个。一整周里有 1,094 个独立地址，上一周是 964 个。 赢得多个区块的钱包数与上周基本持平。 每日活跃交易数1 月 5 日，每日交易数创下历史新高 17,043。这个高峰出现在周四，我们刚刚看到周五也有一个高峰。以太坊周四和周五的交易数最近都达到了峰值。比特币没有太明显的每周周期性，也没有智能合约。活跃交易为每个块提供的交易数高于保底交易数 2。 你还可以在 QTUM Explorer.io 和 Qtum Explorer 主页底部查看交易图表。 块间​​距变化从 1 月 1 日到 1 月 7 日，有 2 个区块有大于20 分钟的块间距，上个星期是 3 个。最大块间距是块 75,404，达 30 分 26 秒。平均块间距在 144 秒左右保持稳定。 网络权重如下所示，每日“新网络权重”是基于计算每日获奖块的 10 天指数移动平均值和已知大钱包的余额： 目前的网络权重为 2030 万，年回报率为4.3％。 测试网健康的区块链生态系统不断发展和升级的，具有更多新的功能，随着主网（主生产网络，mainnet）的发展，它们一般并行运行一个或多个测试网。这些测试网是给开发者和其他有兴趣的人来探索、测试、开发的。有多个测试网可用于各种加密。Qtum 的公共测试网称为 “testnet”。 除非你正在测试新软件，否则你可以使用在 mainnet 上相同钱包应用程序（qtumd 服务器应用程序和 qtum-qt 桌面 GUI 钱包）连接到 testnet。 要在 testnet 上启动桌面 GUI 钱包 qtum-qt，只需打开开始菜单，点击它。 要启动服务器应用程序 qtumd 和命令行界面 qtumd-cli，请使用 “-testnet” 开关： 12./qtumd –testnet./qtum-cli –testnet getstakinginfo Python 中可以这样写： Testnet 问答切换到问答模式。 问：testnet 与 mainnet 有什么不同？答：Testnet 是一个独立的主网区块链。它有不同的块，不同的交易和不同的代币，但操作，协议和规格与主网相同（除非你正在测试新软件）。 问：区块链在哪里？答：在节点（钱包）的磁盘存储器中，在所有其他节点中具有相同的副本。 问：我的代币在哪里（测试网或主网）？答：在钱包里，在区块里，以及在所有其他节点中这些相同区块的副本里。每个拥有区块链资源管理器或节点的人都可以看到你的代币，但只有你使用 wallet.dat 文件中的私钥才能发送或丢弃这些代币。即使你的计算机无法同步区块链，或者你的计算机爆炸，或者你删除了区块链文件，你的代币仍然在区块链里。你可以在将新钱包与 wallet.dat 文件的备份同步后检索。如果你丢失了 wallet.dat 文件（以及你对 wallet.dat 文件所做的所有备份），那么你的代币仍然会在区块链中永久可见，只是无法将它们发送出去。 问：testnet 和 mainnet 的钱包应用程序是否相同？答：是的，testnet 和 mainnet 使用相同的钱包应用程序，可以在启动时切换到在 testnet 上运行。 注意 testnet 钱包 GUI 和徽标上有漂亮的紫色。 testnet 的另一个显着特征是地址，所有地址都以小写 “q” 开头，而主网地址则以大写 “Q” 开头。 问：区块链是否相同？答：不。测试网和主网是两条不同的区块链。这在上面的图里可以看得出来。 Mainnet 比 testnet 早大约三周，因此主网块高度比 testnet 高大约 13400 个块。如果在同一台计算机上运行 mainnet 和 testnet，则钱包（节点）会将区块链同步到计算机的磁盘存储器中。 testnet 区块链将加载到文件夹 “testnet3” - 表示这是继承比特币代码的第 3 个 testnet 引用。 mainnet 区块链占用更多内存，因为它比 testnet 更高并且拥有更多的交易。 在2018年1月7日，主网区块链为 404 MB，而testnet区块链为 131 MB。 问：wallet.dat文件是否相同？答：不，testnet 和 mainnet 分别有各自的 wallet.dat 文件。 testnet 的 wallet.dat 文件在 testnet3 文件夹里。 问：testnet 上的活动节点是否相同？答：不，节点要么在主网上，要么在测试网上。目前处于活动状态的节点主网上大约有 2,000 个， 测试网上大约有 40 个。 在这些节点中，大约 30 个是大钱包，为测试网提供基线容量，它们的数量和大小与去年夏天的天网（Skynet）相似，当时主网还只是帕特里克眼中闪烁的光芒。天网是 mainnet 推出之前的公共测试网络。 Qtum 团队可能会运行这 30 个节点来为 testnet 提供基本的基础架构。 问：测试网和主网上的 QTUM 代币是否相同？我可以将一些免费的测试网代币转移到我的主网钱包吗？答：不，它们是不同的代币。回到图上，在每个主网和测试网的创世块中铸造了100,000,000个代币： 虽然代币的工作方式相同（它们是双胞胎，在出生时分开 - 相隔三周），但是不可能将测试网代币移到主网上。 在每个区块链中，你只能在创世区块的区块链上发送代币。主网地址以大写“Q”开头，例如“Qa93nb …”，而测试网地址以小写“q”开头，例如“qto45H …”在钱包中输错 Q 或 q 地址将导致错误。 问：是否有针对测试网的区块链资源管理器？答：是的，在testnet.qtum.org。除了Nodemap之外，它还有所有可用的 testnet 信息。你可以看到人们正在测试的内容，例如块59,159，它有许多合约调用，包括一个 2.0 币交易费。 好事是测试网代币是免费的。 问：测试网有水龙头(Faucet)吗？答：是的。水龙头是一个免费提供代币的网站。你可以将其视为按需空投。 testnet水龙头是 testnet-faucet.qtum.info，你可以每24小时取一次测试代币。 输入你的测试网钱包地址就可以使用水龙头，在下一个区块中可以收到多达100个测试代币。 另外，我想分享一些有关主网水龙头的消息：向智能合约地址发送 10 个 QTUM：QdonTFalLfoR$uchaNObvioUSscam， 然后你可以从这个水龙头中获得高达 5000 mQTUM。 仅限今晚午夜UTC。 问：我可以练习将测试代币发送到其他显示在水龙头上的地址吗？答：当然，为什么不呢？ 我一直在天网（Skynet）上这样做，也许没有烦到其他人。 问：这是否意味着我可以了解更改地址，向许多人发送诈骗信息，在另一台计算机上备份和恢复加密钱包等等，而且使用测试网代币没有风险？我可以上 testnet 蹦跶，尝试一些新类型的交易，确保我完全理解它，然后在 mainnet 上运行相同的交易吗？答：是的。 问：我可以在testnet上获得块奖励吗？答：是的，这非常简单，因为网络权重如此之低，目前还不到400万。如果你每天从水龙头获得测试代币持续一周，你将有足够的资金每周赢得奖励。 问：我可以在同一台计算机上运行 mainnet 和 testnet 的钱包吗？答：是的。应用程序使用单独的区块链独立运行，所以这没有问题。它们可以同时运行，但我不推荐。 问：你能展示测试网性能的图表吗？答：我以为你永远不会问。 图表 – 测试网络版测试网分析的数据源来自测试网块资源管理器，测试网区块链(从testnet qtumd 登录)，以及来自Copacabana Beach的有关testnet的加密电报消息。 独立奖励地址测试网有 30 个核心钱包，并根据正在进行的测试动态地加入一些额外的节点。对于 12 月份的每日地址数，12 月 28 日达最高为 36，并且之前有很多天只有最低的 30 个独立地址： 每日活跃交易数测试网上的交易很少。活跃交易是指每个块保底的两笔交易（coinbase和coinstake交易）之外的代币或合约的交易。例如，如果一天有 600 个块，就算没有人发送一个代币或合约交易，那么还是会有 1,200 个交易。活跃交易提供超过 1,200 保底的交易数。 这些交易适合使用水龙头，测试合约等的人。 你还可以在测试网块资源管理器主页的底部看到一个 14 天的交易图表。 块间​​距变化12 月平均块间距稳定在 145 秒左右： 对于 52,000 至 56,000（约一周）的区块，有 3 个区块间隔超过 20 分钟，区块 54,053 的块间距最大，为26分08秒。 这组测试网的块间距分布和主网差不多： 网络权重钱包网络权重的计算（随难度而变的平均值）显示测试网是随机变化的，类似于主网。 年回报率网络权重为 394 万，测试网代币的年回报率为 22.2％。这是一些简单的 staking： 来吧！来测试网玩xue耍xi！它为你而生！ 我们本周在里约写完报告。你可能想要去一个温暖，友好的地方，如巴西的里约热内卢（3 个节点的家），完败北半球的冬天。 海滩很漂亮，人们很友善（只是不要把你华丽的加密珠宝带到海滩）。在海滩上有一个新鲜的椰子，它们几乎和那些块奖励一样美味！ Obrigado，愿你的区块奖励像 Sugarloaf 山（PãodeAçucar）的Copacabana海滩升起的太阳！ JB395 参考 Bodhi Prediction Market Alpha 现已上线 Qtum Testnet！ 在这里查看 Bodhi 的测试合约。 测试网块浏览器，支持比特币和以太坊Ropsten。 如果你只关注此报告中的一个链接，那一定是以太坊区块链可视化，来自澳大利亚堪培拉的联邦科学与工业资源组织（CISRO，Commonwealth Scientific and Industrial Resource Organization）。这是一个令人惊叹的网站，可以实时显示以太坊区块链。未确认交易在云（mempool）中浮动，然后随着区块链的增长弹入块中。对于交易，你可以查看单个发送，合约调用和合约创建（单击这些浮动图标可以转到区块链资源管理器）。 叔块（以太坊独有）显示为红色，你可以看到主链与绿色标题和绿色链接一起增长。你参加加密派对的话，可以在电视大屏幕上显示这个网站。 推荐一段关于隐秘(cryptic)和加密(crypto)的关系的音乐，来自挪威/英国 EDM 制作人 Alan Walker，用在现场表演的视频YouTube Space NY里，由 Alan，Noah Cyrus 和 Juliander 创作（歌词不宜在办公室浏览，nsfw，Not Safe For Work），以及对持有者的一些话：“当它全部倒下时，那么随你。” 有关里约热内卢伊帕内玛海滩的悲伤歌曲，创作于智能合约和空投之前的一段时间。 问答来自 Mahmoud Al-Karim 的问题，2018年7月23日： 问：需要为 qrc token 准备测试网 qt 钱包。 答： 这个博客“QTUM 102：建立自己的QRC20 token ”会有帮助吗？https://medium.com/@IAMEIdentity/qtum-102-build-your-own-qrc20-token-59547654b518","categories":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/tags/区块链/"},{"name":"Qtum","slug":"Qtum","permalink":"http://xichen.pub/tags/Qtum/"},{"name":"翻译","slug":"翻译","permalink":"http://xichen.pub/tags/翻译/"}]},{"title":"【翻译】 Qtum Mainnet 成果","slug":"2018-07-30-翻译-QtumMainnet成果","date":"2018-07-30T06:11:00.000Z","updated":"2019-04-01T15:18:44.234Z","comments":true,"path":"2018/07/30/2018-07-30-翻译-QtumMainnet成果/","link":"","permalink":"http://xichen.pub/2018/07/30/2018-07-30-翻译-QtumMainnet成果/","excerpt":"","text":"原文：https://medium.com/@jb395official/newbie-wallets-april-1-2018-26ea7a06489c译者：中山大学数学学院（珠海）林学渊大二时给量子做的翻译，转载注明出处，谢谢 Qtum Mainnet 成果 12 月 25 日至 31 日 以下是每周的 Qtum Mainnet 性能的图表评估，包括常用的图和表，以及使用虚拟专用网络（VPN）和 Qtum staking rig 的教程。有一万个理由你应该使用 VPN 上网，甚至你应该使用 VPN 挖加密货币。这个星期我们就着眼于 VPN 以及 Qtum 节点如何（以及在​​何处）通过 VPN 连接吧。 我是社区成员之一，也是独立研究者，还没加入量子团队，但非常欣赏他们的技术指导和社区中的高谈阔论，以及这些酷酷的贴纸。 图表Qtum Mainnet 性能评估的数据源来自 Qtum Explorer，区块链(从 qtumd 服务器应用程序登录)以及来自 Pangyo 的加密电报消息。 独立奖励地址这一周，每日独立地址数最高在 12 月 28 日达 294 个。整个星期里有 964 个独立地址，上周是 946 个，表示中小钱包正常参与。 赢得多个区块的钱包数与上周基本持平。 每日活跃交易数每日交易数从上周开始下滑，可能是因为放假。活跃交易为每个块提供的交易数高于保底交易数2。 你还可以在 QTUM Explorer.io 和 Qtum Explorer 主页底部查看交易图表。 块间​​距变化从 12 月 25 日到 12 月 31 日，有 3 个区块有大于20 分钟的块间距，上个星期是 6 个。最大块间距是块 71,003，达 24 分 34 秒。平均块间距在 144 秒左右保持稳定。 新网络权重如下所示，每日“新网络权重”是基于计算随每日获奖块的 10 天指数而变的平均值和已知大钱包的余额的： 如年度回报率表所示，网络权重为 1,990 万，年回报率为 4.4％： 更多关于交易费用的信息这是上周关于交易费用报告的后续。我做了一些额外分析，发现了从硬件钱包发送的低费用交易 - 其中有47个。 现在这些交易都在区块链上，所以有一个快乐的结局。 上周的报告已经用这个信息更新了。 VPN - 你能看见我嘛？这周的教程我们研究虚拟专用网络（VPN），以及它们如何与 Qtum staking 钱包一起使用。 你可能需要考虑使用 VPN 的安全和隐私功能进行加密货币挖矿活动。有 VPN 的话你的网络对以下是不可见的 1) 你的Internet服务提供商（ISP）2）老大哥(big brother) 3）黑客（但是你可能获得恶意软件）。VPN提供商提供在你的计算机上运行的应用程序，以便与其远程服务器建立加密连接，从而将你的流量解密并上传到网络上。 译者注：2）老大哥的梗是 Big Brother is Watching You（老大哥在看着你），是出自英国著名政治小说《一九八四》的金句。 你的 ISP 无法解析 VPN 加密流量来看你正在浏览的网站（等等，我的 ISP 怎么知道我正在搜索可食用的内衣？），你的 IP 地址也被隐藏，通过你的VPN服务转换为提供的远程服务器的 IP 地址。你还可以使用 VPN 绕过地理限制。 可能加密矿工也担心因为带宽使用情况的签名，将他们识别为持有比特币（Qtum）的矿工，这可能使他们成为黑客的目标。此外，有些应用程序可以监视节点对等 IP 地址并与区块链交易（发送）相关联，确定哪些 IP 地址赢得了块奖励。如果你通过 VPN 连接到网络，则不必担心任何这类问题，因为你的节点 IP 地址来自 VPN 服务器，而不是你的真实网络连接地址。 你能玩些使用 VPN 通过国际服务器连接到你的 staking 设备的游戏。比如，定位在Qtum Nodemap上未显示的国家/地区，突然有个节点出现在 Casablanca 等等。开启 VPN 后，你的节点应该在大约一周内从 Nodemap 删除。 我不会详细介绍如何选择VPN，但是在隐私和安全方面，有些服务比其他服务更好（在这里或这里阅读）。 如果你确实安装了一个VPN，那你应该选择附近的服务器以减少与 Internet 连接的延迟。不要连接到首尔的服务器（除非你的是 ROC 中的 600 多个节点之一）。我不得不微调 VPN 设置来让它稳定一点：为特定城市选择“最佳服务器”，并设置为“自动重新连接”。 此外，我建议你在激活 VPN 之前有一个稳定的 staking 设置，因为故障排除更难，比如，通过 VPN CanYouSeeMe.org 无法检查端口 3888 是否打开。 我注意到的另一件事是打开 VPN 后，IPv6 连接都断了。你可能会担心甚至开着 VPN ，你的 IP 地址还是泄漏了。如果你返回到你的 ISP DNS（域名服务器）查找IP地址的话，则会发生这种情况，因此好的 VPN 应该提供自己的 DNS。另一个问题似乎是 IPv6 地址并不总是通过 VPN 路由，因此 VPN 可以将其切断。 监控节点也可以连接到其他许多个节点（你在 Qtum 网络里可以轻易做到这个 - 我在看着你，Nodemap），以及寻找第一个中继新块的节点并记录该节点的 IP 地址。Blockchain.info 做的事类似，通过“Relayed By”信息，它们能够识别大型比特币挖矿池。下面的“addrlocal”字段显示节点的 IP 地址，即显示启用 VPN 的对等点的 VPN 出口服务器地址。注意，这些块不携带任何IP地址，但可以监视网络上的节点，将节点 IP 地址与 Qtum 钱包地址相关联。 Ping 时间你知道，Qtum 权益证明（PoS）挖矿以 16 秒的增量慢慢运行，所以启用 VPN 的几毫秒延迟应该问题不大。我想通过查看 ping 时间来验证这一点。 1234567891011121314151617181920212223242526&gt;qtum-cli getpeerinfo[ &#123; \"id\": 1, \"addr\": \"42.33.140.123:3888\", \"addrlocal\": \"135.23.65.157:23569\", \"services\": \"000000000000000d\", \"relaytxes\": true, \"lastsend\": 1563586912, \"lastrecv\": 1563586910, \"bytessent\": 204216, \"bytesrecv\": 138312, \"conntime\": 1563583815, \"timeoffset\": 0, \"pingtime\": 0.0781, \"minping\": 0.068727, \"version\": 70016, \"subver\": \"/Satoshi:0.14.8/\", \"inbound\": false, \"addnode\": false, \"startingheight\": 8607, \"banscore\": 0, \"synced_headers\": 75092, \"synced_blocks\": 75092, \"inflight\": [ ], Ping 表示 Packet Internet Groper，它表示你的计算机可以与 Internet 上另一个节点通信的速度，例如，上面的对等点信息显示的 ping 时间是 78.1 毫秒。 我在网上看到的其他 Qtum 节点上最快的 ping 大约是 15 毫秒，如果节点位于世界的另一端，ping可以延长到几百毫秒。你知道接下来我会写什么：我爬了一堆数据，在Excel中处理它，并可视化出一些图表。 我从使用 getpeerinfo 的对等连接列表开始，并在激活 VPN 之前获得了 ping 时间。对于这个节点，有 123 个连接，平均 ping 时间为 170 毫秒： 启用 VPN（但不重新启动节点），连接计数降了一两个小时，然后平均 ping 时间为187毫秒。在 VPN 启用后，大约一半的对等点连接成功转移。但所有 IPv6 对等点连接都断了。 为了研究 ping 时间和网络的影响，我选择了韩国首尔的 VPN 出口服务器，根据Nodemap，这个服务器托管着 270 个节点。难道用 VPN 可以更快 ping 到首尔的所有节点么？有 123 个连接，平均 ping 时间为 204 毫秒（在下图中，最长两个 755 和 797 毫秒的 ping 被切断）： 再来看看对等点在首尔 VPN 的出口位置。节点应该参与区域网络图的形成。记住，节点是通过在它们之间中继未经确认的交易和新块来工作。 首先，这是今天早些时候 Nodemap 中前 10 个国家的分布： 韩国和美国领先。这两者谁第一几乎每天都在变化，现在中国（ROC，应该是Republic of China 中华民国）已经落后了。对于在首尔使用 VPN 服务器的节点，分布不会发生太大变化： “其他”组里，这些国家都有一个节点：印度，印度尼西亚，伊朗，日本，马耳他，荷兰，挪威，波兰，俄罗斯，新加坡和瑞典。在你的家庭办公室或云托管服务提供商中运行节点，可以在全球范围内与全球各地的 Qtum 节点进行全球通信。 下一周：你是这个邻域的新手，技术上很好奇，那么你在量子链上应该怎样玩耍？一步步安装钱包，练习备份和恢复钱包，甚至免费获得测试代币？下周：所有关于测试网的那些事。 我们在首尔与我们的 VPN 服务器一起写完报告，并祝大家健康快乐，享受有区块奖励的新年。干杯，2018 年！ 새해 복 많이받으세요（新年快乐） JB395 参考： “窃听”攻击可以曝光多达 60％ 的比特币用户，Coindesk，2014年6月 如何查看比特币交易的IP地址？ StackExchange，2012 韩国无人机4K - 早晨平静的土地（釜山，巨济，首尔），YouTube，2017年11月 请参阅我之前放在 Medium 上的报告。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/tags/区块链/"},{"name":"Qtum","slug":"Qtum","permalink":"http://xichen.pub/tags/Qtum/"},{"name":"翻译","slug":"翻译","permalink":"http://xichen.pub/tags/翻译/"}]},{"title":"【翻译】 QRC20 token 报告","slug":"2018-07-24-翻译-QRC20token报告","date":"2018-07-24T06:11:00.000Z","updated":"2019-04-01T15:18:44.233Z","comments":true,"path":"2018/07/24/2018-07-24-翻译-QRC20token报告/","link":"","permalink":"http://xichen.pub/2018/07/24/2018-07-24-翻译-QRC20token报告/","excerpt":"","text":"原文：https://medium.com/@jb395official/qrc20-token-report-february-25-2018-ff397a1ac070译者：中山大学数学学院（珠海）林学渊大二时给量子做的翻译，转载注明出处，谢谢 QRC20 token 报告 - 2018年2月25日 为了表达我对社区的感谢，这里有一个关于 Qtum QRC20 token 的教程：它们是什么，它们在哪里，如何与它们交互，如何查看它们以及如何创建和销毁它们，用最近的 token 空投为 Qtum 持有者解释 token 生命周期中的这些细节。 我是一名独立研究员，偶尔写博客和主持社交媒体，十分中意Qtum的技术指导以及社区讨论。如果你对本文有想法或批评，请在社交软件上发给我或在下面评论。 主网性能首先，简要回顾最近的 Qtum 主网性能。 独立奖励地址过去 7 天里，每日独立地址数最高于2月25日达 306 个，平均值是 291 个每天。这意味着每天 600 个区块的区块奖励中，几乎一半是小钱包赢得的。一周的独立地址数是 1,107。这些数字表示，与 10 天前相比，独立奖励地址数有略微增加，也暗示部署的小钱包更多了，这在我的新年报告中有提到。 节点数 节点地图(Nodemap)显示，节点数在3,250左右，其中大约1,260个在中国。我想如果节点地图能跟上即将到来的节点数的数量级增加，其他区块链节点地图也能处理很多节点就好了，那么让我们祝愿节点地图更加健壮，足以应对这些增加的工作量吧！ 交易费用去年，交易费用只占每天区块奖励的百分之几。两个星期前，交易费用大约占区块奖励的一半。刚过去的一个星期里，资源管理器显示有几个时间段是交易费用比区块奖励还多(每个时间段是24小时制)。如果资源管理器计算正确，这意味着网络内交易数有很大的增幅，尤其是智能合约调用( token 和DAPP)，这一般会带有 0.1 QTUM 费用。随着空投的部署，交易费用出现了一些大高峰。 块间距块间距稳定在 600 块每天附近。在2月11到2月24两个星期内，有14个区块，间隔超过20分钟，最长间隔是到区块 98,210 的 31 分 20 秒。 网络权重我计算网络权重的方法依赖于具有已知余额的大钱包所获得的块奖励百分比。这种方法提供了比钱包计算估计的网络权重更稳定和准确的数字。在上周，这些总余额为 664 万的大型钱包获得了 26.4％ 的块奖励，网络权重为 2520 万。网络权重为2520万表示年度回报率为3.5％。 token 时间如果你只想要理解 QRC20 token ，下面是太长不看版： QTUM QRC20 token 是标准化的数字资产，它们在 Qtum 智能合约中创建并活在这个智能合约中，永不离开合约。通过与合约交易可以将 token 分配给不同的所有者，合约存储 Qtum 地址列表和每个地址拥有的 token 。任何人都可以创建智能合约并创建 token ，而所有 token 的智能合约都存在于Qtum区块链中。 token 代表了区块链 2.0 平台的重要功能，性能和经济价值。 为了更深入地了解 token ，我们在发现之旅中的陪同者将是爱丽丝，一位 150 岁的文学角色，对加密货币有着天生的好奇心： 这时，爱丽丝跳了起来，她突然想到：从来没有见过穿着有口袋背心的兔子，更没有见到过兔子还能从口袋里拿出—块表来，她好奇地穿过田野，紧紧地追赶那只兔子，刚好看见兔子跳进了矮树下面的一个大洞。爱丽丝也紧跟着跳了进去，根本没考虑怎么再出来。爱丽丝梦游仙境，刘易斯卡罗尔，1865年。 爱丽丝想向 鲍勃 发送10个 Wonderland（WON） token 。 但是，当爱丽丝试图用她的钱包中进行交易时，事情变得越来越怪。爱丽丝决定学习关于 QRC20 token 的所有内容，并跟随一只名叫 Satoshi 的白兔，她最终从兔子洞落到一个充满了 token 和智能合约的另一个宇宙中。 如果你想加入爱丽丝并掉入兔子洞以了解关于 Qtum QRC20 token 的所有信息，请继续阅读，包括爱丽丝在吃完蘑菇后发现的两个秘密。 让我们从一些基本的解释开始。 QRC20 token 是可编程数字资产，创建于 Qtum 区块链的智能合约。 Qtum 区块链及其 EVM（以太坊虚拟机，Ethereum Virtual Machine）提供可执行代码和存储数据的智能合约。 使用Qtum Core 钱包，Qtum 手机钱包和 Qtum Web 钱包可以轻松创建带有 token 的基础智能合约。目前，更复杂的智能合约可以用编程语言 solidity 编写并发布在区块链上。 Qtum 继承了当前的虚拟机，用于执行来自以太坊有 token 的智能合约。 在以太坊中，基础 token 被称为 ERC20，以Ethereum Request for Comments 20命名。这是添加 token 功能的协议，于 2015 年发布。 Qtum token 命名为 QRC20，因为它遵循与 ERC20 token 相同的协议和标准。 爱丽丝知道可视化区块链模型 - 智能合约 - token 架构是可行的（并且在进行交易时更安全），这也有助于解释 token 和空投如何运作。 智能合约在合约创建交易中发布到网络，该交易包含在特定区块中，在这个区块里智能合约将永久存在。上图显示了一个智能合约（测试网区块 34,546 中的 Bodhi 合约）管理 QRC20 token ，合约将有存储空间来跟踪余额信息并提供六个功能来创建 token ，在地址之间转移 token ，查看余额等等。 合约创建当合约创建交易发布到区块链时，智能合约在 Qtum 区块链上开始生效。 要看一下这样的合约创建交易，我们可以查看测试网上的 Bodhi合约（我在主网上找不到 Bodhi 合约）。 开发人员使用测试网来评估和测试他们的软件，这正是Bodhi对这个智能合约做的。 Bodhi 测试智能合约开始生命周期于测试网块 35,456，2017年11月20.合约创建了 335,000 测试用的 BOT token ，Bodhi 开发者能运行测试，确保代码准备好发布到主网了。 交易所和钱包下面，我们来看一个交易所和钱包的简化模型，这有利于了解空投如何运作。 注意，在下图中，为了清楚起见， Q 地址是有序的。实际上，块编号是有序的，但 Q地址是随机的。 如图所示，交易所客户可以自己买卖，不需要区块链交易。 交易所使用一个热钱包和一个冷钱包（可能是每个的倍数）保存余额。 对于这个例子，交易所具有6,000,000个币的余额，这些币作为交易存储在区块链中，但从不存储在交易所本身中。 后来，爱丽丝吃了蘑菇，并了解了这些币的秘密。 我们考虑两个交易。首先，一个账户从交易中提现 300 币到个人钱包。为了实现这个，客户输入钱包地址（这里是Q 12），交易热钱包（可能通过交易所的中间地址）发送 300 个币的交易。其次，对于存入交易所的存款，客户输入其交易账户的存款地址，并将交易（可能通过交易所的一些中间地址）发送到交易所热钱包。 现在让我们看看一些直接连接到区块链的钱包，而不是通过交易所。 前面我将钱包描述为区块链上可以管理货币的浏览器。作为早期的加密货币使用者，爱丽丝可以向我们提供钱包角色的更多细节： 浏览区块链并根据过去的交易计算余额 持有私钥并签署交易 设置交易费用（将随时间变化） 对于某些钱包，发布智能合约和合约调用（ token 交易等） 只有全节点（含有整个区块链）可以将交易发送到网络以写进区块链中，因此上面使用简化支付验证的钱包（手机钱包）和其他轻量级钱包都必须通过全节点与区块链交互。 爱丽丝想要指出钱包本身并没有持有任何货币或代币，因为货币或代币总是存放在区块链上。 我们将在下面看到（扰流警报）即使在区块链上， token 也永远不会离开创建它们的智能合约。 它们该有多么无聊！ 当我们沿着兔子洞向下走时，爱丽丝有一个关于货币分享的秘密。 她说 Qtum 区块链上没有真正的货币。钱包为地址计算未花费的交易额总和，因此“货币”更像是Excel电子表格SUM公式的结果。 另一方面，QRC20 token 值是单独的金额，如Excel中单个单元格中的值。 快照 当我们跟着爱丽丝走下兔子洞时，我们决定采取自拍或者说快照。空投快照​​是特定时间，特定区块的区块链读数。对于Bodhi空投，快照是在 2013 年 2 月 2 日 23:40:16 UTC 的 93,333 块。爱丽丝指出，数字 3 和 9 在中国被认为是幸运的，代表着生活，生命和永恒。 然后发生的（猜一猜……）是 Bodhi 取区块链中 0 到 93,333 块，解析所有交易，找到每个 Qtum 地址的余额。 空投这一节爱丽丝告诉你谁领到了空投，答案是：所有人。真正的问题是你是否有通过钱包或交易所来访问 token 的方法。 Bodhi 报告称他们以 4：100 的比例为 Qtum 持有者空投了4,015,325.92 BOT 代币，这意味着他们空投了 100,383,148 QTUM（他们排除了少于 10 QTUM 的地址）。 根据流通图表中的QTUM，2月2日有 100,353,364 QTUM（到目前为止，创造了1亿+块奖励），这意味着几乎每个 Qtum 地址都收到了BOT 空投的简单公平的方法是给每个活动地址提供 token 。为了检查快照所看到的区块链历史记录有多长，爱丽丝使用时光机（Explorer）来查看最早的块奖励获奖者。 她找不到创世块（1-5000）中任何活跃的钱包地址，但是这个家伙 …Ch5b 在 2017 年 9 月 8 日赢得了 5,041 块，这是一个真正的 OG 钱包，在 2017 年 10 月之前挖了点矿。…Ch5b 仍有余额并确实收到了 BOT 空投。在看到合约调用工作后，我们将在下面看到实际的空投交易。 我们可以从上面回到我们的图，看看空投如何填充各种区块链地址。 现在我们可以在区块链的左侧看到 Bodhi 智能合约存储，其中 BOT 空投到所有的地址。例如，地址 Q2 的交易所冷钱包将有 200,000 个 BOT 空投。该图中有两个时序假设。1）如果 Q10 的存入发生在块 93,333 之后，那么该地址仍然有 10 个 BOT 来自空投。 2）如果 Q12 的提现发生在块 93,333 之前，那么它将收到空投。 让我们看一下钱包在空投中的行为。 这与预期非常符合，因为 BOT 被空投到每个活动地址（大于10 QTUM）。如上所述，这个包罗万象的空投问题是钱包是否可以访问 token ，这意味着钱包必须有办法添加 token 合约地址，并能够创建和发送 token 合约调用，而不是上面所有的钱包都可以做到这一点。 与智能合约交流回到爱丽丝原来的问题，爱丽丝把我们带到了这个兔子洞，爱丽丝想要向鲍勃发送 10 个 WON token 。 可以这样类似地想。如果爱丽丝想要向鲍勃发送 10 个 token ，她不能简单地将 10 个 token 从她的钱包发送到 Bob 的钱包，即他的 Q 地址。这种方法存在一些问题。首先，代币不在爱丽丝的钱包中，而是在智能合约中。其次， token 不会被发送到鲍勃的钱包，它们会被移到智能合约存储中的鲍勃的 Q 地址。 不用担心交叉，爱丽丝的钱包知道如何与智能合约交流，因为她添加了 token 并输入了她钱包里的智能合约地址。向鲍勃“发送” token 的交易实际上被发送到智能合约，并且鲍勃的 Q 地址以及要转移给鲍勃的 token 的数量都作为数据被包含在合约调用交易中。 我们等下将在合约调用中查看数据，这之前先修复另一个易混淆因素。 比特币地址和 Qtum Q 地址由人们显式输入为 Base58 编码的字母数字字符。你可能从未注意到它（爱丽丝从未这样做过）但比特币和Q地址从不包含数字零，大写字母O，大写字母 I 或小写字母 l。其他的数字和字母都还好，但是如果名叫 Satoshi 的白兔子发现未来的加密货币用户搞砸了，会完全输入 “0”“O”“I”“l”（这很难，是的），为了减少 Bithumb 和 Coinbase 痛苦的客户服务电话，当人们将他们的比特币发送到错误的地址的时候，他们只需忽略这些字符，这对于一只兔子来说是非常具有前瞻性的想法。 这是很复杂的因素。 人类可读的 Base58 地址被转换为更有效的十六进制地址，用于在合约调用交易中发送，以及在智能合约中存储。 要在Base58和十六进制之间进行转换，请使用此网页进行Base58编码，解码和验证。 现在我们可以查看合约调用中的数据，这是一个典型的例子： 数据显示： a9059cbb 表示这是一个转移操作 e22843f9a4 …是要转给的地址，以十六进制表示 3956ed39 转移的数量，十六进制，satoshis 你对实际完成的空投怎么看？Bodhi 基金会不得不发出这么多合约调用。一旦智能合约启动，它很高兴在区块链中坐等指令。对于空投，这些指令将 BOT 从 Bodhi 基金会地址转移给所有的空投接收者。 例如，你可以在 2 月 15 日早上看到这种空投，比如 100,719 这样的块，有这么多、大的合约调用，它收 20 QTUM 的交易费！ 这些块包含多个合约调用，每个调用最多 200 个交易，因为Bodhi 更新了合约存储来执行空投。 以下是一些 Q 地址的空投交易： 所有这些更新 Bodhi 智能合约的交易都已发布到区块链的 100,719 块和其他区块，但区块链中的智能合约存储实际上是如何更新的？ 显然，块奖励获奖钱包在区块链的本地副本中处理这些智能合约调用，将更新填充到其本地存储适当的块中。 以下是爱丽丝想要分享的第二个秘密：所有的全节点验证新块，它们还在智能合约块的本地副本上处理智能合约交易。 爱丽丝的第二个秘密是 - 每个节点在发布块时执行每个合约调用。 我们可以看看这些数据如何存储在智能合约中（再次使用令人困惑的十六进制地址）： 你想要的话，你可以浏览这个存储，找到你的地址，以及你地址的 token 数。不过不要试这个，有一个更简单的方法来看你的 token 余额，爱丽丝将在下面向我们展示。不过你知道我无法看着这样一个丰富的数据表而不抓着它运行一些 Excel 分析。 在资源管理器的智能合约页面，点击“显示所有”按钮，然后等一杯咖啡的时间让你的浏览器加载 31,944 项。一些我看不懂的有趣数据：有许多地址有1或2个satoshis token （0.00000001或0.00000002 token ），在其他区块链上称为灰尘。忽略这些条目， token 分布是： 10个最大的代币持有量如在下图所示。爱丽丝猜测，4000 万那个位置是 Bodhi 基金会，其余的是交易所。 查看你的 token 余额很容易爱丽丝想要有一个超级简单的方式检查合约存储中的 token 余额。她说要导航到代币 页面 我们找不到她的WON token ，所以在这个例子中会使用 BOT; 点击 “BOT - Bodhi Token” 这个名字 选择“READ SMART CONTRACT”并将 Q 地址粘贴到 “BalanceOf” 字段中，然后选择“Query”。 将出现 satoshis 的余额。获取 token 中的余额，将小数点向左移动 8 位（仅这个 token ）。 如果你可以在资源管理器中查看 token ，也可以通过在资源管理器中单击地址的 token 收藏来获取此页面的快捷方式。 资源管理器中的 token空投后，爱丽丝感到很困惑，因为她无法在资源管理器中看到她的地址的代币，但有其他地址已经自豪地展示了他们的代币。 要理解为什么资源管理器感觉不到空投代币，请记住空投是如何工作的：快照，一些处理，然后空投合约调用智能合约，没有任何东西触及区块链上的 Q 地址。 资源管理器一直处于蒙蔽状态，直到你将 token 添加到钱包并使用你的 Q 地址进行 token 交易（无论多小）。或者重新加载你的钱包（爱丽丝必须与白兔核对这个），然后资源管理器才知道你拥有该 token ，查询智能合约并正确显示 token 余额。 以太坊资源管理器内置了最受欢迎的 ERC20 token ，因此你可以查看给定地址的 token 。 也许 Qtum 资源管理器未来的版本中会也有这个功能。 烧币（Burning Tokens）现在我们已经到了爱丽丝兔子洞的底部，是时候讨论在它们的使用寿命结束时如何销毁或“烧毁” token 。例如，在 Qtum Mainnet Ignition 启动之前，Qtum token 以Ethereum ERC20 token 的形式存在。 2017年10月初，各种交易所允许 Qtum 代币持有人提交他们的 Qtum ERC20 代币换成 QTUM Mainnet 代币，换掉的 Qtum ERC20 代币随后被烧毁。 为什么有人想要收购好的 token ？也许 token 会升级为新的代币或代币，就像 Qtum 的情况一样。此外，组织可以回收一些代币库存以减少供应，支持价格，类似于公司回购自己股票。 烧毁 token 你需要把他们发送给一个不存在的地址，将它们永久留在那里。例如，我们造个以太坊地址 0x1111111111111…，一个没有人拥有私钥的合法地址。我们告诉智能合约把 token 转移到那个地址，然后它们就被永久销毁了。我们可以在以太坊 Qtum ERC-20 token 页面查看这些可怜的 token ，并通过累计所有烧毁地址的百分比，看到 97.05％ 的旧 Qtum ERC20 token 已被烧毁： 如果你持有 Qtum ERC20 代币，那么建议在代币变得毫无价值之前，将这些 ERC20 代币转换为 Qtum Mainnet 代币。查一下社交媒体，看看是否还有可以完成这种交易的交易所。请快点，因为 Qtum ERC20 token 将永久埋葬在加密墓地，并且这些 token 将变成纪念品，因为不能再换成主网币。 我不确定 Patrick 最近在哪儿环球旅行，但我认为 Earlz 最近参加完柏林的聚会，回到了阿姆斯特丹。我有几篇报告有柏林的照片，所以让我们在阿姆斯特丹完成。 阿姆斯特丹是一座历史悠久的城市，拥有美丽的运河，提供“咖啡”的咖啡馆，以及全年提供特殊照明的红灯区。 阿姆斯特丹是郁金香泡沫的家园（1637年内爆），有些人将其与所谓的加密货币泡沫相提并论。 但是，如果你做自己的研究（DYOR），你可以类比区块链2.0平台，如 Qtum（成立于2017年）类比荷兰东印度公司（成立于1602年），这是第一家具有重要新商业范例的全球性公司（第一家） ，在股票市场公开交易），在当时是世界上最有价值的公司。 我们不要在风车上谈论泡沫。在阿姆斯特丹附近看一些精美的风车吧。今天，这些风车是优雅的历史宝石，但在它们的荣耀中，它们是锯木材，磨面粉和提取亚麻籽油的工业机器。 我很高兴地报告说，爱丽丝确实爬出了兔子洞，如果你看到她和白兔说话，不要担心，他们可能只是讨论区块链治理和扩展。 我希望你和爱丽丝一起享受这段旅程，了解 token 以及你的代币将非常有用和有利可图。 Jackson (JB395) 参考： 官方 Qtum Core 和 QRC20 Token 指南：Medium 来自社区的一些出色的QRC20 token 资源： Silverminer, 如何评价 Bodhi token 。Steemit Sam Suh，使用 QBao 钱包的 QTUM 钱包教程 - 用于 Bodhi（BOT）代币或其他 QRC20 代币。Medium 优秀参考资料，关于移动端，QBao，qtum-qt 和qtumd / qtum-cli 等钱包从 Bodhi 基金会添加代币和代币交易。 Github 上的 Bodhi token 合约。 我最喜欢的以太坊ERC20 token ，UET。 对不起，我忘记这个 ICO 了。 爱丽丝梦游仙境，全文。 区块链研究时听的音乐：Be In The Moment with Amsterdam DJ Armin Van Buren 和他的每周视频博客A State of Trance 东南亚的Armin 阿姆斯特丹的无人机镜头（DJI Mavic Pro），以4k观看","categories":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/tags/区块链/"},{"name":"Qtum","slug":"Qtum","permalink":"http://xichen.pub/tags/Qtum/"},{"name":"翻译","slug":"翻译","permalink":"http://xichen.pub/tags/翻译/"}]},{"title":"【翻译】 新手钱包","slug":"2018-07-18-翻译-新手钱包","date":"2018-07-18T06:11:00.000Z","updated":"2019-04-01T15:18:44.232Z","comments":true,"path":"2018/07/18/2018-07-18-翻译-新手钱包/","link":"","permalink":"http://xichen.pub/2018/07/18/2018-07-18-翻译-新手钱包/","excerpt":"","text":"原文：https://medium.com/@jb395official/newbie-wallets-april-1-2018-26ea7a06489c译者：中山大学数学学院（珠海）林学渊大二时给量子做的翻译，转载注明出处，谢谢 新手钱包 – 2018年4月1日 在本报告中，我们分析区块链，了解自今年年初以来新钱包对节点数增长的贡献。我们的区块链浏览器是qtum.info，它本周增加了一个 staking 奖励计算器，需要输入地址或输入 stake 金额。这个新的资源管理器给我留下了深刻的印象，它具有明亮的背景，能够快速显示一个地址直到“出生日期”的所有交易。 TL;DR 1月下旬，大约有2000个 staking 钱包，每个有 500 个代币，这可能与宣布给中国的 50,000 个节点的视频流平台有关。 我是一名独立研究员，偶尔是博主，社交版主，并中意 Qtum 团队的技术指导和社区的高谈阔论。如果你对本文有任何意见或更正，请联系社交媒体。本博客假设你对Qtum 权益证明（Proof of Stake）和区块奖励机制有一些基本的了解，新的社区成员可以阅读我在以下参考文献中以前博客的链接来了解有关这些主题的更多信息。 网络权重（在家试试）经常看我博客的人知道我通过爬取资源管理器块奖励地址来计算网络权重的替代方法，识别具有稳定余额的大钱包，并使用这些大钱包赢得的总奖励和块奖励百分比来计算网络权重。在过去两周内，这个方法算的网络权重为 3340 万。 使用新的资源管理器，你可以用这些步骤在家里玩玩网络权重。将你喜欢的浏览器导航到新的资源管理器Biggest Miners页面： 爬取数据并保存到文本文件。然后恰好一周后，再次爬取数据。对那些在两次爬取之间具有大致相同余额的大钱包（考虑到增加的块奖励），计算总余额和本周开采的块。 网络权重 = 总余额 /（本周开采的块/每周4200块）。 如果你本周进行计算，你的应该接近我上面计算的网络权重（除非有人添加节点😊） 节点地图 NodemapNodemap 本周更新了，可以显示网络上超过 7,000 个节点。这里大事是 Qtum 节点在中国的增长，我不相信其他情况下所谓的“剧情反转”：目前 Qtum 在中国的节点数超过 4,400，是比特币或以太坊的中国节点的两倍多。下一步将是 Qtum 超过比特币的全球节点数，给它两个月。 去年，在韩国退出之前，节点数第一在韩国和美国之间来回切换。 2017年10月21日，你可以在此屏幕截图中看到，staking 大城市是加州山景城（Google Cloud的主页）和首尔。 截至2017年底，网络权重为 2000 万，节点数约为 1,200。但从那时起，节点部署和网络权重增加的速度有所加快。 目前，中国有11个城市拥有 100 个以上节点，其中包括南京的1000个节点。看看今天这个屏幕截图，酷！南京是江苏省的省会，拥有 3000 万人口，感觉就像你走动的时候不可能不撞到 Qtum 节点，这可能就是正在发生的事情。这些新节点非常有趣，因此我有一个大胆的想法(SWAG，Scientific wild-ass guess)，关于其目的的：位于便利店的终端/信息亭，允许人们在不使用银行或信用卡的情况下为视频流服务支付现金。但这是一个完整的猜测，如果实际情况和我想的不一样，这些句子将被神奇地编辑掉。 下表显示，从2月中旬到本周末的节点数变化。每个国家的都有增长，韩国节点数今天刚刚达到四位数字，中国节点数的增长目前占总节点数的63％。 下面的饼图显示了节点位置百分比。 新手钱包我们回到 Excel 表格分析，看看七天内块奖励获奖者。以下是它的工作原理：从资源管理器中删除块奖励获胜者的地址，在 Excel 中对独立地址排序，用宏记录程序将每个地址粘贴回资源管理器并爬取对应钱包余额和交易数。 staking 地址的交易数很有意思，它提供了有关钱包年龄的线索，因为每个区块奖励的支付时间在 10 次交易内。 如果你看到一个包含 50 到 5,000 笔交易的 staking 钱包地址，则那个钱包已经存在了一段时间。 但如果你看到一个钱包赢得区块奖励时少于 10 次交易，那么这正是它的第一次区块奖励体验（第一次是最好的时间！） 让我们进一步分析区块奖励获奖者。有趣的是一些新手钱包有500 QTUM，还有一些有400 QTUM。 人们喜欢整数，过去的研究显示，经常有 365,500,1000,2000 和 10000 QTUM 的钱包。但是现在有很多这种 500 QTUM 大小的新钱包。 上面的例子展示了这种钱包中的一个，它有 500 QTUM，当时是 2018 年 1 月 30 日。你能看见转入 84, 854 QTUM 的交易和转出 84,354 QTUM 的交易。你能假定它下一次交易就是用这 84,354 QTUM 发送 500 QTUM 给另一个钱包，如此继续下去，造另外的 168 个钱包。 我保证这些 staker 喜欢这 168 份交易费用，对此我只想用一个词来形容，“盲目发送(sendmanywithdupes)”。这本来只需一笔交易费即可为多个地址转入代币。在这次分析里，我看到了很多 sendmanywithdupes 交易的例子，包括去年发送 365 个 QTUM 到多个地址的那个著名系列，后来用来挖矿。注意，将 QTUM 拆分为单独的挖矿地址并没有改变赢得区块奖励的可能性，因为钱包软件保证了在有 27,375 个代币的单个钱包地址和分别有365个代币（共27,375个代币）的 75 个地址之间，赢得区块奖励的概率都是一样的。 中国的节点增长源自哪里？一种可能是中国视频流媒体公司宣布他们将在商业网络中部署 50,000 个节点。 我们可以折腾区块链，看看是否可以发现有关新节点的什么模式或细节。我们截取 3 月 24 日至 3 月 30 日的获得区块奖励的钱包，其中对同时满足 QTUM 少于 600 且 2018 年 1 月 1 日之后有过代币交易的钱包进一步过滤： 直方图显示的是在不同日期转入（创建）500 QTUM 的块奖励获奖钱包数。因为块奖励与钱包重量成正比（还有一些随机影响），我们可以反过来处理块奖励计算，并回答这个问题：如果网络权重为 3340 万，一周内赢得 129 块奖励所需的钱包大小是多少？ [参考1] 答案是大约100万枚代币。如果你按 500 QTUM 部署 100万个，那么你将有 2000 个钱包，这肯定在中国的增长范围内，甚至可能有点低。在任何情况下，概率论表明如果你有一个有着 100 万个代币的钱包，或者每个有 500 个代币的 2000 个钱包，都能在一周内赢得 129 个块奖励。 我希望你能享受这次关于区块链操作的讨论，并学到点东西。4月1日是复活节星期天，如果你关注复活节，那我希望你复活节快乐。 今天是复活节，我们在梵蒂冈写完博客。这里是基督教(Catholic Christianity)，圣彼得大教堂(St. Peter’s Basilica)和西斯廷教堂(the Sistine Chapel)之家。在西斯廷教堂，文艺复兴时期的艺术天才米开朗基罗花了10年（1502-1512）亲自画天花板和墙壁。 创世纪的标志性形象 – 创造亚当（所以亚当必须是人类的“第1块(block 1)”？）并给出了加密货币创世块的名称。 注意在线安全，我会在社交媒体上看到你 Jackson 参考 在一周内获得 129 份块奖励，每天 600 块，也就是 4,200 块。钱包重量为： 看我之前写在Medium上的博客 不是从无人机拍摄，而是一些不错的视频,关于圣彼得广场和圣彼得大教堂的，1080P。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/tags/区块链/"},{"name":"Qtum","slug":"Qtum","permalink":"http://xichen.pub/tags/Qtum/"},{"name":"翻译","slug":"翻译","permalink":"http://xichen.pub/tags/翻译/"}]},{"title":"【翻译】 钱包和密钥","slug":"2018-07-12-翻译-钱包和密钥","date":"2018-07-12T06:11:00.000Z","updated":"2019-04-01T15:18:44.231Z","comments":true,"path":"2018/07/12/2018-07-12-翻译-钱包和密钥/","link":"","permalink":"http://xichen.pub/2018/07/12/2018-07-12-翻译-钱包和密钥/","excerpt":"","text":"原文：https://medium.com/@jb395official/wallets-and-keys-july-23-2018-92abf2a2d2bf译者：中山大学数学学院（珠海）林学渊大二时给量子做的翻译，转载注明出处，谢谢 Wallets and Keys — July 25, 2018 钱包和密钥-2018年7月25日本文考虑钱包和密钥。先简要介绍，再上例子。大多数例子基于浏览器上的 Qtum Web 钱包，类似于以太坊钱包 MyEtherWallet和MyCrypto。 Qtum Web 钱包运行在浏览器上，并不需要下载区块链，而是通过专用全节点连接到区块链。 Web 钱包是一个强大的变色龙，提供了很多恢复其他类型Qtum钱包的方式。没有 Web 钱包恢复不了的钱包（如果你用本博客的技术的话）。注意Web钱包具有完整QRC20令牌功能。 注意事项：本博客和钱包恢复步骤包括处理私钥和种子词。在你尝试这些步骤前，确保你完全理解流程且电脑没有恶意软件和病毒。简单地发送QTUM或代币到一个新钱包比乱动私钥更安全，但有时无法发送代币，比如，你的手机钱包掉马桶或被忘在浴缸里一整夜。永远不要把你的私钥或种子词给别人因为他们能拿走你的币。 我是一名独立研究员，偶尔写博客和主持社交媒体，十分中意Qtum的技术指导。如果你对本文有想法或批评，请在社交软件上发给我或在下面评论。 介绍 TL;DR Qtum 钱包的安装使用了随机生成的私钥或种子词。通过导出私钥或种子词，你能在各种钱包之间转移你的 Qtum 地址。重要的是保证私钥和种子词安全–保持你的私人私密！ 你知道钱包在区块链建立它们的身份时使用了一个 Qtum地址 “Q…”。 这个地址生成自公钥，而公钥生成自私钥。 Satoshi 给比特币取了错误的名字 “钱包”， 因为钱包实际上不存任何币或代币，它们存在区块链里。“钱包”的正确名字应该是“密钥库”因为钱包的主要工作是保存和管理私钥，通过私钥来支持交易。 私钥和种子词 一个私钥是一个简陋的字符串，但它是通往王国的关键。私钥（不用密码）允许存储在由私钥生成的地址中的QTUM访问。你需要十分小心地使用私钥，因为如果任何一个人（黑客、恶意软件、甜言蜜语的热心人）拿了你的私钥，他们就可以拿了你的钱。 私钥也能用种子词生成。典型的是，钱包使用的种子词有两种，桌面钱包使用 bip-039 种子词，手机钱包使用“字典”种子词。这两种不相容，这个差别由 Web 钱包管理，它两种都能接受，是 bip-039 种子词则使用 “从助记符中恢复” ，是“字典”种子词则使用“从手机钱包恢复”。 比特币改进协议（Bitcoin Improvement Protocol 39 （bip-039)）给出了规则，生成私钥要使用从 2,048 个单词列表中导出的 12 个种子词[参考文献1]。手机钱包使用的“字典”单词一列是 4,216个类似bip-039的单词[参考文献2]。 输入种子词来恢复钱包有风险，因为私钥是从种子词里精确地生成而来，多一个符号或一个空格都会生成一个完全不同的私钥和完全不同的 Qtum 地址。如果你错输了种子词，你会创建给钱包创建一个你不期望的 Qtum 地址。如果你发币给那个地址，你很有可能永远无法再输入那个错字恢复钱包地址，这就意味着你的币永久丢失了。 下图显示了用于创建钱包或恢复钱包的所有 Web 钱包选项： 生成新钱包 – 创建一个随机地址，下载一个密钥文件 用助记符创建 – 创建 12 个种子词生成的一个随机地址 从助记符恢复 – 使用 12 个 bip-039 种子词从另一个钱包恢复一个地址 从 WIF 恢复 – 从一个密钥中恢复一个地址 从手机钱包恢复 – 使用 12 个 “字典” 种子词从一个 Qtum 手机钱包中恢复一个地址 从密钥文件恢复 – 从 Web 钱包创建的密钥文件中恢复一个地址 从 Ledger 恢复 - 允许使用安全存储在 Ledger 硬件钱包中的私钥进行交易 让我们逐个详细地介绍这些选项。 生成新钱包 生成新钱包会创建一个随机地址并下载一个密钥文件，其名称由 unix 纪元时间（以毫秒为单位）给出，例如 “1532053935952.txt”，其中包含由密码加密的文本，例如： 1&#123;“version”:”0.1\",”content”:”tFz3ctzaITRniFjD6lDm1m8Zyu7LeNjNm/j2ao/hxoIhYAwqlC9iZYZ9TCermbrxF2ljd/wTXnRq/Ca6nYPYZNJ4GC0=”&#125; 将密钥文件保存在计算机上，并备份到多个USB设备。重新启动 / 恢复用“生成新钱包”选项创建的钱包的唯一方法是通过加载密钥文件并输入密码来“从密钥文件恢复”（请参阅​​下面的步骤6）。 使用又长又强的密码，而不是像“12345”这样的简单密码。 用助记符创建 “用助记符创建” 创建 12 个种子词生成的一个随机地址。你必须重新输入那 12 个种子词，确保你以及保存好种子词了。 用这个选项你只要下面的 3 步就能从助记符（种子词）中恢复钱包。你也能（必须能）通过“转储为密钥文件”创建一个密钥文件来备份钱包。现在你有 2 种方式恢复钱包，使用种子词和密钥文件。这很有效地使你恢复钱包的能力翻倍，但也意味着你现在需要安全地存储三样东西（密码，种子词和密钥文件）。 注意，助记符不同于 Core 钱包密码短语（这是一种自由格式的文本密码短语并且不是种子词） 从助记符恢复 “从助记符恢复”使用 12 个 bip-039 种子词从另一个钱包恢复一个地址。输入种子词时，他们必须和原种子词字字匹配。这意味着全部小写（永远没有大写字母）因为这是种子词生成的形式。任何差异或额外单词都会为钱包创建一个不同的随机的地址，也就是它会显示 0 零钱，这很危险，如果你发送 QTUM 给这个新地址的话。确保你检查过地址并确认那就是你要的地址。安全一点的是从助记符恢复以保存密钥文件，并使用密钥文件恢复钱包以打开钱包。 从 WIF 恢复 WIF 电子钱包导入格式（Wallet Import Format） 是私钥一种纠错和缩短的格式[参考文献3]。你遇到的大多数私钥都使用WIF，通常长度为52个字符，而本地私钥使用 64 个十六进制字符。 Web钱包和Core钱包提供私钥作为WIF，此选项将允许从WIF私钥恢复钱包地址。 从手机钱包恢复 “从手机钱包恢复”使用 12 个 “字典” 种子词从一个 Qtum 手机钱包中恢复一个地址。要让这种恢复正常工作，必须为每个字符正确输入手机钱包种子词（现在这听起来熟悉吗？）。单词总是小写，永远不会有大写字符。 此外，请勿在任何单词后面输入尾随空格，否则生成一个非常危险的新随机地址。 请确认这个选项创建的地址与你手机钱包中的地址相匹配（否则你输入的种子词不正确）。 选择 CONFIRM 后，选择要恢复的地址： 从密钥文件恢复 “从密钥文件恢复”从 Web 钱包创建的密钥文件中恢复一个地址。从电脑加载密钥文件并输入密码来恢复钱包地址。 从 Ledger 恢复 这个选项与其他选项的工作方式不同。“从 Ledger 恢复”允许使用安全存储在 Ledger 硬件钱包中的私钥进行交易。对于这个选项来说，私钥不会离开硬件钱包，而是 Ledger 签署交易（允许手动验证）和批准交易。 要使用 Ledger 硬件钱包，请在 Web 钱包上选择“从 Ledger 恢复”，连接你的 Ledger，登录并启动 Qtum 应用程序，然后选择CONNECT 来让 Web 钱包连接到 Ledger。 选择默认路径 m/44’/88’/0’/0 并单击绿色挂锁按钮： 在屏幕上默认路径 m/44’/88’/0’/0 选择所需的地址，然后单击绿色挂锁按钮： 这仅仅会启动标准 Web 钱包页面，因为私钥仍然锁定在Ledger中，没有可用的私钥，并且“转储到密钥文件” 按钮不可用。 测试网例子 接下来是在各种 Qtum 钱包之间转移私钥或种子词来恢复钱包的一些真实示例。在本练习中，我使用Qtum Testnet，如果你需要在 Testnet 上进行复习，请参阅这个博客。 让我说我对 Testnet QTUM 的价格发展感到非常失望。似乎 Testnet QTUM 大佬 正在操纵这种币抑制价格，这对于 Testnet QTUM 持有者来说是很伤心。 没有价格升值，而且这种币似乎永远停留在 0 satoshis。 Testnet QTUM 在任何主要交易所，任何小型交易所或任何交易所都没有交易对。 它基本上是一个毫无价值的币，我们唯一可以做的就是在 Qtum Testnet 上进行测试，所以我们就这样做。 A. 手机到 Web 钱包要在网络钱包上恢复 Qtum 手机钱包，请在移动设备上转到个人资料 - 电子钱包备份并输入你的个人识别码以查看种子词（你之前也应保存它们）。 在 Web 钱包上，选择“从手机钱包恢复”，准确输入种子词，然后选择确认。 从 Qtum 地址列表中（除非你在移动设备上选择了其他地址，否则应该是最重要的地址）找到所需的 Qtum 地址并选择 CHOOSE。检查恢复的地址是否与你的移动钱包地址相同（如果没有，请重新输入种子词并仔细检查所有字符）。使用“转储作为密钥文件”成功还原后，你可能要备份密钥文件。 B. Core 到 Web 钱包在 Qtum Core 钱包（显示 qtum-qt）上，选择 “帮助” - “调试窗口” - “命令”，并输入 dumpprivkey 命令需要的所有地址（有关多个地址的信息，请参阅参考资料4）。 复制 WIF 私钥，这里是 “cPuz…”。 在 Web 钱包上选择“从 WIF 恢复”，粘贴私钥，然后单击确认。 使用“转储为密钥文件”成功还原后，你可能要备份密钥文件。 C. Web 到 Core 钱包 这与上面的 B 正好相反。 在 Web 钱包上选择“查看钱包信息”，查看私钥并复制私钥。 在 qtum-qt Core 钱包上选择“帮助” - “调试窗口” - “控制台”并输入命令 importprivkey 并粘贴私钥： Core 钱包将扫描区块链一两分钟，调试窗口标题将显示（Not Responding），Console 响应为“null”，你应该看到新地址加了 QTUM 余额。 你应该对 wallet.dat 文件重新备份，因为它包含一个新的私钥。 D. 手机到 Core 钱包 显然，做 A - 手机到 Web 钱包再做 C - Web 到 Core 钱包。 E. Qbao 到 Web 钱包 在Qbao上转到“我” - “助记符导出” - 输入你的 PIN（密码）并复制助记符（12个种子词 - 你之前应该保存这些）。 在 Web 钱包上，选择“从手机钱包恢复”，并仔细输入12个种子字（无额外空格）并选择确认。 通过选择 CHOOSE 从“从手机钱包恢复”列表中选择所需的地址。 你可能要使用“转储为密钥文件”来保存密钥文件。 F. Electrum 到 Web 钱包 要使用种子词将地址从 Electrum 钱包转移到 Web 钱包，你需要在初始安装中将 Electrum 设置为与 Qtum 手机种子词兼容（然后使用手机钱包种子词来恢复 Electrum 上的手机钱包 ）。这个设置的 Electrum 配置截屏为： 在这个截图之后，你输入手机钱包种子词（这些单词也与“从手机钱包中恢复”的 Web 钱包选项兼容）。 如果你尚未将 Electrum 钱包设置为与手机钱包兼容，则可以使用私钥恢复 Web 钱包上的 Electrum 钱包。 在 Electrum 钱包上选择“钱包” - “私钥” - “导出”，你将导出文件 qtum-electrum-private-keys.csv 或只复制一个私钥。 在 Web 钱包上选择“从 WIF 恢复”，粘贴私钥并选择确认。 检查钱包地址是否正确。 你可能需要使用“转储为密钥文件”来保存密钥文件。 F. Core 到 Core 见下面的参考文献4。 我希望这个关于私钥和种子词的解释有助于你理解钱包。请记住，钱包不会存储硬币或代币。 硬币和代币总是存储在区块链中，但钱包存储私钥并使用私钥管理交易。 直接使用私钥和种子词时请务必小心。 确保你的计算机不含病毒和恶意软件，并且永远不要使用在线存储来存储私钥，种子词或密码 保持在线安全。 Jackson 参考： bip-039 参数。 bip-039种子词 英语单词表。 如果你的 bip-039 种子词不在这个表中，那么你写错了！ “字典”种子词列表。 如果你的种子词不在这个列表中，你就错了！ 钱包导入格式（Wallet Import Format），比特币的一个例子。 转移私钥 - Core 到 Core 钱包（显示为 qtum-qt Desktop GUI Core 钱包） 在导出私钥之前，最好更新防病毒软件并运行完整的防病毒扫描。 永远不要把私钥给任何人，他们可以拿走你的 QTUM。 如果你有加密钱包，请解锁钱包（而不是仅用于 staking） 转到“设置” - “解锁钱包”，取消选中“仅限 staking”，输入你的密码并按“确定” 你应该看到小挂锁符号搭扣打开了 选择要导出私钥的 Qtum 地址 转到“文件” - “接收地址…”，然后复制 Qtum 地址以导出私钥 选择地址并按 COPY，关闭该窗口 如果你的钱包有多个持有 QTUM 的接收地址，你可以找到哪些地址持有 QTUM，请转到“文件” - “调试窗口” - “控制台”并输入命令 listaddressgroupings 。 滚动列表并复制保存 QTUM 的地址以导出这些私钥 打开控制台并输入命令以导出私钥 转到“文件” - “调试窗口” - “控制台” 在控制台底部，开始输入命令dumpprivkey 然后粘贴你刚刚复制的地址。 这个命令看起来像这样： dumpprivkey QskjfhGF28374Daskfjh238742837482374 输入命令 私钥将作为包含 52 个字符的文本字符串显示在控制台上 将私钥复制到文本文件中并保证其安全。这是一个未加密的私钥，任何拥有这个私钥的人都可以使用你的 QTUM。 切勿将私钥交给任何人。 要在第二个 Qtum Core 钱包上导入这个私钥，请启动该钱包并将其解锁（如果已加密） 在控制台中输入 importprivkey 命令 转到“文件” - “调试窗口” - “控制台”，并在底部开始输入命令importprivkey 复制并粘贴先前转储的私钥。 该命令看起来像这样：importprivkey Siufy238746FGasj127356asjdhYTVss93845kajsfmyQTUM 输入命令 钱包将重新扫描本地区块链大约两分钟，以查找此新地址的交易，在此期间，调试窗口标题将显示“无响应(Not Responding）” 然后响应 “null” 你应该看到新私钥的未花费的交易的值已添加到钱包的总余额中。 你可能要将所有转移过的私钥（它将与你在步骤 2 中开始的地址）中的所有 QTUM 发送到另一个地址，因为私钥已导出并暴露在加密钱包之外（丢弃这个私钥）。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/tags/区块链/"},{"name":"Qtum","slug":"Qtum","permalink":"http://xichen.pub/tags/Qtum/"},{"name":"翻译","slug":"翻译","permalink":"http://xichen.pub/tags/翻译/"}]},{"title":"【翻译】 以太坊的挑战者：量子链（QTUM）","slug":"2018-07-06-翻译-以太坊的挑战者-量子链(QTUM)","date":"2018-07-06T06:11:00.000Z","updated":"2019-04-01T15:18:44.229Z","comments":true,"path":"2018/07/06/2018-07-06-翻译-以太坊的挑战者-量子链(QTUM)/","link":"","permalink":"http://xichen.pub/2018/07/06/2018-07-06-翻译-以太坊的挑战者-量子链(QTUM)/","excerpt":"","text":"原文：https://strategiccoin.com/the-ethereum-challengers-qtum/译者：中山大学数学学院（珠海）林学渊大二时给量子做的翻译，转载注明出处，谢谢 以太坊的挑战者：量子链（QTUM）– Guest Contributor Peter Keay 是 ICO Alert 的全球化总监，也是 Bitgenstein’s Table加密哲学播客节目的主持人。他是“以太坊的挑战者”系列作者。 这篇文章最初发表在这里。 该系列涵盖的其他竞争对手包括 RSK，EOS和Cardano。 很多加密货币用户和投资者都十分支持比特币或以太坊，甚至达到了“极端主义者”的程度。 极端主义者们认为，他们喜欢的币将占据市场主导地位并广泛应用，而所有其他加密货币最终都会消亡 - 或者只是作为主导币的测试网络。 实际上，BTC和ETH货币是当今最重要的数字资产，而且在可预见的未来可能也是如此。 然而比特币和以太坊是完全不同的，它们的优点和缺点都不一样。 所以，在2016年，一个简单的想法诞生了： 如果加密货币同时拥有比特币和以太坊的优点会怎样？ 遇见 Qtum。发音为“Quantum” 译者注：发音和中文“狂腾”相近 Qtum 结合了比特币技术和以太坊技术。 在“以太坊的挑战者”的系列中，我已经为大多数挑战者做了一些相关概念的总结。 例如，我们讨论了图灵完整性和侧链与RSK，PoS和DPoS与EOS，以及用Cardano的形式验证。 自从 Qtum（请记住：在你的心里请读作“Quantum”）将其平台作为比特币和以太坊的结合来推广时，让我们来谈谈两个主要的区块链交易模型。 然后，我们将讨论 Qtum 的其他功能，包括一些近期的公告，并看看它如何处理我们的七大问题。 所以，首先是交易模型。比特币使用 UTXO 模型。 以太坊使用帐户模型。 Qtum 想两者都要。 UTXO 模型（BTC）vs. 账户模型你是否曾把 BTC 从一个地址发送到另一个地址，结果在块浏览器中看到你的帐户实际发送了更多的BTC？ 这是 UTXO 模型的工作原理决定的，但对于习惯帐户模型的人来说，这并不直观。 事实上，看你的地址，显然发送的 BTC 比告诉你的要多得多，这十分可怕。 你习惯帐户模型，在那里你的帐户有余额。 例如，你的以太坊地址也是你的以太坊帐户。 你可以从余额中支出并接收余额付款。 虽然建议仅使用一次地址 - 出于隐私和安全的原因 - 实际上帐户模型会激励用户重复使用地址，因为这是最简单的用钱方式。 以太坊账户类型：以太坊有两种账户：由私钥控制的账户 - 如果你使用ETH，则为你所有 - 以及由合约代码控制的账户。私钥帐户制作并签署要发送给其他帐户的信息，而合约帐户会在收到信息时激活其代码以执行各种交易（包括发送其他信息，签订合约以及读取或写入自己的存储）。请注意，区块链中的“信息”包括交易。 帐户模型使用类似于银行帐户的余额管理系统。 但是像比特币这样的 UTXO（Unspent Transaction Output，未花费的交易输出）模型是不同的。 用 UTXO 模型的感觉类似于你只用支票付款，一直持有直到你需要用掉它。 正如你不能在银行只兑现支票的某一部分，而是必须兑现全部。在比特币里，一个地址收到一定钱后又只想只花掉其中一点，这样不行，它必须花掉所有的钱。 当你发送 BTC 时，你会花费 “vins” 并生成新的 “vouts”. UTXO 无法重复使用，所以通过花费 vins 并生成 vouts 后 UTXO 就被销毁了。 因此，如果你收到一个声称有 3.152 BTC 的 UTXO vin，然后发送 2.1 BTC，你实际上必须发送整个 3.152 BTC - 在这种情况下，作为两个 vouts：〜2.1给你的收件人和~1.052给你自己。 （小的采矿费会略微降低实际数量。）你收到的 3.152 BTC的 UTXO 已完成使命且无法重复使用，但 BTC 仍然存在于新的 UTXO 中。 在后台，你创建的 vout 脚本（发送）需要vin脚本的许可。 换句话说，为了花钱，你必须有一张有效的支票或多张支票，证明你过去收到过这笔钱（或者更多），并且支票一定不能撕掉。 因此，在帐户模型中，你的余额会被检查并借记和贷记，这不是比特币的工作方式。 如果你将BTC从Ledger钱包发送给其他人并在一个块代理商上检查交易，你可能已经注意到了这一点。 看似任意数量的BTC会被发送出去。 但你发送的实际金额将发送给收件人，剩余部分将转到一个你能控制的新地址。 你没有发送给收件人的BTC仍然是你的，但会被发送到新地址。 这是 UTXO 的工作原理决定的。 同样，如果你收到了两个分别为 1.1 BTC 和 0.8 BTC 的 UTXO，并且你想花费 1.3 BTC，那么两个 UTXO 都将 “被花费”，其余的将作为新的 UTXO 发送给你 - 在这种情况下，有 0.6 BTC，减去交易费用。 为什么这可能比简单的账户余额系统更好？ UTXO 模型激励用户限制他们对地址的重复使用，因为每次花费时 BTC 都会自动发送到新地址。 这样更安全，即使是对于量子计算（quantum computing）这样的进步也是如此，因为在你的地址开始使用之前，你的公钥不会泄露。 你的公共地址是公钥的哈希，而不是你的公钥本身，即使很多人错误地使用这些术语。 公钥和地址是相关但不同的东西。 但是，一旦地址开始花钱，该地址的公钥就会发布到区块链，因此理论上容易受到攻击，立刻就暴露了。 但是，如果地址的余额为空，即使成功攻击你的公钥也毫无价值 - 它发送到了你控制的新地址，并带有未公开的公钥 - 因此当BTC将“零钱”发送到新地址时，你将重新获得未知公钥安全上的好处。 一次性地址也具有隐私优势。 这种从地址到地址发送 BTC 的行为使得跟踪个人变得更加困难。 BTC 本身仍然可以很容易被跟踪，但在许多情况下，很难确定所涉及的大量地址的所有权。 其他代币以其他方式实现了类似或更高级别的隐私优势和安全性，不仅拥有这些优点，同时还保留了重复使用地址的便利性。 然而，这些代币在测试时间上没有比特币长，或者程度上没有比特币剧烈，并且他们的解决方案可能存在无法预料的复杂情况。 如果像以太坊这样的帐户模型加密货币的用户遵循仅使用每个地址一次的推荐做法，他们享有与UTXO提供的相同的安全和隐私权益。 但在比特币中，用户更有可能遵循这一最佳实践，因为它是默认行为。 附注：这些优点不适用于不再受欢迎的单地址钱包。 单地址钱包将UTXO的“零钱”发送回同一地址。它们适用于其他两种主要类型：1）随机生成新地址的钱包，现在也不常见。 当发送BTC时，用过的UTXO的“零钱”被发送到新的随机地址。 这是有风险的，因为如果钱包丢失，自上次备份以来生成的随机地址也将丢失。 2）能生成确定地址的钱包。 你今天用BTC的钱包可能会确定性地创建地址。 例如，硬件钱包和Electrum桌面钱包都是确定性的。 它们包含几乎无限的数学生成地址池。 无论何时发送BTC，这些钱包都会将用过的UTXO发送的“零钱”发送到新生成的地址。 确定性地址生成优于随机地址生成，因为一个种子可以重新生成所有相同的地址，从而提供更好的备份和恢复功能。 比特币的简单支付验证UTXO模型的一个优点是 SPV，(Simplified Payment Verification，简单支付验证），允许客户端验证一个交易是否包含在一个块中，而无需下载和验证整个区块链。 简而言之，希望下载的数据更少，因为任何人一旦把钱用出去，UTXO输出就会被遗忘。 块标题足以进行验证，因为它们可以提供 Merkle branchas “包含证明（proof of inclusion）”在 Satoshi 的原白皮书中描述了 SPV 背后的想法，尽管不是所有的功能。 这种轻量级验证方法确实存在一些风险，但是 Bloom 过滤器和连接到多个节点而不是一个节点的各种措施用于缓解此方法带来的安全问题。否则，轻型比特币客户端联系的完整节点可能会有1) 通过假装不存在的交易欺骗用户或2）获得所需的数据轻松跟踪比特币用户。 结合两种模型：QtumQtum 以 UTXO 模型及其 SPV 功能为基础运行，但增加了以太坊虚拟机 - 并且还支持其他虚拟机，我们稍后会介绍。 此外，尽管 UTXO 模型（BTC，BCH，LTC和DGB都是UTXO代币的例子）不支持退款，但 Qtum 可以通过创建新输出来退款。 在以太坊设置 “gas 限制” 并获得所有未使用的有作用的 gas 退款，因为以太坊没有运行在 UTXO 模型上。 但Qtum已成功启用此退款功能，即使它基于比特币的交易模式。 使用比特币运行，Qtum 可以轻松采用比特币开发，如 SegWit 和闪电网络（Lightning Network），以及之后的比特币改进建议。 使用以太坊的虚拟机运行，允许 Qtum 支持 Turing 完整的智能合约，这是比特币无法支持的。 为什么比特币脚本不够用比特币的智能合约能力非常有限 - 尽管 RSK 和 CounterParty 正致力于以不同的方式在比特币区块链上实现智能合约。 特别是，比特币的脚本语言没有循环功能。 根据给定的变量，代码不能执行多次。 这一点或其他因素使比特币语言只能完成最简单的任务。 因此，Qtum 通过在比特币代码之上允许以太币虚拟机，在比特币代码库上实现图灵完备脚本 - 尽管不在实际比特币区块链上。 为了做到这一点，它中间需要多一层。 Qtum 帐户抽象层为了使智能合约虚拟机及帐户模型适用于比特币的无帐户UTXO模型，Qtum包含了一个“帐户抽象层”。正如你可能想象的那样，让基于帐户的系统在无帐户底层上运行需要在 AAL（Account Abstract Layer，用户抽象层） 做一些复杂工作。 最终结果是为用户提供了 UTXO 和开发人员优势的图灵完备的以太坊虚拟机的优势。 新操作码 操作码：代码行的一部分，用于标识将要执行的操作。 有关其他示例，请查看比特币的可用操作码。 这些操作码是比特币脚本语言的所有功能。 寻求为比特币添加智能合约功能的解决方案，例如 RSK，通常需要一些新的操作码，且需要比特币来升级其代码。 Qtum 不需要比特币分支来添加新的操作码，因为它已经将比特币的代码分配到一个新项目中，因此能够简单地添加新的操作码。 技术说明：Qtum仍然使用比特币脚本语言，但是三个新的操作码使虚拟机能够在此基础上运行 OP_EXEC：执行特定的以太坊虚拟机字节码。 OP_EXEC_ASSIGN：与上述相同，可以包含合约地址和合约数据。它可选择将资金转移到智能合约上。 OP_TXHASH：推送当前执行的交易的ID哈希。Qtum 必须允许智能合约在添加到区块链时立即执行，因此前两个操作码将以特殊优先级进行处理。 通过添加这些操作码及帐户抽象层，Qtum 成功允许比特币代码库支持以太坊虚拟机。 现在，任何以太坊应用程序都可以在Qtum上运行，并享受UTXO基础带来的好处。 但是等等……还有更多。 权益证明，模板和向后兼容性Qtum对以太坊虚拟机的实现并不意味着它包含了以太坊的局限性。 像比特币一样，以太坊是建立在工作量证明之上的。节点消耗大量能量，首先解决非常困难的难题，并声称采矿奖励。我们在EOS第2章中里讨论了的共识模型，包括工作量证明。 Qtum取而代之的是建立在 Peercoin（PPC）之上的 Proof of Stake 模型，这是第一个使用赌注模型生效的加密货币。 Stof of Stake共识模型允许Qtum在没有高计算能力需求和每秒更多交易数的情况下运行。 如果您想详细阅读有关权益证明的信息，特别是与工作量证明相比较，我推荐以太坊团队成员撰写的文章。 不可否认，许多其他货币已经转移到了权益证明，以太坊计划在某些时候部分或全部这样做。 Qtum 还在实施模板以简化 dApp 开发 - 这是 NEM 等备选方案的重点，也是通过Crowd Machine 等项目引入以太坊的。 Qtum确实提供了一项功能，与 PoS 和模板不同，以太坊很可能永远不具备：向后兼容性。 Qtum 节点即使没有完全更新到最新版本的 Qtum，也可以参与共识。 Qtum X86 虚拟机Qtum AAL最着名的是允许使用以太坊虚拟机，但它也允许用其他虚拟机。 在5月23号，即本文发布的几个星期前，Qtum在韩国 Qtum X86 虚拟机会议上做了一个演讲。X86 VM 允许开发人员使用许多不同的编程语言。提到的C和C++已经支持了，其他像Rust, Python 和 Go 正在路上。 目前的Qtum路线图将 X86 集成放在 2018 年末。 Qtum Enterprise（Qtum X）Qtum Enterprise（Qtum X）也在同一个5月23日的会议中描述，是一项旨在吸引企业的新举措。 Qtum X 将是一个权威证明（Proof of Authority）系统，允许每秒更多的交易。 Qtum X 和 Qtum 是独立的产品，至少目前是这样。 我还没有找到关于这两种产品是否可以互通的任何信息，即它们是否将共享相同的货币。 宣布之后可能还需要很长时间才能获得许多细节，特别是英语版，所以如果有读者有更多信息，我会十分感谢分享。 连接到世界除了Qtum X和X86虚拟机之外，Qtum还有许多其他项目正在开发中，旨在吸引开发人员和企业加入Qtum生态系统。 API。 模板。 功能齐全的SDK。 原子交换。 Qtum 卫星。 原子交换：将一种加密货币交易给另一种货币而不涉及任何第三方。 在典型的原子交换中，在一个区块链上启动时间锁定的智能合约。 如果另一方未在规定时间内交付所交易的货币，则该交易将被取消。 是的，我不是在开玩笑说卫星。 与Nexus一样，Qtum计划与SpaceChain合作发射卫星。 看来，与前者相比，Qtum在审查阻力之后，主要是在现阶段拉动宣传噱头 - 正如他们所说的那样，“无可争议地证明了我们决心成为世界领先的加密货币和区块链平台。” 好吧，让我们把话题带回地球。 Qtum如何回答我们的七大问题？ 1.可扩展性 由于它是从比特币和以太坊构建的，因此Qtum每秒没有大量的交易。 权益证明（Proof of Stake）有助于实现 SegWit，将 TPS 提升至 60 左右。截至我看到的最新信息，Qtum 未来的可扩展性开发可能包括脱链渠道抑或类似于以太坊提议的分片的功能。 Qtum Enterprise（Qtum X）将使用授权证书来实现更高的交易吞吐量。 目前尚不清楚Qtum X和Qtum将如何或是否将在此时集成，但由于其可扩展性优势，企业可能对Qtum X感兴趣。 2.治理 Qtum的股权证明，最初建立在PeerCoin开创性的PoS代码之上。Qtum确实有一个分散治理协议（DGP）。 Qtum X 将在权威证明上运行。 Qtum区块链基金会指导DGP范围之外的决策。 3.开发复杂性 虽然Qtum可以使用以太坊的EVM和Solidity，但新的Qtum X86虚拟机还是会允许 C 和 C++ 和之后其他语言比如 Ruby, Go, Python. 与以太坊不同，Qtum的EVM始终向后兼容。 eSML是Qtum的计划语言，具有正式的验证能力。我们在episode #3 (Cardano)讨论了正式验证。正式验证是 Cardano 的主要关注点。 公平地说，一些第三方解决方案以及可能即将推出的 Casper 也将为以太坊引进正式验证。 4.时间轴 Qtum 很活跃，新的 X86 虚拟机将在今年晚些时候集成。 Qtum X（Qtum Enterprise）项目时间表在撰写本文时尚不清楚。 5.广义特征 如上所述，模板计划为应用程序开发人员提供通用功能，减少重复性工作和错误倾向。 除此之外，尚未出现广义特征。 随着X86虚拟机的集成，我不会惊讶于看到许多有趣的功能。 6.可采纳性 几个基本的 Qtum 可采用性功能已经到位，例如 Ledger 钱包集成，但由于以业务为中心的 Qtum X 仍处于早期开发阶段，我怀疑我们不会知道最终的 Qtum dApp 生态系统以及后来的游戏有多么对用户友好。 Qtum 确实有交易费用，但是像以太坊的费用一样，它们可能最终会被企业从用户那里抽象出来。 我没有找到有关 Qtum 上人类可读的地址计划的信息。 7.市场地位 据我所知，Qtum没有像我们迄今为止讨论过的大多数解决方案那样大的开发者社区。 然而，在Qtum上运行了一些dApp和ICO。 如果Qtum区块链基金会能够在加强Qtum营销的同时快速实现计划中的X86 VM，Qtum X和更多功能，那么它可能会使它们成为强大的以太坊挑战者。 当然，随着我们通过市值进一步向下移动，我们应该期待看到处于早期阶段的项目。 他们根本没有顶级项目那么多的嗡嗡声 - 也没有多少钱。 Qtum带来了其他智能合约平台的许多优势，以及它自己的一些重点。 因此，尽管我大声地认为Qtum确实需要一个新的标识，但我很高兴看到该项目的去向。 毕竟，在NEO的第4集中，我们讨论了中国项目在中国的表现如何比外国项目更好。 事实上，好多了。 中国的强大优势可能会使Qtum成为以太坊的严峻挑战者。 与本系列中的所有平台一样，我将密切关注 Qtum 及 X86 VM 和 Qtum X 的发布。 让我知道你对Twitter上Qtum的看法","categories":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/tags/区块链/"},{"name":"Qtum","slug":"Qtum","permalink":"http://xichen.pub/tags/Qtum/"},{"name":"翻译","slug":"翻译","permalink":"http://xichen.pub/tags/翻译/"}]},{"title":"【翻译】 深入理解以太坊虚拟机 - 如何解释一个智能合约的方法调用","slug":"2018-06-30-翻译-深入理解以太坊虚拟机-EVM汇编代码简介","date":"2018-06-30T06:11:00.000Z","updated":"2019-04-01T15:18:44.228Z","comments":true,"path":"2018/06/30/2018-06-30-翻译-深入理解以太坊虚拟机-EVM汇编代码简介/","link":"","permalink":"http://xichen.pub/2018/06/30/2018-06-30-翻译-深入理解以太坊虚拟机-EVM汇编代码简介/","excerpt":"","text":"原文：https://medium.com/@hayeah/how-to-decipher-a-smart-contract-method-call-8ee980311603译者：中山大学数学学院（珠海）林学渊大二时给量子做的翻译，转载注明出处，谢谢 如何解释一个智能合约的方法调用 在本系列的前几篇文章中，我们已经看到了 Solidity 如何在 EVM 存储中表示复杂的数据结构。但是如果没有办法与数据交互，数据就毫无用处。智能合约是数据与外部世界交互的中介。 在本文中，我们将看到 Solidity 和 EVM 如何使外部程序能够调用合约的方法并使其状态发生变化。 “外部程序” 不限于 DApp / JavaScript。 任何可以使用 HTTP RPC 与以太坊节点进行通信的程序都可以通过创建交易来与部署在区块链上的任何合约进行交互。 创建一个交易就像创建一个 HTTP 请求。 Web 服务器可以接受你的 HTTP 请求并更改数据库。同理，网络将接受一个交易，然后底层区块链扩展以包括状态的改变。 交易对于智能合约来说就像是 HTTP 请求对于 Web 服务。 如果对 EVM 汇编和 Solidity 的数据表示不熟悉，请参阅本系列以前的文章以了解更多信息： EVM汇编代码简介 如何表示固定长度的数据类型 如何表示动态数据类型 合约交易我们来看一个将状态变量设置为 0x1 的交易。与之交互的合约有变量 a 的一个 setter 和一个 getter： 12345678910pragma solidity ^0.4.11;contract C &#123; uint256 a; function setA(uint256 _a) &#123; a = _a; &#125; function getA() returns(uint256) &#123; return a; &#125;&#125; 该合约部署在测试网络Rinkeby上。可以使用 Etherscan 查看地址0x62650ae5…. 我创建了一个可以调用 setA(1) 的交易。可以在地址0x7db471e5….处查看此交易 交易的输入数据是：10xee919d500000000000000000000000000000000000000000000000000000000000000001 对 EVM 来说，这仅仅是 36 个字节的原始数据。将它作为 calldata 传给未经处理的智能合约。如果智能合约是一个 Solidity 程序，那么它将这些输入字节解释为一个方法调用，并为 setA(1) 执行相应的汇编代码。 输入数据可以分解为两个子部分： 1234# 方法选择器 (4 bytes)0xee919d5# 第一个参数 (32 bytes)00000000000000000000000000000000000000000000000000000000000000001 前四个字节是方法选择器，其余部分是 32 字节块的方法参数。在这个例子里只有 1 个参数，值 0x1。 方法选择器是方法签名的 kecccak256 哈希。在这个例子里，方法签名是 setA(uint256) ，它是方法的名称和参数的类型。 我们用 Python 来计算一下方法选择器。首先，散列方法签名： 1234# 安装 pyethereum https://github.com/ethereum/pyethereum/#installation&gt; from ethereum.utils import sha3&gt; sha3(\"setA(uint256)\").hex()'ee919d50445cd9f463621849366a537968fe1ce096894b0d0c001528383d4769' 然后获取哈希的前4个字节： 12&gt; sha3(\"setA(uint256)\")[0:4].hex()'ee919d50' 应用程序二进制接口（ABI）就 EVM 而言，交易的输入数据（calldata）只是一个字节序列。EVM 没有内置的方法调用的支持。 智能合约可以选择通过结构化方式来处理输入数据以模拟方法调用，如前一节所述。 如果 EVM 上的语言对输入数据的解释达成一致，那么它们可以很容易地进行交互。合约应用程序二进制接口（ABI）指定了一种通用的编码方案。 我们已经知道 ABI 如何编码一个简单的方法调用，如 setA(1)。在后面的章节中，我们将看到有更复杂参数的方法调用是如何编码的。 调用 Getter如果调用的方法改变了状态，那么整个网络都必须同意。这将需要一笔交易，并且会耗费 gas。 像 getA() 这样的 getter 方法不会改变任何东西。我们可以将方法调用发送到本地以太坊节点，而不是要求整个网络进行计算。 eth_call RPC 请求允许在本地模拟交易。这对只读方法或 gas 的使用评估非常有用。 eth_call 就像缓存的 HTTP GET请求。 它不会改变全局共识状态。 本地区块链（“cache”）可能有点过时。 让我们发起一个 eth_call 调用 getA 方法，返回状态 a。 首先，计算出方法选择器： 12&gt;&gt;&gt; sha3(\"getA()\")[0:4].hex()'d46300fd' 由于没有参数，输入数据本身就是方法选择器。 我们可以向任意一个以太坊节点发送 eth_call 请求。 在这个例子中，我们会将请求发送到由 infura.io 托管的公共以太坊节点：1234567891011121314151617$ curl -X POST \\-H \"Content-Type: application/json\" \\\"https://rinkeby.infura.io/YOUR_INFURA_TOKEN\" \\--data '&#123; \"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"eth_call\", \"params\": [ &#123; \"to\": \"0x62650ae5c5777d1660cc17fcd4f48f6a66b9a4c2\", \"data\": \"0xd46300fd\" &#125;, \"latest\" ]&#125;' EVM 执行计算并返回原始字节： 12345&#123; \"jsonrpc\":\"2.0\", \"id\":1, \"result\":\"0x0000000000000000000000000000000000000000000000000000000000000001\"&#125; 根据 ABI，这些字节应该被解释为值 0x1。 用于外部方法调用的汇编代码现在我们来看编译后的合约如何处理原始输入数据来进行方法调用的。 考虑定义了 setA(uint256) 的合约： 12345678pragma solidity ^0.4.11;contract C &#123; uint256 a; // 注意: `payable` 让汇编代码简单一点 function setA(uint256 _a) payable &#123; a = _a; &#125;&#125; 编译： 1solc --bin --asm --optimize call.sol 被调用方法的汇编代码位于 sub_0 下的合约主体中： 123456789101112131415161718192021222324252627282930sub_0: assembly &#123; mstore(0x40, 0x60) and(div(calldataload(0x0), 0x100000000000000000000000000000000000000000000000000000000), 0xffffffff) 0xee919d50 dup2 eq tag_2 jumpi tag_1: 0x0 dup1 revert tag_2: tag_3 calldataload(0x4) jump(tag_4) tag_3: stop tag_4: /* \"call.sol\":95:96 a */ 0x0 /* \"call.sol\":95:101 a = _a */ dup2 swap1 sstore tag_5: pop jump // outauxdata: 0xa165627a7a7230582016353b5ec133c89560dea787de20e25e96284d67a632e9df74dd981cc4db7a0a0029&#125; 有两段与本次讨论无关的样板代码: mstore(0x40，0x60) 位于顶部，用于保存内存中 sha3 哈希的前 64 个字节。无论合同是否需要，它总是存在的。 auxdata 位于最底部，用于验证发布的源代码与部署的字节码是否相同。 这是可选的，但可以编译到编译器中。 让我们将剩余的汇编代码分成两部分以便于分析： 匹配选择器并跳转到方法。 加载参数，执行方法和从方法返回。 首先，用于匹配选择器的汇编代码如下（带注释）： 1234567891011121314151617// 加载前 4 个字节作为方法选择器and(div(calldataload(0x0), 0x100000000000000000000000000000000000000000000000000000000), 0xffffffff)// 如果选择器匹配到 `0xee919d50`, 跳转到 setA0xee919d50dup2eqtag_2jumpi// 没有匹配到的方法. 失败 &amp; 返回.tag_1: 0x0 dup1 revert// setA 方法的主体tag_2: ... 很直接，除了在开始从调用数据里加载 4 个字节的位交换。 为了清楚起见，低层次伪代码中的汇编逻辑如下所示： 123456methodSelector = calldata[0:4]if methodSelector == \"0xee919d50\": goto tag_2 // 跳转到 setAelse: // 没有匹配到的方法. 失败 &amp; 返回. revert 实际方法调用的汇编代码（带注释）：123456789101112131415161718192021// setAtag_2: // 方法调用后返回的位置 tag_3 // 加载参数 (参数值为 0x1，0x4是地址，0x0~0x3是方法选择器). calldataload(0x4) // 执行 jump(tag_4)tag_4: // sstore(0x0, 0x1) 0x0 dup2 swap1 sstoretag_5: pop // 程序结束, 跳转到 tag_3 停止 jumptag_3: // 程序结束 stop 在进入方法主体之前，汇编代码做了两件事： 保存方法调用后返回的位置。 将来自调用数据的参数加载到堆栈上。 低层次的伪代码： 1234567891011// 保存方法调用后返回的位置.@returnTo = tag_3tag_2: // setA // 将调用数据的参数加载到堆栈中. @arg1 = calldata[4:4+32]tag_4: // a = _a sstore(0x0, @arg1)tag_5 // return jump(@returnTo)tag_3: stop 将两部分组合在一起：123456789101112131415methodSelector = calldata[0:4]if methodSelector == \"0xee919d50\": goto tag_2 // 跳转到 setAelse: // 没有匹配的方法. 失败. revert@returnTo = tag_3tag_2: // setA(uint256 _a) @arg1 = calldata[4:36]tag_4: // a = _a sstore(0x0, @arg1)tag_5 // return jump(@returnTo)tag_3: stop 有趣的花絮:返回的操作码是 fd。 但是你在黄皮书里找不到它的规范，或者在代码中实现。 实际上，fd 并不存在！ 这是一个无效的操作。 当 EVM 遇到无效操作时，它会因为副作用而放弃并恢复状态。 处理多个方法Solidity 编译器如何为具有多个方法的合同生成汇编代码？ 1234567891011pragma solidity ^0.4.11;contract C &#123; uint256 a; uint256 b; function setA(uint256 _a) &#123; a = _a; &#125; function setB(uint256 _b) &#123; b = _b; &#125;&#125; 简单。只是更多的 if-else 分支一个一个接上去： 1234567891011121314// methodSelector = calldata[0:4]and(div(calldataload(0x0), 0x100000000000000000000000000000000000000000000000000000000), 0xffffffff)// if methodSelector == 0x9cdcf9b0x9cdcf9bdup2eqtag_2 // SetBjumpi// elsif methodSelector == 0xee919d50dup10xee919d50eqtag_3 // SetAjumpi 伪代码： 12345678methodSelector = calldata[0:4]if methodSelector == \"0x9cdcf9b\": goto tag_2elsif methodSelector == \"0xee919d50\": goto tag_3else: // 没有匹配的方法. 失败. revert 用于复杂方法调用的 ABI 编码 对于方法调用，交易的输入数据前四个字节总是方法选择器。 然后方法参数以 32 个字节的块为单位。 ABI编码规范详细说明了复杂类型参数是如何编码的，但读取会非常痛苦。 学习 ABI 编码的另一个策略是使用 pyethereum 的 ABI 编码函数来研究如何对不同数据类型进行编码。 我们将从简单的案例开始，并构建更复杂的类型。 首先，导入 encode_abi 函数： 1from ethereum.abi import encode_abi 对于有三个 uint256 参数的方法（例如 foo(uint256 a，uint256 b，uint256 c)），编码的参数就是一个接一个的 uint256 数字: 123456# 第一个数组列出参数类型# 第二个数组列出参数值&gt; encode_abi([\"uint256\", \"uint256\", \"uint256\"],[1, 2, 3]).hex()000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003 小于 32 个字节的数据类型填充为32个字节： 1234&gt; encode_abi([\"int8\", \"uint32\", \"uint64\"],[1, 2, 3]).hex()000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003 对于定长数组，元素也是 32 字节的块（如果需要，填充 0 ），依次排列： 123456789101112&gt; encode_abi( [\"int8[3]\", \"int256[3]\"], [[1, 2, 3], [4, 5, 6]]).hex()// int8[3]. 用 0 填充到 32 bytes.000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003// int256[3].000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000006 动态数组的 ABI 编码ABI 引入了一个间接层来对动态数组进行编码，遵循称为头尾编码的方案。 这个想法是，动态数组的元素封装在交易的 calldata 的尾部。 参数（“头部”）是对数组元素所在的 calldata 的引用。 如果我们调用一个含 3 个动态数组的方法，则参数会像这样编码（为了清晰起见添加了注释和换行符）： 12345678910111213141516171819202122232425262728&gt; encode_abi( [\"uint256[]\", \"uint256[]\", \"uint256[]\"], [[0xa1, 0xa2, 0xa3], [0xb1, 0xb2, 0xb3], [0xc1, 0xc2, 0xc3]]).hex()/************* 头部 (32*3 bytes) *************/// arg1: 查看位置 0x60 寻找数组数据0000000000000000000000000000000000000000000000000000000000000060// arg2: 查看位置 0xe0 寻找数组数据00000000000000000000000000000000000000000000000000000000000000e0// arg3: 查看位置 0x160 寻找数组数据0000000000000000000000000000000000000000000000000000000000000160/************* 尾部 (128**3 bytes) *************/// 位置 0x60. arg1 的数据.// 长度后跟元素000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000a100000000000000000000000000000000000000000000000000000000000000a200000000000000000000000000000000000000000000000000000000000000a3// 位置 0xe0. arg2 的数据.000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000b100000000000000000000000000000000000000000000000000000000000000b200000000000000000000000000000000000000000000000000000000000000b3// 位置 0x160. arg3 的数据.000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000c100000000000000000000000000000000000000000000000000000000000000c200000000000000000000000000000000000000000000000000000000000000c3 所以头部有三个 32 字节的参数，指向尾部的位置，它包含三个动态数组的实际数据。 例如，第一个参数是 0x60，指向 calldata 的第96个（0x60）字节。 如果你看第 96 个字节，它是一个数组的开始。 前 32 个字节是长度，后面是三个元素。 可以混合动态和静态参数。 这里有一个 (静态, 动态, 静态) 参数的例子。 静态参数按原样编码，而第二个动态数组的数据放置在尾部： 1234567891011121314151617&gt; encode_abi( [\"uint256\", \"uint256[]\", \"uint256\"], [0xaaaa, [0xb1, 0xb2, 0xb3], 0xbbbb]).hex()/************* 头部 (32*3 bytes) *************/// arg1: 0xaaaa000000000000000000000000000000000000000000000000000000000000aaaa// arg2: 查看数组数据的位置 0x60 0000000000000000000000000000000000000000000000000000000000000060// arg3: 0xbbbb000000000000000000000000000000000000000000000000000000000000bbbb/************* 尾部 (128 bytes) *************/// 位置 0x60. arg2 的数据.000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000b100000000000000000000000000000000000000000000000000000000000000b200000000000000000000000000000000000000000000000000000000000000b3 很多零，但没关系。 编码字节字符串和字节数组也用头尾编码。唯一的区别是这些字节以 32 字节的块形式紧密打包，如下所示： 12345678910111213141516171819&gt; encode_abi( [\"string\", \"string\", \"string\"], [\"aaaa\", \"bbbb\", \"cccc\"]).hex()// arg1: 查看位置 0x60 寻找字符串数据0000000000000000000000000000000000000000000000000000000000000060// arg2: 查看位置 0xa0 寻找字符串数据00000000000000000000000000000000000000000000000000000000000000a0// arg3: 查看位置 0xe0 寻找字符串数据00000000000000000000000000000000000000000000000000000000000000e0// 0x60 (96). arg1 的数据00000000000000000000000000000000000000000000000000000000000000046161616100000000000000000000000000000000000000000000000000000000// 0xa0 (160). arg2 的数据00000000000000000000000000000000000000000000000000000000000000046262626200000000000000000000000000000000000000000000000000000000// 0xe0 (224). arg3 的数据00000000000000000000000000000000000000000000000000000000000000046363636300000000000000000000000000000000000000000000000000000000 对于每个字符串/字节数组，它前 32 个字节对​​长度进行编码，后跟字节。 如果字符串大于 32 字节，则使用多个 32 字节的块： 1234567891011// encode 48 bytes of string dataethereum.abi.encode_abi( [\"string\"], [\"a\" * (32+16)]).hex()0000000000000000000000000000000000000000000000000000000000000020// 字符串长度是 0x30 (48)000000000000000000000000000000000000000000000000000000000000003061616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616100000000000000000000000000000000 嵌套数组嵌套数组，每个嵌套有一个间接寻址。 1234567891011121314151617181920212223242526&gt; encode_abi( [\"uint256[][]\"], [[[0xa1, 0xa2, 0xa3], [0xb1, 0xb2, 0xb3], [0xc1, 0xc2, 0xc3]]]).hex()// arg1: 外层数组位于 0x20.0000000000000000000000000000000000000000000000000000000000000020// 0x20. 每个元素都是一个内部数组的位置。0000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000160// array[0] at 0x60000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000a100000000000000000000000000000000000000000000000000000000000000a200000000000000000000000000000000000000000000000000000000000000a3// array[1] at 0xe0000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000b100000000000000000000000000000000000000000000000000000000000000b200000000000000000000000000000000000000000000000000000000000000b3// array[2] at 0x160000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000c100000000000000000000000000000000000000000000000000000000000000c200000000000000000000000000000000000000000000000000000000000000c3 呀，很多零。 gas 成本 &amp; ABI 编码设计为什么 ABI 将方法选择器截断为只有 4 个字节？ 如果不用 sha256 的全部 32 个字节，那么对于不同的方法是否会出现碰撞？ 如果截断是为了节省成本，为什么还要在方法选择器中节省 28 字节却让它浪费更多的零填充字节？ 这两个设计选择似乎是矛盾的……直到我们考虑交易的 gas 成本。 21000 支付给每笔交易 4 支付给交易的每个 0 字节数据或代码 68 支付给交易的每个非零数据或代码 啊哈！ 零字节便宜17倍，所以零填充不是那么糟糕。 方法选择器是一个加密哈希，它是伪随机的。一个随机字符串往往会有大部分非零字节，因为每个字节只有 0.3％（1/255）的可能性为 0。 0x1 填充为 32 字节，成本 192 gas 4 * 31 (零字节) + 68 (1个非零字节) sha256 很可能有 32 个非零字节，成本约为 2176 gas 32 * 68 sha256 截断为 4 个字节，成本约为 272 gas 32 * 4 ABI 展示了另一个由 gas 成本结构激励的低级设计的例子。 负整数…负整数通常使用称为补码的方案来表示。int8 的 -1 编码全是1 1111 1111。 ABI 使用 1 来填充负整数，所以 -1 会填充为： 12// 16进制表示ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff 小负数主要是 1，因此耗费大量 gas。 ¯\\_(ツ)_/¯ 小结要与智能合约交互，需要向其发送原始字节。它执行一些计算，可能会改变它自己的状态，然后返回原始字节。方法调用实际上不存在。 这是 ABI 创造的集体幻想。 ABI被指定为低级格式，但在功能上它更像是跨语言 RPC 框架的序列化格式。 我们可以在 DApp 和 Web App 的架构层之间进行类比： 区块链就像支持数据库。 合约就像一个 web 服务。 交易就像一个请求。 ABI 是数据交换格式，如协议缓冲区。 如果你喜欢这篇文章，你应该在Twitter @hayeah上关注我。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/tags/区块链/"},{"name":"Qtum","slug":"Qtum","permalink":"http://xichen.pub/tags/Qtum/"},{"name":"翻译","slug":"翻译","permalink":"http://xichen.pub/tags/翻译/"}]},{"title":"【翻译】 深入理解以太坊虚拟机 - 如何表示动态数据类型","slug":"2018-06-24-翻译-深入理解以太坊虚拟机-如何表示动态数据类型","date":"2018-06-24T06:11:00.000Z","updated":"2019-04-01T15:18:44.226Z","comments":true,"path":"2018/06/24/2018-06-24-翻译-深入理解以太坊虚拟机-如何表示动态数据类型/","link":"","permalink":"http://xichen.pub/2018/06/24/2018-06-24-翻译-深入理解以太坊虚拟机-如何表示动态数据类型/","excerpt":"","text":"原文：https://medium.com/@hayeah/diving-into-the-ethereum-vm-the-hidden-costs-of-arrays-28e119f04a9b译者：中山大学数学学院（珠海）林学渊大二时给量子做的翻译，转载注明出处，谢谢 如何表示动态数据类型数组的隐性成本 Solidity 提供了我们熟悉的数据结构。除了简单的如数字和结构体，也有其他数据类型，它们能随着数据的添加而动态变化。3个主要的动态类型是： 映射：mapping(bytes32 =&gt; uint256)，mapping(address =&gt; string)，等等。 数组：[]uint256，[]byte，等等。 字节数组：只有两种，字符串和字节。 在本系列第二篇文章中，我们已经看到固定长度的简单类型在存储中是如何表示的。 基础类型：uint256，byte，等等。 定长数组：[10]uint8，[32]byte，bytes32。 结构体：用以上两种类型组装而成。 固定长度的存储变量在存储中一个接一个存储，尽可能轻量地打包成32字节的块。 如果对这个不熟，我建议看: Diving Into The Ethereum VM Part II — Storage Cost 在这篇文章中，我们深入理解 Solidity 是如何支持更多复杂的数据结构的。 Solidity 中的数组和映射可能看起来很熟悉，但它们的实现方式使它们具有本质的不同。 我们从映射开始，这是三者中最简单的一种。 事实证明，数组和字节数组只是有更多的功能的映射。 映射在 uint256 =&gt; uint256 映射中存储一个值：1234567pragma solidity ^0.4.11;contract C &#123; mapping(uint256 =&gt; uint256) items; function C() &#123; items[0xC0FEFE] = 0x42; &#125;&#125; 编译:1solc --bin --asm --optimize c-mapping.sol 汇编代码:12345678910111213tag_2: // 什么也没干. 可以优化. 0xc0fefe 0x0 swap1 dup2 mstore 0x20 mstore // 存储 0x42 到地址 0x798...187c 0x42 0x79826054ee948a209ff4a6c9064d7398508d2c1909a392f899d301c6d232187c sstore 我们可以将 EVM 存储视为键值对数据库，每个键限制为 32 个字节。不是直接使用键 0xC0FEFE ，而是将键散列为 0x798...187c，并将值 0x42 存储在那里。使用的哈希函数是 keccak256（SHA256）。 在这个例子里，我们没有看到 keccak256 指令，因为优化器已经预先计算结果并将其内联到字节码里了。可以从这些没用的 mstore 指令中看到这种计算的痕迹。 计算地址让我们用一些 Python 代码来将 0xC0FEFE 散列为 0x798...187c。如果你想跟着做，你需要 Python 3.6，或者安装 pysha3 来获得 keccak_256 哈希函数。 定义两个辅助函数： 12345678import binasciiimport sha3# 把一个数转化为 32 字节的数组def bytes32(i): return binascii.unhexlify('%064x' % i)# 计算 32 字节数组的 keccak256 哈希def keccak256(x): return sha3.keccak_256(x).hexdigest() 把一个数转化为 32 字节的数组:1234&gt;&gt;&gt; bytes32(1)b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01'&gt;&gt;&gt; bytes32(0xC0FEFE)b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xc0\\xfe\\xfe' 用 + 运算把两个字节数组接在一起：12&gt;&gt;&gt; bytes32(1) + bytes32(2)b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02' 计算字节数组的 keccak256 哈希12&gt;&gt;&gt; keccak256(bytes(1))'bc36789e7a1e281436464229828f817d6612f7b477d66591ff96a9e064bcc98a' 现在我们可以计算 0x798...187c了。 存储变量 items 的位置是 0x0（因为它是第一个存储变量）。要获取地址，将键 0xc0fefe 与 items 的位置接在一起：123# key = 0xC0FEFE, position = 0&gt;&gt;&gt; keccak256(bytes32(0xC0FEFE) + bytes32(0))'79826054ee948a209ff4a6c9064d7398508d2c1909a392f899d301c6d232187c' 计算一个键的存储地址的公式为：1keccak256(bytes32(key) + bytes32(position)) 2 个映射让我们用公式来计算值会存储到哪个位置！假设我们有2个映射： 123456789pragma solidity ^0.4.11;contract C &#123; mapping(uint256 =&gt; uint256) itemsA; mapping(uint256 =&gt; uint256) itemsB; function C() &#123; itemsA[0xAAAA] = 0xAAAA; itemsB[0xBBBB] = 0xBBBB; &#125;&#125; itemsA 的位置为 0, 键为 0xAAAA:123# key = 0xAAAA, position = 0&gt;&gt;&gt; keccak256(bytes32(0xAAAA) + bytes32(0))'839613f731613c3a2f728362760f939c8004b5d9066154aab51d6dadf74733f3' itemsB 的位置为 1, 键为 0xBBBB:123# key = 0xBBBB, position = 1&gt;&gt;&gt; keccak256(bytes32(0xBBBB) + bytes32(1))'34cb23340a4263c995af18b23d9f53b67ff379ccaa3a91b75007b010c489d395' 我们用编译器证明我们的计算：1$ solc --bin --asm --optimize c-mapping-2.sol 汇编代码:12345678tag_2: // ... 忽略内存优化，可以优化掉 0xaaaa 0x839613f731613c3a2f728362760f939c8004b5d9066154aab51d6dadf74733f3 sstore 0xbbbb 0x34cb23340a4263c995af18b23d9f53b67ff379ccaa3a91b75007b010c489d395 sstore 和我们想的一样。 汇编里的 KECCAK256编译器能预先计算一个键的地址，因为涉及的键是常量。如果键是一个变量，那么散列需要用汇编代码完成。现在我们要禁用这个优化，以便看到哈希如何在汇编中完成。 事实证明，通过引入一个额外变量 i 可以简化优化器： 123456789pragma solidity ^0.4.11;contract C &#123; mapping(uint256 =&gt; uint256) items; // 这个变量使常值优化失败 uint256 i = 0xC0FEFE; function C() &#123; items[i] = 0x42; &#125;&#125; 变量位置还是 0x0, 所以我们认为地址和前面一样。 编译，但这次没有哈希预计算：1$ solc --bin --asm --optimize c-mapping--no-constant-folding.sol 汇编代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445tag_2: // `i` 入栈 sload(0x1) [0xC0FEFE] // 存储键 `0xC0FEFE` 到内存 0x0, 准备哈希. 0x0 [0x0 0xC0FEFE] swap1 [0xC0FEFE 0x0] dup2 [0x0 0xC0FEFE 0x0] mstore [0x0] memory: &#123; 0x00 =&gt; 0xC0FEFE &#125; // 保持位置 `0x0` 到内存 0x20 (32), 准备哈希. 0x20 // 32 [0x20 0x0] dup2 [0x0 0x20 0x0] swap1 [0x20 0x0 0x0] mstore [0x0] memory: &#123; 0x00 =&gt; 0xC0FEFE 0x20 =&gt; 0x0 &#125; // 从第 0 个字节开始，依次哈希内存中接下来的 0x40 (64) 字节 0x40 // 64 [0x40 0x0] swap1 [0x0 0x40] keccak256 [0x798...187c] // 保存 0x42 到计算地址 0x42 [0x42 0x798...187c] swap1 [0x798...187c 0x42] sstore store: &#123; 0x798...187c =&gt; 0x42 &#125; mstore 指令在内存中写入 32 个字节。 内存要便宜得多，只需要 3 gas 来读写。汇编代码前半部分通过将键和位置加载到相邻的内存块中来“连接”键和位置：12 0 31 32 63[ key (32 bytes) ][ position (32 bytes) ] 然后，keccak256 指令散列该内存区域中的数据。成本取决于有多少数据被散列： 30 付给每个SHA3操作。 6 付给每个32字节的字。 对于 uint256 键，gas 成本是 42（30 + 6 * 2）。 映射大数值每个存储单元只能存储 32 个字节。如果试图存储更大的结构会发生什么？ 1234567891011121314pragma solidity ^0.4.11;contract C &#123; mapping(uint256 =&gt; Tuple) tuples; struct Tuple &#123; uint256 a; uint256 b; uint256 c; &#125; function C() &#123; tuples[0x1].a = 0x1A; tuples[0x1].b = 0x1B; tuples[0x1].c = 0x1C; &#125;&#125; 编译，你可以看到 3 个 sstore 指令：1234567891011tag_2: // ...忽略未优化代码 0x1a 0xada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7d sstore 0x1b 0xada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7e sstore 0x1c 0xada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7f sstore 注意，除了最后一位数字，计算出的地址都是相同的。Tuple 结构的字段一个接一个地排列（.7d，.7e，.7f）。 映射不打包由于映射的设计方式，即使只存储 1 个字节，每一项的最小存储量也是 32 个字节： 12345678pragma solidity ^0.4.11;contract C &#123; mapping(uint256 =&gt; uint8) items; function C() &#123; items[0xA] = 0xAA; items[0xB] = 0xBB; &#125;&#125; 如果值大于 32 字节，则以 32 字节为单位支付存储费用。 动态数组是 Mappings++（译者注：C和C++的梗） 在经典程序语言中，数组只是一个在内存中连续排列数据项的列表。假设你有一个含 100 个 uint8 元素的数组，那么它将占用 100 个字节的内存。在此方案中，将整个阵列批量加载到 CPU 缓存中并循环遍历项目很便宜。 对于大多数语言而言，数组比映射便宜。不过，对于 Solidity 而言，数组是一种更昂贵的映射。数组的数据项按顺序放置在存储中，如：12340x290d...e5630x290d...e5640x290d...e5650x290d...e566 但记住，每次对这些存储单元的访问实际上都是数据库中的键值查找。访问数组元素与访问映射元素没有区别。 考虑类型 [] uint256，它与映射（uint256 =&gt; uint256）基本相同，并增加了使其“类似数组”的功能： length 表示有多少数据项。 绑定检查。读取或写入超出长度的索引时会引发错误。 比映射更复杂的存储打包行为。 数组缩小时自动释放未使用的存储单元。 对 bytes 和 string 进行特殊优化，使短数组（小于31字节）的存储效率更高。 简单数组我们来看看存储三个数据项的数组：12345678910// c-darray.solpragma solidity ^0.4.11;contract C &#123; uint256[] chunks; function C() &#123; chunks.push(0xAA); chunks.push(0xBB); chunks.push(0xCC); &#125;&#125; 数组访问的汇编代码太复杂，无法跟踪。我们用 Remix 调试器来运行合约： 可以看到使用了 4 个存储单元：12345678key: 0x0000000000000000000000000000000000000000000000000000000000000000value: 0x0000000000000000000000000000000000000000000000000000000000000003key: 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563value: 0x00000000000000000000000000000000000000000000000000000000000000aakey: 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e564value: 0x00000000000000000000000000000000000000000000000000000000000000bbkey: 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e565value: 0x00000000000000000000000000000000000000000000000000000000000000cc 一个块的位置是 0x0，它用于存储数组的长度（0x3）。散列变量的位置以查找数组数据项的地址：123# position = 0&gt;&gt;&gt; keccak256(bytes32(0))'290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563' 数组中的每个数据项都从该地址（0x29..63，0x29..64，0x29..65）开始顺序布局。 动态数组打包你怎么看这些所有重要的打包行为？基于映射的数组的一个优点是打包。 四个数据项的 uint128 [] 数组恰好填满两个存储单元（加 1 用于存储长度）。 考虑：1234567891011pragma solidity ^0.4.11;contract C &#123; uint128[] s; function C() &#123; s.length = 4; s[0] = 0xAA; s[1] = 0xBB; s[2] = 0xCC; s[3] = 0xDD; &#125;&#125; 在 Remix 上运行, 最终存储的状态是：123456key: 0x0000000000000000000000000000000000000000000000000000000000000000value: 0x0000000000000000000000000000000000000000000000000000000000000004key: 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563value: 0x000000000000000000000000000000bb000000000000000000000000000000aakey: 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e564value: 0x000000000000000000000000000000dd000000000000000000000000000000cc 和我们想的一样，只用了 3 个存储单元。长度存储在 0x0 处，即存储变量的位置。四个数据项打包在两个独立的存储单元中。该数组的起始地址是变量位置的哈希值： 123# position = 0&gt;&gt;&gt; keccak256(bytes32(0))'290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563' 现在每增加两个数组元素，地址才会增加一次。看起来ok！ 但汇编代码本身并没有得到很好的优化。由于只使用两个存储单元，因此我们希望优化器也只使用两个 sstore 进行分配。然而，在引入边界检查（以及其他）情况下，不可能优化 sstore 指令。 四个 sstore 指令用于分配： 12345678/* \"c-bytes--sstore-optimize-fail.sol\":105:116 s[0] = 0xAA */sstore/* \"c-bytes--sstore-optimize-fail.sol\":126:137 s[1] = 0xBB */sstore/* \"c-bytes--sstore-optimize-fail.sol\":147:158 s[2] = 0xCC */sstore/* \"c-bytes--sstore-optimize-fail.sol\":168:179 s[3] = 0xDD */sstore 字节数组 &amp; 字符串bytes 和 string 是分别针对字节和字符进行优化的特殊数组类型。如果数组的长度小于 31 个字节，则只用一个存储单元来存储整个数组。较长的字节数组与正常数组的表示方式大致相同。 我们来看一个实际使用的短字节数组： 12345678910// c-bytes--long.solpragma solidity ^0.4.11;contract C &#123; bytes s; function C() &#123; s.push(0xAA); s.push(0xBB); s.push(0xCC); &#125;&#125; 由于数组只有 3 个字节（小于 31 个字节），因此它只占用一个存储单元。在 Remix 中运行，存储状态为：12key: 0x0000000000000000000000000000000000000000000000000000000000000000value: 0xaabbcc0000000000000000000000000000000000000000000000000000000006 数据 0xaabbcc... 从左到右存储。后面的 0 是空数据。最后一个字节 0x06 是数组的编码长度。 公式为 encodedLength / 2 = length。这种情况下，实际长度是 6/2 = 3。 字符串的工作方式和这个完全相同。 长字节数组如果数据量大于 31 字节，则字节数组就像 []byte。让我们看看长度为 128 字节的字节数组：123456789101112// c-bytes--long.solpragma solidity ^0.4.11;contract C &#123; bytes s; function C() &#123; s.length = 32 * 4; s[31] = 0x1; s[63] = 0x2; s[95] = 0x3; s[127] = 0x4; &#125;&#125; 在 Remix 运行，可以看到存储里使用了 4 个存储单元：123456789100x0000...00000x0000...01010x290d...e5630x0000...00010x290d...e5640x0000...00020x290d...e5650x0000...00030x290d...e5660x0000...0004 存储单元 0x0 不再用于存储数据。整个存储单元现在存储编码后的数组长度。为了得到实际的长度，做 length =（encodedLength - 1）/ 2。在这种情况下，长度为 128 =（0x101 - 1）/ 2。实际字节存储在 0x290d...e563 中，以及按顺序排列的存储单元中。 字节数组的汇编代码非常大。除了正常的边界检查和调整数组大小的东西，它还要编码/解码长度，以及在长和短字节数组之间进行转换。 为什么要对长度进行编码？因为这种方式有一个简单的方法来检测一个字节数组是短还是长。注意，长数组的编码长度总是奇数，短数组的编码长度总是偶数。汇编只需要查看最后一位，看它是零（偶/短）还是非零（奇/长）。 小结查看 Solidity 编译器的内部工作，我们发现熟悉的数据结构（如映射和数组）与传统的编程语言的完全不同。 回顾一下： 数组就像映射，效率不高。 比映射更复杂的汇编代码。 比较小类型（字节，uint8，字符串）映射更好的存储效率。 汇编代码没有很好地优化。即使打包过了，还是每个分配要一个 sstore 。EVM 存储是一个键值对数据库，非常像 git。如果你改变了任何东西，那么根节点的校验和就会改变。如果两个根节点具有相同的校验和，则存储的数据相同。 要了解 Solidity 和 EVM 的独特之处，可以想象数组中的每个元素都是一个文件在 git 存储库中。当你改变一个数组元素的值时，你实际上正在创建一个 git commit。在遍历数组时，无法一次加载整个数组，您必须查看存储库并分别查找每个文件。 不仅如此，每个文件被限制为 32 个字节！因为我们需要将数据结构分割成32个字节的块，所以 Solidity 的编译器由于各种逻辑和优化技巧而复杂化，所有这些都是在汇编中完成的。 然而，32 字节的限制完全是任意的。备份键值存储可以使用键存储任意数量的字节。也许在将来我们可以添加一个新的 EVM 指令来存储任意字节和一个关键字。 目前，EVM 存储是一个预先假定为32字节数组的键值对数据库。 请参阅 ArrayUtils::resizeDynamicArray，了解编译器在调整数组大小时的作用。通常情况下，数据结构将作为标准库的一部分在语言中完成，但在 Solidity 中，它会被烧录入编译器。 如果你喜欢这篇文章，你应该在 Twitter @hayeah 上关注我。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/tags/区块链/"},{"name":"Qtum","slug":"Qtum","permalink":"http://xichen.pub/tags/Qtum/"},{"name":"翻译","slug":"翻译","permalink":"http://xichen.pub/tags/翻译/"}]},{"title":"【翻译】 深入理解以太坊虚拟机 - 如何表示固定长度的数据类型","slug":"2018-06-18-翻译-深入理解以太坊虚拟机-如何表示固定长度的数据类型","date":"2018-06-18T06:11:00.000Z","updated":"2019-04-01T15:18:44.225Z","comments":true,"path":"2018/06/18/2018-06-18-翻译-深入理解以太坊虚拟机-如何表示固定长度的数据类型/","link":"","permalink":"http://xichen.pub/2018/06/18/2018-06-18-翻译-深入理解以太坊虚拟机-如何表示固定长度的数据类型/","excerpt":"","text":"原文：https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-2-storage-layout-bc5349cb11b7译者：中山大学数学学院（珠海）林学渊大二时给量子做的翻译，转载注明出处，谢谢 如何表示固定长度的数据类型我是怎样学会了担忧以及计算存储成本 在本系列文章的第一篇中，我们看了一个简单 Solidity 合约的汇编代码： 123456contract C &#123; uint256 a; function C() &#123; a = 1; &#125;&#125; 该合约实际上是调用了 sstore 指令：12// a = 1sstore(0x0, 0x1) EVM 把值 0x1 保存在存储位置 0x0. 每个存储位置实际上能存 32 字节 (或者 256 比特). 如果对这个不熟，我建议看: Diving Into The Ethereum VM Part 1 — Assembly &amp; Bytecode 在本篇文章中，我们关注 Solidity 如何使用32字节的块来表示更多复杂的数据类型，比如结构体和数组。我们也能看到如何优化存储，及怎样可能优化失败。在典型的程序语言中，理解数据类型在底层如何表示不是特别有用。但在 Solidity (或任何 EVM 语言) 这种知识至关重要，因为存储访问太贵了。 sstore 花费 20000 gas, 或者比基础算术指令贵约 5000倍. sload 花费 200 gas, 或者比基础算术指令贵约 100倍. 对于“花费”，我们这里谈的是真钱，不仅仅是性能上的多少毫秒。运行和使用合约的花费中，sstore 和 sload 占主导地位！ 磁带解析 构建通用计算机的两个基本要素： 一种循环方式，无论是跳转还是递归。 无限内存 EVM 汇编代码提供跳转，EVM 存储提供无限内存。这些对一切都够用了，包括模拟一个运行以太坊的世界，其以太坊又模拟了一个运行以太坊的世界… EVM 存储一个合约像是一条没有尽头的磁带，磁带的每个单元有32字节，像这样：1[32 字节][32 字节][32 字节]... 我们会看到数据如何在无尽的磁带上变得生动起来的。 磁带长度为 2²⁵⁶, 或者每个合约有大约10⁷⁷个单元。宇宙的可观测的粒子数是10⁸⁰。大约1000个合约就足以容纳所有质子，中子和电子。不要相信营销炒作，因为它比无限更短。 空白磁带存储最初是空白的，默认为 0 。拥有无限磁带并不需要花费任何东西。 我们来看一个简单的合约来说明零价值行为：123456789101112pragma solidity ^0.4.11;contract C &#123; uint256 a; uint256 b; uint256 c; uint256 d; uint256 e; uint256 f; function C() &#123; f = 0xc0fefe; &#125;&#125; 存储中的布局很简单。 变量 a 位于位置 0x0 变量 b 位于位置 0x1 如此下去…关键问题: 如果我们只用 f, 我们给 a, b, c, d, e花多少?编译看一下：1$ solc --bin --asm --optimize c-many-variables.sol 汇编:12345// sstore(0x5, 0xc0fefe)tag_2: 0xc0fefe 0x5 sstore 因此，存储变量的声明不需要任何费用，因为没有初始化。 Solidity 为该变量保留一个位置，并且只有当你存储某些内容时才支付 gas 。 在这种情况下，我们只为存储到 0x5 花钱。 如果我们手工编写汇编，我们可以任意选择存储位置而不必“扩展”存储： 12// 写入任意位置sstore(0xc0fefe, 0x42) 读取 0你不仅可以在存储的任何位置写入，还可以立即从任何位置读取。读取未初始化的位置仅返回 0x0 。 让我们看一个读取未初始化位置的合约： 1234567pragma solidity ^0.4.11;contract C &#123; uint256 a; function C() &#123; a = a + 1; &#125;&#125; 编译:1$ solc --bin --asm --optimize c-zero-value.sol 汇编代码:1234567891011tag_2: // sload(0x0) returning 0x0 0x0 dup1 sload // a + 1; where a == 0 0x1 add // sstore(0x0, a + 1) swap1 sstore 注意：生成从未初始化位置加载数据的代码是有效的。 然而，我们可以比 Solidity 编译器更聪明。由于我们知道tag_2是构造函数，并且从未写入过，所以我们可以用0x0替换sload序列。这可以省 5,000 gas。 结构体的表示我们来看第一个复杂数据类型，一个有 6 个字段的结构体：123456789101112131415pragma solidity ^0.4.11;contract C &#123; struct Tuple &#123; uint256 a; uint256 b; uint256 c; uint256 d; uint256 e; uint256 f; &#125; Tuple t; function C() &#123; t.f = 0xC0FEFE; &#125;&#125; 存储中的布局和状态变量一样。 变量 t.a 位于位置 0x0 变量 t.b 位于位置 0x1 如此下去… 和之前类似，我们可以直接向 t.f 写入而不用给初始化花钱。 编译：1$ solc --bin --asm --optimize c-struct-fields.sol 我们看到了一样的汇编代码：1234tag_2: 0xc0fefe 0x5 sstore 定长数组声明一个定长数组：1234567pragma solidity ^0.4.11;contract C &#123; uint256[6] numbers; function C() &#123; numbers[5] = 0xC0FEFE; &#125;&#125; 由于编译器确切地知道有多少个 uint256 （ 32 个字节），因此它可以简单地将数组元素放在存储器中，就像存储变量和结构体一样。 在这份合约中，我们再次存储到位置 0x5 。 编译：1$ solc --bin --asm --optimize c-static-array.sol 汇编代码：12345678910tag_2: 0xc0fefe 0x0 0x5tag_4: add 0x0tag_5: pop sstore 它稍微长一些，但如果你稍微眯起一点，你会发现它实际上是一样的。我们手动进一步优化：12345678910tag_2: 0xc0fefe // 0+5. 用 0x5 代替 0x0 0x5 add // Push then pop immediately. Useless, just remove. 0x0 pop sstore 除去标签和伪指令，我们再次得到相同的字节码序列：1234tag_2: 0xc0fefe 0x5 sstore 数组边界检测我们已经看到，定长数组与结构体或状态变量两者具有相同的存储布局，但生成的汇编代码是不同的。原因是 Solidity 为数组访问生成了边界检查。 让我们再次编译数组合约，这次先关闭优化：1$ solc --bin --asm c-static-array.sol 注释一下，在每条指令后打印机器状态： 1234567891011121314151617181920212223242526272829tag_2: 0xc0fefe [0xc0fefe] 0x5 [0x5 0xc0fefe] dup1 /* 数组边界检测代码 */ // 5 &lt; 6 0x6 [0x6 0x5 0xc0fefe] dup2 [0x5 0x6 0x5 0xc0fefe] lt [0x1 0x5 0xc0fefe] // bound_check_ok = 1 (TRUE) // if(bound_check_ok) &#123; goto tag5 &#125; else &#123; invalid &#125; tag_5 [tag_5 0x1 0x5 0xc0fefe] jumpi // 测试情形是对的. 将跳转到 tag_5. // 并且 `jumpi` 消费了栈中 2 个元素. [0x5 0xc0fefe] invalid// 数组访问合法，继续// stack: [0x5 0xc0fefe]tag_5: sstore [] storage: &#123; 0x5 =&gt; 0xc0fefe &#125; 现在可以看到边界检测代码了。编译器能够优化这些东西，但并不完美。 在本文的后面，我们将看到数组边界检测如何干扰编译器的优化，使得定长数组比存储变量或结构的效率低得多。 打包行为存储很贵（啊啊啊我已经说一百万次了）。一个关键的优化是尽可能多地将数据打包到一个 32 字节的单元中。 考虑有四个存储变量（每个 64 比特）的合约，总共可以累加到 256 比特（ 32 字节）： 12345678910111213pragma solidity ^0.4.11;contract C &#123; uint64 a; uint64 b; uint64 c; uint64 d; function C() &#123; a = 0xaaaa; b = 0xbbbb; c = 0xcccc; d = 0xdddd; &#125;&#125; 我们希望编译器只用一个 sstore ，所以将它们放在同一个存储单元中。 编译：1$ solc --bin --asm --optimize c-many-variables--packing.sol 汇编代码：12345678910111213141516171819202122232425262728293031tag_2: /* \"c-many-variables--packing.sol\":121:122 a */ 0x0 /* \"c-many-variables--packing.sol\":121:131 a = 0xaaaa */ dup1 sload /* \"c-many-variables--packing.sol\":125:131 0xaaaa */ 0xaaaa not(0xffffffffffffffff) /* \"c-many-variables--packing.sol\":121:131 a = 0xaaaa */ swap1 swap2 and or not(sub(exp(0x2, 0x80), exp(0x2, 0x40))) /* \"c-many-variables--packing.sol\":139:149 b = 0xbbbb */ and 0xbbbb0000000000000000 or not(sub(exp(0x2, 0xc0), exp(0x2, 0x80))) /* \"c-many-variables--packing.sol\":157:167 c = 0xcccc */ and 0xcccc00000000000000000000000000000000 or sub(exp(0x2, 0xc0), 0x1) /* \"c-many-variables--packing.sol\":175:185 d = 0xdddd */ and 0xdddd000000000000000000000000000000000000000000000000 or swap1 sstore 有很多我无法破译的位交换，但不用在意这些细节。关键要注意的是，只用了一个 sstore。 优化成功！ 打破优化要是优化器可以一直完美工作就好了。让我们打破它。我们唯一的改变是我们使用帮助函数来设置存储变量： 12345678910111213141516171819pragma solidity ^0.4.11;contract C &#123; uint64 a; uint64 b; uint64 c; uint64 d; function C() &#123; setAB(); setCD(); &#125; function setAB() internal &#123; a = 0xaaaa; b = 0xbbbb; &#125; function setCD() internal &#123; c = 0xcccc; d = 0xdddd; &#125;&#125; 编译1$ solc --bin --asm --optimize c-many-variables--packing-helpers.sol 汇编输出太多了。我们将忽略大部分细节并关注结构：1234567891011121314151617181920212223// 构造函数tag_2: // ... // 跳转到 tag_5，调用 setAB() jumptag_4: // ... // 跳转到 tag_7，调用 setCD() jump// 函数 setAB()tag_5: // 位交换，设置 a, b // ... sstoretag_9: jump // 返回 setAB() 的调用者// 函数 setCD()tag_7: // 位交换，设置 c, d // ... sstoretag_10: jump // 返回 setCD() 的调用者 现在有两个 sstore ，而不是一个。 Solidity 编译器可以在标签内进行优化，但不能跨标签进行优化。 调用函数可能会花费更多，而不是太多，不仅因为函数调用很贵（它们只是跳转指令），而且因为 sstore 优化可能会失败。 为了解决这个问题， Solidity 编译器需要学习如何内联函数，使得本质上得到的代码与不调用函数的相同： 1234a = 0xaaaa;b = 0xbbbb;c = 0xcccc;d = 0xdddd; 如果我们仔细阅读完整的汇编输出，我们会看到函数 setAB（）和 setCD（）的汇编代码被包含了两次，使代码臃肿，还花费额外 gas 部署合约。我们稍后在了解合约生命周期时再讨论这一点。 为什么优化器坏了优化器不会跨标签进行优化。考虑 “1 + 1” ，如果在同一标签下，它可以优化为 0x2 ：123456// 优化成功!tag_0: 0x1 0x1 add ... 但会优化失败，如果指令被标签分开了的话：1234567// 优化失败!tag_0: 0x1 0x1tag_1: add ... 这个行为在 0.4.13 版时是真的。以后可能会变。 再次打破优化让我们看看优化失败的另一种方式。打包是否适用于定长数组？考虑：12345678910pragma solidity ^0.4.11;contract C &#123; uint64[4] numbers; function C() &#123; numbers[0] = 0x0; numbers[1] = 0x1111; numbers[2] = 0x2222; numbers[3] = 0x3333; &#125;&#125; 同样，我们希望只用一个 sstore 指令将 4 个 64 比特的数字打包到一个 32 字节的存储单元中。 编译后的汇编代码太长了。作为替代，计算 sstore 和 sload 指令的数量：123456789$ solc --bin --asm --optimize c-static-array--packing.sol | grep -E '(sstore|sload)' sload sstore sload sstore sload sstore sload sstore 嗷！不！！即使这个定长数组的存储布局与等效的结构体或存储变量完全相同，优化也会失败。它现在需要四对 sload 和 sstore 。 快速浏览汇编代码可以发现，每个数组访问都有边界检测代码，并在不同的标签下进行组织。但标签边界打破了优化。 然而有一点小小的安慰的是，3 个额外的 sstore 指令比第一个便宜： sstore 花费 20,000 gas用于第一次写入新位置。 sstore 花费 5,000 gas用于后续写入现有位置。 所以这个特定优化的失败花费我们 35k 而不是 20k ，多了 75％ 。 小结如果 Solidity 编译器能够计算出存储变量的大小，它只须简单地将它们放在一个接一个的存储空间中。如果可能的话，编译器将数据紧密地打包成32字节的块。 总结我们目前为止看到的打包行为： 存储变量：有。 结构字段：有。 定长数组：无。理论上，有。 由于存储访问成本非常高，因此应该将存储变量视为数据库架构。在编写合约时，可能会很有用的是做小型实验，并检查汇编代码以确定编译器是否正在优化。 可以肯定， Solidity 编译器将来会有所改进。不幸的是，现在我们还不能盲目信任它的优化器。 理解存储变量要花钱，字面意思，花钱。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/tags/区块链/"},{"name":"Qtum","slug":"Qtum","permalink":"http://xichen.pub/tags/Qtum/"},{"name":"翻译","slug":"翻译","permalink":"http://xichen.pub/tags/翻译/"}]},{"title":"【翻译】 深入理解以太坊虚拟机 - EVM汇编代码简介","slug":"2018-06-12-翻译-深入理解以太坊虚拟机-EVM汇编代码简介","date":"2018-06-12T06:11:00.000Z","updated":"2019-04-01T15:18:44.223Z","comments":true,"path":"2018/06/12/2018-06-12-翻译-深入理解以太坊虚拟机-EVM汇编代码简介/","link":"","permalink":"http://xichen.pub/2018/06/12/2018-06-12-翻译-深入理解以太坊虚拟机-EVM汇编代码简介/","excerpt":"","text":"原文：https://blog.qtum.org/diving-into-the-ethereum-vm-6e8d5d2f3c30译者：中山大学数学学院（珠海）林学渊大二时给量子做的翻译，转载注明出处，谢谢 EVM汇编代码简介 Solidity 提供了很多高级语言抽象，但这些功能很难让我理解程序运行时到底发生了什么。阅读 Solidity 的文档仍然使我对一些基础的东西感到疑惑。 string, bytes32, byte[], bytes 有什么区别? 什么时候应该用哪个？ 把 string 转为 bytes 发生了什么？转为 byte[] 呢？ 这些需要多少 gas ？ mapping 在以太坊虚拟机里是怎么存的？ 为什么不能把 mapping 删了？ 能构建 maping 到 maping 的数据结构吗？(当然可以，但这是怎么实现的？) 为什么有存储 mapping ，但是没有内存 mapping ? 编译后的合约在以太坊虚拟机里长什么样？ 合约如何创建？ 构造方法是什么？真的吗？ 回退函数是什么？ 我想，学习一门在以太坊虚拟机( EVM )上运行的高级语言如 Solidity 会是一个好的自我投资。有以下原因。 Solidity 不是最后一门语言。更好的 EVM 语言正在到来。(漂亮，对不对？) EVM是个数据库引擎。理解用任意一种 EVM 语言写的智能合约前，必须理解数据是如何被组织、存储和操控的。 了解如何成为一个贡献者。以太坊工具链刚刚起步，深入理解EVM会帮助你给你自己或其他人造出惊艳的工具。 智力挑战。EVM使得你能在密码学、数据结构和程序语言设计的交汇处获得最佳实践。 在本系列文章中，我会解构一些简单的 Solidity 智能合约，以便理解它们作为 EVM 字节码时如何工作。 我希望学习和写作的要点： EVM 字节码的基础 不同数据类型( mapping, array )的表现形式 合约创建时发生了什么 一个方法调用时发生了什么 ABI 桥如何区别了 EVM 语言 我的终极目标是能够完全理解一个编译后的 Solidity 合约。先从一些基础的 EVM 字节码开始阅读吧！ 一个有用的引用：EVM 指令集 一个简单的智能合约我们的第一个合约有构造函数和一个常量：12345678// c1.solpragma solidity ^0.4.11;contract C &#123; uint256 a; function C() &#123; a = 1; &#125;&#125; 用 solc 命令编译： 1234567891011121314151617181920212223242526272829303132333435363738394041424344$ solc --bin --asm c1.sol======= c1.sol:C =======EVM assembly: /* \"c1.sol\":26:94 contract C &#123;... */ mstore(0x40, 0x60) /* \"c1.sol\":59:92 function C() &#123;... */ jumpi(tag_1, iszero(callvalue)) 0x0 dup1 reverttag_1:tag_2: /* \"c1.sol\":84:85 1 */ 0x1 /* \"c1.sol\":80:81 a */ 0x0 /* \"c1.sol\":80:85 a = 1 */ dup2 swap1 sstore pop /* \"c1.sol\":59:92 function C() &#123;... */tag_3: /* \"c1.sol\":26:94 contract C &#123;... */tag_4: dataSize(sub_0) dup1 dataOffset(sub_0) 0x0 codecopy 0x0 returnstopsub_0: assembly &#123; /* \"c1.sol\":26:94 contract C &#123;... */ mstore(0x40, 0x60) tag_1: 0x0 dup1 revertauxdata: 0xa165627a7a72305820af3193f6fd31031a0e0d2de1ad2c27352b1ce081b4f3c92b5650ca4dd542bb770029&#125;Binary:60606040523415600e57600080fd5b5b60016000819055505b5b60368060266000396000f30060606040525b600080fd00a165627a7a72305820af3193f6fd31031a0e0d2de1ad2c27352b1ce081b4f3c92b5650ca4dd542bb770029 数字 6060604052... 是 EVM 真正运行的字节码。 蹒跚学步一半的汇编是模板，以至于在大多数 Solidity 程序中都一样。我们等下再来看这些。现在，我们来实验我们合约独特的一部分，存储变量的声明：1a = 1 这个声明的字节码表示是 6001600081905550 。根据指令换行：12345660 0160 0081905550 EVM 底层循环是从上到下运行每一条指令。我们注释一下汇编代码(以 tag_2 开头)以便阅读：12345678910111213tag_2: // 60 01 0x1 // 60 00 0x0 // 81 dup2 // 90 swap1 // 55 sstore // 50 pop 注意汇编中的 0x1 实际上是 push(0x1) 的缩写。这条指令表示吧数字 1 入栈。 如果只盯着这个看，很难捕获到发生了什么。不要担心，模仿 EVM 一行一行地走，很简单的。 模仿 EVMEVM 是堆栈机器。指令可以使用栈中的值作为参数，也可以把某一些值入栈作为结果。举个例子， add 指令。 假设栈中有 2 个值：1[1, 2] 当 EVM 看到 add 时，它把栈顶的 2 项出栈相加，然后把结果入栈回去，操作后：1[3] 以后我们仍然用 [] 这个符号来表示栈：1234// 空栈stack: []// 有3个元素的栈. 栈顶元素是 3. 栈底元素是 1.stack: [3 2 1] 用 {} 来表示合约存储:1234// 空存储store: &#123;&#125;// 值 0x1 存储在地址 0x0.store: &#123; 0x0 =&gt; 0x1 &#125; 现在我们来看一些实际的字节码。我们将模仿EVM运行字节序列 6001600081905550 ，同时写出每一条指令运行后的机器状态： 123456789101112131415161718192021// 60 01: 将1入栈0x1 stack: [0x1]// 60 00: 将0入栈0x0 stack: [0x0 0x1]// 81: 复制栈中的第二个元素，入栈dup2 stack: [0x1 0x0 0x1]// 90: 交换栈顶2个元素swap1 stack: [0x0 0x1 0x1]// 55: 把值 0x1 存储到地址 0x0// 这条指令使用了栈顶的两个元素sstore stack: [0x1] store: &#123; 0x0 =&gt; 0x1 &#125;// 50: 出栈，即丢掉栈顶一个元素pop stack: [] store: &#123; 0x0 =&gt; 0x1 &#125; 运行完了。栈空了，同时有一个元素存储到了存储器里。 值得注意的是 Solidity 决定把状态变量 uint256 a 存储到地址 0x0 。很可能其他语言会把状态变量存到其他地方。 写出伪代码， EVM 运行 6001600081905550 就像是这样： 12// a = 1sstore(0x0, 0x1) 看仔细一点，会发现 dup2, swap1, pop 是多余的。汇编代码可以更简单： 1230x10x0sstore 你可以试着模拟运行上面的3条指令，肯定会惊喜地发现它们结束时的机器状态是一样的： 12stack: []store: &#123; 0x0 =&gt; 0x1 &#125; 2 个存储变量添加另一个相同数据类型的存储变量： 12345678910// c2.solpragma solidity ^0.4.11;contract C &#123; uint256 a; uint256 b; function C() &#123; a = 1; b = 2; &#125;&#125; 编译，注意 tag_2:123456789101112131415161718192021$ solc --bin --asm c2.sol// ... more stuff omittedtag_2: /* \"c2.sol\":99:100 1 */ 0x1 /* \"c2.sol\":95:96 a */ 0x0 /* \"c2.sol\":95:100 a = 1 */ dup2 swap1 sstore pop /* \"c2.sol\":112:113 2 */ 0x2 /* \"c2.sol\":108:109 b */ 0x1 /* \"c2.sol\":108:113 b = 2 */ dup2 swap1 sstore pop 汇编伪代码： 1234// a = 1sstore(0x0, 0x1)// b = 2sstore(0x1, 0x2) 现在我们知道这两个存储变量是依次存储的，a 存储在地址 0x0，b 存储在地址 0x1。 打包存储每个存储单元能存 32 字节。如果全部使用 32 字节的话，如果一个变量只要 16 字节，那就很浪费了。 Solidity 通过把 2 个短的数据类型打包成 1 个来提高存储效率。 把 a 和 b 改成每个 16 字节： 123456789pragma solidity ^0.4.11;contract C &#123; uint128 a; uint128 b; function C() &#123; a = 1; b = 2; &#125;&#125; 编译合约： 1$ solc --bin --asm c3.sol 生成的汇编代码更复杂了：123456789101112131415161718192021222324252627282930313233343536373839404142434445tag_2: // a = 1 0x1 0x0 dup1 0x100 exp dup2 sload dup2 0xffffffffffffffffffffffffffffffff mul not and swap1 dup4 0xffffffffffffffffffffffffffffffff and mul or swap1 sstore pop // b = 2 0x2 0x0 0x10 0x100 exp dup2 sload dup2 0xffffffffffffffffffffffffffffffff mul not and swap1 dup4 0xffffffffffffffffffffffffffffffff and mul or swap1 sstore pop 上面的汇编代码把 2 个变量打包到1个存储地址( 0x0 )，像这样： 12[ b ][ a ][16 bytes / 128 bits][16 bytes / 128 bits] 打包的原因是目前最贵的操作就是存储空间的使用： sstore 花费 20,000 gas 来第一次写入一个新地址 sstore 花费 5,000 gas 来随后写入一个已存在的地址 sload 花费 500 gas 大多数指令只花费 3~10 gas 通过使用相同的地址， Solidity 为第二个变量存储只支付 5,000 而不是 20,000，省了 15,000 gas。 更多优化不分别同 2 个 sstore 指令来保存 a 和 b ，而把2个128比特的数字打包到内存里再使用1个 sstore ，从而节省 5,000 gas。 你可以通过 optimize 标志来让Solidity做这个操作： 1$ solc --bin --asm --optimize c3.sol 这个方式生成的汇编代码只使用1个 sload 和1个 sstore :1234567891011121314151617181920212223tag_2: /* \"c3.sol\":95:96 a */ 0x0 /* \"c3.sol\":95:100 a = 1 */ dup1 sload /* \"c3.sol\":108:113 b = 2 */ 0x200000000000000000000000000000000 not(sub(exp(0x2, 0x80), 0x1)) /* \"c3.sol\":95:100 a = 1 */ swap1 swap2 and /* \"c3.sol\":99:100 1 */ 0x1 /* \"c3.sol\":95:100 a = 1 */ or sub(exp(0x2, 0x80), 0x1) /* \"c3.sol\":108:113 b = 2 */ and or swap1 sstore 字节码是1600080547002000000000000000000000000000000006001608060020a03199091166001176001608060020a0316179055 格式化字节码成一行一条指令的形式：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// push 0x060 00// dup180// sload54// push17 作为 32 字节的数字，把接下来的 17 字节入栈70 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00/* not(sub(exp(0x2, 0x80), 0x1)) */// push 0x160 01// push 0x80 (32)60 80// push 0x80 (2)60 02// exp0a// sub03// not19// swap190// swap291// and16// push 0x160 01// or17/* sub(exp(0x2, 0x80), 0x1) */// push 0x160 01// push 0x8060 80// push 0x0260 02// exp0a// sub03// and16// or17// swap190// sstore55 在汇编代码里有4个魔法变量： 0x1 (16 字节), 使用低 16 位字节 123// 字节码表示 0x0116:32 0x0000000000000000000000000000000000:16 0x00000000000000000000000000000001 0x2 (16 字节), 使用高 16 位字节 123//字节码表示 0x20000000000000000000000000000000016:32 0x0000000000000000000000000000000200:16 0x00000000000000000000000000000000 not(sub(exp(0x2, 0x80), 0x1)) 123// 高 16 字节的二进制掩码16:32 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00:16 0x00000000000000000000000000000000 sub(exp(0x2, 0x80), 0x1) 123// 低 16 字节的二进制掩码16:32 0x00000000000000000000000000000000 00:16 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF 代码对这些值做了位交换以获得需要的结果：1216:32 0x00000000000000000000000000000002 00:16 0x00000000000000000000000000000001 最后，这个 32 字节的值存储在地址 0x0。 gas 的使用 600080547002000000000000000000000000000000006001608060020a03199091166001176001608060020a0316179055 注意 0x200000000000000000000000000000000 嵌在字节码里了。但编译器也可能选择用指令 exp(0x2, 0x81) 计算值，这将生成更短的字节码序列。 结果好像是 0x200000000000000000000000000000000 比 exp(0x2, 0x81) 更便宜。我们看一下分别需要花费的 gas： 4 gas 花在一笔交易中的每一个为 0 的数据或代码 68 gas 花在一笔交易中的每一个非 0 的数据或代码 比较一下总的gas花费： 字节码 0x200000000000000000000000000000000. 它有很多 0 ，更便宜(1 68) + (16 4) = 196. 字节码 608160020a. 更短，但没有0.5 * 68 = 340. 更长但有更多 0 的序列实际上更便宜！ 总结EVM 编译器实际上没有优化字节码大小或速度抑或内存效率。取而代之的是，它优化了 gas 的使用，这是一个间接的层面，可以激励以太坊区块链进行高效计算。 我们已经看到了 EVM 一些诡异的方面： EVM 是 256 比特机器。以 32 字节为块来操作数据最自然。 持久化存储很贵。 Solidity 编译器为了最小化 gas 的使用采取了有趣的做法。 gas 成本的设定是任意的，以后可能会变。随着成本的变化，编译器会做出不同的选择。 在本系列文章中，关于 EVM 我会写： EVM 汇编代码的介绍 定长数据类型如何表示 动态数据类型如何表示 ABI编码的外部函数如何调用 一个新合约创建时发生了什么","categories":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/tags/区块链/"},{"name":"Qtum","slug":"Qtum","permalink":"http://xichen.pub/tags/Qtum/"},{"name":"翻译","slug":"翻译","permalink":"http://xichen.pub/tags/翻译/"}]},{"title":"【翻译】 QtumJS 文档","slug":"2018-06-06-翻译-QtumJS文档","date":"2018-06-06T06:11:00.000Z","updated":"2019-04-01T15:18:44.222Z","comments":true,"path":"2018/06/06/2018-06-06-翻译-QtumJS文档/","link":"","permalink":"http://xichen.pub/2018/06/06/2018-06-06-翻译-QtumJS文档/","excerpt":"","text":"原文：https://github.com/qtumproject/qtumjs-doc译者：中山大学数学学院（珠海）林学渊大二时给量子做的翻译，转载注明出处，谢谢 介绍 安装 qtumjs 1npm install qtumjs QtumJS是一个用于在Qtum区块链上开发DApp的JavaScript库。您可以使用此库来开发在浏览器中运行的前端UI以及在NodeJS中运行的后端脚本。 主要的类：类 | 描述——— | ———–QtumRPCRaw | 使用 JSONRPC 1.0调用合约，直接访问 qtumd 的区块链 RPC 服务。QtumRPC | QtumRPCRaw 的封装，提供像 JSONRPC 2.0 这样的接口。Contract | 与智能合约交互的抽象层。使用 ABI encoding/decoding. QtumJS 使用 TypeScript 开发, 因此为所有 API 提供了健壮的类型定义。 我们建议使用 VSCode 来获得语言支持，例如类型提示和自动完成。 当然，你愿意的话也可以选择使用普通的 JavaScript 和记事本。 本文档是 QtumJS API 及其基本用法的参考文档。有关 QtumJS 的教程式介绍，查看: QtumBook - ERC20 With QtumJS. 运行 Qtum RPC 开发模式运行 qtumd： 12345docker run -it --rm \\ --name myapp \\ -v `pwd`:/dapp \\ -p 3889:3889 \\ hayeah/qtumportal 测试网络（testnet）运行 qtumd： 123456docker run -it --rm \\ --name myapp \\ -e \"QTUM_NETWORK=testnet\" \\ -v `pwd`:/dapp \\ -p 3889:3889 \\ hayeah/qtumportal QtumJS 依赖 qtumd 提供的访问 QTUM 区块链的 JSON-RPC 服务。 更多细节请查看: QtumBook - Running QTUM. 默认 JSON-RPC 是 “qtum：test”，运行端口为 3889 ERC20 实例1234567891011121314151617181920import &#123; Qtum,&#125; from \"qtumjs\"const repoData = require(\"./solar.json\")const qtum = new Qtum(\"http://qtum:test@localhost:3889\", repoData)const myToken = qtum.contract(\"zeppelin-solidity/contracts/token/CappedToken.sol\")async function transfer(fromAddr, toAddr, amount) &#123; const tx = await myToken.send(\"transfer\", [toAddr, amount], &#123; senderAddress: fromAddr, &#125;) console.log(\"transfer tx:\", tx.txid) console.log(tx) await tx.confirm(3) console.log(\"transfer confirmed\")&#125; 假设 solar.json 包含已部署的合约，则可以使用 qtumjs 调用代币合约的方法来流通代币。 一个实例 solar.json. 这个可以使用 solar 部署工具自动生成。 完整实例: qtumproject/qtumbook-mytoken-qtumjs-cli 合约开发, 查看 Solar Smart Contract Deployment Tool. 为了充实教程, 查看 QtumBook - ERC20 With QtumJS. Qtum12const repoData = require(\"./solar.json\")const qtum = new Qtum(\"http://qtum:test@localhost:3889\", repoData) Qtum 是 qtumjs API 的一个对象. 它提供两个主要功能： 对 qtumd RPC 服务的访问. 它是 QtumRPC 的子类. 实例化 Contract 对象的工厂方法, 用于与已部署的合约进行交互。 参数 类型 url string qtumd RPC 服务的 URL repoData IContractsRepoData 关于 Solidity 合约的信息. repoData 包含所有已部署合约或库的 ABI 定义，以及它们的部署地址。这些信息用于实例化 Contract 实例。 使用 Qtum 的工厂方法实例化的 Contract 对象能够解码所有在 repoData 里的事件类型. 但是手动构建的合约只能解码在其范围内定义的事件类型, 这也是 Solidity 编译器输出 ABI 定义的限制。 建议使用 Qtum 来实例化 Contract 对象. contract1const myToken = qtum.contract(\"zeppelin-solidity/contracts/token/CappedToken.sol\") 实例化这个合约使用了 这些 信息。 实例化 Contract 对象的工厂方法，使用了 repoData 中的 ABI 定义和地址。合约对象是使用一个事件 log 解码器来配置的，这个解码器能解码所有 repoData 中已知的事件类型。 参数 类型 name string 作为 repoData.contracts map 的 key，用于获取合约信息。 rawCall继承自 QtumRPC#rawcall Contract与智能合约交互的抽象层。 这比使用 QtumRPC 直接调用 RPC 的 sendcontract 和 calltocontract 方法更方便。它处理 ABI 编码，转换 JS 和 Solidity 值。 有 API 用于确认交易。 有 API 用于调用合约方法，使用 call 或 send . 有 API 用于获取合约 log 事件。 构造函数12345const rpc = new QtumRPC(\"http://qtum:test@localhost:3889\")const myToken = new Contract(rpc, repo.contracts[ \"zeppelin-solidity/contracts/token/CappedToken.sol\"]) 合约 信息 可以使用 solar. 生成 参数 类型 描述 rpc QtumRPC RPC 对象，用于与合约进行交互 info IContractInfo 信息，用于部署合约 建议使用 Qtum#contract 而不是这个构造器。 call12345678async function totalSupply() &#123; const result = await myToken.call(\"totalSupply\") // supply is a BigNumber instance (see: bn.js) const supply = result.outputs[0] console.log(\"supply\", supply.toNumber())&#125; 实例输出: 1234567891011121314151617&#123; address: 'a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3', executionResult: &#123; gasUsed: 21689, excepted: 'None', newAddress: 'a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3', output: '00000000000000000000000000000000000000000000000000000000000036b0', codeDeposit: 0, gasRefunded: 0, depositSize: 0, gasForDeposit: 0 &#125;, transactionReceipt: &#123; stateRoot: '5a0d9cd5df18165c75755f4345ca81da94f9247c1c031171fd6e2ce1a368844c', gasUsed: 21689, bloom: '00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000', log: [] &#125;, outputs: [ &lt;BN: 36b0&gt; ] &#125; 模拟 “mint” 调用: 1const result = await myToken.call(\"mint\", [\"dcd32b87270aeb980333213da2549c9907e09e94\", 1000]) 运行结果: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&#123; \"address\": \"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3\", \"executionResult\": &#123; \"gasUsed\": 39306, \"excepted\": \"None\", \"newAddress\": \"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3\", \"output\": \"0000000000000000000000000000000000000000000000000000000000000001\", \"codeDeposit\": 0, \"gasRefunded\": 0, \"depositSize\": 0, \"gasForDeposit\": 0 &#125;, \"transactionReceipt\": &#123; \"stateRoot\": \"9922edb770bd700a212427d3bc0764a9fed953a987952b2619b8a78dac7498aa\", \"gasUsed\": 39306, \"bloom\": \"00000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000020000000000008000000000000000000000000000000000000000000000000020000000020000000000800000000000000400000000010000000000000000000000000000000000000000000000000000000000000000000000000000080000000080000000000000000000000000000000000000000000000000000000002010000000000000000000000000000000200000000000000000020000000000000000000000000000000000000000000000000020000000000000000\", \"log\": [ &#123; \"address\": \"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3\", \"topics\": [ \"0f6798a560793a54c3bcfe86a93cde1e73087d944c0ea20544137d4121396885\", \"000000000000000000000000dcd32b87270aeb980333213da2549c9907e09e94\" ], \"data\": \"00000000000000000000000000000000000000000000000000000000000003e8\" &#125;, &#123; \"address\": \"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3\", \"topics\": [ \"ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\", \"0000000000000000000000000000000000000000000000000000000000000000\", \"000000000000000000000000dcd32b87270aeb980333213da2549c9907e09e94\" ], \"data\": \"00000000000000000000000000000000000000000000000000000000000003e8\" &#125; ] &#125;, \"outputs\": [ true ], \"logs\": [ &#123; \"type\": \"Mint\", \"to\": \"dcd32b87270aeb980333213da2549c9907e09e94\", \"amount\": \"3e8\" &#125;, &#123; \"type\": \"Transfer\", \"from\": \"0000000000000000000000000000000000000000\", \"to\": \"dcd32b87270aeb980333213da2549c9907e09e94\", \"value\": \"3e8\" &#125; ]&#125; 使用 callcontract 在你本地 qtumd 节点 “模拟” 执行合约方法。这是免费的，实际上并不修改区块链。 这个免费。 参数 类型 method string 合约方法名 args Array\\ 调用方法的参数 opts IContractCallRequestOptions 调用配置项 @return Promise\\&lt;IContractCallResult&gt; 调用结果，带有 ABI 解码的输出 send123456789101112131415async function mint(toAddr, amount) &#123; // Submit a `sendtocontract` transaction, invoking the `mint` method. const tx = await myToken.send(\"mint\", [toAddr, amount]) console.log(\"tx:\", tx) // Wait for 3 confirmations. The callback receives the // updated transaction info for each additional confirmation. // // Both arguments are optional. `await tx.confirm()` would do. const receipt = await tx.confirm(3, (updatedTx) =&gt; &#123; console.log(\"new confirmation\", updatedTx.txid, updatedTx.confirmations) &#125;) console.log(\"tx receipt:\", JSON.stringify(receipt, null, 2))&#125; 实例输出: 123456789101112131415161718192021mint tx: 858347704258506012f538b19b9702d636dc350bc25a7e60d404bf3d2c08efd9&#123; amount: 0, fee: -0.081064, confirmations: 0, trusted: true, txid: '858347704258506012f538b19b9702d636dc350bc25a7e60d404bf3d2c08efd9', walletconflicts: [], time: 1515475961, timereceived: 1515475961, 'bip125-replaceable': 'no', details: [ &#123; account: '', category: 'send', amount: 0, vout: 0, fee: -0.081064, abandoned: false &#125; ], hex: '0200000001006a977de70014fdc2546ed19a531326086c6c9631cb1c5352db5f09e147736b0100000049483045022100b4ca32770a9f42679c6d20b7ddb5feb160303fceafc2db0fedba18a22f0b643602203c2568eb689fd324e76a12f367552fe4cce36b29f8174738209f881959aadbab01feffffff02000000000000000063010403400d0301284440c10f19000000000000000000000000dcd32b87270aeb980333213da2549c9907e09e9400000000000000000000000000000000000000000000000000000000000003e814a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3c2601e72902e0000001976a914dcd32b87270aeb980333213da2549c9907e09e9488ac212e0000', method: 'mint', confirm: [Function: confirm] &#125; 回调打印 3 次，分别对应每次确认 123new confirmation 858347704258506012f538b19b9702d636dc350bc25a7e60d404bf3d2c08efd9 1new confirmation 858347704258506012f538b19b9702d636dc350bc25a7e60d404bf3d2c08efd9 2new confirmation 858347704258506012f538b19b9702d636dc350bc25a7e60d404bf3d2c08efd9 3 确认后返回的交易收据： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&#123; \"blockHash\": \"3b53ad132c26f9c30e5be9f664573428dad8b52e167becea4428d6903cb32740\", \"blockNumber\": 13917, \"transactionHash\": \"79338589bb75e1865be889142890a4e25d3b9dbd454ce3f3c2614587c85e2ed3\", \"transactionIndex\": 1, \"from\": \"dcd32b87270aeb980333213da2549c9907e09e94\", \"to\": \"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3\", \"cumulativeGasUsed\": 39306, \"gasUsed\": 39306, \"contractAddress\": \"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3\", \"logs\": [ &#123; \"type\": \"Mint\", \"to\": \"dcd32b87270aeb980333213da2549c9907e09e94\", \"amount\": \"7d0\" &#125;, &#123; \"type\": \"Transfer\", \"from\": \"0000000000000000000000000000000000000000\", \"to\": \"dcd32b87270aeb980333213da2549c9907e09e94\", \"value\": \"7d0\" &#125; ], \"rawlogs\": [ &#123; \"address\": \"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3\", \"topics\": [ \"0f6798a560793a54c3bcfe86a93cde1e73087d944c0ea20544137d4121396885\", \"000000000000000000000000dcd32b87270aeb980333213da2549c9907e09e94\" ], \"data\": \"00000000000000000000000000000000000000000000000000000000000007d0\" &#125;, &#123; \"address\": \"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3\", \"topics\": [ \"ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\", \"0000000000000000000000000000000000000000000000000000000000000000\", \"000000000000000000000000dcd32b87270aeb980333213da2549c9907e09e94\" ], \"data\": \"00000000000000000000000000000000000000000000000000000000000007d0\" &#125; ]&#125; 创建一个交易，在网络全局执行合约方法，会改变区块链。 这要花费 gas. 对一个合约有 2 个异步步骤 你提交交易到网络 一旦提交，等待一个指定的确认数 成功确认后，返回带有ABI解码的事件日志的交易收据 (IContractSendReceipt) 参数 类型 method string 合约方法名 args Array\\ 所调用方法的参数 opts IContractSendRequestOptions 可选 发送配置项 @return Promise\\&lt;IContractSendResult&gt; 调用结果, 带有 ABI 解码的输出 方法重载如果没有歧义，使用方法名称来调用/发送方法。 如果相同方法名称具有多个定义，请使用方法签名来调用/发送方法。 方法名 foo 可能有多个定义: 1234function foo();function foo(int256 _a);function foo(uint256 _a, uint256 _b);function foo(int256 _a, int256 _b); foo 方法有 0 个参数和有 1 个参数没有歧义。可以直接调用。 12contract.call(\"foo\")contract.call(\"foo\", [1]) foo 方法带 2 个参数的有歧义，必须带完整方法签名： 12contract.call(\"foo(uint256,uint256)\", [1, 2])contract.call(\"foo(int256,int256)\", [1, 2]) logs123456789async function getLogs(fromBlock=0, toBlock=\"latest\") &#123; const logs = await myToken.logs(&#123; fromBlock, toBlock, minconf: 1, &#125;) console.log(JSON.stringify(logs, null, 2))&#125; 实例输出 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&#123; \"entries\": [ &#123; \"blockHash\": \"369c6ded05c27ae7efc97964cce083b0ea9b8b950e67c51e52cb1bf898b9c415\", \"blockNumber\": 12184, \"transactionHash\": \"d1638a53f38fd68c5763e2eef9d86b9fc6ee7ea3f018dae7b1e385b4a9a78bc7\", \"transactionIndex\": 2, \"from\": \"dcd32b87270aeb980333213da2549c9907e09e94\", \"to\": \"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3\", \"cumulativeGasUsed\": 39306, \"gasUsed\": 39306, \"contractAddress\": \"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3\", \"topics\": [ \"0f6798a560793a54c3bcfe86a93cde1e73087d944c0ea20544137d4121396885\", \"000000000000000000000000dcd32b87270aeb980333213da2549c9907e09e94\" ], \"data\": \"00000000000000000000000000000000000000000000000000000000000003e8\", \"event\": &#123; \"type\": \"Mint\", \"to\": \"dcd32b87270aeb980333213da2549c9907e09e94\", \"amount\": \"3e8\" &#125; &#125;, &#123; \"blockHash\": \"369c6ded05c27ae7efc97964cce083b0ea9b8b950e67c51e52cb1bf898b9c415\", \"blockNumber\": 12184, \"transactionHash\": \"d1638a53f38fd68c5763e2eef9d86b9fc6ee7ea3f018dae7b1e385b4a9a78bc7\", \"transactionIndex\": 2, \"from\": \"dcd32b87270aeb980333213da2549c9907e09e94\", \"to\": \"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3\", \"cumulativeGasUsed\": 39306, \"gasUsed\": 39306, \"contractAddress\": \"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3\", \"topics\": [ \"ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\", \"0000000000000000000000000000000000000000000000000000000000000000\", \"000000000000000000000000dcd32b87270aeb980333213da2549c9907e09e94\" ], \"data\": \"00000000000000000000000000000000000000000000000000000000000003e8\", \"event\": &#123; \"type\": \"Transfer\", \"from\": \"0000000000000000000000000000000000000000\", \"to\": \"dcd32b87270aeb980333213da2549c9907e09e94\", \"value\": \"3e8\" &#125; &#125; ], \"count\": 2, \"nextblock\": 12185&#125; 获取由合约生成的 Solidity 事件日志 。 通过指定 fromBlock 和 toBlock，可以将事件日志查询限制块号范围。 例如，可以查询块 1000 到 1500 之间的事件日志。 此外，你可以使用 minconf 指定事件日志之前确认的最小数量作为结果返回。 参数 类型 opts IRPCWaitForLogsRequest 事件日志查询参数 @return Promise\\&lt;IContractEventLogs&gt; 日志查询结果，带有 ABI 解码的输出 onLogs123myToken.onLog((entry) =&gt; &#123; console.log(entry)&#125;, &#123; minconf: 1 &#125;) 订阅合约新事件。每次收到新事件时都会调用回调。默认情况下，onLog 监听来自区块链顶端的日志。 使用 fromBlock 也可以接收较早的事件。 参数 类型 callback (entry: IContractEventLog) =&gt; void opts IRPCWaitForLogsRequest 事件日志查询参数 logEmitter12345678910111213this.emitter = myToken.logEmitter(&#123; minconf: 1 &#125;)this.emitter.on(\"Mint\", (event) =&gt; &#123; // ...&#125;)this.emitter.on(\"Transfer\", (event) =&gt; &#123; // ...&#125;)this.emitter.on(\"?\", (event) =&gt; &#123; // all un-decodeable events&#125;) 使用 EventsEmitter 接口订阅合约新事件。发出的事件是 IContractEventLog 对象。 Solidity 事件名作为发出的事件名使用。 缺失 ABI 定义的事件 (即不能解析) 会发送 “?”. 参数 类型 opts IRPCWaitForLogsRequest 事件日志查询参数 receipt123const txid = \"62fecfd27d71ddb260ac48c73c8f0f87e96d0b3a598ed2c2251caa4e6f9a9d97\"const receipt = await qrcToken.receipt(txid)console.log(JSON.stringify(receipt, null, 2)) 实例输出 123456789101112131415161718192021222324252627282930&#123; \"blockHash\": \"af37cb8d9905521542243005fadc9f18c1498c9823e35fa277ea1c37174c289a\", \"blockNumber\": 83981, \"transactionHash\": \"62fecfd27d71ddb260ac48c73c8f0f87e96d0b3a598ed2c2251caa4e6f9a9d97\", \"transactionIndex\": 28, \"from\": \"57142e3bcf000f28890b5d979afc7ea90204e1de\", \"to\": \"49665919e437a4bedb92faa45ed33ebb5a33ee63\", \"cumulativeGasUsed\": 37029, \"gasUsed\": 37029, \"contractAddress\": \"49665919e437a4bedb92faa45ed33ebb5a33ee63\", \"logs\": [ &#123; \"type\": \"Transfer\", \"from\": \"57142e3bcf000f28890b5d979afc7ea90204e1de\", \"to\": \"c0ed80283c53c300c31c2bda6eca841e53cb6a21\", \"value\": \"1ba5add5700\" &#125; ], \"rawlogs\": [ &#123; \"address\": \"49665919e437a4bedb92faa45ed33ebb5a33ee63\", \"topics\": [ \"ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\", \"00000000000000000000000057142e3bcf000f28890b5d979afc7ea90204e1de\", \"000000000000000000000000c0ed80283c53c300c31c2bda6eca841e53cb6a21\" ], \"data\": \"000000000000000000000000000000000000000000000000000001ba5add5700\" &#125; ]&#125; 获取已被网络接受的交易收据。 如果交易尚未确认，则返回空值。 交易事件日志是 ABI 编码 参数 类型 txid string 交易 ID @return Promise\\&lt;IContractSendReceipt&gt; 交易收据, 带有事件日志. QtumRPC1const rpc = new QtumRPC('http://qtum:test@localhost:3889'); 这是一个用于直接访问 qtumd RPC API 的 JSON-RPC 客户端。它不会为你处理任何 ABI 编码或解码。 有需要的话你可以把 RPC 用户名和密码包含到 URL 里。在例子中，用户名是 qtum ，密码是 test. QtumRPC类有一些在合约抽象内部使用的未公开的方法。 考虑将来可能会发生变化的任何未经证实的不受支持的内容。 现在，rawCall是唯一的公共API。注意: QtumRPC 类有一些没文档的 public 方法在 Contract 抽象层内部使用到了. 你要考虑到之后可能不支持的无文档的内容. 现在 rawCall 是唯一发布的 API. 参数 类型 url string qtumd RPC 服务的 URL rawCall 调用 getinfo RPC 方法以获取 Qutm 区块链的基本信息： 12const info = await rpc.rawCall(\"getinfo\")console.log(info) getinfo 的输出: 12345678910111213141516171819&#123; version: 141300, protocolversion: 70016, walletversion: 130000, balance: 0, stake: 0, blocks: 85685, timeoffset: 0, connections: 8, proxy: '', difficulty: &#123; 'proof-of-work': 0.0000152587890625, 'proof-of-stake': 5207642.8878753 &#125;, testnet: false, moneysupply: 100322740, keypoololdest: 1513325658, keypoolsize: 100, paytxfee: 0, relayfee: 0.004, errors: '' &#125; 发起一个 JSON-RPC 1.0 方法调用, 返回调用结果. 如果 JSON API 返回不是 200 HTTP 结果，则抛出错误。 使用 try...catch 处理错误: 1234567async function main() &#123; try &#123; const result = await rpc.rawCall(\"unknown-method-hohoho\") &#125; catch (err) &#123; console.log(\"err\", err) &#125;&#125; All RPC 方法qtumd 支持的所有 RPC 方法 . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131== Blockchain ==callcontract \"address\" \"data\" ( address )getaccountinfo \"address\"getbestblockhashgetblock \"blockhash\" ( verbose )getblockchaininfogetblockcountgetblockhash heightgetblockheader \"hash\" ( verbose )getchaintipsgetdifficultygetmempoolancestors txid (verbose)getmempooldescendants txid (verbose)getmempoolentry txidgetmempoolinfogetrawmempool ( verbose )getstorage \"address\"gettransactionreceipt \"hash\"gettxout \"txid\" n ( include_mempool )gettxoutproof [\"txid\",...] ( blockhash )gettxoutsetinfolistcontracts (start maxDisplay)preciousblock \"blockhash\"pruneblockchainsearchlogs &lt;fromBlock&gt; &lt;toBlock&gt; (address) (topics)verifychain ( checklevel nblocks )verifytxoutproof \"proof\"waitforlogs (fromBlock) (toBlock) (filter) (minconf)== Control ==getinfogetmemoryinfohelp ( \"command\" )stop== Generating ==generate nblocks ( maxtries )generatetoaddress nblocks address (maxtries)== Mining ==getblocktemplate ( TemplateRequest )getmininginfogetnetworkhashps ( nblocks height )getstakinginfogetsubsidy [nTarget]prioritisetransaction &lt;txid&gt; &lt;priority delta&gt; &lt;fee delta&gt;submitblock \"hexdata\" ( \"jsonparametersobject\" )== Network ==addnode \"node\" \"add|remove|onetry\"clearbanneddisconnectnode \"node\"getaddednodeinfo ( \"node\" )getconnectioncountgetnettotalsgetnetworkinfogetpeerinfolistbannedpingsetban \"subnet\" \"add|remove\" (bantime) (absolute)setnetworkactive true|false== Rawtransactions ==createrawtransaction [&#123;\"txid\":\"id\",\"vout\":n&#125;,...] &#123;\"address\":amount,\"data\":\"hex\",...&#125; ( locktime )decoderawtransaction \"hexstring\"decodescript \"hexstring\"fromhexaddress \"hexaddress\"fundrawtransaction \"hexstring\" ( options )gethexaddress \"address\"getrawtransaction \"txid\" ( verbose )sendrawtransaction \"hexstring\" ( allowhighfees )signrawtransaction \"hexstring\" ( [&#123;\"txid\":\"id\",\"vout\":n,\"scriptPubKey\":\"hex\",\"redeemScript\":\"hex\"&#125;,...] [\"privatekey1\",...] sighashtype )== Util ==createmultisig nrequired [\"key\",...]estimatefee nblocksestimatepriority nblocksestimatesmartfee nblocksestimatesmartpriority nblockssignmessagewithprivkey \"privkey\" \"message\"validateaddress \"address\"verifymessage \"address\" \"signature\" \"message\"== Wallet ==abandontransaction \"txid\"addmultisigaddress nrequired [\"key\",...] ( \"account\" )addwitnessaddress \"address\"backupwallet \"destination\"bumpfee \"txid\" ( options )createcontract \"bytecode\" (gaslimit gasprice \"senderaddress\" broadcast)dumpprivkey \"address\"dumpwallet \"filename\"encryptwallet \"passphrase\"getaccount \"address\"getaccountaddress \"account\"getaddressesbyaccount \"account\"getbalance ( \"account\" minconf include_watchonly )getnewaddress ( \"account\" )getrawchangeaddressgetreceivedbyaccount \"account\" ( minconf )getreceivedbyaddress \"address\" ( minconf )gettransaction \"txid\" ( include_watchonly ) (waitconf)getunconfirmedbalancegetwalletinfoimportaddress \"address\" ( \"label\" rescan p2sh )importmulti \"requests\" \"options\"importprivkey \"qtum\" ( \"label\" ) ( rescan )importprunedfundsimportpubkey \"pubkey\" ( \"label\" rescan )importwallet \"filename\"keypoolrefill ( newsize )listaccounts ( minconf include_watchonly)listaddressgroupingslistlockunspentlistreceivedbyaccount ( minconf include_empty include_watchonly)listreceivedbyaddress ( minconf include_empty include_watchonly)listsinceblock ( \"blockhash\" target_confirmations include_watchonly)listtransactions ( \"account\" count skip include_watchonly)listunspent ( minconf maxconf [\"addresses\",...] [include_unsafe] )lockunspent unlock ([&#123;\"txid\":\"txid\",\"vout\":n&#125;,...])move \"fromaccount\" \"toaccount\" amount ( minconf \"comment\" )removeprunedfunds \"txid\"reservebalance [&lt;reserve&gt; [amount]]sendfrom \"fromaccount\" \"toaddress\" amount ( minconf \"comment\" \"comment_to\" )sendmany \"fromaccount\" &#123;\"address\":amount,...&#125; ( minconf \"comment\" [\"address\",...] )sendmanywithdupes \"fromaccount\" &#123;\"address\":amount,...&#125; ( minconf \"comment\" [\"address\",...] )sendtoaddress \"address\" amount ( \"comment\" \"comment_to\" subtractfeefromamount )sendtocontract \"contractaddress\" \"data\" (amount gaslimit gasprice senderaddress broadcast)setaccount \"address\" \"account\"settxfee amountsignmessage \"address\" \"message\" 实例: getblockcount返回最长的区块链的块数。 1const result = await rpc.rawCall(\"getblockcount\") 结果 185687 实例: getnewaddress返回接收付款的新 Qtum 地址。可能对要为用户生成存款地址的交易所有用。 1const result = await rpc.rawCall(\"getnewaddress\") 结果 1QSnrDTj4UNcRwKdhY8sUZEd74VzwqeAddW 实例: fromhexaddress把一个 base58 pubkeyhash 地址转化成 16 进制地址用于智能合约。 1const result = await rpc.rawCall(\"gethexaddress\", [\"QSnrDTj4UNcRwKdhY8sUZEd74VzwqeAddW\"]) 结果 143debdac95a0eaa4ff92d6b873944a4d92beae59 实例: gettransactionreceipt获得确认交易的收据。 12const txid = \"62fecfd27d71ddb260ac48c73c8f0f87e96d0b3a598ed2c2251caa4e6f9a9d97\"const result = await rpc.rawCall(\"gettransactionreceipt\", [txid]) 结果 123456789101112131415161718192021222324[ &#123; \"blockHash\": \"af37cb8d9905521542243005fadc9f18c1498c9823e35fa277ea1c37174c289a\", \"blockNumber\": 83981, \"transactionHash\": \"62fecfd27d71ddb260ac48c73c8f0f87e96d0b3a598ed2c2251caa4e6f9a9d97\", \"transactionIndex\": 28, \"from\": \"57142e3bcf000f28890b5d979afc7ea90204e1de\", \"to\": \"49665919e437a4bedb92faa45ed33ebb5a33ee63\", \"cumulativeGasUsed\": 37029, \"gasUsed\": 37029, \"contractAddress\": \"49665919e437a4bedb92faa45ed33ebb5a33ee63\", \"log\": [ &#123; \"address\": \"49665919e437a4bedb92faa45ed33ebb5a33ee63\", \"topics\": [ \"ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\", \"00000000000000000000000057142e3bcf000f28890b5d979afc7ea90204e1de\", \"000000000000000000000000c0ed80283c53c300c31c2bda6eca841e53cb6a21\" ], \"data\": \"000000000000000000000000000000000000000000000000000001ba5add5700\" &#125; ] &#125;] 类型词典IContractInfo12345678910111213141516export interface IContractInfo &#123; /** * 合约的 ABI 定义, solc 生成. */ abi: IABIMethod[] /** * 合约地址 */ address: string /** * 合约所有者的地址 */ sender?: string&#125; 与部署合约交互所需的最少部署信息。 IContractCallResult调用一个合约方法的返回结果，带有解码的输出和日志。 123456789101112131415161718192021222324252627282930313233export interface IContractCallResult extends IRPCCallContractResult &#123; /** * ABI 解码的输出 */ outputs: any[] /** * ABI 解码的日志 */ logs: Array&lt;IDecodedSolidityEvent | null&gt;&#125;export interface IRPCCallContractResult &#123; address: string executionResult: IExecutionResult, transactionReceipt: &#123; stateRoot: string, gasUsed: string, bloom: string, log: any[], &#125;&#125;export interface IExecutionResult &#123; gasUsed: number, excepted: string, newAddress: string, output: string, codeDeposit: number, gasRefunded: number, depositSize: number, gasForDeposit: number,&#125; 实例: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&#123; \"address\": \"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3\", \"executionResult\": &#123; \"gasUsed\": 39306, \"excepted\": \"None\", \"newAddress\": \"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3\", \"output\": \"0000000000000000000000000000000000000000000000000000000000000001\", \"codeDeposit\": 0, \"gasRefunded\": 0, \"depositSize\": 0, \"gasForDeposit\": 0 &#125;, \"transactionReceipt\": &#123; \"stateRoot\": \"9922edb770bd700a212427d3bc0764a9fed953a987952b2619b8a78dac7498aa\", \"gasUsed\": 39306, \"bloom\": \"00000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000020000000000008000000000000000000000000000000000000000000000000020000000020000000000800000000000000400000000010000000000000000000000000000000000000000000000000000000000000000000000000000080000000080000000000000000000000000000000000000000000000000000000002010000000000000000000000000000000200000000000000000020000000000000000000000000000000000000000000000000020000000000000000\", \"log\": [ &#123; \"address\": \"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3\", \"topics\": [ \"0f6798a560793a54c3bcfe86a93cde1e73087d944c0ea20544137d4121396885\", \"000000000000000000000000dcd32b87270aeb980333213da2549c9907e09e94\" ], \"data\": \"00000000000000000000000000000000000000000000000000000000000003e8\" &#125;, &#123; \"address\": \"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3\", \"topics\": [ \"ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\", \"0000000000000000000000000000000000000000000000000000000000000000\", \"000000000000000000000000dcd32b87270aeb980333213da2549c9907e09e94\" ], \"data\": \"00000000000000000000000000000000000000000000000000000000000003e8\" &#125; ] &#125;, \"outputs\": [ true ], \"logs\": [ &#123; \"type\": \"Mint\", \"to\": \"dcd32b87270aeb980333213da2549c9907e09e94\", \"amount\": \"3e8\" &#125;, &#123; \"type\": \"Transfer\", \"from\": \"0000000000000000000000000000000000000000\", \"to\": \"dcd32b87270aeb980333213da2549c9907e09e94\", \"value\": \"3e8\" &#125; ]&#125; Contract#call 的返回类型. IContractSendRequestOptionsContract#send 的配置项 123456789101112131415161718192021222324/** * `send` 合约方法的配置项. */export interface IContractSendRequestOptions &#123; /** * 要发送的 QTUM 数. 例如 0.1, 默认: 0 */ amount?: number | string /** * gasLimit, 默认: 200000, 最大: 40000000 */ gasLimit?: number /** * 每 gas 的 Qtum 价格, 默认: 0.00000001, 最小:0.00000001 */ gasPrice?: number | string /** * 发送者的 quantum 地址 */ senderAddress?: string&#125; IContractSendResult1234const tx = await contract.send(method, args)await tx.confirm(3, (updatedTx, receipt) =&gt; &#123; /// ...&#125;) 返回 Contract#send 的值。 confirm 方法用来等待交易确认。 confirm 方法的参数: 参数 类型 n number 可选 须等待的确认数 callback IContractSendConfirmationHandler 可选 回调函数，每次确认都会调用 回调值为: 参数 类型 updatedTx IRPCGetTransactionResult 关于提交给网络的交易的基本信息 receipt IContractSendReceipt 关于已确认交易的其他信息 参考 IRPCGetTransactionResult IContractSendReceipt IRPCGetTransactionResult123456789101112131415export interface IRPCGetTransactionResult &#123; amount: number, fee: number, confirmations: number, blockhash: string, blockindex: number, blocktime: number, txid: string, walletconflicts: any[], time: number, timereceived: number, \"bip125-replaceable\": \"no\" | \"yes\" | \"unknown\", details: any[] hex: string,&#125; 关于提交给网络的交易的基本信息。 IContractSendReceiptContract#send 的合约收据, 带有解码的事件日志 1234567891011121314151617181920212223242526export interface IContractSendReceipt extends IRPCGetTransactionReceiptBase &#123; /** * 使用 ABI 解码的日志 */ logs: IDecodedLog[], /** * 未解码的日志 */ rawlogs: ITransactionLog[],&#125;/** * 解码的 Solidity 事件日志 */export interface IDecodedLog &#123; /** * 事件日志名称 */ type: string /** * 键值映射作为事件日志参数 */ [key: string]: any&#125; 实例 12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; \"blockHash\": \"3b53ad132c26f9c30e5be9f664573428dad8b52e167becea4428d6903cb32740\", \"blockNumber\": 13917, \"transactionHash\": \"79338589bb75e1865be889142890a4e25d3b9dbd454ce3f3c2614587c85e2ed3\", \"transactionIndex\": 1, \"from\": \"dcd32b87270aeb980333213da2549c9907e09e94\", \"to\": \"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3\", \"cumulativeGasUsed\": 39306, \"gasUsed\": 39306, \"contractAddress\": \"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3\", \"logs\": [ &#123; \"type\": \"Mint\", \"to\": \"dcd32b87270aeb980333213da2549c9907e09e94\", \"amount\": \"7d0\" &#125;, &#123; \"type\": \"Transfer\", \"from\": \"0000000000000000000000000000000000000000\", \"to\": \"dcd32b87270aeb980333213da2549c9907e09e94\", \"value\": \"7d0\" &#125; ], \"rawlogs\": [ &#123; \"address\": \"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3\", \"topics\": [ \"0f6798a560793a54c3bcfe86a93cde1e73087d944c0ea20544137d4121396885\", \"000000000000000000000000dcd32b87270aeb980333213da2549c9907e09e94\" ], \"data\": \"00000000000000000000000000000000000000000000000000000000000007d0\" &#125;, &#123; \"address\": \"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3\", \"topics\": [ \"ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\", \"0000000000000000000000000000000000000000000000000000000000000000\", \"000000000000000000000000dcd32b87270aeb980333213da2549c9907e09e94\" ], \"data\": \"00000000000000000000000000000000000000000000000000000000000007d0\" &#125; ]&#125; 参考 IRPCGetTransactionReceiptBase IRPCWaitForLogsRequest123456789101112131415161718192021export interface IRPCWaitForLogsRequest &#123; /** * 查找日志的开始块号。 */ fromBlock?: number | \"latest\", /** * 查找日志的停止块号. 如果是 null, 会无限期等待 */ toBlock?: number | \"latest\", /** * 过滤日志的条件。 地址和主题分别指定为十六进制字符串数组 */ filter?: ILogFilter, /** * 日志返回前的最少确认数 */ minconf?: number,&#125; IContractEventLogs12345678910111213141516171819/** * 查询合约事件日志的结果。 */export interface IContractEventLogs &#123; /** * 事件日志, ABI 解码. */ entries: IContractEventLog[] /** * 返回的事件日志数 */ count: number /** * 要开始查询新事件日志的块号 */ nextblock: number&#125; 查询合约事件日志的结果。 要查询尚未出现的新日志，请在查询事件日志时将 nextblock 用作 startBlock： IContractEventLog IContractEventLog一条解码的合约事件日志 12345678910111213141516171819202122232425262728293031323334353637383940export interface IContractLogEntry extends ILogEntry &#123; /** * Solidity 事件, ABI 解码. 如果没有找到 ABI 定义，为 Null */ event?: ISolidityEvent&#125;/** * qtumd 返回的原始日志数据，不是 ABI 解码 */export interface ILogEntry extends IRPCGetTransactionReceiptBase &#123; /** * EVM 日志主题 */ topics: string[] /** * EVM 日志数据, 十六进制字符串 */ data: string&#125;/** * qtumd 返回的交易收据 */export interface IRPCGetTransactionReceiptBase &#123; blockHash: string blockNumber: number transactionHash: string transactionIndex: number from: string to: string cumulativeGasUsed: number gasUsed: number contractAddress: string&#125; 实例 123456789101112131415161718192021&#123; \"blockHash\": \"369c6ded05c27ae7efc97964cce083b0ea9b8b950e67c51e52cb1bf898b9c415\", \"blockNumber\": 12184, \"transactionHash\": \"d1638a53f38fd68c5763e2eef9d86b9fc6ee7ea3f018dae7b1e385b4a9a78bc7\", \"transactionIndex\": 2, \"from\": \"dcd32b87270aeb980333213da2549c9907e09e94\", \"to\": \"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3\", \"cumulativeGasUsed\": 39306, \"gasUsed\": 39306, \"contractAddress\": \"a778c05f1d0f70f1133f4bbf78c1a9a7bf84aed3\", \"topics\": [ \"0f6798a560793a54c3bcfe86a93cde1e73087d944c0ea20544137d4121396885\", \"000000000000000000000000dcd32b87270aeb980333213da2549c9907e09e94\" ], \"data\": \"00000000000000000000000000000000000000000000000000000000000003e8\", \"event\": &#123; \"type\": \"Mint\", \"to\": \"dcd32b87270aeb980333213da2549c9907e09e94\", \"amount\": \"3e8\" &#125;&#125; IDecodedSolidityEvent1234567891011121314/** * 一个解码的 Solidity 事件日志 */export interface IDecodedSolidityEvent &#123; /** * 事件名称 */ type: string /** * 键值映射作为事件日志参数 */ [key: string]: any&#125; Example 123456&#123; \"type\": \"Transfer\", \"from\": \"0000000000000000000000000000000000000000\", \"to\": \"dcd32b87270aeb980333213da2549c9907e09e94\", \"value\": \"3e8\"&#125; 解码的 Solidity 事件日志。 事件参数存储在键值映射中。 IRPCGetTransactionReceiptBase网络接受的交易收据。它由 gettransactionreceipt RPC 调用返回。 123456789101112131415export interface IRPCGetTransactionReceiptBase &#123; blockHash: string blockNumber: number transactionHash: string transactionIndex: number from: string to: string cumulativeGasUsed: number gasUsed: number contractAddress: string&#125; IContractsRepoData合约相关信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354export interface IContractsRepoData &#123; /** * 部署合约的相关信息 */ contracts: &#123; [key: string]: IContractInfo, &#125;, /** * 部署库的相关信息 */ libraries: &#123; [key: string]: IContractInfo, &#125; /** * 部署合约/库引用的合约信息，但未部署 */ related: &#123; [key: string]: &#123; abi: IABIMethod[], &#125;, &#125;&#125;/** * 与部署合约进行交互所需的最少部署信息。 */export interface IContractInfo &#123; /** * 合约的 ABI 定义, solc 生成. */ abi: IABIMethod[] /** * 合约地址 */ address: string /** * 合约所有者的地址 */ sender?: string&#125;export interface IABIMethod &#123; name: string, type: string, payable: boolean, inputs: IABIInput[], outputs: IABIOutput[], constant: boolean, anonymous: boolean,&#125; 可以使用开发工具 solar 自动生成。 样例 solar.json.","categories":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/tags/区块链/"},{"name":"Qtum","slug":"Qtum","permalink":"http://xichen.pub/tags/Qtum/"},{"name":"翻译","slug":"翻译","permalink":"http://xichen.pub/tags/翻译/"}]},{"title":"【翻译】 Bitcoin Core 0.15.0版本说明","slug":"2018-05-30-翻译-BitcoinCore0.15.0版本说明","date":"2018-05-30T06:11:00.000Z","updated":"2019-04-01T15:18:44.221Z","comments":true,"path":"2018/05/30/2018-05-30-翻译-BitcoinCore0.15.0版本说明/","link":"","permalink":"http://xichen.pub/2018/05/30/2018-05-30-翻译-BitcoinCore0.15.0版本说明/","excerpt":"","text":"原文：https://bitcoin.org/en/release/v0.15.0译者：中山大学数学学院（珠海）林学渊大二时给量子做的翻译，转载注明出处，谢谢 0.15.0版本说明当前对隔离见证的支持版本0.15.0支持通过 addwitnessaddress RPC 添加隔离见证地址，但请注意，这是一个 测试/专家 RPC，它不保证从备份恢复。 要是你知道你在做什么，就使用这个 RPC 吧。下一个版本将提供更完整的隔离见证的钱包支持。 加密钱包重新扫描和以前的版本一样，当使用加密的 HD 钱包时，如果没有解锁钱包，密钥池不会被自动检测。 这意味着，目前，如果要从加密 HD 钱包的备份恢复，用户必须用非常长的时间解锁钱包并手动触发重新扫描，否则当自动检测程序无法运行时，会有可能丢失一些密钥。 不幸的是，在这个版本中没有 rescan RPC，它放在以后的版本中。所以现在重新扫描可以使用其中一个 import* 命令触发，同时要用另一个（可信）钱包生成的虚拟地址。 重大改动性能改进版本0.15包含许多重要的性能改进，这使得初始块下载，启动，交易和块验证速度更快： 链状态数据库 (用于跟踪 UTXO ) 已从每交易模型更改为每交易输出模型（请查看 PR 10195）。 这个模型的优点是它： 避免反序列化和序列化未使用输出的CPU开销； 更可预测的内存使用情况; 更简单的代码; 适用于各种未来的缓存刷新策略。因此，在初始块下载（IBD）和重新索引期间验证区块链的速度提高约30-40％，使用的内存减少10-20％，并且刷新到磁盘的频率要更低。 唯一的缺点是磁盘上的数据库大小增加15％。 在从以前的格式转换过来的过程中，可能会使用额外几千兆字节。 早期版本在刷新 UTXO 到磁盘时遇到了内存使用量激增。 结果，实际只有一半的可用内存用作缓存，而另一半则被保留以应付数据刷新。 不会再有这种情况了（请查看 PR 10148），并且整个可用缓存（请查看 -dbcache）现在确实用作缓存。 这将数据刷新频率降低了2倍甚至更多。 在前面的版本中, 当交易被内存池接受时，交易的签名验证会被缓存。版本 0.15 版本0.15将其有效性扩展为缓存整个脚本（请查看 PR 10192）。 这意味着如果块中的交易已被内存池接受，私钥签名不需要重新计算。 经验测试表明，这使新块的验证速度提高40-50％。 LevelDB 已经升级到版本1.20 (请查看 PR 10544). 这个版本包括用于在支持SSE 4.2的体系结构中 CRC 的硬件加速 。因此，同步和块验证现在更快。 针对支持SSE 4的体系结构（参见 PR 10821），SHA256哈希已优化。 在支持的硬件上 SHA256 速度提高了约50％，这导致IBD和块验证速度提高了约5％。 在版本0.15中，默认情况下，发布版本中禁用SHA256硬件优化，但可以在构建时使用 --enable-experimental-asm 启用。 重新填充密钥池不再刷新每个密钥对应的钱包，使创建新钱包的速度提高了20倍。 部分加速用来将默认密钥池增加到1000个密钥，以使恢复能力更加健壮。（见 PR 10831). 手续费评估的改进版本0.15中，手续费评估速度有了明显提高，钱包使用的手续费评估更准确，而对于estimatesmartfee 和 estimaterawfee RPC（见 PR 10199）的高级用户而言，手续费评估的可选范围更广。 内部逻辑和钱包行为的变化 手续费评估现在在3个不同的时间范围内进行跟踪。这使更长远的目标和评估方法能更迅速地适应条件的变化。 评估现在可以选择 保守的 或 经济的。 保守评估使用更长的时间范围来产生评估，不易受费用条件快速变化影响。经济评估使用更短的时间范围，受费用条件的短期变化影响更大。 在低交易活动期间（例如在周末），经济评估可能会相当低，但如果通行费用迅速增加，则可能导致交易未被证实。 默认，钱包使用保守的手续费评估来增加在预期目标内被确认的交易的可靠性。对于被标记为可替换的交易，钱包默认会使用经济评估，因为如果费用条件迅速变化，费用可能会“冲突” (查看 PR 10589). 现在可以对最多1008个块的确认目标进行评估（一周内）。 存储更多关于历史收费率的数据，从而使手续费评估更精确。 对由于驱逐或其他未确认的原因而离开内存池的交易，不再考虑手续费评估，使手续费评估更准确。 手续费评估逻辑将确保收集到足够的数据以返回有意义的估算值。 如果数据不足，则使用后备的默认费用。 手续费评估 RPC 的变化 estimatefee RPC 现在废弃了，建议使用 estimatesmartfee (支持 GUI) estimatesmartfee RPC 接口改变 (查看 PR 10707): nblocks 参数重命名成 conf_target (与其他RPC方法一致). 增加 estimate_mode 参数. 该参数为以下字符串之一： CONSERVATIVE, ECONOMICAL 或 UNSET (默认是 CONSERVATIVE). RPC返回对象现在包含一个 error 成员，它返回处理期间遇到的错误。 如果 Bitcoin Core 运行时间不够长，并且没有足够的数据块或交易来产生准确的手续费评估，则会返回一个错误（之前使用-1表示错误，这可能会导致费率混淆）。 新增 estimaterawfee RPC 提供原始费用数据. 外部客户端可以在他们自己的手续费评估逻辑中查询和使用这些数据。 多钱包支持Bitcoin Core现在支持加载多个独立钱包 (查看 PR 8694, PR 10849).钱包是完全分开的，具有个人余额，钥匙和收到的交易. 启动比特币时使用 -wallet 参数可启用多钱包，在命令行或比特币配置文件中都可以。 在Bitcoin-Qt中，只有第一个钱包才会显示并可用于创建和签署交易。 未来版本将支持 GUI 来选多个钱包。 但是，即使在版本0.15的其他加载的钱包中，仍然会与后台节点的当前提示保持同步。 这可能很有用，如果是运行一个修剪过的节点的话，因为加载一个最新同步超出修剪高度的钱包导致必须下载并重新验证整个区块链。 继续同步后台中的所有钱包可避免此问题。 Bitcoin Core 0.15.0 包括下列RPC接口的改动及多钱包的 bitcoin-cli : 当用一个钱包运行 Bitcoin Core 时，RPC 接口或 bitcoin-cli 不会 变化。所有 RPC 调用和 bitcoin-cli 命令和之前一样继续运行. 当用多钱包运行 Bitcoin Core 时, 所有 节点级 RPC 方法和之前一样继续运行. HTTP RPC 请求应该发送至 &lt;RPC IP address&gt;:&lt;RPC port&gt; , 并且 bitcoin-cli 命令应该和之前一样继续运行. 一个 节点级 RPC 方法是不需要访问钱包的任意方法。 当用多钱包运行 Bitcoin Core 时, 钱包级 RPC 方法必须指定他们在每个请求中所针对的钱包。 HTTP RPC 请求应该发送至 &lt;RPC IP address&gt;:&lt;RPC port&gt;/wallet/&lt;wallet name&gt; , 例如 127.0.0.1:8332/wallet/wallet1.dat. bitcoin-cli 命令应该使用 -rpcwallet 选项运行, 例如 bitcoin-cli -rpcwallet=wallet1.dat getbalance. 添加了一个新的 节点级 listwallets RPC 方法来显示当前加载哪些钱包。 此方法返回的名称与HTTP端点和 rpcwallet 参数中使用的名称相同。 请注意，虽然现在完全支持多钱包，但对于版本0.15.0，RPC多钱包界面应被视为不稳定，并且未来版本中可能存在向后不兼容的更改。 在GUI中 RBF(replace-by-fee)控制Bitcoin Core 支持从版本0.12.0开始创建 replace-by-fee（RBF）交易，并且自0.14.0版本开始包含一个 bumpfee RPC 方法，用支付更高费用的新交易取代未经证实的选择性RBF交易。 在版本0.15中，创建一个选择性的RBF交易，和用更高费用的交易替换未确认的交易都在GUI中支持（见 PR 9592). 移除币龄优先Bitcoin Core前面的版本中, 每块的一部分可以根据他们花费的 UTXO 的年龄和价值预留给交易。 这个概念（币龄优先）是矿工的一项政策选择，并且没有围绕包括币龄优先交易的共识规则。 在实践中，只有少数矿工继续使用币龄优先进行交易。 Bitcoin Core 0.15删除了币龄优先的所有支持（见 PR 9602）。 这具有以下意义： 免费交易 的概念已被移除。即使没有附加矿工费，高币龄优先交易也会允许进行转账。 这是不可能的，因为不再有币龄优先的概念。 控制免费交易的-limitfreerelay 和 -relaypriority 选项已被移除。 -sendfreetransactions 选项已被移除, 因为几乎所有的矿工都不要不附加交易费的交易。 -blockprioritysize 选项已被移除. estimatepriority 和 estimatesmartpriority RPCs 已被移除. getmempoolancestors, getmempooldescendants, getmempoolentry 和 getrawmempool RPCs 不再返回 startingpriority 和 currentpriority. prioritisetransaction RPC 不再有 priority_delta 参数, 它替换成 dummy 参数，以便与使用位置参数的客户端向后兼容。 RPC 仍然适用于通过使用fee_delta 参数来改变交易的明显费率。 -minrelaytxfee 现在可以设为 0. 如果设置了 minrelaytxfee , 那么小于 minrelaytxfee (每 kB) 的费用拒绝中继，挖掘和创建交易。默认为1000 satoshi / kB。 -printpriority 选项升级为只在挖矿代码输出费率和包含在块中的交易哈希. 内存池持久化重启版本0.14 引入了内存池持久化重启（内存池在关闭之前保存到数据目录中的 mempool.dat 文件中，并在节点重新启动时恢复内存池）。 版本0.15允许使用-persistmempool 命令行选项打开或关闭此功能（请参阅 PR 9966）。 默认情况下，该选项设置为true，内存池在关机时保存并在启动时重新加载。 如果设置为false，则 mempool.dat 文件将不会在启动时加载或在关闭时保存。 新 RPC 方法版本 0.15 引入一些新的 RPC 方法: abortrescan 停止当前钱包的重新扫描, 比如，在被一个 importprivkey 调用触发时 (查看 PR 10208). combinerawtransaction 接受一个原始交易的JSON数组，将它们组合成一个原始交易 (查看 PR 10571). estimaterawfee 返回原始费用数据，以便可以使用定制的逻辑来分析数据并计算估算值。 有关费用估算逻辑和接口更改的完整详细信息，请参阅 手续费评估的改进 getchaintxstats 返回关于链中交易总数和速率的统计信息(查看 PR 9733). listwallets 列出当前加载的钱包。查看多钱包 ( 多钱包支持) 获得更多细节。 uptime 返回自上次启动以来 bitcoind 服务器的总运行时间 (查看 PR 10400). 底层 RPC 更改 在使用 Bitcoin Core 的多钱包模式时, 钱包方法的RPC请求必须指定它们的用途。 有关完整的详细信息，请参阅 多钱包支持 。 新的数据库模型不再存储关于未使用输出的交易版本的信息（请参阅 性能改进). 这意味着: gettxout RPC 的返回不再有 version 字段. gettxoutsetinfo RPC 报告 hash_serialized_2 而不是hash_serialized, 后者没有提交未使用输出的交易版本，但确实提交了高度和coinbase 信息。 getutxos REST 路径不再以JSON格式报告 txvers 字段。始终以二进制格式报告交易版本为0。 estimatefee RPC 废弃. 用户应该转向使用 estimatedmartfee RPC，这会返回更好的费用估算。查看 手续费评估的改进 详细了解费用估算逻辑和接口的变化。 gettxoutsetinfo 的返回现在包含 disk_size 和 bogosize 而不是bytes_serialized。第一个是对实际磁盘使用情况的更准确的估计，但不是确定性的。 第二个与磁盘使用无关，但也与UTXO集大小无关，与数据库无关:它将每个UTXO条目计数为 50 + 其scriptPubKey长度 (查看 PR 10426). signrawtransaction 不能再用于将多个交易组合为单个交易. 作为替代, 使用新的 combinerawtransaction RPC (查看 PR 10571). fundrawtransaction 不再接受一个 reserveChangeKey 选项. 此选项用于允许 RPC 用户使用密钥池中的密钥为更改地址提供原始交易处理，而无需将其从密钥池中的可用密钥中移除。密匙能重用，通过调用 getnewaddress , 但这可能会导致混淆或危险的行为 (查看 PR 10784). estimatepriority 和 estimatesmartpriority 已被移除. 查看 移除币龄优先. listunspent RPC 现在可以接受一个 query_options 参数 (查看 PR 8952), 它是一个包含一个或多个以下成员的JSON字段： minimumAmount - 一个数字，指定每个UTXO的最小值 maximumAmount - 一个数字，指定每个UTXO的最大值 maximumCount - 一个数字，指定UTXO的最小数量 minimumSumAmount - 一个数字，指定UTXO的最大数量 getmempoolancestors, getmempooldescendants, getmempoolentry 和 getrawmempool RPCs 不再返回 startingpriority 和 currentpriority. 查看 移除币龄优先. dumpwallet RPC 现在返回虚拟钱包（dumped wallet）的完整绝对路径. 即使成功，它也不会返回任何值 (查看 PR 9740). getpeerinfo RPC中, 每个peer的返回对象现在返回一个 addrbind 成员，其中包含到peer的连接的IP地址和端口。 这是除了包含本地节点的IP地址和端口的 addrlocal 成员之外，由peer方报告的成员 (查看 PR 10478). disconnectnode RPC 现在可以断开由节点ID（以及IP地址/端口）指定的节点。 要根据节点ID断开节点，请使用新的 nodeid 参数 (查看 PR 10143). prioritisetransaction 的第二个参数已经从 priority_delta 重命名成 dummy，因为 Bitcoin Core 不再有币龄优先的概念。 dummy 参数没有功能影响，但为了兼容性保留位置。查看 移除币龄优先. resendwallettransactions RPC 抛出错误如果 -walletbroadcast 选项设置为 false (查看 PR 10995). submitblock RPC 的第二个参数从 parameters 重命名为 dummy. 这个参数从来没有任何效果，重命名只是将这个事实传达给用户 (查看 PR 10191)(用户应该，无论如何，使用 submitblock 的位置参数以便与BIP 22兼容。) getblock 的 verbose 参数重命名成 verbosity ，现在接受 0 到 2 的int整数. verbose等级0等同于 verbose=false。 verbose等级1相当于verbose=true. Verbose 等级 2 将给出由 getrawtransaction 给出的输出中每个交易的完整交易详情。为了兼容性，仍旧保留使用详细命名参数和布尔值的旧行为。 错误代码已更新为更准确的以下错误情况 (查看 PR 9853): getblock 现在返回 RPC_MISC_ERROR 如果区块在硬盘上找不到 (比如如果区块被修剪). 之前返回 RPC_INTERNAL_ERROR. pruneblockchain 现在返回 RPC_MISC_ERROR 如果由于节点不是处于修剪模式而无法修剪区块。 之前返回 RPC_METHOD_NOT_FOUND. pruneblockchain 现在返回 RPC_INVALID_PARAMETER 如果由于提供的时间戳太晚了而无法修剪区块. 之前返回 RPC_INTERNAL_ERROR. pruneblockchain 现在返回 RPC_MISC_ERROR 如果由于区块链太短而无法修剪区块. 之前返回 RPC_INTERNAL_ERROR. setban 现在返回 RPC_CLIENT_INVALID_IP_OR_SUBNET if the supplied IP addressor subnet is invalid. 之前返回 RPC_CLIENT_NODE_ALREADY_ADDED. setban 现在返回 RPC_CLIENT_INVALID_IP_OR_SUBNET 如果提供的IP地址或子网无效. 之前返回 RPC_MISC_ERROR. removeprunedfunds 现在返回 RPC_WALLET_ERROR 如果 bitcoind 无法移除交易. 之前返回 RPC_INTERNAL_ERROR. removeprunedfunds 现在返回 RPC_INVALID_PARAMETER 如果在钱包中交易不存在. 之前返回 RPC_INTERNAL_ERROR. fundrawtransaction 现在返回 RPC_INVALID_ADDRESS_OR_KEY 如果提供了无效的更改地址. 之前返回 RPC_INVALID_PARAMETER. fundrawtransaction 现在返回 RPC_WALLET_ERROR 如果 bitcoind 不能创建一个交易. 错误消息提供了更多详细信息。. 之前返回 RPC_INTERNAL_ERROR. bumpfee 现在返回 RPC_INVALID_PARAMETER 如果提供的交易在钱包中有后代. 之前返回 RPC_MISC_ERROR. bumpfee 现在返回 RPC_INVALID_PARAMETER 如果提供的交易在内存池中有后代. 之前返回 RPC_MISC_ERROR. bumpfee 现在返回 RPC_WALLET_ERROR 如果提供的交易已被开采或与挖矿交易发生冲突. 之前返回 RPC_INVALID_ADDRESS_OR_KEY. bumpfee 现在返回 RPC_WALLET_ERROR 如果提供的交易不是BIP 125可替换. 之前返回 RPC_INVALID_ADDRESS_OR_KEY. bumpfee 现在返回 RPC_WALLET_ERROR 如果提供的交易已经被不同的交易冲突. 之前返回 RPC_INVALID_REQUEST. bumpfee 现在返回 RPC_WALLET_ERROR 如果提供的交易包含不属于该钱包的输入. 之前返回 RPC_INVALID_ADDRESS_OR_KEY. bumpfee 现在返回 RPC_WALLET_ERROR 如果提供的交易有多个变更输出. 之前返回 RPC_MISC_ERROR. bumpfee 现在返回 RPC_WALLET_ERROR 如果提供的交易没有变化输出. 之前返回 RPC_MISC_ERROR. bumpfee 现在返回 RPC_WALLET_ERROR 如果手续费太高. 之前返回RPC_MISC_ERROR. bumpfee 现在返回 RPC_WALLET_ERROR 如果手续费太低. 之前返回RPC_MISC_ERROR. bumpfee 现在返回 RPC_WALLET_ERROR 如果变化的产出太小而不能收费. 之前返回 RPC_MISC_ERROR.","categories":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/tags/区块链/"},{"name":"Qtum","slug":"Qtum","permalink":"http://xichen.pub/tags/Qtum/"},{"name":"翻译","slug":"翻译","permalink":"http://xichen.pub/tags/翻译/"}]},{"title":"【翻译】 十大 Qtum 新用户会问的问题","slug":"2018-05-24-翻译-十大Qtum新用户会问的问题","date":"2018-05-24T06:11:00.000Z","updated":"2019-04-01T15:18:44.219Z","comments":true,"path":"2018/05/24/2018-05-24-翻译-十大Qtum新用户会问的问题/","link":"","permalink":"http://xichen.pub/2018/05/24/2018-05-24-翻译-十大Qtum新用户会问的问题/","excerpt":"","text":"原文：https://medium.com/@jb395official/top-10-qtum-new-user-questions-april-22-2018-307a65dad83f译者：中山大学数学学院（珠海）林学渊大二时给量子做的翻译，转载注明出处，谢谢 十大 Qtum 新用户会问的问题 - 2018年4月22日以下是 Qtum 新用户的前 10 个问题和回答，但首先是关于 Qtum 主网性能和网络权重的更新。 我是独立的区块链研究人员，喜欢在 Qtum 社区混，最近担任社交媒体渠道的管理员。 我很欣赏 Qtum 团队的技术指导，希望很快能在网上与你聊天。 下面分析的数据来自屏幕抓取区块链资源管理器，从 qtumd 服务器钱包记录，以及来自 Lisboa 的 A Ginjinha 的加密电报消息。 网络权重新用户留步 - 这是对区块链性能的一些更详细的分析 - 你可以跳到下面的 Q&amp;A 一节。 钱包计算网络权重的估计值，用于给出块奖励的平均时间。 钱包算法是短期的，并且有一些变化。 网络权重来源于赢得下一个区块奖励的难度，该区块奖励会根据Qtum股权证明中的每个区块进行调整。 以下是从4月15日至21日所有区块的钱包计算的网络权重估算图： 这个博客的定期读者知道我在比钱包更长的时间范围内计算我自己的网络权重估计值，还有更多的数据点。 4月15日至21日，已知余额326万美元的大钱包在 4207 块奖励中获得 684 个奖励，网络权重为2000万美元。 网络权重为 2000 万，意味着参与 stake 采矿的 Qtum 钱包的年回报率为4.4％[参考文献1]： 块间​​距Qtum 的块间隔平均大约 144 秒，或每天 600 块。 调整块奖励难度以保持该平均间隔，但是由随机抽奖算法选择块奖励获胜者引起的块间距存在一些变化。 下面的柱状图显示了 4 月 15 日至 21 日分组为 16 秒桶的块间隔数，其中块间距为 2 秒至 256 秒。 在这段时间里，有两个区块间隔大于 20 分钟，最长的区块在 26:55 处是 138,226。 电报翻译社交网络上的 Qtum 社区拥有全球成员（就像全球有 Qtum 节点一样）。 Qtum Telegram 提供英语，西班牙语，中文，韩语和俄语的频道。 为了帮助沟通，你可以将 Google Chrome 与电报网络版一起使用，并让 Google 翻译提高你的语言技能： 如果你正在翻译 Telegram note，那么用户名也将被翻译，这可以给出一些有趣的结果。 点击 Chrome 浏览器地址栏最右侧的 Google 翻译图标，然后选择“选项”来管理翻译。 出于安全原因，必须输入你的电报帐户的用户名，这在全球所有电报渠道中都是唯一的。 此外，如果我可以要求电报用户输入一个配置文件照片，只是为了让它更有趣。 它不一定是 Instagram 那种质量的图片，也可以放你的宠物，最喜欢的旅游景点等，你甚至可以放在多张照片，并显示你的个性，例如，看到我的第二张照片😉。 十大 Qtum新用户会问的问题欢迎来到 Qtum！ 加密货币欢迎新用户加入他们的社区。 新用户意味着增长，采用，新想法和新问题。 来自新用户的唯一愚蠢问题就是未经询问的问题。 Cryptocurrencies 和区块链 2.0 是一种快速发展的技术，有很多值得学习的东西，几个月前的活跃用户似乎是专家。 作为一个新用户，我希望这个 Q&amp;A 将加速你对Qtum的认识，并且在几个月内，你也可以成为专家。 如果你是Qtum的新手，以下参考资料中的词汇表可能会对术语有所帮助。 Q 1.我需要投入多少 QTUM？ 如何为 Staking 工作提供奖励？ 是否有masternodes(主节点)？ 你可以在你的钱包中使用低至 1.0 QTUM，但需要更多的奖励才能赢得块奖励。 Qtum 使用权益证明(PoS)，在随机抽奖过程中获得块奖励，其中获胜的可能性取决于你的钱包中的硬币数量与网络上的硬币总数。 每个 Qtum Core 钱包都是网络上分散的完整节点; 没有masternodes(主节点)。 你 stake 的硬币越多，你的钱包就越能赢得 4 QTUM的奖励。 Staking 将会给予每年几个百分点的回报。 要估算块奖励的平均时间，请检查 stake 计算器。 这个估计值是一个区块奖励的平均时间，Qtum区块奖励不会像池塘挖掘一样累积或累积，并且你的区块奖励可能会早于估计值或稍后。 在 staking 中，将你的硬币分成不同的钱包或不同的地址不会改变你获胜的几率; 只有一种方法可以提高你的赔率：购买更多的 QTUM！ Q 2.什么钱包可用于 staking？ 只有 Qtum Core 钱包（qtum-qt 桌面 GUI 钱包，qtumd 服务器钱包）可用于 staking。 这些钱包在 Qtum 网络上运行一个完整的节点，通过实时验证所有事务/块来保护网络，并接收块奖励作为这项工作的激励。 放钱包应该全天候运行，因为它们只能在线时获得奖励。 下面的例子集中在 qtum-qt，这是一个非常适合初学者的桌面 GUI 钱包，但你也可以使用 qtumd 和命令行界面。 你可以从Qtum网站下载最新的Qtum Core钱包： 非新手用户可能对 Qtum Project GitHub 存储库感兴趣，其中包含所有钱包分发包和 GitHub 上的SHA-256哈希验证。 Q 3.还有哪些钱包？ 除 Qtum Core 钱包外，Qtum 还提供 Web 钱包（如MyEtherWallet），Electrum 钱包（支持 Ledger 和 Trezor 硬件钱包）和 Android 手机钱包。 在 qtumeco.io/wallet 获取这些钱包。 Q 4.我的QTUM丢失了。 Blockchain Explorer说我的余额太低了，wtf？ [参考文献2] 这可能是新手遇到的最常见的问题（不要问我怎么知道，但是对于 Earlz 来说，在 Testnet 早期的时候为新手回答了这个问题），特别是如果你是区块链的新手，或来自具有帐户架构的区块链。 Qtum 使用 Unspent Transaction Output（UTXO）模型存储值，与比特币相同。 这意味着当你发送 QTUM 交易时，你的钱包将选择以前的一笔或多笔交易，交易金额超过你支付的金额，并全部发送这些交易。 你的钱包还将提供一个“更改地址”，以便返回更改。 像这样想。 如果你想以 3 欧元的价格购买咖啡，并给咖啡店一张 5 欧元的纸币，那么他们将返还 2 欧元。 这正是钱包使用更改地址所做的事情（除非你启用了硬币控制功能）。 你的钱包将显示其管理的所有地址的总余额，包括更改地址，但资源管理器一次只能显示单个地址的余额。 资源管理器和钱包从他们的角度展示了 QTUM 的正确平衡，但除非你知道 UTXO 如何使用更改地址，否则它可能会令人困惑。 请记住，从技术上讲，钱包中没有真正的 QTUM “硬币”（或 QRC20 代币）。 “硬币”实际上是作为区块链块中的交易存储的，“钱币”实际上是钱包地址的所有先前交易的未使用值的钱包的总和。 钱包确实具有存储和管理私钥的关键工作，并且钱包本质上是一个区块链浏览器，可让你管理实际存储在区块链中的“硬币”和代币。 Q 5.我过去常常获得固定的奖励，但最近并没有那么多。 如何检查我的钱包设置是否正确？ 请记住，随着有机增长和商业 DAPP 的部署涉及到钱包，网络权重的趋势正在上升，这意味着固定大小的钱包的块奖励之间的时间也在增加。 对于 Qtum 生态系统来说，不断上升的网络权重是一件好事：它意味着更大，更强大，更安全的网络。 你可以使用 Stake计算器 检查你的预期时间以获得积分奖励。 要确定你的 Qtum Core 钱包是否正确 staking，请检查以下事项： 同步到最新块，将鼠标悬停在钱包右下角的小复选标记图标上 解锁仅用于 staking，将鼠标悬停在小挂锁图标上（这将显示稍微打开，显示“unlocked for staking only”）。 电脑时钟在正确时间的几秒钟内设置。 使用 “getinfo” 命令进行检查，并参见问题 9 以输入命令。 这里计算机时间和 Qtum 网络时间同步（“timeoffset”为零秒）。 如果你的钱包具有此配置，你只需等待块奖励，由于块奖励抽奖的随机性，可能会在下一个块（但非常不可能）或预期时间的 5 到 9 倍之间出现 。 Q 6.我的钱包不同步。 我能做什么？ 要参与 staking 或甚至正确查看近期交易的余额，你的钱包必须与区块链正确同步并加载最新的区块。 以下是故障排除列表，但请确保你了解这些步骤，并在有任何问题时向社交媒体寻求帮助。 如果你的钱包卡在“从2017年9月6日落后XX周”这意味着钱包甚至没有开始同步（生日快乐到 Qtum - 2017年9月6日是 Qtum 主网推出的日期）所以下面的步骤 3 怀疑是看端口连接问题。 安装最新版本的Qtum核心钱包https://qtumeco.io/wallet 或 https://github.com/qtumproject/qtum/releases 退出钱包。 制作 wallet.dat 文件的多个备份副本。 这是非常重要的 - 如果你没有做好钱包备份，那么你将失去你的 QTUM。 确保钱包应用程序可以通过防火墙/路由器进行通信，如果需要，为端口 3888 TCP 输入/输出（端口映射或转发）添加白名单。 钱包应该能够连接至少几个对等点，运行一段时间后最多可以连接8个活动连接点。 有时使用addnode命令添加第一个节点会有所帮助，例如： 1addnode 35.197.138.163:3888 add 请查看下面关于输入命令的问题 9。 确保计算机时区设置正确，计算机时钟设置准确。 使用 getinfo 命令检查时间，如上面的回答 5 所示。 只有拥有良好的 wallet.dat 备份时才执行下一步。 在钱包停止的情况下，删除区块链（文件夹：blocks，chainstate，database和stateQtum - 与 wallet.dat 文件位于相同的 “Qtum” 文件夹中）。 这会导致你的钱包在重新启动时重新加载整个区块链。 别担心，区块链会保存你的硬币/代币余额，全球共有 7000 份。 如果你的钱包卡在区块链中部分同步，则此步骤非常有效。 确保至少有2 GB的磁盘存储空间。 重新启动计算机。 再次运行钱包。 祝你好运！ Q 7.如何在钱包中看到 QRC20 代币？ QRC20 代币与你的钱包 Q 地址相关联。 只有在将该代币添加到钱包后，你才能看到 QRC20 代币并发送这些代币 - 通过将特定的QRC20代币“添加”到你的钱包中，告诉你要管理该特定代币的钱包。 要将QRC20代币添加到你的 Qtum Core 钱包，请查看这本手册。 Q 8.我怎样才能保证钱包的安全？ 生命中存在很大的风险，明天你可能会屈服于Mac卡车综合症（被Mac卡车碾过）。 加密中也存在很多风险：交换被黑客入侵，诈骗者，智能合约爆炸，哦，我的天。 基于我在社区中看到的故障排除，你的硬币的主要风险是人类阅读此博客时的人为错误。 有两种方式可以保证破坏你的QTUM：1）丢失核心钱包的 wallet.dat 文件，2）丢失密码/密码短语/种子单词。 对于核心钱包，wallet.dat 文件包含钱包的私钥。 如果因为没有很好的备份而丢失了这个文件，你的 QTUM 将会永远丢失。 同样，如果你丢失钱包的密码/密码/种子字，你的 QTUM 将永远丢失。 有一些非常狭窄的角落案例，你可以从忘记的密码/种子词中恢复。 密码和种子词必须正确输入，字符为字符，大写/小写正确，没有多余的空格等。在加密中，没有密码重置，没有退款，纠纷或类似的事情，如果 你不喜欢你的硬币的个人责任，那么加密不适合你。 对于一般的安全性，Ledger Nano S 和 Trezor 等硬件钱包是最好的方法。 如果你将运行用于 Qtum staking 的核心钱包，最佳做法是从专用计算机中放弃使用电子邮件或浏览网页（为什么？因为你可以通过浏览网页和钓鱼邮件获取恶意软件）。 如果你在 QTUM 中持有任何价值，你应该阅读，理解并实施这些博客中的优秀建议：QTUM 钱包使用最佳实践以及此非官方指南来加密，备份和恢复你的 Qtum 钱包。 Q 9.如何输入命令以查看有关我的钱包的更多信息？ 在菜单栏中选择“帮助”，然后选择“调试窗口” 在调试窗口中选择“控制台” 在控制台的底部，你可以输入一个命令，一个好的命令开始是“帮助” Q 10.我在哪里可以找到关于 Qtum 的更多信息？ 以下是一些很好的参考资料：Qtum使用指南Qtum钱包最佳使用指南Cryptominder对非常官方 staking 指南在Qtum博客上看到的新闻和公告Twitter反馈: Qtum官方和PatrickXDaiQtum Telegram（英文），Qtum subreddit，Qtum Discord 。 我们今天在里斯本完成博客。根据葡萄牙的海军实力，葡萄牙在十五世纪和十六世纪因全球勘探而闻名。 葡萄牙拥有四个 Qtum 节点，在伊比利亚半岛拥有独特的历史和文化。 在里斯本，你可以享受丰富的历史，有轨电车，美味的 pastéisde nata 和法多（深情的蓝调）。 Obrigado e fique seguro在线， Jackson 参考资料 年百分比=（100 x 600块/天x 365天x 4 QTUM /块）/网络权重（百万） “wtf”是技术首字母缩略词，意思是“这种行为的技术解释是什么(What is the Technical explanation For this behavior)”。 有关 “wtf” 的更多信息，请查看加泰罗尼亚 DJ Sak Noel - 洛卡人 NSFW 的说明。 这样美丽的里斯本无人机视频。 DJI Mavic Pro，4k观看。 再见Avicii，RIP。 新用户调查的音乐，挪威DJ Kygo - Stargazing。 注意音乐录影带导演如何使用黑暗并揭示乐团。 而多一点能量，阿姆斯特丹DJ也会这样。 Qtum词汇表 积分奖励(Block rewards) - Qtum Proof of Stake 矿工的奖励，目前在随机抽奖过程中每隔~2分钟支付4.0 QTUM。 Earlz - Jordan Earls，Qtum联合创始人兼首席开发人员，区块链架构师，并在加密中运用最好的胡子。 主网或主网点火(Mainnet or Mainnet Ignition) - 公共 Qtum 区块链，于2017年9月6日推出. Patrick - Patrick Dai，Qtum 联合创始人兼首席执行官，环球传播福音传播者和Qtum项目的主唱。 PoS - 权益证明(Proof of Stake)，Qtum 区块链一致性算法，基于 SHA-256 哈希算法。 QRC20 - Qtum 区块链的数字资产代币，以以太坊 ERC20 代币为模型。 量子链(QTUM) - Qtum Mainnet区块链硬币，用于支持 Qtum 智能合约。 量子基金会(Qtum Foundation) - 在新加坡注册的非营利性基金会，负责监督 Qtum 平台。 测试网络(Testnet) - 用于测试和开发的 Qtum 网络，请查看 Testnet Explorer。 5.请查看我之前的 Medium 博客。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/tags/区块链/"},{"name":"Qtum","slug":"Qtum","permalink":"http://xichen.pub/tags/Qtum/"},{"name":"翻译","slug":"翻译","permalink":"http://xichen.pub/tags/翻译/"}]},{"title":"【翻译】 Qtum 对等连接","slug":"2018-05-18-翻译-Qtum对等连接","date":"2018-05-18T06:11:00.000Z","updated":"2019-04-01T15:18:44.218Z","comments":true,"path":"2018/05/18/2018-05-18-翻译-Qtum对等连接/","link":"","permalink":"http://xichen.pub/2018/05/18/2018-05-18-翻译-Qtum对等连接/","excerpt":"","text":"原文：https://medium.com/@jb395official/qtum-peer-connections-may-21-2018-ba12bda71e4f译者：中山大学数学学院（珠海）林学渊大二时给量子做的翻译，转载注明出处，谢谢 Qtum 对等连接 — 2018年3月21日 这篇文章深入探讨了运行 Qtum 全节点时其中一个最有趣的问题：钱包/节点如何连接到其他 Qtum 对等方，它需要多少连接，以及无法连接时如何排除错误？ 对大多数应用程序来说，家庭网络足够简单易用，但是当你使用 Qtum 节点遇到问题时，你打算怎么处理？ 路由器 - 防火墙 - 杀毒软件体系具有许多内置保护功能，可以确保你网络的安全和正常运行，但运行加密货币钱包可能会与这些内置保护措施发生冲突。 我们使用社交媒体上的 “好友请求” 心智模型来探索节点连接。“好友请求” 就是你发送一个请求给你想聊天的人，比如在 Facebook，Telegram 等等。类似地，你的节点将 “好友请求” 发送出去，与其他节点连接，它们确认请求后就可以与你的节点聊天了。你的节点也能够从其他节点接收“好友请求”。 我们将会了解什么是 Qtum 全节点，Qtum 网络与对等连接如何运作，以及如何覆盖可以阻止这些通信的防火墙和路由器。 我们将花一些时间在端口和网络协议上，并会涉及与 “netstat” 网络状态相关的工具。 我希望在我们完成这些工作之后，你将了解你的 Qtum 节点如何能愉快地与世界各地的同行聊天。 我是一名独立的区块链研究员，偶尔写博客和主持社交媒体，十分中意 Qtum 团队的技术指导。 我希望在社交媒体上能够很快与大家聊天。 请在 Qtum 的电报，Reddit，Discord 和 Forum 社交频道上搜索 “Jackson” 或 “JB395”。 Qtum 主网性能Qtum 主网持续稳定运行，最近通过了 150,000 个区块和7,000 个完全分散的 权益证明 节点。 我的计算结果显示，网络权重为 2080 万，因为在一周内稳定的总余额 185 万的大型钱包赢得了8.9％的区块奖励。这表示 Qtum 权益节点的年回报率为4.2％： 反杀毒软件 TL;DR 由于历史原因，许多杀毒程序在下载 Qtum 钱包安装文件时会误报病毒错误，并隔离或删除这些下载。 要解决此问题，请为杀毒程序添加白名单，如果有问题，请从 Qtum GitHub 站点 下载并使用验证文件校验。译者注：TL;DR 是 “too long; don’t read” 的缩写，意思是太长别看。 在运行我们的钱包并让它发出“好友请求”之前，我们必须安装钱包，但是在下载钱包安装文件时可能会出现一些问题，因为有杀毒软件。 杀毒软件当然没有最完美的终端（台式机等）恶意软件保护技术，但它是我们大多数人使用的。 杀毒软件通过将文件签名与已知的恶意软件文件签名进行匹配来工作。 这可能是最令人沮丧的，因为你从开始下载钱包安装文件，下载完成，到最后它却消失了。 发生了什么？ 回到比特币历史中，人们曾在比特币挖矿文件中发现了一些恶意代码，并且自从杀毒程序标记比特币挖矿文件以来，这些文件与 Qtum 节点文件十分相近。 这是来自 McAfee 杀毒软件的下载警告消息，它在这方面表现很好，提供了一个“接受风险”选项以允许下载安装文件。 其他杀毒软件对用户不太方便，因为它们会在不发出警告的情况下隔离或删除文件。 如果你下载的钱包文件消失了，请在杀毒程序中寻找添加白名单的方法（或者最坏的情况下，暂时关闭杀毒软件进行下载）。 也可能你能够下载并安装钱包，这是因为文件只有在杀毒软件下一次完整扫描你的计算机时才会消失。 这可以通过在杀毒程序中添加白名单来解决。 那么该怎么办？ 请到 Qtum GitHub 站点获取最新版本（https://github.com/qtumproject/qtum/releases） 下载正确版本的钱包来安装，并验证 SHA256 校验和。 将相应的校验和复制到你最喜欢的校验和工具中以验证文件： Qtum 对等连接 TL;DR Qtum 节点（核心钱包）将连接多达 125 个对等点。 前 8 个连接仅出站：节点伸出以连接到其他 8 个节点。 如果路由器和家庭网络的端口 3888 处于打开状态，则该节点将接受对等点 9 到 125 的入站连接。如果该节点也用作 Staking 钱包，则它将通过 8 或 125 个连接同样获得块奖励。 具有多于 8 个对等连接的节点支持连接到网络的新节点，并将下载块来同步这些新节点。 有 8 个出站连接的节点不能这样做。 现在我们已经绕过杀毒程序并安装了钱包，我们可以启动该节点并开始连接到其他节点。 全节点 - 8 vs. 125 个连接在了解关于 Qtum 对等连接如何工作的细节之前，我们先看一下全节点的角色，Staking 钱包以及出站连接与入站连接的问题。 Qtum 全节点（qtumd 或 qtum-qt Core 钱包）连接到 Qtum 对等网络，将整个区块链同步到本地存储中，并实时验证和传送每个区块和交易。 Qtum 节点以此验证来保护网络，然后将块/交易转发给其他节点。 一个 Qtum 节点不需要持有任何 QTUM 或者为了当这个重要的安全角色而 Staking。 只有 Qtum 核心钱包（ qtumd 和 qtum-qt）才能成为全节点，不过轻量级交易钱包提供商也可以运行全节点，可能基于 qtumd。 一个 Qtum 全节点可能另外持有 QTUM 并 Staking 以赢取块奖励。 这些放大的全节点有助于保护网络，并有机会赢得块奖励。 对 Qtum 来说，全节点始终是钱包，但钱包并不总是全节点，例如，Android 手机钱包和 Web 钱包不是全节点，也不能用于 Staking 。 在这篇文章中，我会写关于 “节点” 的内容，但请记住，这是真正的 Qtum 核心钱包，可能会或可能不会 Staking。 按照设计，节点建立的前 8 个连接只是出站连接。 这意味着你的节点将主动发送 “好友请求” 与其他节点连接。 最初，我发现这个“出站”的概念令人困惑; 节点始终与其对等点进行双向通信（输入和输出），但解释是对于前 8 个连接，你的节点通过主动连接其他节点来启动连接。 任何大于 8 个的对等连接都是入站连接（除非使用出站的 addnode 命令）。 这意味着你的节点将接受来自其他节点的连接，即远程节点发送“好友请求”。具有入站连接的节点在 Qtum 网络上具有特殊功能：它们将允许新节点连接到网络，并且将它们以前存的块下载到这些新节点。 对于有入站连接的节点，我们应该特别感谢，没有它们，网络无法通过添加新节点来增长。 我们将在下面看到，节点在主网上允许入站连接的能力取决于路由器到家庭网络的端口 3888 ，所以这些入站的好友请求可以实际到达节点。 请注意，为了获得区块奖励，Staking 钱包有8个连接还是多达125个连接没有区别，事实上，就算只有一个对等连接，钱包也可以进行交易，甚至可以赢得区块奖励（参考文献1）。 对于 qtumd（“无头”服务器钱包）用户，可以使用以下命令监听连接： “getconnectionscount” 将给出当前对等连接数，如 8 或 124. “getpeerinfo” 将提供有关当前对等连接的详细信息。 路由器和家庭网络大多数家庭网络通过因特网服务提供商（ISP）提供的网络接入设备连接到因特网，该服务提供商可以是电缆调制解调器，DSL调制解调器或其他网络接口设备。 调制解调器通常有一个内置路由器，路由器的工作是提供从 ISP 提供的单个公共 Internet 地址到家庭网络上多个内部IP地址的地址转换。 这些内部IP地址通常由诸如 UPnP（universal plug and play）之类的协议自动分配，重要的是要知道，路由器将单个外部 IP 地址映射到家庭网络上连接的多个设备的内部IP地址。 让我们看一下在家庭网络上运行的 Qtum 节点的简化图： 这里有很多东西需要解释。 ISP 为这个宽带客户提供的公共 IP 地址是 123.24.67.89，因特网上的任何地方的计算机都可以发送消息到这个地址。 内部网络 IP 地址为运行 Qtum 节点的计算机 A 为 192.0.0.1，计算机 B 为 192.0.0.2，正在进行网络冲浪，以此类推计算机C. 基于来回的流量，路由器知道如何将网页请求发送回计算机B，并将 Qtum 节点的出站节点请求发送回计算机A. 但是，在 Qtum 节点与前 8 个节点用那些出站的对等请求连接之后会发生什么？问题在于，对于入站的对等请求，路由器可能不够智能，无法将这些好友请求自动路由到计算机 A 中的节点，因此入站的对等请求会丢失，并且该节点无法连接到 8 个节点之上。 要解决这个问题，并允许节点接收入站的对等请求，我们可以使用端口转发为计算机 A 打开端口 3888. 要打开端口 3888，我们配置路由器将端口 3888 的所有流量转发到 IP 地址 192.0.0.1，以到达计算机 A 节点。根据你的网络设置，还可以从钱包映射端口 3888，使用 UPnP 选择设置 - 选项 - 网络 - 映射端口。 网站 portforward.com 有程序和屏幕截图来设置数百个路由器上的端口转发（只需点击他们的广告），程序基本上是登录到你的路由器，找到设置端口转发的部分，并填写表格将 TCP 输入端口 3888 分配给你节点的本地IP地址。 老实说，端口映射应该可以允许入站连接，但我无法使其工作。 如果有人可以提供一些指点，我可以更新这个博客。 Netstat工具在本节中，我们添加一些实用的网络程序和诊断技术。 通常，你的家庭网络允许 Qtum 节点自动同步，但如果没有，这些工具可能有助于排除错误。 为了监控你的家庭网络，netstat（网络状态）程序是一个很好的开始。 从命令提示符运行此工具。 它内置于 Mac 和 Windows，在Linux上你可能需要安装它（apt-get install net-tools）。netstat 选项列表在参考2中给出。 “netstat -n” 命令将以数字形式显示网络地址和端口，显示一个节点连接到端口 3888 上的远程节点： Addnode 命令如果你的新节点没有与对等方连接，则需要使用 “addnode” 命令提供帮助。 你可以告诉节点向特定 IP 发送“好友请求”。但是你应该使用哪些 IP？ addnode 命令的一个很好的对等 IP 地址来源是 coinexchange.io，它列出了来自其 Qtum 节点的 “getpeerinfo” 数据。要使用此站点中的IP地址，请将其输入为 1addnode 123.45.67.89:3888 add （这是一个合成的IP地址，你应该使用来自 coinexchange.io 的实际 IP 地址） 对 addnode 命令的正确响应是 “null”，然后你的节点将尝试一两分钟连接到该对等点 IP 地址。 你可以尝试手动添加 5 个或 10 个对等连接。 在启动时连接在本节中，我们将了解节点如何在启动时建立连接，并使用 netstat 来监听网络并查看节点如何连接。 我们的 netstat 命令是 “netstat -an 30”，意思是每隔 30 秒以数字格式显示所有连接和监听端口。 启动节点时，有几种方法可以找到要连接的对等点。如果节点先前已经运行，它将保存 IP 地址和时间在 peers.dat 文件中。 如果节点是新的或者在 peers.dat 文件中找不到一些好的IP地址，它将向 DNS 服务器查询当前 IP 地址的列表。 最后，你可以手动输入 IP 地址来尝试使用 “addnode” 命令。 首先，我们安装时将节点设置为在全局启动，且不使用 peers.dat 文件中的历史记录（只需重命名 peers.dat 文件，使节点找不到它）。 下面是一个新节点寻找其他节点的消息序列。 这个节点没有使用留有以前“朋友”的 peers.dat 文件。 在半小时的过程中，它将尝试多个IP地址，找到两个要连接的对等点： Qtum 核心钱包有一个文件，其中包含所有“好友请求”，即 peers.dat 文件。 同一个节点使用 peer.dat 文件启动（将先前的文件名改回 “peers.dat”）可使钱包在 12 分钟内与 10 个对等点连接。 下面的图表显示钱包另找新朋友（没有 peers.dat 文件 - 如上所示）与仅仅联系以前的朋友（使用peers.dat 文件）时的差异： 用于网络事件的 Debug.log 文件Qtum 节点现在已经准备好了它的特写，我们将通过设置 debug.log 来捕获所有网络事件。 这是启动钱包时通过 debug=net 开关完成的： 1C:\\Program Files\\Qtum&gt;qtum-qt.exe -debug=net 根据你的操作系统调整此命令。 使用此命令后，节点将记录有关网络活动的所有详细信息。 有关显示连接如何建立简单的列表（下面的参考文献7中给出了更完整的序列），日志显示： （1）启动后，我们的节点尝试根据 peers.dat 文件连接到多个 IP。 它在十天前看到节点 59.189.111.143，但现在不能连接。 （2）我们的节点连接到 DNS 种子服务器以获取最近的一些 IP 地址。 （3）我们的节点试图连接到地址 35.226.31.206，要尝试的是第6个节点。 （4）我们的节点在 35.226.31.206 处向节点发送版本消息（软件版本，块编号和时间参考）。 该版本消息是“好友请求”。远程节点将使用自己的版本消息进行响应。 （5）节点交换 verack 消息（版本确认）以确认连接。 现在它们是好友，可以开始聊天了。 我们的节点将向远程节点请求额外的IP地址，发送其他“好友请求”。 （6）我们的节点将其最新的块（它离线差了 4 块）发送到 35.226.31.206，并请求下载块以追上。 （7）我们的节点开始接收来自节点 6 的块。 请注意时间戳，节点启动后尝试连接节点 6（对等节点 1 到节点 5 未连接）需要45秒，然后等待一秒完成连接（verack 消息）并开始下载块。 我在莫斯科写完博客，部分原因是我收到了来自 Qtum Telegram Russia 频道的管理员 Lisa L 的一个好友请求，要翻译之前的 Qtum Russian Community 博客，因为俄罗斯目前有 17 个 Qtum 节点，并且国际足联世界杯将于 6 月份来到俄罗斯。还要更好的理由在克里姆林宫和红场进行摄影漫步嘛？这个地区是俄罗斯的文化中心，列宁坟墓的所在地，圣巴西尔大教堂（建于 1561 年），众多的博物馆以及 2 月份记者访问时的寒冷天气。 鸣谢特别感谢 Liza L 的俄文翻译。 参考资料 我使用 Testnet 钱包来验证使用单个对等连接操作的节点，使用以下命令： 1qtum-qt.exe -testnet -noconnect -connect=35.197.132.10:13888 netstat工具。 Qtum 对等通信基于比特币，下面是一些相关的比特币参考： BitcoinCore — 运行完整节点 Reddit bitcoin post:我正在运行一个全节点，你也来吧 区块链研究的音乐。 柴可夫斯基 - 意大利随想曲 - Igor Manasherov，莫斯科爱乐乐团，柴可夫斯基音乐厅，2015年6月，莫斯科。 无人机在克里姆林宫上，在 YouTube 上看。 以下是连接到 35.226.31.206 的节点 6 的更完整的日志列表：","categories":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/tags/区块链/"},{"name":"Qtum","slug":"Qtum","permalink":"http://xichen.pub/tags/Qtum/"},{"name":"翻译","slug":"翻译","permalink":"http://xichen.pub/tags/翻译/"}]},{"title":"【翻译】 孤儿块","slug":"2018-05-12-翻译-孤儿块","date":"2018-05-12T06:11:00.000Z","updated":"2019-04-01T15:18:44.217Z","comments":true,"path":"2018/05/12/2018-05-12-翻译-孤儿块/","link":"","permalink":"http://xichen.pub/2018/05/12/2018-05-12-翻译-孤儿块/","excerpt":"","text":"原文：https://medium.com/@jb395official/orphan-blocks-june-16-2018-a8f4799dcc2c译者：中山大学数学学院（珠海）林学渊大二时给量子做的翻译，转载注明出处，谢谢 孤儿块 — 2018年4月16日这一次我们讨论孤儿块。当两个钱包在相近的时间获得块奖励并将块发布到网络时，就会产生孤儿块。其中一个区块将被接受并扩充区块链，另一个区块将成为孤儿并被拒绝。 我们看一下孤儿块的两个问题： 谁挖到了孤儿块？ 我的钱包是否挖到了孤儿块？我该怎么办？ 我们转向一位熟悉的朋友来回答这些问题：钱包的 debug.log 文件。 我承认这是一个只有少数人感兴趣的专门话题。 如果你好奇区块链，请继续阅读; 如果你认为你已经挖到了一个孤儿块，你必须阅读; 如果你对区块链和糟糕的区块链笑话有普遍兴趣，那随你便…… 我是一名独立的区块链研究员，偶尔写博客和主持社交媒体，十分中意 Qtum 团队的技术指导。如果你对本文有任何意见或更正，请在社交媒体上联系我。 主网性能首先简要回顾一下 Qtum 主网的最新性能。 网络权重我另一种计算网络权重的方法依赖于大赌注钱包所获得的积分奖励的百分比，这些大赌注钱包具有已知余额。我的方法也提供了比钱包的计算的网络权重估计更准确的数字。在上周，这些 175 万余钱的大钱包获得了9.96％的积分奖励，网络权重为 1760 万。 网络权重为 1760 万意味着年度回报率为 5.0％ 交易费用由于合约调用，最近出现了一些初始两位数的交易费用。 重量级是 167,861 块，收 5.9 QTUM 交易费，其中包括来自与 Luna Stars 促销相关的一系列 LSTR 令牌转账的 gas。 该区块持有 323 笔交易，在 gas 退款后为区块奖励获奖者支付了9.9 QTUM（4.0 QTUM 区块奖励 + 5.9 交易费用(来自 10 种方式)）后支付 29.92 QTUM 的初始交易费用。 请注意，对于此区块，交易费用大于区块奖励。 孤儿块 TL;DR 当两个节点在相似时间发布新块时，分散式区块链挖矿平台偶尔会挖出孤儿块。孤儿块对于分散式网络来说是完全正常和健康的。 Qtum 的孤儿块率约为1.6％，即每天有 10 个孤儿块。 Qtum 网络一视同仁处理孤儿块（它们被取消），但偶尔中断这一过程会导致孤儿块奖励搁浅，在这种情况下，可以使用一些钱包命令行工具进行恢复。 孤儿简介百老汇音乐剧“小孤儿安妮”于 1977 年在纽约市首映，并讲述了这个勇敢的（有音乐天赋的）小孤儿安妮的故事，她在孤儿院里生活艰苦，并最终被百万富翁实业家 Daddy Warbucks 领养。 在电影版的安妮故事里，汉尼根小姐，孤儿院的邪恶女校长说： .“为什么所有孩子都想成为一个孤儿？我不懂。你会熬夜工作直到这个垃圾场…像克莱斯勒大厦的顶部一样耀眼。”... 在 Qtum 区块链上，当两个 Staking 钱包在相似的时间产生新的区块时，就会生成孤儿块。 对于分散节点，这是偶然且完全自然的结果。 孤儿块与主区块链的关系如下： 为了分析产生的孤儿块的数量，我在 Excel 中处理 debug.log 文件来检查何时挖到新块。 对于允许入站连接的钱包，每个块接收自许多不同的节点（30 个或更多），并且钱包将验证并选择一个附到本地区块链副本。 所有 30 个块都收到相同的数据，包括相同的交易 ID，因为它们来自奖励获奖钱包的那一区块，嗯，你知道这是为啥。 如果挖掘了孤儿块，与其他块相比，它将有相同的块编号，但有不同的交易 ID。 如果将一周的 debug.log 文件行导入 Excel，并运行一些字符串匹配公式，则会弹出孤儿块。 怎么算孤儿块个数？ 我在之前的博客中有一些估计。 比特币的孤儿率约为0.5％（可能是由于快速中继网络），而目前约为 23％ 以太坊叔块（以太坊的叔块激励和处理的方式与 Qtum 孤儿块不同）。 我的分析显示，Qtum 的孤儿块率为1.6％。 这意味着每天 600 块，将会有大约 10 个孤儿。 另一种看待这个问题的方法是：如果一个钱包平均 63 块（在一段时间内）挖矿，那么平均一个将成为一个孤儿。 谁挖到了孤儿块？寻找一个孤儿块有点像在干草堆里找针。解析 debug.log 文件查找孤儿意味着多达 1,000,000 行的多个 Excel 工作表。 幸运的是，有一个 Excel FINDNEEDLE 函数可以找到那些害羞的孤儿块[参考文献2]： 在一周的数据里，我发现了 67 个孤儿（可能还有几个孤儿）。 注意孤儿块 165,136 和 165,137 是相连的孤儿，孤儿高度是两个块（孤儿块 165,137 的父亲是 Mainchain 块 165,136）。 大 staking 钱包将创造许多孤儿块。 我们可以看看 QNqKe …，这是目前最大的 Staking 钱包，我相信这是一个交易热门钱包，而且也 Staking 了（我不知道是属于哪个交易所，但感谢帮忙保护区块链！）。 我们知道钱包会在每 63 块奖励中击中一个孤儿块（但有很多随机变化），而 QNqKe ……在 2 天多一点的时间里获得 63 块奖励。 这是来自 QNqKe 的孤儿块 163,638 …： 请注意这个区块的两件事情，资源管理器将其标记为“孤儿”，下一个应该列出区块的空间却是空的。 这个孤儿块有上一个区块 163,637，但没有下一个区块。 有一个父块但没有子块[参考文献3]。 只有 explorer.qtum.org 会显示孤儿块，其他资源管理器没有。 主网区块 163,638 实际上是通过钱包 QgVXC 赢得的……并且其资源管理器页面显示“Mainchain”和Next Block 163,639： 那些眼睛犀利的人可能会注意到挖到 Mainchain 块的难度高于孤儿块，这就是其他节点在孤儿块上选择 Mainchain 块的方式：赋予区块链最高难度（最安全） 。 当坏事情发生在好钱包时从你的钱包中检测孤儿块的一种方法是查看 debug.log 文件。 如果你不熟悉 debug.log 文件，请参阅此博客。 要查看你的钱包是否已挖到孤儿块，请打开 debug.log 文件并从底部向上搜索“conflicts with wallet transaction”。 如果你的钱包挖到了一个孤儿，你会发现这条日志行和几行后面的日志行显示 “CT_DELETED”，它会从交易表中删除孤儿交易。 如果你正在看你的桌面 GUI 钱包，你会看到一开始 0.4+ 挖矿交易出现，然后神秘地消失。 怎么看这个日志？ 从 “conflicts with wallet transaction” 一行取出两个交易 ID 并在 Explorer.qtum.org 中搜索它们。 你可能会看到这些事务 ID 都不能在区块链中找到，或者它们可以显示为孤儿块。 无论结果如何，这都意味着你肯定挖到了孤儿块。 让我们来回顾一下赢得大块奖励时你的钱包有什么行为。 得到块奖励的获奖钱包将 1）选择一个或多个先前的交易金额（UTXO）来 stake 500 块，2）尽可能多地抓取内存池里正在等待的交易，并将它们组装到新块中，3）根据区块链的本地副本执行这些交易中的所有智能合约调用，4）将新块发布到网络。 当你的钱包完成所有这一切时，它不知道它是创建了一个 Mainchain 块还是一个孤儿块，因为它只是做完这一切并提交了这个 stake。 当你的钱包挖到孤儿块时，最好的办法是不要做任何事情，保持冷静。 你的钱包会发现它挖到了一个孤儿并且迟早会取消所有的孤儿块活动，包括返还 stake。 不管如何，这种孤儿块取消过程很少会中断。 我说实话，我不完全理解孤儿中断过程，但可以猜测，如果你对服务感到紧张，正在密切关注你的钱包，并开始恢复它交换 wallet.dat 文件以取回孤儿 stake - 这可能会滞留孤儿 stake。 在这种情况下，资源管理器将显示地址的正确余额，否则你的钱包将在该地址处显示余额低于 stake 的 UTXO 的金额。 钱包中丢失的金额可能与之前未花费的交易金额完全匹配，你的钱包选择为该孤立区块进行 stake。 如果你发现自己处于这种状况，那么现在是某些命令行工具的时候了。 为了从孤儿 stake 中恢复，“打捞钱包”是无效的，因为它可以修复损坏的 wallet.dat 文件，这不是问题。 请注意，我们正在查看启动钱包时使用的命令行参数，而不是在钱包运行后在调试控制台输入/qtum-cli 命令。 这些命令行工具在你从命令行启动钱包时使用。 对于 Mac OS X，你将在终端中输入命令行，如本博客中所述。 对于 Windows，你将使用本博客中描述的 Windows 命令提示符输入命令。 如果你正在运行服务器钱包 qtumd ，则可以在启动 qtumd 时添加命令行参数（请勿对这些命令使用qtum-cli）。 只有在你拥有 wallet.dat 文件的 良好备份 并完成上述故障排除以确认孤儿块时才使用这些步骤。 重新扫描命令重新扫描命令将通过你本地的区块链副本并从头构建数据库。 在这篇文章中了解重新扫描工作原理。 输入重新扫描命令： 1qtum-qt.exe -rescan 当你输入 qtum-qt 的命令时，启动屏幕将显示状态“重新扫描… XX％”一两分钟，然后打开主钱包。 Zapwallettxes 命令zapwalletxes 命令将重新扫描本地区块链，并删除（“zap”）钱包中未发布在区块链上的所有交易。 在维基 阅读更多关于 zapwallettxes 的信息。 输入 zapwallettxes 命令: 1qtumd.exe –zapwallettxes=2 输入命令后，qtum-qt 将启动并在右下角显示“重新扫描…”。 一两分钟后，将出现完整的钱包窗口，很有希望会恢复孤儿 stake。 如果你在 qtumd 中使用这些命令，请给它一两分钟来完成重新扫描，在此之前它不会响应 info 命令。 在音乐剧和电影的结尾，百万富翁工业家爸爸 Warbucks 领养了小孤儿安妮，然后过上了奢华的生活。 同样地，Qtum 孤儿块会返还它们的 stake 然后 staking 并保护 Qtum 区块链。 请保持在线安全， Jackson 参考资料 看我的过去的博客，包含以下主题： QRC20 Token 更新，设定发送QRC20代币的气体限价和气体价格，发布于2018年5月28日 Qtum 对等连接，详细了解Qtum节点连接到2018年5月21日发布的其他节点，传出/传入连接以及一些用于监控流量的工具 Qtum 新用户十大问题，2018年4月22日发布的新Qtum用户的答案 网络哈希率，比特币，以太坊和Qtum网络哈希率的比较，这些数字可能会让你感到惊讶，2018年4月6日发布 新手钱包 :分析块奖励获奖钱包和新中文节点，发布于2018年4月1日 调试日志，虚拟机日志:debug.log（和虚拟机日志）是你的朋友，如何查找和阅读调试日志，发布于2018年3月13日 QTUM上限供应减半:QTUM的供应量是多少，将会有多少？ QTUM的上限，“减半”的工作原理以及2018年3月4日发布的新资源管理器 QRC20令牌报告:QRC20令牌，BOT空投，发布于2018年2月25日 Qtum PoS模拟器:发布于2018年2月16日 Testnet:Qtum测试网络，于2018年1月7日发布 虚拟专用网络（VPN）:使用VPN进行赌注，于2017年12月31日发布 交易费用，2017年12月24日发布 密码短语，密码短语和密码猜测脚本，2017年12月17日发布 内存池（mempool），内存池和未确认事务的处理，于2017年12月10日发布 孤儿块，发布于2017年12月3日 QTUM.explorer.io合同页面:2017年11月26日发布 SHA256哈希算法和难度，于2017年11月20日发布 “钱包赢得座位奖励”的分发，2017年11月12日发布 SHA256哈希算法，目标和难度，于2017年11月5日发布 Qtum 采矿权益证明的介绍 - 赛车故事，关于PoS采矿的ELI5故事。2017年10月29日发布 基础的钱包离场，2017年10月29日发布 非官方赌注常见问题解答，2017年10月26日发布 网络权重，奖励时间，Nodemap，2017年10月22日发布 模拟 Qtum 采矿权益证明，2017年10月21日发布 用于PoS挖掘的早期模拟器 Stake 采矿的Qtum证明，2017年10月16日发布 Qtum 主网点火结果10月9日至15日，主网图表和图表介绍，于2017年10月15日发布 另一个糟糕的杰克逊笑话。 在 Excel 中没有 FINDNEEDLE 函数，但是这些公式对于使用 E 列中的块事务 ID 和 F 列中的块号加载的 debug.log 数据工作得很好。使用字符串函数来提取事务 ID 和块号： 12=IF(FIND(“height”, F2),MID(F2, 8, 6)) — extract the block number=IF(FIND(“height”, F2),MID(E, 6, 64)) — extract the transaction ID “孤儿”不是这些块最好的名词。 孤儿块有父母，我们知道孤儿块的父母，但他们没有孩子。 我认为一个更好的术语是 Freemartin。 显然，Satoshi 不是一个行话。 比特币孤儿块显示在 blockchain.info 上 百老汇音乐剧安妮开幕之夜是1977年4月21日在纽约市的阿尔文剧院。 制作有2,377场演出，并于1983年1月2日结束。 孤儿研究的音乐，Aileen Quinn 在 1982 年的电影“安妮”中演唱“明日”。 明天太阳会出现，明天你会赢得奖励奖励。 Spotify 专辑链接，Annie：百老汇音乐剧 30 周年演员录音 纽约无人机航班，4k观看","categories":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/tags/区块链/"},{"name":"Qtum","slug":"Qtum","permalink":"http://xichen.pub/tags/Qtum/"},{"name":"翻译","slug":"翻译","permalink":"http://xichen.pub/tags/翻译/"}]},{"title":"【Android TimeCat】 反编译","slug":"2018-04-11-Android-TimeCat-反编译","date":"2018-04-11T06:11:00.000Z","updated":"2019-04-01T15:18:44.216Z","comments":true,"path":"2018/04/11/2018-04-11-Android-TimeCat-反编译/","link":"","permalink":"http://xichen.pub/2018/04/11/2018-04-11-Android-TimeCat-反编译/","excerpt":"","text":"背景需要参考一些好的项目，但是并没有开源，自己写是不会写的，这辈子都不会写的，抄又不能直接抄，只有靠反编译才能维持得了生活这样子。。。 神操作在线反编译：http://www.javadecompilers.com/apk 常规操作APK AnalyzerAndroid Studio 自带的 APK Analyzer 可直接查看APK内的 图片，xml内容，dex结构，文件尺寸等，还可以比较两个apk的差异。 虽然不能导出资源有点可惜，但已经很强大方便了。 用法：将 apk 拖入 AndroidStudio 就好了 参考：developer.android.com/studio/buil… 常用三件套安装javaWindows环境下JDK安装与环境变量配置详细的图文教程 下载工具 apktool：资源文件获取，可以提取出图片文件和布局文件进行使用查看下载地址：https://ibotpeaches.github.io/Apktool/Mac下载地址：http://mac.softpedia.com/get/Developer-Tools/Apktool.shtml dex2jar：将apk反编译成java源码（classes.dex转化成jar文件）下载地址：https://github.com/pxb1988/dex2jarMac下载地址：http://mac.softpedia.com/get/Developer-Tools/dex2jar.shtml jd-gui：查看APK中classes.dex转化成出的jar文件，即源码文件下载地址：https://code.google.com/archive/p/innlab/downloadsMac下载地址：http://mac.softpedia.com/get/Development/Java/JD-GUI.shtml 注：有个合集，更加傻瓜化的工具onekey-decompile-apk：https://github.com/ufologist/onekey-decompile-apk把apk拖到文件目录下就能直接反编译了 其实一些常见工具都可以通过 homebrew 或 homebrew-cask 安装12345brew install apktoolbrew install smalibrew install dex2jarbrew install jadxbrew cask install jd-gui 使用apktoolapk 虽然实际上是个 zip 可以直接 unzip，但里边的 xml 都是 Binaray XML 形式，需要再次转化成 xml 才能查看。 apktool 可以将 apk 内的资源全部提取出来，同时 xml 也转化好可直接查看内容。 apktool 也可以用于在修改资源后重新打包 apk 用法：12345678// 提取资源apktool d test.apk// 提取资源并指定输出目录apktool d test.apk -o test// 重新打包apkapktool b test 参考：ibotpeaches.github.io/Apktool/ smali/baksmalibaksmali 可将 dex/odex 转成 .smali 文件集smali 可将 .smali 文件集 转成 dex/odex 注：odex 转 smali 需要相应系统的 framework，adb pull /system/framework 用法：12345678910// 将 test.dex 分解到 test 目录baksmali test.dex -o test // 将 test 目录里的 smali 文件组装到 haha.dexsmali test -o haha.dex// 获取系统 frameworkadb pull /system/framework// 将 test.odex 分解到 test 目录baksmali test.odex b framework -o test 参考: https://github.com/JesusFreke/smali/wiki下载：https://bitbucket.org/JesusFreke/smali/downloads/ dex2jardex2jar 可将 .dex 转换成 .jar 用法：12// 将 test.dex 转成 test.jar 文件d2j-dex2jar test.dex -o test.jar 参考: https://github.com/pxb1988/dex2jar下载：https://bitbucket.org/pxb1988/dex2jar/downloads/ jadxjadx 可以将 .dex/.jar/.class 文件反编译成 .java 源码jadx 也可以直接反编译 .apk 并处理好资源(binary xml -&gt; xml) jadx-gui 可视化查看工具 用法：1234567891011// 反编译 test.dex 并输出到 test 目录jadx test.dex -d test// 反编译 test.apkjadx test.apk -d test// 反编译 test.jarjadx test.jar -d test// 反编译 test.classjadx test.class -d test 参考：github.com/skylot/jadx jd-guijd-gui 可视化反编译查看 .jar 文件 参考：jd.benow.ca/ 附:Android APK中的Java代码可以被反编译到什么程度Android APK中的Java代码可以被反编译到什么程度主要看APK的加密程度。 第一种情况：无混淆无加密无加壳。直接利用Dex2jar和JD-GUI可把源码从APK里抠出来，代码逻辑清晰，基本上做到可复用，只是资源文件的引用需要计算一下。 第二种情况：混淆。通常是利用Proguard做的防护。因为是对jar做的不可逆混淆（除非有mapping），因此不能还原成原来的代码。但是代码结构，代码逻辑一致，只要花长时间对代码进行梳理一样可找准核心代码，解密方法跟第一种一致。 第三种情况：加密。这里以DexGuard为例。对于这种代码加密的方法，在程序运行中必定会进行解密，只要抽出它解密的逻辑便可。PS：我自己做过DexGuard的解密，如果用Dex2jar反编译看的话逻辑是不对的，一定要从Smali代码看。后来发现网上已经有人做了。解密的脚本：A look inside Dexguard 第四种情况：加壳。这种情况跟第三种类似。无论你怎么加壳，运行的时候必定是Dalvik可识别的Odex代码，建议直接在内存里dump出来。这里推荐Xpose的ZjDroid。脱壳教程：ZjDroid工具介绍及脱壳详细示例1234作者：Vince链接：https://www.zhihu.com/question/30723538/answer/49382019来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 引用 官方-配置 Android Studio Android Studio 设置内存大小及原理 APK 在线反编译 反编译apk的步骤 手把手教你逆向分析 Android 程序 Android逆向之旅—反编译利器Apktool和Jadx源码分析以及错误纠正","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android Studio","slug":"Android-Studio","permalink":"http://xichen.pub/tags/Android-Studio/"}]},{"title":"【Android TimeCat】 让Android-Studio快十倍","slug":"2018-04-09-Android-TimeCat-让Android-Studio快十倍","date":"2018-04-09T06:11:00.000Z","updated":"2019-04-01T15:18:44.214Z","comments":true,"path":"2018/04/09/2018-04-09-Android-TimeCat-让Android-Studio快十倍/","link":"","permalink":"http://xichen.pub/2018/04/09/2018-04-09-Android-TimeCat-让Android-Studio快十倍/","excerpt":"","text":"背景Android Studio 越用越卡，明明电脑配置不低了。。。 原因分析Android Studio 是Java写的软件，运行在Java虚拟机上，如果使用时间长，会频繁触发垃圾回收机制，导致卡顿。 解决方法配置Android Studio，给它分多点内存。给2048m应该够用了，如果不够，再来4096m. 解决思路配置Android Studio，给它分多点内存。 Android Studio 通过 Help 菜单提供对两个配置文件的访问： studio.vmoptions：自定义 Studio Java 虚拟机 (JVM) 的选项，如堆内存和缓存大小。请注意，对于 Linux 机器，此文件可能命名为 studio64.vmoptions，具体取决于您的 Android Studio 版本。 idea.properties：自定义 Android Studio 的属性，如插件文件夹路径或最大支持文件大小。 自定义 VM 选项通过 studio.vmoptions 文件，您可以自定义适用于 Android Studio 的 JVM 的选项。为了提高 Studio 的性能，最常用的调节选项是最大堆内存，但您也可以使用 studio.vmoptions 文件替换其他默认设置，如初始堆内存、缓存大小和 Java 垃圾回收开关。 要新建 studio.vmoptions 文件或打开现有文件，请执行以下步骤： 点击 Help &gt; Edit Custom VM Options。如果您之前从未编辑过适用于 Android Studio 的 VM 选项，IDE 将提示您新建一个 studio.vmoptions 文件。点击 Yes 创建文件。 此时 studio.vmoptions 文件将在 Android Studio 的编辑器窗口中打开。编辑文件以添加您自己的自定义 VM 选项。如需可自定义 JVM 选项的完整列表，请参阅 Oracle 的 Java HotSpot VM 选项页。您创建的 studio.vmoptions 文件将添加至默认 studio.vmoptions 文件，后者位于 Android Studio 安装文件夹内的 bin/ 目录中。 请注意，切勿直接编辑 Android Studio 程序文件夹内的 studio.vmoptions 文件。尽管您可以访问该文件来查看 Studio 的默认 VM 选项，但仅编辑自己的 studio.vmoptions 文件可确保您不会替换 Android Studio 的重要默认设置。因此，在您的 studio.vmoptions 文件中，请仅替换您关注的属性，使 Android Studio 可以继续使用未更改的任何属性的默认值。 最大堆内存默认情况下，Android Studio 的最大堆内存为 1280MB。如果您要处理大项目，或者您的系统有大量 RAM 可用，您可以通过在 Android Studio 的 VM 选项中增加最大堆内存来提高性能。如果系统的内存有限，您可能希望降低最大堆内存。 要更改最大堆内存，请执行以下步骤： 点击 Help &gt; Edit Custom VM Options 以打开您的 studio.vmoptions 文件。向 studio.vmoptions 文件添加一个行，使用语法 -XmxheapSize 设置最大堆内存。您选择的大小应该基于项目大小以及机器上的可用 RAM。作为基准，如果您有 4GB 以上的 RAM 和中等大小的项目，则应该将最大堆内存设置为 2GB 或更高。以下行可将最大堆内存设置为 2GB：1-Xmx2g 保存对 studio.vmoptions 文件所做的更改，然后重新启动 Android Studio 以使更改生效。 # 从AndroidStudio的启动参数了解到的下JVM的一些东西（内存使用，JIT等） 如果你使用AndroidStudio经常觉得很卡，那有可能是因为系统给AS分配的内存不够的原因。打开/Applications/Android Studio.app/Contents/bin/studio.vmoptions (Mac)，可以看到有以下配置：1-Xms128m -Xmx750m -XX:MaxPermSize=350m -XX:ReservedCodeCacheSize=96m -XX:+UseCompressedOops 这些参数分别是什么意思呢？ -Xms128m1The -Xms option sets the initial and minimum Java heap size. The Java heap (the “heap”) is the part of the memory where blocks of memory are allocated to objects and freed during garbage collection. 就是JVM启动的起始堆内存，堆内存是分配给对象的内存。这里我把它改成了512m -Xmx750m1This option sets the maximum Java heap size. 也就是AndroidStudio能使用的最大heap内存，这里我改成了2048m 这两个参数都是-X开头的，表示非标准的参数。什么叫非标准的呢？我们知道JVM有很多个实现，Oracle的，OpenJDK等等，这里的-X参数，是Oracle的JVM实现使用的，OpenJDK不一定能使用，也就是没有将这些参数标准化，让所有的JVM实现都能使用。 -XX:MaxPermSize=350m这个参数指定最大的Permanent generation大小。根据oracle的文档：1Permanent Generation (non-heap): The pool containing all the reflective data of the virtual machine itself, such as class and method objects. With Java VMs that use class data sharing, this generation is divided into read-only and read-write areas. 可知，Permanent Generation也是一块内存区域，跟heap不同，它里面存放的事类本身（不是对象），以及方法，一些固定的字符串等等。更多关于Permanent Generation -XX:ReservedCodeCacheSize=90m1ReservedCodeCacheSize (and InitialCodeCacheSize) is an option for the (just-in-time) compiler of the Java Hotspot VM. Basically it sets the maximum size for the compiler's code cache. 设置JIT java compiler在compile的时候的最大代码缓存。简单地说就是JIT（Just In Time）编译器在编译代码的时候，需要缓存一些东西，这个参数指定最多能使用多大内存来缓存这些东西。什么叫JIT呢？看wikipedia的解释：1In computing, just-in-time compilation (JIT), also known as dynamic translation, is compilation done during execution of a program – at run time – rather than prior to execution.Most often this consists of translation to machine code, which is then executed directly, but can also refer to translation to another format. JIT compilation is a combination of the two traditional approaches to translation to machine code – ahead-of-time compilation (AOT), and interpretation – and combines some advantages and drawbacks of both.[1] Roughly, JIT compilation combines the speed of compiled code with the flexibility of interpretation, with the overhead of an interpreter and the additional overhead of compiling (not just interpreting). JIT compilation is a form of dynamic compilation, and allows adaptive optimization such as dynamic recompilation – thus in principle JIT compilation can yield faster execution than static compilation. Interpretation and JIT compilation are particularly suited for dynamic programming languages, as the runtime system can handle late-bound data types and enforce security guarantees. 我们知道编程语言分两种： - 编译型，先将人写的代码整个编译成汇编语言或机器语言，一条一条代码然后执行。 - 解释型，不需要编译，将人写的代码一条一条拿过来一次执行，先取一条，执行，完了再取下一条，然后在执行。 而对于Java来说，这个情况就比较特殊了，因为在Java这里，JVM先是将Java代码整个编译成bytecode，然后在JVM内部再一条一条执行bytecode代码。你说它是编译型的吧，bytecode又不用编译成机器代码，二是一条条bytecode一次执行。你说它是解释型的吧，它又有一个编译的过程。对于Java到底是编译型还是解释型到现在也没有一个定论。不过，我们还是可以探讨一下Java的JIT编译技术。刚刚说了，在bytecode层面，代码是解释执行的。解释型的语言会比较慢，因为它没有办法根据上下文对代码进行优化。而编译型的语言则可以进行优化。Java的JIT技术，就是在bytecode解释执行的时候，它不一定是一条条解释执行的，二是取一段代码，编译成机器代码，然后执行，这样的话就有了上下文，可以对代码进行优化了，所以执行速度也会更快。可见，JIT技术结合了编译型（速度更快）和解释型语言（代码更灵活）二者的优势。对于动态语言的执行来说，是一个非常大的优势。 -XX:+UseCompressedOops这个参数允许系统将代码里面的引用(reference)类型用32位存储，同时却能够让引用能够使用64位的内存大小。我们知道现代的机器基本都是64位的，在这种情况下，Java代码里面的reference类型也变成了用64位来存储，这就导致了两个问题： 64位比32为更大，占的内存更多，这是显然的，当然这个问题在整个程序看来根本不显然，因为哪怕系统同时有1000个引用存在，那多出来的内存也就4M，这个不重要，因为现在手机都动不动好几个G，大型服务器就更加不用说了。更重要的是第二点。 相对于内存，CPU的cache就小的可怜了，当reference从32bit变成64bit时，cache里面能存放的reference数量就顿时少了很多。所以64bit的reference对cache是个大问题，于是就有了这个选项，可以允许系统用32bit来存储reference，让cache里面能存放更多的reference，同时又不影响reference的取址范围。至于他们是怎么做到的，我就不得而知了。。。 以上三个参数是以-XX开头的，根据Oracle的说明，1Options that are specified with -XX are not stable and are subject to change without notice. 引用 官方-配置 Android Studio Android Studio 设置内存大小及原理 Configuring JVM options and platform properties JVM系列三:JVM参数设置、分析","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android Studio","slug":"Android-Studio","permalink":"http://xichen.pub/tags/Android-Studio/"}]},{"title":"【Android TimeCat】 解决cannot resolve symbol R","slug":"2018-04-08-Android-TimeCat-解决cant-resolve-symbol-R","date":"2018-04-08T06:11:00.000Z","updated":"2019-04-01T15:18:44.213Z","comments":true,"path":"2018/04/08/2018-04-08-Android-TimeCat-解决cant-resolve-symbol-R/","link":"","permalink":"http://xichen.pub/2018/04/08/2018-04-08-Android-TimeCat-解决cant-resolve-symbol-R/","excerpt":"","text":"背景莫名其妙出现了，鬼知道怎么来的。 解决方法总结1. 推荐解决90%的情况： Build-&gt;Clean ProjectBuild-&gt;Rebuild Project 2. 不常见Android Studio 有个奇葩的设置。。 欸，来搞一下分配的空间就行了。 打开ide配置 填入idea.max.intellisense.filesize=99999999 清缓存然后重启Android Studio 引用 “cannot resolve symbol R” in Android Studio 官方-配置 Android Studio File size exceeds configured limit (2560000), code insight features not available","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android Studio","slug":"Android-Studio","permalink":"http://xichen.pub/tags/Android-Studio/"}]},{"title":"【计算机组成原理】 八大思想之抽象","slug":"2018-03-13-计算机组成原理-八大思想之抽象","date":"2018-03-12T20:11:00.000Z","updated":"2019-04-01T15:18:44.212Z","comments":true,"path":"2018/03/13/2018-03-13-计算机组成原理-八大思想之抽象/","link":"","permalink":"http://xichen.pub/2018/03/13/2018-03-13-计算机组成原理-八大思想之抽象/","excerpt":"","text":"计算机领域对我影响最大的思想是抽象。 何为抽象？抽象就是隐藏具体，暴露功能。用通俗一点的话说，抽象就是你好好做自己的事，以及知道别人能帮你干什么事，至于别人是如何帮你完成的，你没必要知道。 比如理发就是一个抽象，我想理发，我只需要知道理发师会理发就可以了，至于理发师是怎样理发的，我不用关心。当然，这个例子中我们通常喜欢选最好的理发师，这些理发师虽然都有理发的功能，但理发的速度等是有区别的，这里的区别也就是其实现的不同。甚至一个能理发的机器也是可以的，因为其也有理发的功能，虽然机器理发的具体实现有点奇怪。 目前数据结构课程中的抽象数据类型其实是抽象的具体实现。比如栈，作为使用者你只需要知道它有push、pop、isEmpty等方法，但它的底层实现到底是array还是linked list，你是不需要知道的。 抽象思想大大提高了开发者的工作效率。因为开发者只需要关注功能和组装功能，完成需求就行了。用行话就是不用重复造轮子。。。不过要提升自己，最好还是做个创造者，走进轮子内部，学习具体的实现，而不是只会搬砖。。 事实上，抽象可以放到人类社会的方方面面，上面理发是一个例子。各行各业都是抽象的，比如软件开发，也是提供接口给人类使用；比如平面设计，也是提供一个看的接口；比如学校、人民教师、官员等等，一步一步抽象下去，最后都是提供了为人民服务的接口。。。","categories":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"http://xichen.pub/categories/计算机组成原理/"}],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"http://xichen.pub/tags/计算机组成原理/"},{"name":"八大思想","slug":"八大思想","permalink":"http://xichen.pub/tags/八大思想/"}]},{"title":"【Android TimeCat】 解决Gradle :Resolve dependencies :classpath的办法","slug":"2018-03-06-Android-TimeCat-解决Gradle-Resolvedependencies-classpath的办法","date":"2018-03-06T06:11:00.000Z","updated":"2019-04-01T15:18:44.210Z","comments":true,"path":"2018/03/06/2018-03-06-Android-TimeCat-解决Gradle-Resolvedependencies-classpath的办法/","link":"","permalink":"http://xichen.pub/2018/03/06/2018-03-06-Android-TimeCat-解决Gradle-Resolvedependencies-classpath的办法/","excerpt":"","text":"背景想学习一下别人的成型项目FastHub，结果build失败，gradle信息如下： 123456789101112131415161718192021222324252627282930Executing tasks: [assemble]Configuration on demand is an incubating feature.FAILURE: Build failed with an exception.* What went wrong:A problem occurred configuring root project 'FastHub'.&gt; Could not resolve all files for configuration ':classpath'. &gt; Could not resolve com.android.tools.build:gradle:3.2.0-alpha04. Required by: project : &gt; Could not resolve com.android.tools.build:gradle:3.2.0-alpha04. &gt; Could not get resource 'https://dl.google.com/dl/android/maven2/com/android/tools/build/gradle/3.2.0-alpha04/gradle-3.2.0-alpha04.pom'. &gt; Could not GET 'https://dl.google.com/dl/android/maven2/com/android/tools/build/gradle/3.2.0-alpha04/gradle-3.2.0-alpha04.pom'. &gt; Connect to dl.google.com:443 [dl.google.com/2404:6800:4008:c01:0:0:0:88] failed: Connection timed out: connect &gt; Could not resolve com.android.tools.build:gradle:3.2.0-alpha04. Required by: project : &gt; com.apollographql.apollo:gradle-plugin:0.4.1 &gt; Could not resolve com.android.tools.build:gradle:3.2.0-alpha04. &gt; Could not get resource 'https://dl.google.com/dl/android/maven2/com/android/tools/build/gradle/3.2.0-alpha04/gradle-3.2.0-alpha04.pom'. &gt; Could not GET 'https://dl.google.com/dl/android/maven2/com/android/tools/build/gradle/3.2.0-alpha04/gradle-3.2.0-alpha04.pom'. &gt; Connect to dl.google.com:443 [dl.google.com/2404:6800:4008:c01:0:0:0:88] failed: Connection timed out: connect* Try:Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.* Get more help at https://help.gradle.orgBUILD FAILED in 3m 18s 首先在设置&gt;proxy里使用系统默认代理，check connection 使用&#39;https://dl.google.com/dl/android/maven2/com/android/tools/build/gradle/3.2.0-alpha04/gradle-3.2.0-alpha04.pom&#39;完美通过，心想应该不是proxy的问题。可就是build失败，提示要么Connection timed out，要么unknown host: dl.google.com，简直逼疯。最后参考了一下，死马当活马医，在参考的文章里找到了解决方案。（我参考的不只下面的3个参考页面，开了一大堆csdn、StackOverflow、github issue的相关网页，都没解决，这3个是我解决时的参考，所以放这里了） 解决在项目目录下新建文件gradle.properties: 12345678910111213141516171819## Project-wide Gradle settings.## For more details on how to configure your build environment visit# http://www.gradle.org/docs/current/userguide/build_environment.html## Specifies the JVM arguments used for the daemon process.# The setting is particularly useful for tweaking memory settings.# Default value: -Xmx1024m -XX:MaxPermSize=256m# org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8## When configured, Gradle will run in incubating parallel mode.# This option should only be used with decoupled projects. More details, visit# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects# org.gradle.parallel=true#Fri Mar 09 22:26:51 CST 2018systemProp.https.proxyPort=1080systemProp.http.proxyHost=127.0.0.1systemProp.https.proxyHost=127.0.0.1systemProp.http.proxyPort=1080 内容意思是使用本地127.0.0.1:8000端口进行代理。 注意： gradle.properties与app文件夹同级，而不是在app文件夹内。 记得把shadowsocks挂到1080端口，之前的check connection没卵用。 参考 android studio 解决Gradle :Resolve dependencies :classpath的办法 Android Studio 解决resolve dependencies ‘classpath’卡住 Accessing the web through a HTTP proxy","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"Gradle","slug":"Gradle","permalink":"http://xichen.pub/tags/Gradle/"}]},{"title":"【Android TimeCat】 切换软键盘和标签键盘时界面跳动","slug":"2018-03-06-Android-TimeCat-切换软键盘和标签键盘时界面跳动","date":"2018-03-06T04:11:00.000Z","updated":"2019-04-01T15:18:44.209Z","comments":true,"path":"2018/03/06/2018-03-06-Android-TimeCat-切换软键盘和标签键盘时界面跳动/","link":"","permalink":"http://xichen.pub/2018/03/06/2018-03-06-Android-TimeCat-切换软键盘和标签键盘时界面跳动/","excerpt":"","text":"背景在信息操作页面，点击标签打开对应的选择面板时，输入界面会上下跳动一下。分析一下原因，点击标签按钮后，先收起了软键盘，当前Activity的高度变高，输入框回到了界面底部；再打开选择面板时，输入框又被顶上来，所有看起来点击标签按钮后输入框会上下跳动一下。无论是先隐藏软键盘还是先打开选择面板都会有这个问题 解决如果这时候去纠结隐藏软键盘和打开面板如何同步的话就会走进一个牛角尖，去处理不同机型之间的兼容性问题了。其实解决思路非常简单，输入框不是会上下跳么，那固定它的位置不就好了？ 举个例子，如果整个界面的根布局是LinearLayout，那么一个控件的位置其实是由它上面所有控件的高度决定的，如果它上面所有控件的高度都不变化，那即使整个Activity的高度变化（开/关软键盘）也不会影响这个控件的位置，也就不会发生跳动了。 但是我们发现，即使锁定了我们的信息操作页面根布局的高度，切换时还是有小幅度跳动。经过细致的分析冷静思考，我们终于找到了答案。由于我们的信息操作页面是用Activity通过设置弹框样式android:theme=&quot;@style/EditDialogStyle&quot;来实现的，而弹框样式是悬浮着的，会自动调整页面位置，软键盘显示时即使根布局的高度锁定，整个视图仍然会小幅度上移。所以我们的完美解决方案是同时锁定根布局高度和页面位置。 具体实现我们已经封装在SmartKeyboardManager类中，自动处理锁定高度和锁定页面位置的问题，顺便封装了addKeyboard方法来绑定按钮和相应的面板，并且使用了建造者设计模式。使用时如下调用 1234567891011121314/** * 设置软键盘和选择面板的平滑交互 */private void setKeyboardManager() &#123; mSmartKeyboardManager = new SmartKeyboardManager.Builder(this) .setContentView(ll_content_view) .setEditText(et_content) .addKeyboard(btn_label, select_label) .addKeyboard(btn_date, select_date) .addKeyboard(btn_time, select_time) .addKeyboard(btn_remind, select_remind) .addKeyboard(btn_tag, select_tag) .create();&#125; SmartKeyboardManager","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"Keyboard","slug":"Keyboard","permalink":"http://xichen.pub/tags/Keyboard/"}]},{"title":"【Android TimeCat】 原地归并排序","slug":"2018-03-01-Android-TimeCat-原地归并排序","date":"2018-03-01T04:43:00.000Z","updated":"2019-04-01T15:18:44.206Z","comments":true,"path":"2018/03/01/2018-03-01-Android-TimeCat-原地归并排序/","link":"","permalink":"http://xichen.pub/2018/03/01/2018-03-01-Android-TimeCat-原地归并排序/","excerpt":"","text":"背景Time Cat中有个需求，需要把用户的task排序。 排序规则为，先按label排，每个label下按创建日期排，task处于完成状态的话覆盖原来label。label有四个，重要紧急，重要不紧急，紧急不重要，不重要不紧急。label加上完成状态共5组。 实现思路是先用桶排序分组，再对每个组内用原地归并排序。 考虑到分组有且只有5组，用桶排序逻辑清晰，易于阅读，效率也高。 之所以用原地归并排序，是因为我想学(zhuang)习(bi)。用其他排序方法也是可以的，因为单个用户的task不会太多，而且排序放在网络请求之后，各种排序方法的差别不大。 纯java版原地归并排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* * 原地归并 */public class InPlaceMergeSort &#123; private static void reverse(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i++] = arr[j]; arr[j--] = temp; &#125; // swap [bias, bias+headSize) and [bias+headSize, bias+headSize+endSize) private static void swapAdjacentBlocks(int arr[], int bias, int oneSize, int anotherSize) &#123; reverse(arr, bias, bias + oneSize - 1); reverse(arr, bias + oneSize, bias + oneSize + anotherSize - 1); reverse(arr, bias, bias + oneSize + anotherSize - 1); &#125; private static void inplaceMerge(int arr[], int l, int mid, int r) &#123; int i = l; // 指示左侧有序串 int j = mid + 1; // 指示右侧有序串 while(i &lt; j &amp;&amp; j &lt;= r) &#123;//原地归并结束的条件。 while(i &lt; j &amp;&amp; arr[i] &lt;= arr[j]) &#123; i++; &#125; int index = j; while(j &lt;= r &amp;&amp; arr[j] &lt;= arr[i]) &#123; j++; &#125; swapAdjacentBlocks(arr, i, index-i, j-index); i += (j-index); &#125; &#125; public static void mergeSort(int arr[], int l, int r) &#123; if(l &lt; r) &#123; int mid = (l + r) / 2; mergeSort(arr, l, mid); mergeSort(arr, mid + 1, r); inplaceMerge(arr, l, mid, r); &#125; &#125; private static void print(int[] arr) &#123; for (int i : arr) &#123; System.out.print(i+\", \"); &#125; System.out.println(); &#125; /* 测试用例 */ public static void main(String[] args) &#123; int[] arr = &#123;3,5,1,7,0,6,9,11&#125;; mergeSort(arr, 0, arr.length-1); print(arr); &#125;&#125; 纯java版非原地归并排序12345678910111213141516171819202122232425262728293031private static void merge(int[] dest, int[] src, int l, int mid, int r) &#123; int i = l; int p = l; int q = mid + 1; while (p &lt;= mid &amp;&amp; q &lt;= r) &#123; if (src[p] &lt;= src[q]) &#123; dest[i++] = src[p++]; &#125; else &#123; dest[i++] = src[q++]; &#125; &#125; while (p &lt;= mid) &#123; dest[i++] = src[p++]; &#125; while (q &lt;= r) &#123; dest[i++] = src[q++]; &#125; // （原[l, r]范围的内容被复制回原数组） i = l; while (i &lt;= r) &#123; src[i] = dest[i++]; &#125; &#125;public static void mergeSort(int[] dest, int[] src, int l, int r) &#123; if (l &lt; r) &#123; int mid = (l + r) / 2; mergeSort(dest, src, l, mid); mergeSort(dest, src, mid + 1, r); merge(dest, src, l, mid, r); &#125;&#125; 项目运用版 ：桶排序 + 原地归并排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293private ArrayList&lt;DBTask&gt; sort(ArrayList&lt;DBTask&gt; taskArrayList) &#123; ArrayList&lt;DBTask&gt; sortedDBTaskList = new ArrayList&lt;&gt;(); if (taskArrayList == null || taskArrayList.size() &lt;= 0) &#123; return sortedDBTaskList; &#125; ArrayList&lt;DBTask&gt; label_0_DBTaskList = new ArrayList&lt;&gt;(); ArrayList&lt;DBTask&gt; label_1_DBTaskList = new ArrayList&lt;&gt;(); ArrayList&lt;DBTask&gt; label_2_DBTaskList = new ArrayList&lt;&gt;(); ArrayList&lt;DBTask&gt; label_3_DBTaskList = new ArrayList&lt;&gt;(); ArrayList&lt;DBTask&gt; finished_DBTaskList = new ArrayList&lt;&gt;(); for (DBTask dbTask : taskArrayList) &#123; if (dbTask.getIsFinish()) &#123; finished_DBTaskList.add(dbTask); continue; &#125; switch (dbTask.getLabel()) &#123; case DBTask.LABEL_IMPORTANT_URGENT: label_0_DBTaskList.add(dbTask); break; case DBTask.LABEL_IMPORTANT_NOT_URGENT: label_1_DBTaskList.add(dbTask); break; case DBTask.LABEL_NOT_IMPORTANT_URGENT: label_2_DBTaskList.add(dbTask); break; case DBTask.LABEL_NOT_IMPORTANT_NOT_URGENT: label_3_DBTaskList.add(dbTask); break; &#125; &#125; mergeSort2List(label_0_DBTaskList, sortedDBTaskList); mergeSort2List(label_1_DBTaskList, sortedDBTaskList); mergeSort2List(label_2_DBTaskList, sortedDBTaskList); mergeSort2List(label_3_DBTaskList, sortedDBTaskList); mergeSort2List(finished_DBTaskList, sortedDBTaskList); return sortedDBTaskList;&#125;private void reverse(ArrayList&lt;DBTask&gt; arr, int i, int j) &#123; while(i &lt; j) &#123; DBTask temp = arr.get(i); arr.set(i++, arr.get(j)); arr.set(j--, temp); &#125;&#125;// swap [bias, bias+headSize) and [bias+headSize, bias+headSize+endSize)private void swapAdjacentBlocks(ArrayList&lt;DBTask&gt; arr, int bias, int oneSize, int anotherSize) &#123; reverse(arr, bias, bias + oneSize - 1); reverse(arr, bias + oneSize, bias + oneSize + anotherSize - 1); reverse(arr, bias, bias + oneSize + anotherSize - 1);&#125;private void inplaceMerge(ArrayList&lt;DBTask&gt; arr, int l, int mid, int r) &#123; int i = l; // 指示左侧有序串 int j = mid + 1; // 指示右侧有序串 while(i &lt; j &amp;&amp; j &lt;= r) &#123; //原地归并结束的条件。 while(i &lt; j &amp;&amp; isValid(arr, i, j)) &#123; i++; &#125; int index = j; while(j &lt;= r &amp;&amp; isValid(arr, j, i)) &#123; j++; &#125; swapAdjacentBlocks(arr, i, index-i, j-index); i += (j-index); &#125;&#125;private boolean isValid(ArrayList&lt;DBTask&gt; arr, int i, int j) &#123; Date date_i = TimeUtil.formatGMTDateStr(arr.get(i).getCreated_datetime()); Date date_j = TimeUtil.formatGMTDateStr(arr.get(j).getCreated_datetime()); return (date_i != null ? date_i.getTime() : 0) &lt;= (date_j != null ? date_j.getTime() : 0);&#125;private void mergeSort(ArrayList&lt;DBTask&gt; arr, int l, int r) &#123; if(l &lt; r) &#123; int mid = (l + r) / 2; mergeSort(arr, l, mid); mergeSort(arr, mid + 1, r); inplaceMerge(arr, l, mid, r); &#125;&#125;private void mergeSort2List(ArrayList&lt;DBTask&gt; taskArrayList, ArrayList&lt;DBTask&gt; result) &#123; if (taskArrayList == null || taskArrayList.size() &lt;= 0) &#123; return; &#125; mergeSort(taskArrayList, 0, taskArrayList.size()-1); result.addAll(taskArrayList);&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://xichen.pub/tags/Algorithm/"}]},{"title":"【Android TimeCat】 给刷新按钮添加旋转动画","slug":"2018-03-01-Android-TimeCat-给刷新按钮添加旋转动画","date":"2018-03-01T04:11:00.000Z","updated":"2019-04-01T15:18:44.208Z","comments":true,"path":"2018/03/01/2018-03-01-Android-TimeCat-给刷新按钮添加旋转动画/","link":"","permalink":"http://xichen.pub/2018/03/01/2018-03-01-Android-TimeCat-给刷新按钮添加旋转动画/","excerpt":"","text":"背景本着用户的动作反馈原则，给刷新按钮添加旋转动画。 实现思路是给原来的按钮上面覆盖一层view来承担动画效果，点击按钮时，覆盖的view显示并旋转，此时按钮被覆盖处于不可点击状态；当动画完成时隐藏覆盖的view，按钮又可以被点击了。需要计算动画时间来及时把动画停掉，我采用postdelay解决。 res/menu/main.xml123456789&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\" &gt; &lt;item android:id=\"@+id/refresh\" android:icon=\"@drawable/ic_action_refresh\" android:showAsAction=\"always\"&gt; &lt;/item&gt;&lt;/menu&gt; res/layout/action_view.xml12345678910&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;ImageView xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center\" android:minHeight=\"24dp\" android:minWidth=\"24dp\" android:paddingEnd=\"12dp\" android:paddingStart=\"12dp\" android:scaleType=\"centerInside\"/&gt; res/anim/refresh.xml设置一秒绕中心旋转720度的动画，这样动画重复次数取1，不用重复 12345678&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;rotate xmlns:android=\"http://schemas.android.com/apk/res/android\" android:duration=\"1000\" android:fromDegrees=\"0\" android:interpolator=\"@android:anim/linear_interpolator\" android:pivotX=\"50%\" android:pivotY=\"50%\" android:toDegrees=\"720\" /&gt; MainActivity.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class MainActivity extends Activity &#123; protected MenuItem refreshItem; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.main, menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.refresh: showRefreshAnimation(item); return true; default: return super.onOptionsItemSelected(item); &#125; &#125; @SuppressLint(\"NewApi\") private void showRefreshAnimation(MenuItem item) &#123; hideRefreshAnimation(); //清空之前的效果 refreshItem = item; //这里使用一个ImageView设置成MenuItem的ActionView，这样我们就可以使用这个ImageView显示旋转动画了 ImageView refreshActionView = (ImageView) getLayoutInflater().inflate(R.layout.action_view, null); refreshActionView.setImageResource(R.drawable.ic_autorenew_white_24dp); refreshItem.setActionView(refreshActionView); //显示刷新动画 Animation animation = AnimationUtils.loadAnimation(this, R.anim.refresh); animation.setRepeatMode(Animation.RESTART); animation.setRepeatCount(1); // 这里设置动画重复次数 refreshActionView.startAnimation(animation); new Handler().postDelayed(new Runnable() &#123; @Override public void run() &#123; hideRefreshAnimation(); &#125; &#125;, 1000); // 在动画xml文件里定义了动画时长为1秒，而动画重复次数为1次，所以在1秒后停止动画即可防止过度点击。 &#125; @SuppressLint(\"NewApi\") private void hideRefreshAnimation() &#123; if (refreshItem != null) &#123; View view = refreshItem.getActionView(); if (view != null) &#123; view.clearAnimation(); refreshItem.setActionView(null); &#125; &#125; &#125;&#125; 在项目中的应用 refresh.xml action_view.xml main_menu.xml MainActivity.java","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"Animation","slug":"Animation","permalink":"http://xichen.pub/tags/Animation/"}]},{"title":"【Android TimeCat】 MVP架构演进","slug":"2018-02-28-Android-TimeCat-MVP架构演进","date":"2018-02-27T23:42:00.000Z","updated":"2019-04-01T15:18:44.205Z","comments":true,"path":"2018/02/28/2018-02-28-Android-TimeCat-MVP架构演进/","link":"","permalink":"http://xichen.pub/2018/02/28/2018-02-28-Android-TimeCat-MVP架构演进/","excerpt":"","text":"背景我就想看看MVP怎么搞… 分层架构…ui/fragment/NotesFragment.java 代码行数：~290 文件目录结构：1NotesFragment.java 优点： 业务分层，把fragment的初始化分成initView(), initData(), initListener() 功能分区，按View, Data, Listener,在fragment文件内部分区，用注释隔开，简单易懂 缺点： fragment持有内部类 数据的刷新需要context, 应该做到数据与状态无关，易于复用 fragment管的东西太多 基础MVP架构…ui/fragment/notes/view/NotesFragment.java 代码行数：~160 目录结构：123456789101112notes├── model│ ├── NotesDataManagerAction.java│ └── NotesDataManager.java├── presenter│ ├── NotesPresenterAction.java│ └── NotesPresenter.java└── view ├── CardStackViewAdapter.java ├── ColorItemViewHolder.java ├── NotesFragmentAction.java └── NotesFragment.java 优点： 数据（model）和UI（view）解耦，双方都只暴露接口给presenter，由presenter决定数据和UI的互动 NotesFragment只作为view层，下放业务处理能力给presenter，使代码量大量减少（实际是转移给presenter，没有减少） NotesFragment不再持有内部类，加载速度增加 在数据层去掉context，使data与view相互独立 缺点： 没有绑定view，presenter可能在fragment销毁后仍有其引用，导致内存泄漏 NotesFragment里除了需要显示的view的初始化就都是接口的具体实现，对新手不友好 高级MVP架构…ui/fragment/notes/view/NotesFragment.java 代码行数：~160 目录结构：12345678910notes/├── model│ └── NotesDataManager.java├── presenter│ └── NotesPresenter.java└── view ├── CardStackViewAdapter.java ├── ColorItemViewHolder.java ├── NotesFragmentAction.java └── NotesFragment.java 优点： 高度抽象，减少代码冗余（比如绑定view） 使用代理模式将绑定和解绑view的操作抽离出来 使用工厂模式和注解在上层统一创建Presenter 将Presenter的创建过程放入到获取Presenter的方法中，如果存在返回，不存在创建，保证Presenter不会为空，保证在使用的时候再创建，节省内存资源 删除不必要的接口文件，用分区的方法突出类内可调用的业务处理函数 总的来说就是耐操 缺点： 新手不友好，依赖注入设计模式等操作有一定的复杂度 MVP固有缺点：每条逻辑都要有完全不同的presenter来管理 添加多个presenter麻烦","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"http://xichen.pub/tags/MVP/"}]},{"title":"【Android TimeCat】 RecyclerView的卡顿问题","slug":"2018-02-27-Android-TimeCat-RecyclerView的卡顿问题","date":"2018-02-27T00:12:00.000Z","updated":"2019-04-01T15:18:44.202Z","comments":true,"path":"2018/02/27/2018-02-27-Android-TimeCat-RecyclerView的卡顿问题/","link":"","permalink":"http://xichen.pub/2018/02/27/2018-02-27-Android-TimeCat-RecyclerView的卡顿问题/","excerpt":"","text":"背景Time Cat中大量使用了RecycleView和折叠结构，虽然便于用户交互，但同时也使性能成为一个问题。 RecyclerView为什么会卡RecyclerView作为v7包的新控件，自从推出就广受Android Developer们欢迎，实际上它已经取代了ListView和GridView两位老前辈的地位。然而不少亲们想必也已经发现了：没有优化过的Recycler性能很poor。上一篇博主使用的item也仅仅是一个图两串字而已，结果一滑动就卡的要命，不能忍！那么why？回想在用ListView和GridView的adapter时，我们是用一种叫ViewHolder的自定义类（容器）来实现优化的，而RecyclerView的特性之一就是强制你使用它的RecyclerView.ViewHolder。可是，RecyclerView.ViewHolder要比我们写的那个单纯的容器复杂多了（源码里算上注释有大约500行），与RecyclerView.Adapter的联系也是千丝万缕。 按stackoverflow上面比较通俗的解释：RecyclerView.Adapter里面的onCreateViewHolder()方法和onBindViewHolder()方法对时间都非常敏感。类似I/O读写，Bitmap解码一类的耗时操作，最好不要在它们里面进行。 如何解决卡顿问题首先当然得优化你的item，合理运用&lt;include&gt;，&lt;merge&gt;，&lt;ViewStub&gt;等标签，使布局层次尽量少——其实ListView和GridView里你也应该这么做，应该当成是一种写UI的习惯。 其次就是灵活使用各种第三方库，去完成各种耗时操作，比如通过Glide或者是Picasso加载图片。优秀的开源库在性能上往往都考虑得很仔细。 最后的问题来了，如果只想写一个小demo，不愿大张旗鼓怎么办？如果即便一般的第三方库也不好解决问题，比如上一篇那个该死的loadIcon()方法返回的是一个Drawable对象，Glide和Picasso都没法直接处理，转码又等于添了个耗时任务，那怎么办？真正的app管理应用，应该引入UIL或者Picasso一类的加载库进行图标加载（在此原谅博主没仔细敲代码，就信口开河了）答案就是，想法在你setAdapter之前就把任务给完成。 TimeCat 实例1234567891011public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; context = getContext(); View view = inflater.inflate(R.layout.fragment_notes, container, false); mStackView = view.findViewById(R.id.notes_csv); // 初始化RecycleView cardStackViewAdapter = new CardStackViewAdapter(context); // 初始化Adapter refreshData(); // 刷新一次数据 mStackView.setAdapter(cardStackViewAdapter); // 在数据准备好后再setAdapter() return view;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"RecycleView","slug":"RecycleView","permalink":"http://xichen.pub/tags/RecycleView/"}]},{"title":"【Android TimeCat】 当RxJava遇到Retrofit（二）api注解@Path, @Url等","slug":"2018-02-27-Android-TimeCat-当RxJava遇到Retrofit（二）api注解@Path, @Url等","date":"2018-02-26T08:12:00.000Z","updated":"2019-04-01T15:18:44.204Z","comments":true,"path":"2018/02/26/2018-02-27-Android-TimeCat-当RxJava遇到Retrofit（二）api注解@Path, @Url等/","link":"","permalink":"http://xichen.pub/2018/02/26/2018-02-27-Android-TimeCat-当RxJava遇到Retrofit（二）api注解@Path, @Url等/","excerpt":"","text":"背景下面分为GET、POST、DELETE还有PUT的请求，说明@Path、@Query、@QueryMap、@Body、@Field的用法。 初始化Retrofit1234String BASE_URL = \"http://192.168.88.105:8000/api/\";Retrofit retrofit = new Retrofit.Builder() .baseUrl(BASE_URL) .build(); GET样式1（一个简单的get请求）http://192.168.88.105:8000/api/News12@GET(\"News\")Call&lt;NewsBean&gt; getItem(); 样式2（URL中有参数）http://192.168.88.105:8000/api/News/1http://192.168.88.105:8000/api/News/{资讯id}123@GET(\"News/&#123;newsId&#125;\")Call&lt;NewsBean&gt; getItem(@Path(\"newsId\") String newsId); 或http://192.168.88.105:8000/api/News/1/类型1http://192.168.88.105:8000/api/News/{资讯id}/{类型} 12@GET(\"News/&#123;newsId&#125;/&#123;type&#125;\")Call&lt;NewsBean&gt; getItem(@Path(\"newsId\") String newsId， @Path(\"type\") String type); 样式3（参数在URL问号之后）http://192.168.88.105:8000/api/News?newsId=1http://192.168.88.105:8000/api/News?newsId={资讯id} 12@GET(\"News\")Call&lt;NewsBean&gt; getItem(@Query(\"newsId\") String newsId); 或http://192.168.88.105:8000/api/News?newsId=1&amp;type=类型1http://192.168.88.105:8000/api/News?newsId={资讯id}&amp;type={类型} 12@GET(\"News\")Call&lt;NewsBean&gt; getItem(@Query(\"newsId\") String newsId， @Query(\"type\") String type); 样式4（多个参数在URL问号之后，且个数不确定）http://192.168.88.105:8000/api/News?newsId=1&amp;type=类型1…http://192.168.88.105:8000/api/News?newsId={资讯id}&amp;type={类型}… 12@GET(\"News\")Call&lt;NewsBean&gt; getItem(@QueryMap Map&lt;String, String&gt; map); 也可以 1234@GET(\"News\")Call&lt;NewsBean&gt; getItem( @Query(\"newsId\") String newsId， @QueryMap Map&lt;String, String&gt; map); POST样式1（需要补全URL，post的数据只有一条reason）http://192.168.88.105:8000/api/Comments/1http://192.168.88.105:8000/api/Comments/{newsId} 12345@FormUrlEncoded@POST(\"Comments/&#123;newsId&#125;\")Call&lt;Comment&gt; reportComment( @Path(\"newsId\") String commentId, @Field(\"reason\") String reason); 样式2（需要补全URL，问号后加入access_token，post的数据只有一条reason）http://192.168.88.105:8000/api/Comments/1?access_token=1234123http://192.168.88.105:8000/api/Comments/{newsId}?access_token={access_token} 123456@FormUrlEncoded@POST(\"Comments/&#123;newsId&#125;\")Call&lt;Comment&gt; reportComment( @Path(\"newsId\") String commentId, @Query(\"access_token\") String access_token, @Field(\"reason\") String reason); 样式3（需要补全URL，问号后加入access_token，post一个body（对象））http://192.168.88.105:8000/api/Comments/1?access_token=1234123http://192.168.88.105:8000/api/Comments/{newsId}?access_token={access_token} 12345@POST(\"Comments/&#123;newsId&#125;\")Call&lt;Comment&gt; reportComment( @Path(\"newsId\") String commentId, @Query(\"access_token\") String access_token, @Body CommentBean bean); DELETE样式1（需要补全URL）http://192.168.88.105:8000/api/Comments/1http://192.168.88.105:8000/api/Comments/{commentId} 123@DELETE(\"Comments/&#123;commentId&#125;\")Call&lt;ResponseBody&gt; deleteNewsCommentFromAccount( @Path(\"commentId\") String commentId); 样式2（需要补全URL，问号后加入access_token）http://192.168.88.105:8000/api/Comments/1?access_token=1234123http://192.168.88.105:8000/api/Comments/{commentId}?access_token={access_token} 1234@DELETE(\"Comments/&#123;commentId&#125;\")Call&lt;ResponseBody&gt; deleteNewsCommentFromAccount( @Path(\"commentId\") String commentId， @Query(\"access_token\") String access_token); 样式3（带有body）http://192.168.88.105:8000/api/Comments 12345@HTTP(method = \"DELETE\",path = \"Comments\",hasBody = true)Call&lt;ResponseBody&gt; deleteCommont( @Body CommentBody body );CommentBody：需要提交的内容，与Post中的Body相同 PUT（这个请求很少用到，例子就写一个）http://192.168.88.105:8000/api/Accounts/1http://192.168.88.105:8000/api/Accounts/{accountId} 12345@PUT(\"Accounts/&#123;accountId&#125;\")Call&lt;ExtrasBean&gt; updateExtras( @Path(\"accountId\") String accountId, @Query(\"access_token\") String access_token, @Body ExtrasBean bean); 总结 @Path：所有在网址中的参数（URL的问号前面），如：http://192.168.88.105:8000/api/Accounts/{accountId} @Query：URL问号后面的参数，如：http://192.168.88.105:8000/api/Comments?access_token={access_token} @QueryMap：相当于多个@Query @Field：用于POST请求，提交单个数据 @Body：相当于多个@Field，以对象的形式提交 Tips Tips1 使用@Field时记得添加@FormUrlEncoded Tips2 若需要重新定义接口地址，可以使用@Url，将地址以参数的形式传入即可。如123456@GETCall&lt;List&lt;Activity&gt;&gt; getActivityList( @Url String url, @QueryMap Map&lt;String, String&gt; map);Call&lt;List&lt;Activity&gt;&gt; call = service.getActivityList( \"http://115.159.198.162:3001/api/ActivitySubjects\", map); 参考https://www.jianshu.com/p/7687365aa946https://www.jianshu.com/p/6b3daeda1eed","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://xichen.pub/tags/Retrofit/"}]},{"title":"【Android TimeCat】 当RxJava遇到Retrofit（一）Retrofit入门","slug":"2018-02-27-Android-TimeCat-当RxJava遇到Retrofit（一）Retrofit入门","date":"2018-02-26T07:37:00.000Z","updated":"2019-04-01T15:18:44.203Z","comments":true,"path":"2018/02/26/2018-02-27-Android-TimeCat-当RxJava遇到Retrofit（一）Retrofit入门/","link":"","permalink":"http://xichen.pub/2018/02/26/2018-02-27-Android-TimeCat-当RxJava遇到Retrofit（一）Retrofit入门/","excerpt":"","text":"背景在Time Cat项目开发过程中，我们尝试过很多网络请求库。基本点的就是原生的http请求框架，好比HttpClient以及HttpUrlConnection等，略懂android开发的估计无人不知android-async-http或者volley啥的，再往上走，有okhttp等。但是最后我们选择了一个新的http请求框架，Retrofit。 Retrofit简介retrofit是Square公司出品的，为android和java提供一个类型安全的Http网络请求库，这里是官网地址。 Retrofit的优点 使用注解来描述http请求 URL参数的替换和query参数的支持 对象转化为请求体（如：JSON，protocol buffers等） 多重请求体和文件上传以上都是官网描述 TimeCat中的实例定义接口1234567// NoteService.javapublic interface NoteService &#123; @Headers(&#123;\"Content-Type: application/json\", \"Accept: application/json\"&#125;) @POST(\"/notes/\") Observable&lt;Note&gt; createNote(@Body Note note);&#125; 辅助使用Retrofit12345678910111213141516171819202122232425262728293031323334353637// RetrofitHelper.javapublic class RetrofitHelper &#123; private static final String BASE_URL = \"http://192.168.88.105:8000/\"; private static OkHttpClient mOkHttpClient; static &#123; initOkHttpClient(); &#125; /** * 初始化OKHttpClient * 设置缓存 * 设置超时时间 * 设置打印日志 * 设置UA拦截器 */ private static void initOkHttpClient() &#123; HttpLoggingInterceptor interceptor = new HttpLoggingInterceptor(new Log()); interceptor.setLevel(HttpLoggingInterceptor.Level.BODY); if (mOkHttpClient == null) &#123; synchronized (RetrofitHelper.class) &#123; if (mOkHttpClient == null) &#123; //设置Http缓存 Cache cache = new Cache(new File(TimeCatApp.getInstance().getCacheDir(), \"HttpCache\"), 1024 * 1024 * 100); mOkHttpClient = new OkHttpClient.Builder().cache(cache).addInterceptor(interceptor).retryOnConnectionFailure(true).connectTimeout(30, TimeUnit.SECONDS).writeTimeout(20, TimeUnit.SECONDS).readTimeout(20, TimeUnit.SECONDS).build(); &#125; &#125; &#125; &#125; public static NoteService getNoteService() &#123; Retrofit retrofit = new Retrofit.Builder() .baseUrl(BASE_URL) .client(mOkHttpClient) .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .addConverterFactory(GsonConverterFactory.create()) .build(); return retrofit.create(NoteService.class); &#125;&#125; 结合RxJava发起网络请求只需要1234567891011121314151617181920212223242526272829303132RetrofitHelper.getNoteService().createNote(note) //获取Observable对象 .compose(this.bindToLifecycle()) // 绑定到生命周期 .subscribeOn(Schedulers.newThread()) //请求在新的线程中执行 .observeOn(Schedulers.io()) //请求完成后在io线程中执行 .doOnNext(new Action1&lt;Note&gt;() &#123; @Override public void call(Note note) &#123; DB.notes().saveAndFireEvent(ModelUtil.toDBNote(note)); // 进行数据读写，甚至可以进行文件读写 Log.e(TAG, \"保存任务信息到本地\" + note.toString()); &#125; &#125;) .observeOn(AndroidSchedulers.mainThread())//最后在主线程中执行 .subscribe(new Subscriber&lt;Note&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; //请求失败 ToastUtil.show(\"添加[ 任务 ]失败\"); Log.e(TAG, e.toString()); &#125; @Override public void onNext(Note note) &#123; //请求成功 ToastUtil.show(\"成功添加[ 任务 ]:\" + dialog_add_task_et_content.getText().toString()); finish(); Log.e(TAG, \"请求成功\" + note.toString()); &#125; &#125;); 使用的套路权限1&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt; 这个没什么好说的，没有网络权限什么都做不了 导包12345compile 'com.squareup.retrofit2:retrofit:2.1.0'compile 'com.squareup.retrofit2:converter-gson:2.1.0'compile 'com.squareup.retrofit2:adapter-rxjava:2.1.0'compile 'com.squareup.okhttp3:logging-interceptor:3.4.1'compile 'io.reactivex:rxandroid:1.2.1' 这里几个库的含义是：我们使用retrofit2.0去进行网络请求操作，同时我们使用gson去进行数据解析，并且结合rxjava去进行相应的代码编写 基本配置123456new Retrofit.Builder() .baseUrl(BASE_URL) .client(mOkHttpClient) .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .addConverterFactory(GsonConverterFactory.create()) .build(); 这段就是使用RxJava，利用gson做解析（这边解析器可以设置注入Jackson之类的，甚至可以自定义），http引擎框架是okhttp API说明Retrofit需要通过注解请求方法以及请求参数来表明应该如何去进行一个Http请求，目前内置了5种注解方式GET、POST、PUT、DELETE以及HEAD。同时资源的相对URL要在注解中明确的指出。比如请求方法1@POST(\"/notes/\") @POST(&quot;/notes/&quot;)的意思是，用POST方法，向BASE_URL + &#39;notes/&#39; 即http://192.168.88.105:8000/notes/发起请求。注意两个斜杆，左边的/代表在BASE_URL的基础上，右边的/表示notes的实际接口，去掉其中一个都会导致不同的结果。 更多api的写法请看下一篇 参考https://www.jianshu.com/p/6b3daeda1eed","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://xichen.pub/tags/Retrofit/"}]},{"title":"【Android TimeCat】 RxJava的使用（四）线程控制 —— Scheduler","slug":"2018-02-26-Android-TimeCat-RxJava的使用（四）线程控制 —— Scheduler","date":"2018-02-26T06:59:00.000Z","updated":"2019-04-01T15:18:44.196Z","comments":true,"path":"2018/02/26/2018-02-26-Android-TimeCat-RxJava的使用（四）线程控制 —— Scheduler/","link":"","permalink":"http://xichen.pub/2018/02/26/2018-02-26-Android-TimeCat-RxJava的使用（四）线程控制 —— Scheduler/","excerpt":"","text":"背景经过前几篇的介绍，对RxJava对模式有了一定的理解：由Observable发起事件，经过中间的处理后由Observer消费。之前的代码中，事件的发起和消费都是在同一个线程中执行，也就是说之前我们使用的RxJava是同步的～～～ 观察者模式本身的目的不就是后台处理，将处理结果回调给前台？这同步的是要哪样？所以，这篇为大家介绍RxJava的重要的概念——Scheduler 介绍RxJava在不指定线程的情况下，发起时间和消费时间默认使用当前线程。所以之前的做法123456789101112131415Observable.just(student1, student2, student2) //使用map进行转换，参数1：转换前的类型，参数2：转换后的类型 .map(new Func1&lt;Student, String&gt;() &#123; @Override public String call(Student i) &#123; String name = i.getName();//获取Student对象中的name return name;//返回name &#125; &#125;) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; nameList.add(s); &#125; &#125;); 因为是在主线程中发起的，所以不管中间 map的处理还是Action1的执行都是在主线程中进行的。若是map中有耗时的操作(比如网络请求)，这样会导致主线程拥塞，这并不是我们想看到的。 SchedulerScheduler：线程控制器，可以指定每一段代码在什么样的线程中执行。模拟一个需求：新的线程发起事件，在主线程中消费12345678910private void rxJavaTest3() &#123; Observable.just(\"Hello\", \"Word\") .subscribeOn(Schedulers.newThread())//指定 subscribe() 发生在新的线程 .observeOn(AndroidSchedulers.mainThread())// 指定 Subscriber 的回调发生在主线程 .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.i(TAG, s); &#125; &#125;); 上面用到了subscribeOn()，和observeOn()方法来指定发生的线程和消费的线程。 subscribeOn()：指定subscribe() 所发生的线程，即 Observable.OnSubscribe 被激活时所处的线程。或者叫做事件产生的线程。 observeOn()：指定Subscriber 所运行在的线程。或者叫做事件消费的线程。 以及参数Scheduler，RxJava已经为我们提供了一下几个Scheduler Schedulers.immediate()：直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。 Schedulers.newThread()：总是启用新线程，并在新线程执行操作。 Schedulers.io()： I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。 Schedulers.computation()：计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。 AndroidSchedulers.mainThread()：它指定的操作将在 Android 主线程运行。 多次切换线程看完上面的介绍想必对RxJava线程的切换有了一些理解，上面只是对事件的发起和消费制定了线程。如果中间有map之类的操作呢？是否可以实现发起的线程在新线程中，map的处理在IO线程，最后的消费在主线程中。12345678910111213141516Observable.just(\"Hello\", \"Wrold\") .subscribeOn(Schedulers.newThread())//指定：在新的线程中发起 .observeOn(Schedulers.io()) //指定：在io线程中处理 .map(new Func1&lt;String, String&gt;() &#123; @Override public String call(String s) &#123; return handleString(s); //处理数据 &#125; &#125;) .observeOn(AndroidSchedulers.mainThread())//指定：在主线程中处理 .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; show(s); //消费事件 &#125; &#125;); 可以看到observeOn()被调用了两次，分别指定了map的处理的现场和消费事件show(s)的线程。 若将observeOn(AndroidSchedulers.mainThread())去掉会怎么样？不为消费事件show(s)指定线程后，show(s)会在那里执行？其实，observeOn()指定的是它之后的操作所在的线程。也就是说，map的处理和最后的消费事件show(s)都会在io线程中执行。observeOn()可以多次使用，可以随意变换线程 小结学会线程控制后才算是真正学会了使用RxJava。RxJava的使用十分灵活，想要对其熟悉使用只有一个办法，那就是多用啦，熟能生巧。 参考：https://www.jianshu.com/p/ecfb9d68d2a2http://gank.io/post/560e15be2dca930e00da1083","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"http://xichen.pub/tags/RxJava/"}]},{"title":"【Android TimeCat】 RxJava的使用（三）对象转换器——map、flatMap","slug":"2018-02-26-Android-TimeCat-RxJava的使用（三）对象转换器——map、flatMap","date":"2018-02-26T06:57:00.000Z","updated":"2019-04-01T15:18:44.194Z","comments":true,"path":"2018/02/26/2018-02-26-Android-TimeCat-RxJava的使用（三）对象转换器——map、flatMap/","link":"","permalink":"http://xichen.pub/2018/02/26/2018-02-26-Android-TimeCat-RxJava的使用（三）对象转换器——map、flatMap/","excerpt":"","text":"map在使用map之前要先说道一个接口：Func1，Func1和上一篇提到的Action1相似。Func1 和 Action的区别在于， Func1 包装的是有返回值的方法。接下来就是map的用法，看代码更直观点； 例：得到多个Student对象中的name，保存到nameList中123456789101112131415Observable.just(student1, student2, student2) //使用map进行转换，参数1：转换前的类型，参数2：转换后的类型 .map(new Func1&lt;Student, String&gt;() &#123; @Override public String call(Student i) &#123; String name = i.getName();//获取Student对象中的name return name;//返回name &#125; &#125;) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; nameList.add(s); &#125; &#125;); 可以看到Observable中原来的参数是Student对象，而最后我们需要的是name，这里使用了map来实现这一转换的过程。当然，map可以多次使用。1234567891011121314151617181920//多次使用map，想用几个用几个Observable.just(\"Hello\", \"World\") .map(new Func1&lt;String, Integer&gt;() &#123;//将String类型的转化为Integer类型的哈希码 @Override public Integer call(String s) &#123; return s.hashCode(); &#125; &#125;) .map(new Func1&lt;Integer, String&gt;() &#123;//将转化后得到的Integer类型的哈希码再转化为String类型 @Override public String call(Integer integer) &#123; return integer.intValue() + \"\"; &#125; &#125;) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.i(TAG, s); &#125; &#125;); flatMapflatMap是一个比教难理解的一个转换，在这里先假设一个需求，需要打印多个Student所学的课程。这跟之前获取Student的name又不同了，这里先确定一下关系，一个Student类中只有一个name，而一个Student却有多门课程（Course），Student我们可以理解成这样：1234567891011121314/** * 学生类 */class Student &#123; private String name;//姓名 private List&lt;Course&gt; coursesList;//所修的课程&#125;/** * 课程类 */class Course &#123; private String name;//课程名 private String id;&#125; 如果使用map来实现打印所有学生所修个课程名，实现的代码是这样的：12345678910111213141516171819202122List&lt;Student&gt; students = new ArrayList&lt;Student&gt;();students.add......Action1&lt;List&lt;Course&gt;&gt; action1 = new Action1&lt;List&lt;Course&gt;&gt;() &#123; @Override public void call(List&lt;Course&gt; courses) &#123; //遍历courses，输出cuouses的name for (int i = 0; i &lt; courses.size(); i++)&#123; Log.i(TAG, courses.get(i).getName()); &#125; &#125;&#125;;Observable.from(students) .map(new Func1&lt;Student, List&lt;Course&gt;&gt;() &#123; @Override public List&lt;Course&gt; call(Student student) &#123; //返回coursesList return student.getCoursesList(); &#125; &#125;) .subscribe(action1); 可以看到，在Action1中出现了for来循环打印课程名，使用RxJava就是为了剔除这样的嵌套结构，使得整体的逻辑性更强。这时候就可以使用flatMap了，使用flatMap实现的代码是这样的：1234567891011121314151617List&lt;Student&gt; students = new ArrayList&lt;Student&gt;();students.add......Observable.from(students) .flatMap(new Func1&lt;Student, Observable&lt;Course&gt;&gt;() &#123; @Override public Observable&lt;Course&gt; call(Student student) &#123; return Observable.from(student.getCoursesList()); &#125; &#125;) .subscribe(new Action1&lt;Course&gt;() &#123; @Override public void call(Course course) &#123; Log.i(TAG, course.getName()); &#125; &#125;); 这样就实现了跟上面代码一样的效果，看起来有点懵？确实，flatMap理解起来有点绕，刚接触flatMap的时候我也是懵逼一个。下面我将flatMap的示意图，希望能帮助理解： flatMap示意图 由上图可以看出Student1、Student2经过flatMap后，按顺序依次经历了Observable1、Observable2，分别转化为Course。最后按顺序得到Course1、Course2、Course3、Course4、Course5、Course6，其中1-3由Student1得到，4-6由Student2得到。结合代码和示意图，是不是对flatMap有了一定的理解。 注意：FlatMap对这些Observables发射的数据做的是合并(merge)操作，因此它们可能是交错的。也就说，传入的顺序可能跟出来的顺序不一样。如果要保证顺的的话，可以使用concatMap。 #其他操作符 除了map和flatMap之外，还有其他操作符以供使用。这里就不一一列举他们的用法了，其他常用的操作符如下： filter：集合进行过滤 each：遍历集合 take：取出集合中的前几个 skip：跳过前几个元素 更多操作符 参考https://www.jianshu.com/p/52cd2d514528http://gank.io/post/560e15be2dca930e00da1083","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"http://xichen.pub/tags/RxJava/"}]},{"title":"【Android TimeCat】 RxJava的使用（二）Action","slug":"2018-02-26-Android-TimeCat-RxJava的使用（二）Action","date":"2018-02-26T06:44:00.000Z","updated":"2019-04-01T15:18:44.195Z","comments":true,"path":"2018/02/26/2018-02-26-Android-TimeCat-RxJava的使用（二）Action/","link":"","permalink":"http://xichen.pub/2018/02/26/2018-02-26-Android-TimeCat-RxJava的使用（二）Action/","excerpt":"","text":"回顾例：分别打印”Hello”、” World”1234567891011121314151617Observable.just(\"Hello\", \"World\") .subscribe(new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(String s) &#123; Log.i(TAG, s); &#125; &#125;); 可以看到，我们这里只用了onNext(obj)，还有两个重写的onError(error)和onCompleted()并没有用到，这样导致我们多出了几行根本用不到的代码。于是就想能不能只写我们使用到的，其他几个没用到的就不写，这样的代码看着才舒服。接下来就是使用本次的主角Action来代替Subscriber Action上部分的代码使用Action来代替Subscriber得到的代码是这样的：1234567Observable.just(\"Hello\", \"World\") .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.i(TAG, s); &#125; &#125;); 舒服多了有没有！！ 什么是ActionAction是RxJava 的一个接口，常用的有Action0和Action1。Action0： 它只有一个方法 call()，这个方法是无参无返回值的；由于 onCompleted() 方法也是无参无返回值的，因此 Action0 可以被当成一个包装对象，将 onCompleted() 的内容打包起来将自己作为一个参数传入 subscribe() 以实现不完整定义的回调。Ation1：它同样只有一个方法 call(T param)，这个方法也无返回值，但有一个参数；与 Action0 同理，由于 onNext(T obj) 和 onError(Throwable error) 也是单参数无返回值的，因此 Action1 可以将 onNext(obj)和 onError(error) 打包起来传入 subscribe() 以实现不完整定义的回调 Action的使用定义三个对象，分别打包onNext(obj)、onError(error)、onCompleted()。1234567891011121314151617181920212223Observable observable = Observable.just(\"Hello\", \"World\");//处理onNext()中的内容Action1&lt;String&gt; onNextAction = new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.i(TAG, s); &#125;&#125;;//处理onError()中的内容Action1&lt;Throwable&gt; onErrorAction = new Action1&lt;Throwable&gt;() &#123; @Override public void call(Throwable throwable) &#123; &#125;&#125;;//处理onCompleted()中的内容Action0 onCompletedAction = new Action0() &#123; @Override public void call() &#123; Log.i(TAG, \"Completed\"); &#125;&#125;; 接下来使用subscribe重载的方法123456//使用 onNextAction 来定义 onNext()Observable.just(\"Hello\", \"World\").subscribe(onNextAction);//使用 onNextAction 和 onErrorAction 来定义 onNext() 和 onError()Observable.just(\"Hello\", \"World\").subscribe(onNextAction, onErrorAction);//使用 onNextAction、 onErrorAction 和 onCompletedAction 来定义 onNext()、 onError() 和 onCompleted()Observable.just(\"Hello\", \"World\").subscribe(onNextAction, onErrorAction, onCompletedAction); 根据实际情况使用以上的方法处理onNext(obj)、onError(error) 、onCompleted()的回调。现在有个疑问，为什么使用Action也能达到使用Subscriber的结果？进subscribe(Action1 onNext)的源码看看。 还以为有多高深，原来就是把Action对象转化成对应的Subscriber对象了。这样就不难理解为什么可以使用Action来代替Subscriber了。 重写打印”Hello”、” Wrod”的方法123456Observable.just(\"Hello\", \"Wrold\").subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.i(TAG, s); &#125;&#125;); 相比第一篇那冗长的代码，现在感觉怎么样？还是觉得代码多？确实，如果只是打印几个字符串确实还是略微复杂。不急，RxJava还有其他功能呢。 小结Action的使用为我们减少了不必要的代码，使得写出的代码看上去更加得简洁。不过就目前来看RxJava还是没有什么优势值得我们去使用，下一篇我还会介绍更多RxJava的用法。慢慢得，你就会发现使用RxJava写出来的代码看上去真的很漂亮。 参考https://www.jianshu.com/p/c7a995f3763chttp://gank.io/post/560e15be2dca930e00da1083","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"http://xichen.pub/tags/RxJava/"}]},{"title":"【Android TimeCat】 RxJava的使用（一）基本用法","slug":"2018-02-26-Android-TimeCat-RxJava的使用（一）基本用法","date":"2018-02-26T05:45:00.000Z","updated":"2019-04-01T15:18:44.193Z","comments":true,"path":"2018/02/26/2018-02-26-Android-TimeCat-RxJava的使用（一）基本用法/","link":"","permalink":"http://xichen.pub/2018/02/26/2018-02-26-Android-TimeCat-RxJava的使用（一）基本用法/","excerpt":"","text":"背景Time Cat中，网络请求是必不可少的。而网络请求最好不要放在主线程中，因为网络请求要监听服务端的回应，耗时长。所以我们一般把网络请求异步处理。异步的话我们一般有现成的 AsyncTask / Handler / View.postdelay / … , 不过，今天我们用RxJava。RxJava的本质是异步处理，RxJava的好处就在于它的简洁性，逻辑简单的时候看不出RxJava的优势，想必大家都知道在调度过程比较复杂的情况下，异步代码经常会既难写也难被读懂。这时候RxJava的优势就来了，随着程序逻辑变得越来越复杂，它依然能够保持简洁。 观察者模式首先要先介绍一下观察者模式（可能比喻的不够恰当，意思到了就好）； 观察者：监视着被观察者的行为，当被观察者某个状态改变的时候会通知观察者，观察者会执行对应的操作； 被观察者：被监视的对象，当某个状态改变的时候会通知观察者； 订阅（或注册）：将观察者和被观察者建立联系。 （很乱？来个栗子？）这里举一个我个常用的例子，点击Button后触发OnClickListener中的onClick()事件。在这个事件中他们的角色分别如下： 观察者：OnClickListener； 被观察者：Button； 订阅（或注册）：setOnClickListener()。 RxJava中的观察者模式在上面介绍了观察者模式，这里也将RxJava中的三个角色进行一下角色分配 观察者：Observer； 被观察者：Observable； 订阅（或注册）：subscribe()。 观察者Observer 即观察者，它决定事件触发的时候将有怎样的行为。 RxJava 观察者的事件回调方法除了普通事件onNext()（相当于onClick()/onEvent()）之外，还定义了两个特殊的事件：onCompleted()和onError()。 onCompleted(): 事件队列完结。RxJava 不仅把每个事件单独处理，还会把它们看做一个队列。RxJava 规定，当不会再有新的onNext()发出时，需要触发onCompleted()方法作为标志。 onError(): 事件队列异常。在事件处理过程中出异常时，onError()会被触发，同时队列自动终止，不允许再有事件发出。 在一个正确运行的事件序列中,onCompleted()和onError()有且只有一个，并且是事件序列中的最后一个。需要注意的是，onCompleted():和onError()二者也是互斥的，即在队列中调用了其中一个，就不应该再调用另一个。 被观察者Observable 即被观察者，它决定什么时候触发事件以及触发怎样的事件。可以使用create()、just(T...)、from(T[])或from(Iterable&lt;? extends T&gt;)来创建一个 Observable ，并为它定义事件触发规则。 订阅创建了Observable和Observer之后，再用subscribe()方法将它们联结起来 Talk is cheap, show me the code例：打印字符串 添加依赖 12compile 'io.reactivex:rxjava:1.0.14'compile 'io.reactivex:rxandroid:1.0.1' 依次创建观察者，被观察者，订阅 1234567891011121314151617181920212223242526272829//创建一个观察者Observer&lt;String&gt; observer = new Observer&lt;String&gt;() &#123; @Override public void onCompleted() &#123; Log.i(TAG, \"Completed\"); &#125; @Override public void onError(Throwable e) &#123; Log.i(TAG, \"Error\"); &#125; @Override public void onNext(String s) &#123; Log.i(TAG, s); &#125;&#125;;//使用Observable.create()创建被观察者Observable observable1 = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext(\"Hello\"); subscriber.onNext(\"Wrold\"); subscriber.onCompleted(); &#125;&#125;);//订阅observable1.subscribe(observer); 以上用到的都是rx包里面的，别用错了！！！123import rx.Observable;import rx.Observer;import rx.Subscriber; 上面完成了一次Rxjava的基本使用，会在log里显示Hello World。 参考https://www.jianshu.com/p/19cac3c5b106http://gank.io/post/560e15be2dca930e00da1083","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"http://xichen.pub/tags/RxJava/"}]},{"title":"【Android TimeCat】 Android抽象布局——include、merge 、ViewStub","slug":"2018-02-26-Android-TimeCat-Android抽象布局——include、merge 、ViewStub","date":"2018-02-26T03:58:00.000Z","updated":"2019-04-01T15:18:44.188Z","comments":true,"path":"2018/02/26/2018-02-26-Android-TimeCat-Android抽象布局——include、merge 、ViewStub/","link":"","permalink":"http://xichen.pub/2018/02/26/2018-02-26-Android-TimeCat-Android抽象布局——include、merge 、ViewStub/","excerpt":"","text":"背景在布局优化中，Androi的官方提到了这三种布局&lt;include /&gt;、&lt;merge /&gt;、&lt;ViewStub /&gt;，并介绍了这三种布局各有的优势，下面也是简单说一下他们的优势，以及怎么使用，记下来权当做笔记。 布局重用&lt;include /&gt;&lt;include /&gt;标签能够重用布局文件，简单的使用如下：1234567891011121314151617&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=”match_parent” android:layout_height=”match_parent” android:background=\"@color/app_bg\" android:gravity=\"center_horizontal\"&gt; &lt;include layout=\"@layout/titlebar\"/&gt; &lt;TextView android:layout_width=”match_parent” android:layout_height=\"wrap_content\" android:text=\"@string/hello\" android:padding=\"10dp\" /&gt; ... &lt;/LinearLayout&gt; &lt;include /&gt;标签可以使用单独的layout属性，这个也是必须使用的。 可以使用其他属性。&lt;include /&gt;标签若指定了ID属性，而你的layout也定义了ID，则你的layout的ID会被覆盖，解决方案。 在include标签中所有的android:layout_*都是有效的，前提是必须要写layout_width和layout_height两个属性。 布局中可以包含两个相同的include标签，引用时可以使用如下方法解决（参考）:123View bookmarks_container_2 = findViewById(R.id.bookmarks_favourite); bookmarks_container_2.findViewById(R.id.bookmarks_list); 减少视图层级&lt;merge /&gt;&lt;merge/&gt;标签在UI的结构优化中起着非常重要的作用，它可以删减多余的层级，优化UI。&lt;merge/&gt;多用于替换FrameLayout或者当一个布局包含另一个时，&lt;merge/&gt;标签消除视图层次结构中多余的视图组。例如你的主布局文件是垂直布局，引入了一个垂直布局的include，这是如果include布局使用的LinearLayout就没意义了，使用的话反而减慢你的UI表现。这时可以使用&lt;merge/&gt;标签优化。12345678910111213&lt;merge xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;Button android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:text=\"@string/add\"/&gt; &lt;Button android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:text=\"@string/delete\"/&gt; &lt;/merge&gt; 现在，当你添加该布局文件时(使用&lt;include /&gt;标签)，系统忽略&lt;merge /&gt;节点并且直接添加两个Button。更多&lt;merge /&gt;介绍可以参考《Android Layout Tricks #3: Optimize by merging》 需要时使用&lt;ViewStub /&gt;&lt;ViewStub /&gt;标签最大的优点是当你需要时才会加载，使用他并不会影响UI初始化时的性能。各种不常用的布局想进度条、显示错误消息等可以使用&lt;ViewStub /&gt;标签，以减少内存使用量，加快渲染速度。&lt;ViewStub /&gt;是一个不可见的，大小为0的View。&lt;ViewStub /&gt;标签使用如下：1234567&lt;ViewStub android:id=\"@+id/stub_import\" android:inflatedId=\"@+id/panel_import\" android:layout=\"@layout/progress_overlay\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:layout_gravity=\"bottom\" /&gt; 当你想加载布局时，可以使用下面其中一种方法：123((ViewStub) findViewById(R.id.stub_import)).setVisibility(View.VISIBLE); // or View importPanel = ((ViewStub) findViewById(R.id.stub_import)).inflate(); 当调用inflate()函数的时候，ViewStub被引用的资源替代，并且返回引用的view。 这样程序可以直接得到引用的view而不用再次调用函数findViewById()来查找了。注：ViewStub目前有个缺陷就是还不支持 &lt;merge /&gt; 标签。 更多&lt;ViewStub /&gt;标签介绍可以参考《Android Layout Tricks #3: Optimize with stubs》 参考：http://developer.android.com/training/improving-layouts/reusing-layouts.htmlhttp://android-developers.blogspot.com/2009/03/android-layout-tricks-3-optimize-by.htmlhttp://developer.android.com/training/improving-layouts/optimizing-layout.html#Linthttp://android-developers.blogspot.com/2009/02/android-layout-tricks-1.htmlhttp://developer.android.com/training/improving-layouts/loading-ondemand.html","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"xml","slug":"xml","permalink":"http://xichen.pub/tags/xml/"}]},{"title":"【Android TimeCat】 OrmLite框架入门与封装（三）封装","slug":"2018-02-26-Android-TimeCat-OrmLite框架入门与封装（三）封装","date":"2018-02-26T03:02:00.000Z","updated":"2019-04-01T15:18:44.190Z","comments":true,"path":"2018/02/26/2018-02-26-Android-TimeCat-OrmLite框架入门与封装（三）封装/","link":"","permalink":"http://xichen.pub/2018/02/26/2018-02-26-Android-TimeCat-OrmLite框架入门与封装（三）封装/","excerpt":"","text":"背景本来打算把Time Cat做成完全依赖网络的，但是考虑到业务场景，离线使用的占比不低，只好做个数据库来适应需求。封装后方便对 OrmLite 的使用 见项目","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"OrmLite","slug":"OrmLite","permalink":"http://xichen.pub/tags/OrmLite/"},{"name":"database","slug":"database","permalink":"http://xichen.pub/tags/database/"}]},{"title":"【Android TimeCat】 OrmLite框架入门与封装（二）高级操作","slug":"2018-02-26-Android-TimeCat-OrmLite框架入门与封装（二）高级操作","date":"2018-02-25T23:02:00.000Z","updated":"2019-04-01T15:18:44.191Z","comments":true,"path":"2018/02/26/2018-02-26-Android-TimeCat-OrmLite框架入门与封装（二）高级操作/","link":"","permalink":"http://xichen.pub/2018/02/26/2018-02-26-Android-TimeCat-OrmLite框架入门与封装（二）高级操作/","excerpt":"","text":"背景本来打算把Time Cat做成完全依赖网络的，但是考虑到业务场景，离线使用的占比不低，只好做个数据库来适应需求。这篇文章主要介绍 OrmLite 框架中使用到的一些查询方法. WEHRE子句在SQL语句中，经常会用到where语句，where 进行条件筛选。dao.queryBuilder.()where()方法返回一个where对象，where中提供了很多方法来进行条件筛选,下边逐个讲where中的方法。 方法 ：eq(columnName,value) 等于（=）equals使用示范：mDao.queryBuilder().where().eq(“id”, 2).query();对应SQL：SELECT * FROM t_person WHERE id = 2 方法 ：lt(columnName,value) 小于（&lt;） less than使用示范：mDao.queryBuilder().where().lt(“id”, 2).query();对应SQL：SELECT * FROM t_person WHERE id &lt; 2 方法 ：gt(columnName,value) 大于（&gt;） greater than使用示范：mDao.queryBuilder().where().gt(“id”, 2).query();对应SQL：SELECT * FROM t_person WHERE id &gt; 2 方法 ：ge(columnName,value) 大于等于（&gt;=）greater-than or equals-to使用示范：mDao.queryBuilder().where().ge(“id”, 2).query();对应SQL：SELECT * FROM t_person WHERE id &gt;= 2 方法 ：le(columnName,value) 小于等于（&lt;=）less than or equals-to使用示范：mDao.queryBuilder().where().le(“id”, 2).query();对应SQL：SELECT * FROM t_person WHERE id &lt;= 2 方法 ：ne(columnName,value) 不等于（&lt;&gt;）not-equal-to使用示范：mDao.queryBuilder().where().ne(“id”, 2).query();对应SQL：SELECT * FROM t_person WHERE id &lt;&gt; 2 方法 ：in(columnName,object…) 在指定列中匹配object数组所对应的值，返回匹配到的结果行集合,in还有几个重载方法，需要的话可以去看文档或源码使用示范：mDao.queryBuilder().where().in(“id”, 1，2).query();对应SQL：SELECT * FROM t_person WHERE id IN (1，2 ) 方法 ：notIn(columnName,object…) 在指定列中匹配object数组所对应的值，返回没有匹配到的结果行集合notIn还有几个重载方法，需要的话可以去看文档或源码使用示范：mDao.queryBuilder().where().notIn(“id”,1,2).query();对应SQL：SELECT * FROM t_person WHERE id NOT IN (1 ,2 ) 方法 ：like(columnName,pattern) 使用%通配符来匹配，指定行数据，返回匹配到的结果使用示范：mDao.queryBuilder().where().like(“LastName”, “A%”).query(); 匹配A开头的LastNamemDao.queryBuilder().where().like(“LastName”, “%s”).query(); 匹配s结尾的LastNamemDao.queryBuilder().where().like(“LastName”, “%art%”).query(); 匹配中间为art的LastName对应SQL：SELECT * FROM `t_person` WHERE `LastName` LIKE &#39;A%&#39; 方法 ：between(columnName,low,high) 获取指定范围内的结果使用示范：mDao.queryBuilder().where().between(“id”, 1, 2).query();获取id是1到2之间的结果对应SQL：SELECT * FROM `t_person` WHERE `id` BETWEEN 1 AND 2 方法and()，or()用来组合上述where子语句。进行与，或操作。方法 ：and() where子句与操作使用示范：mDao.queryBuilder().where().lt(“id”, 3).and().gt(“id”, 1).query();对应SQL：SELECT * FROM `t_person` WHERE (`id` &lt; 3 AND `id` &gt; 1 ) 方法 ：or() where子句或操作使用示范：mDao.queryBuilder().where().eq(“id”, 1).or().eq(“id”, 2).query();对应SQL：SELECT * FROM `t_person` WHERE (`id` = 1 OR `id` = 2 ) ORDER BY根据指定列名排序，降序，升序使用示范：mDao.queryBuilder().orderBy(“id”, false).query(); //参数false表示降序，true表示升序。对应SQL：SELECT * FROM `t_person` ORDER BY `id` DESC（降序） DISTINCT过滤指定列不重复数据行，重复的只返回一次。使用示范：mDao.queryBuilder().selectColumns(“City”).distinct().query();对应SQL：SELECT DISTINCT `City` FROM `t_person` GROUP BY按照指定列分组使用示范：mDao.queryBuilder().groupBy(“city”).query();对应SQL：SELECT * FROM t_person GROUP BY city offset Limitoffset跳过指定的行数limit限制获取指定行数使用示范：mDao.queryBuilder().offset(2).limit(2).query(); 可以用来分页对应SQL：SELECT * FROM t_person LIMIT 2 OFFSET 2 Having等同于sql中的Having，针对分组数据，进行聚合函数（SUM, COUNT, MAX, AVG）运算。使用示范： mPersonList = mDao.queryBuilder().groupBy(“City”).having(“SUM(id)&gt;4”).query()对应SQL： SELECT * FROM t_person GROUP BY City HAVING SUM(id)&gt;4 countOf返回查询结果的总数使用示范：mDao.queryBuilder().countOf()对应SQL：SELECT COUNT(*) FROM t_person iterator返回一个结果集的迭代器。使用示范：Iterator iterator = mDao.queryBuilder().iterator(); queryForFirst返回所有行的第一行。使用示范：mDao.queryBuilder().queryForFirst(); 参考：http://blog.csdn.net/u013501637/article/details/52388802","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"OrmLite","slug":"OrmLite","permalink":"http://xichen.pub/tags/OrmLite/"},{"name":"database","slug":"database","permalink":"http://xichen.pub/tags/database/"}]},{"title":"【Android TimeCat】 OrmLite框架入门与封装（一）快速入门","slug":"2018-02-26-Android-TimeCat-OrmLite框架入门与封装（一）快速入门","date":"2018-02-25T22:49:00.000Z","updated":"2019-04-01T15:18:44.189Z","comments":true,"path":"2018/02/26/2018-02-26-Android-TimeCat-OrmLite框架入门与封装（一）快速入门/","link":"","permalink":"http://xichen.pub/2018/02/26/2018-02-26-Android-TimeCat-OrmLite框架入门与封装（一）快速入门/","excerpt":"","text":"背景本来打算把Time Cat做成完全依赖网络的，但是考虑到业务场景，离线使用的占比不低，只好做个数据库来适应需求。 本文主要针对 Android 使用 OrmLite 框架 对数据库的基本操作介绍，如有那些地方介绍的不对，请指出来，一起学习，一起进步。 添加 OrmLite 包向工程中添加 OrmLite 的 jar 包有两种方式： 到 OrmLite 官网下载 ormlite-core-4.49.jar 和 ormlite-android-4.49.jar 两个jar 包添加到工程中。 在项目中添加依赖的方式。 创建项目中使用DatabaseHelper类首先要简单说一下 OrmLite 框架中 OrmLiteSqliteOpenHelper 类 ，OrmLiteSqliteOpenHelper 类继承了 SQLiteOpenHelper。所以，创建项目中的DatabaseHelper 类，要使该类继承 OrmLite 框架 的 OrmLiteSqliteOpenHelper 类来获得 SQLiteHelper. 继承 OrmLiteSqliteOpenHelper 实现几个方法说明构造函数123456789public DatabaseHelper(Context context, String databaseName, SQLiteDatabase.CursorFactory factory, int databaseVersion) &#123; super(context, databaseName, factory, databaseVersion); /** * 参数说明： * context：上下文。 * databaseName： 数据库名。 * factory： 游标实例，多数时候设置成NULL。 * databaseVersion：数据库版本，当数据库版本升高时，会调用onUpgrade（）方法。 */ 创建数据库表123456789101112public void onCreate(SQLiteDatabase sqLiteDatabase, ConnectionSource connectionSource) &#123; /** * 在该方法中进行创建表操作 * 使用`OrmLite 框架`的 TableUtils.createTable进行创建表操作。 *eg. */ try &#123; TableUtils.createTable(connectionSource, UserInfo.class); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; 数据库版本提升更新方法12public void onUpgrade(SQLiteDatabase sqLiteDatabase, ConnectionSource connectionSource, int i, int i1) &#123; //在该方法中进行更新操作 创建数据库表对应的 BeanBean 类中的变量对应数据库中的字段，在 Bean 中使用注解方式进行设置。实例代码如下：123456789101112131415@DatabaseTable(tableName = \"tb_user_info\")public class UserInfo &#123; @DatabaseField(generatedId = true) private int userId; @DatabaseField(columnName = \"name\") private String name; @DatabaseField(columnName = \"addr\") private String addr; @DatabaseField(columnName = \"sex\") private String sex; // 对应字段的set 和 get 方法&#125; 数据库中字段注解设置说明： 字段名 参数名 说明 @DatabaseTable tableName 指定表明,没有将使用类名作为表明 @DatabaseField cloumnName 指定字段名,不指定则变量名作为字段名 canBeNull 是否可以为null dataType 指定字段的类型 defaultValue 指定默认值 width 指定长度 id 指定字段为id generatedId 指定字段为自增长的id generatedIdSequence foreign 指定这个字段的对象是一个外键,外键值是这个对象的id useGetSet 指定ormlite访问变量使用set,get方法默认使用的是反射机制直接访问变量 throwIfNull 如果空值抛出异常 persisted 指定是否持久化此变量,默认true unique 字段值唯一 uniqueCombo 整列的值唯一 index 索引 uniqueIndex 唯一索引 foreignAutoRefresh 外键值,自动刷新 uniqueIndex 外键值,自动刷新 foreignAutoCreate 外键不存在时是否自动添加到外间表中 foreignColumnName 外键字段指定的外键表中的哪个字段 获取操作数据库对应表的 Bean 的 Dao在OrmLite 框架中。操作数据是通过 对应Bean的Dao 实现的。 那么Dao 是如何获取的呢？ Dao 的获取方式： 对应Bean是通过 OrmLiteSqliteOpenHelper 类中 getDao(Class clazz) 方法获取。 实例代码如下：123456789public class UserDao &#123; private DatabaseHelper helper; public Dao&lt;UserInfo,Integer&gt; getUserDao(Context context) throws SQLException &#123; helper = new DatabaseHelper(context); return helper.getDao(UserInfo.class); &#125;&#125; 通过 Dao 对数据库进行简单增、删、改、查操作1UserDao mDao = new UserDao(); 增：123456try &#123; UserInfo u1 = new UserInfo(\"zhangsan\",\"beijng\",\"nan\"); mDao.getUserDao(mContext).create(u1);&#125; catch (SQLException e) &#123; e.printStackTrace();&#125; 删：下面的示例是使用删除集合完成删除1234567891011121314//修改和删除要通过id 进行操作UserInfo u4 = new UserInfo(\"zhangsan\",\"北京\",\"女\");u4.setUserId(4);UserInfo u3 = new UserInfo(\"招商\",\"beijng\",\"女\");u3.setUserId(3);try &#123; Collection&lt;UserInfo&gt; collection = new ArrayList&lt;UserInfo&gt;(); collection.add(u4); collection.add(u3); mDao.getUserDao(mContext).delete(collection);&#125; catch (SQLException e) &#123; e.printStackTrace();&#125; 改：12345678UserInfo u4 = new UserInfo(\"updateMan\",\"北京\",\"女\");u4.setUserId(4);try &#123; mDao.getUserDao(mContext).update(u4);&#125; catch (SQLException e) &#123; e.printStackTrace();&#125; 查：注：这里只举了一个查询方式，查询全部。条件查询请参考（OrmLite 复杂条件查询）123456789try &#123;List&lt;UserInfo&gt; infos = mDao.getUserDao(mContext).queryForAll(); for(UserInfo info : infos)&#123; //在此处使用TextView进行显示 mUserText.append(\"\\n\" + info.toString() + \"\\n\"); &#125;&#125; catch (SQLException e) &#123; e.printStackTrace();&#125; 参考：http://blog.csdn.net/u013501637/article/details/52388802","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"OrmLite","slug":"OrmLite","permalink":"http://xichen.pub/tags/OrmLite/"},{"name":"database","slug":"database","permalink":"http://xichen.pub/tags/database/"}]},{"title":"【Android TimeCat】 制作捐赠二维码，实现捐赠收款","slug":"2018-02-26-Android-TimeCat-制作捐赠二维码，实现捐赠收款","date":"2018-02-25T22:45:00.000Z","updated":"2019-04-01T15:18:44.198Z","comments":true,"path":"2018/02/26/2018-02-26-Android-TimeCat-制作捐赠二维码，实现捐赠收款/","link":"","permalink":"http://xichen.pub/2018/02/26/2018-02-26-Android-TimeCat-制作捐赠二维码，实现捐赠收款/","excerpt":"","text":"背景撰写了一篇对读者有帮助的博客， 贡献了一套对开发者有用的开源项目，上架了一个免费的App，用户觉得好用想回报作者，上架了一个收费的App，小白用户因不会使用 苹果支付（Apple Pay），谷歌钱包（Google Wallet Card），PayPal，没办法只要使用越狱破解版本，但又想获得版本更新，好用想回报作者， 以上问题因为有了 阿里支付宝（alipay）的二维码支付（捐赠），一切皆不是问题。平时你在互联网上看到的快捷捐赠就是这样实现的，你也可以实现. 步骤分解： PC端登陆支付宝官方网站 https://qr.alipay.com 免费领取“向我付款”的二维码。 个性化设置可以自行上传头像照片，并设置收款人姓名 下载“向我付款”的二维码，放到你的博客、github、App下载页面（注意不要放到AppStore或App内，会违反AppStore审核规则被Reject！） 补充： 支付宝二维码实则为一个可以打开支付宝客户端的url地址。也可以用手机原生浏览器，如iOS的Safari，Android的浏览器，直接访问二维码的Web地址，如我的二维码地址为https://qr.alipay.com/a6x08960yukqk4sjdmrwbd5 必须使用支付宝android，iOS客户端的“扫一扫”功能，如没有安装，先安装。 使用微信扫描时，微信会禁止跳转到支付宝（竞争对手关系吧），这时候需要选择扫描结果页面–右上角的打开方式“…”，使用原生浏览器打开，并拷贝支付地址 案例： WeiboX：新浪微博 MAC客户端，个人开发者http://weiboformac.sinaapp.com/donates.php JeepREC：iPhone版行车记录仪，个人开发者专业版 https://itunes.apple.com/cn/app/xing-che-ji-lu-yi-zhuan-ye/id918614632?mt=8免费版 https://itunes.apple.com/cn/app/xing-che-ji-lu-yi-mian-fei/id918642080?mt=8 参考：如何制作捐赠二维码，实现开源项目或免费应用的捐赠收款（支付宝篇）","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"alipay","slug":"alipay","permalink":"http://xichen.pub/tags/alipay/"}]},{"title":"【Android TimeCat】 Android Studio 高效配置","slug":"2018-02-26-Android-TimeCat-Android Studio高效配置","date":"2018-02-25T22:25:00.000Z","updated":"2019-04-01T15:18:44.187Z","comments":true,"path":"2018/02/26/2018-02-26-Android-TimeCat-Android Studio高效配置/","link":"","permalink":"http://xichen.pub/2018/02/26/2018-02-26-Android-TimeCat-Android Studio高效配置/","excerpt":"","text":"背景1、代码提示不区分大小写File | Settings 打开设置，选择Editor | General | Code Completion Case sensitive completion：选择None。 2、显示行号File | Settings 打开设置，选择Editor | General | Appearance 如图勾选 Show line numbers。 3、自动导包在 Android Studio 中， Alt + Enter 和 Control + Alt + O 是用来导包和清除无用导包。但是，你可以设置其快速自动导包的。 File | Settings打开设置，选择 Editor | General | Auto Import，勾选 Optimize imports on the fly 和 Add unambiguous imports on the fly 。 4、Log日志的颜色自定义Android Studio中 Logcat 的默认只有红白两种颜色，这样不利于我们分析Log打印的信息。建议还是采用Android Holo主题的配色方案。 File | Settings 打开设置，选择Editor | Color &amp; Fonts | Android Logcat，点击 Click on Save As…按钮创建一个新的配色 myLog。 注意：修改之前一定要取消勾选 Use inherited attributes 5、屏幕截图与屏幕录屏Android Studio中 自带了截屏与录屏的功能。如图 截屏： 录屏： 6、Android Studio真机ADB WiFi调试第一步，安装ADBWIFI插件，安装后之后重启AndroidStudio。 第二步，重启后，你会发现Tools | Android 多了一个 ADB WIFI。 手机通过数据线连上电脑，如图点击ADB Restart，出现如下图则成功 再点击 ADB USB to WIFI，出现如下图则成功，便可拔掉数据线无线调试了。 7、WaKaTime一款可以记录你敲代码时间的插件。 安装wakatime插件如上面，安装后重启。记得在官网上注册账号获取API Key。在Tools下面点击WaKaTime Settings 设置你的API Key。 官网地址：https://wakatime.com/ 8、SexyEditor插件（AndroidStudio设置背景）你可以在你的AndroidStudio上设置一张背景图片。File | Settings 打开设置，Other Settings下面的SexyEditor。 opacity：设置图片的 透明度 0-100 数值越大 背景图片越清晰。 shrink to fit: 缩小到适合尺寸。设置图片的缩放。 random:设置图片随机循环播放。 file list ：批量选择图片列表。 往下拉有个Insert 插入图片的按钮。 效果怎么样，是不是高大上。 9、ECTranslation翻译插件选中某个单词，翻译中文。 安装完插件重启，然后在Preferences -&gt; Keymap -&gt; 搜索Translate，右键设置快捷键。 选中某个单词+快捷键如图： 10、GsonFormatjson数据自动生成实体类。安装插件和上面一样，重启之后你可以设置一下快捷键，方法和上面一样，我的快捷键设置的是Alt+S。下面是演示。","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"http://xichen.pub/tags/Android-Studio/"}]},{"title":"【Android TimeCat】 跳转QQ加群","slug":"2018-02-26-Android-TimeCat-跳转QQ加群","date":"2018-02-25T22:25:00.000Z","updated":"2019-04-01T15:18:44.200Z","comments":true,"path":"2018/02/26/2018-02-26-Android-TimeCat-跳转QQ加群/","link":"","permalink":"http://xichen.pub/2018/02/26/2018-02-26-Android-TimeCat-跳转QQ加群/","excerpt":"","text":"背景TimeCat项目内测需要用到 步骤 访问https://qun.qq.com/join.html 登录 左边选择QQ群，右边有代码，直接复制到项目即可 注意 必须明确QQ群号 该用户必须是QQ群号的管理员或群主","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"QQ","slug":"QQ","permalink":"http://xichen.pub/tags/QQ/"}]},{"title":"【Android TimeCat】 Android Studio拾色器","slug":"2018-02-26-Android-TimeCat-Android Studio拾色器","date":"2018-02-25T21:37:00.000Z","updated":"2019-04-01T15:18:44.186Z","comments":true,"path":"2018/02/26/2018-02-26-Android-TimeCat-Android Studio拾色器/","link":"","permalink":"http://xichen.pub/2018/02/26/2018-02-26-Android-TimeCat-Android Studio拾色器/","excerpt":"","text":"背景在考虑UI颜色配置的时候需要颜色对齐，需要用的次数多了，给Android Studio自带的拾色器作个小总结。 你可能下载过一些获取颜色值的一些小工具， 这种方式获取颜色，需要先切换窗口转跳到桌面，然后打开拾色器小工具程序，然后去拾取颜色； 你可能也知道Android Studio自带一个颜色拾色器，通过下面这种方式才能找到 这种方式获取颜色值限制性很强，需要特定的窗口，需要点击那么一小块颜色才能弹出窗口，才能使用 那有没有更好的方式？ 答案是肯定的，不然这些个干嘛~~不用向上面那样去打开拾色器小工具程序，不用在特定的窗口点击特定的位置弹出拾色器工具，是用我们最喜欢的快捷键的方式打开Android Studio自带了颜色拾色器工具，但是它没有设置快捷键，也没有告诉我们， 这才是问题，不罗嗦了，跟着下面的设置去设置快捷键吧 设置好之后Apply应用 + OK确认下就好了 下面就能愉快的玩耍了，Alt+C~~ 参考：Android Studio设置颜色拾色器工具Color Picker","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"http://xichen.pub/tags/Android-Studio/"}]},{"title":"【Android TimeCat】 懒加载需求下的BaseFragment封装","slug":"2018-02-26-Android-TimeCat-懒加载需求下的BaseFragment封装","date":"2018-02-25T20:37:00.000Z","updated":"2019-04-01T15:18:44.199Z","comments":true,"path":"2018/02/26/2018-02-26-Android-TimeCat-懒加载需求下的BaseFragment封装/","link":"","permalink":"http://xichen.pub/2018/02/26/2018-02-26-Android-TimeCat-懒加载需求下的BaseFragment封装/","excerpt":"","text":"背景在多个Fragment需要加载的时候,启动速度往往会变慢，影响用户体验。分析发现并非所有的Fragment都需要第一时间将数据填充完毕，因为它们都还没有被用户所”看见”.所以我们要达到的效果是Fragment被显示后才加载数据(lazy load)。由于这种需求具有共性，即每个Fragment都可能有懒加载的需要，故封装成基类BaseFragment. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160public abstract class BaseFragment extends Fragment &#123; /** * Fragment title */ public String fragmentTitle; /** * 是否可见状态 为了避免和&#123;@link Fragment#isVisible()&#125;冲突 换个名字 */ private boolean isFragmentVisible; /** * 标志位，View已经初始化完成。 */ private boolean isPrepared; /** * 是否第一次加载 */ private boolean isFirstLoad = true; /** * &lt;pre&gt; * 忽略isFirstLoad的值，强制刷新数据，但仍要Visible &amp; Prepared * 一般用于PagerAdapter需要刷新各个子Fragment的场景 * 不要new 新的 PagerAdapter 而采取reset数据的方式 * 所以要求Fragment重新走initData方法 * 故使用 &#123;@link BaseFragment#setForceLoad(boolean)&#125;来让Fragment下次执行initData * &lt;/pre&gt; */ private boolean forceLoad = false; @Override public void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Bundle bundle = getArguments(); if (bundle != null &amp;&amp; bundle.size() &gt; 0) &#123; initVariables(bundle); &#125; &#125; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; // 若 viewpager 不设置 setOffscreenPageLimit 或设置数量不够 // 销毁的Fragment onCreateView 每次都会执行(但实体类没有从内存销毁) isFirstLoad = true; View view = initViews(inflater, container, savedInstanceState); isPrepared = true; lazyLoad(); return view; &#125; /** * 如果是与ViewPager一起使用，调用的是setUserVisibleHint * * @param isVisibleToUser 是否显示出来了 */ @Override public void setUserVisibleHint(boolean isVisibleToUser) &#123; super.setUserVisibleHint(isVisibleToUser); if (getUserVisibleHint()) &#123; onVisible(); &#125; else &#123; onInvisible(); &#125; &#125; /** * 如果是通过FragmentTransaction的show和hide的方法来控制显示，调用的是onHiddenChanged. * 若是初始就show的Fragment 为了触发该事件 需要先hide再show * * @param hidden hidden True if the fragment is now hidden, false if it is not * visible. */ @Override public void onHiddenChanged(boolean hidden) &#123; super.onHiddenChanged(hidden); if (!hidden) &#123; onVisible(); &#125; else &#123; onInvisible(); &#125; &#125; protected void onVisible() &#123; isFragmentVisible = true; lazyLoad(); &#125; protected void onInvisible() &#123; isFragmentVisible = false; &#125; /** * 要实现延迟加载Fragment内容,需要在 onCreateView * isPrepared = true; */ protected void lazyLoad() &#123; if (isPrepared() &amp;&amp; isFragmentVisible()) &#123; if (forceLoad || isFirstLoad()) &#123; forceLoad = false; isFirstLoad = false; initData(); &#125; &#125; &#125; @Override public void onDestroyView() &#123; super.onDestroyView(); isPrepared = false; &#125; /** * 被ViewPager移出的Fragment 下次显示时会从getArguments()中重新获取数据 * 所以若需要刷新被移除Fragment内的数据需要重新put数据 eg: * Bundle args = getArguments(); * if (args != null) &#123; * args.putParcelable(KEY, info); * &#125; */ public void initVariables(Bundle bundle) &#123;&#125; protected abstract View initViews(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState); protected abstract void initData(); public boolean isPrepared() &#123; return isPrepared; &#125; /** * 忽略isFirstLoad的值，强制刷新数据，但仍要Visible &amp; Prepared */ public void setForceLoad(boolean forceLoad) &#123; this.forceLoad = forceLoad; &#125; public boolean isFirstLoad() &#123; return isFirstLoad; &#125; public boolean isFragmentVisible() &#123; return isFragmentVisible; &#125; public String getTitle() &#123; if (null == fragmentTitle) &#123; setDefaultFragmentTitle(null); &#125; return TextUtils.isEmpty(fragmentTitle) ? \"\" : fragmentTitle; &#125; public void setTitle(String title) &#123; fragmentTitle = title; &#125; /** * 设置fragment的Title直接调用 &#123;@link BaseFragment#setTitle(String)&#125;,若不显示该title 可以不做处理 * * @param title 一般用于显示在TabLayout的标题 */ protected abstract void setDefaultFragmentTitle(String title);&#125; 参考：LazyFragment","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"Fragment","slug":"Fragment","permalink":"http://xichen.pub/tags/Fragment/"}]},{"title":"【Android TimeCat】 Android中使用矢量图（SVG, VectorDrawable）","slug":"2018-02-25-Android-TimeCat-使用矢量图（SVG, VectorDrawable）","date":"2018-02-25T03:28:00.000Z","updated":"2019-04-01T15:18:44.184Z","comments":true,"path":"2018/02/25/2018-02-25-Android-TimeCat-使用矢量图（SVG, VectorDrawable）/","link":"","permalink":"http://xichen.pub/2018/02/25/2018-02-25-Android-TimeCat-使用矢量图（SVG, VectorDrawable）/","excerpt":"","text":"背景TimeCat项目中需要根据不同的场景动态改变图标颜色，如果用png等格式，会使图片资源过多。明明图案是一样的，为什么改变个颜色就得多一张图?如果整体颜色风格改变，那之前的图片资源就都废了？所以选择用xml文件来描述图片颜色，想用什么色就用什么色。 图片本质上是一个存像素点的矩阵，而svg高级一点，存一些点，比如一个圆，那么就存圆心和半径数据就行了，这是轨迹，然后再规定颜色，这样和png资源相比，内存大大减少，还容易自定义，改个图标颜色简直不要太方便！ SVG 和 VectorDrawableSVG 可缩放矢量图形（英语：Scalable Vector Graphics，SVG）是一种基于可扩展标记语言（XML），用于描述二维矢量图形的图形格式。SVG由W3C制定，是一个开放标准。——摘自维基百科 .svg格式相对于.jpg、.png甚至.webp具有较多优势，我认为核心有两点： 省时间。图像与分辨率无关，收放自如，适配安卓机坑爹的分辨率真是一劳永逸； 省空间。体积小，一般复杂图像也能在数KB搞定，图标更不在话下。 VectorDrawableVectorDrawable是Google从Android 5.0开始引入的一个新的Drawable子类，能够加载矢量图。到现在通过support-library已经至少能适配到Android 4.0了（通过AppBrain统计的Android版本分布来看，Android 4.1以下（api&lt;15）几乎可以不考虑了）。Android中的VectorDrawable只支持SVG的部分属性，相当于阉割版。 它虽然是个类，但是一般通过配置xml再设置到要使用的控件上。在Android工程中，在资源文件夹res/drawable/的目录下（没有则需新建），通过&lt;vector&gt;&lt;/vector&gt;标签描述，例如svg_ic_arrow_right.xml： 123456789&lt;vector xmlns:android=\"http://schemas.android.com/apk/res/android\" android:width=\"8dp\" android:height=\"8dp\" android:viewportHeight=\"24.0\" android:viewportWidth=\"24.0\"&gt; &lt;path android:fillColor=\"#ffffff\" android:pathData=\"M12,4l-1.41,1.41L16.17,11H4v2h12.17l-5.58,5.59L12,20l8,-8z\"/&gt;&lt;/vector&gt; 基本属性说明： width, height：图片的宽高。可手动修改到需要尺寸； viewportHeight, viewportWidth：对应将上面height width等分的份数。以svg_ic_arrow_right.xml举例，可以想象将长宽都为8dp的正方形均分为24x24的网格，在这个网格中就可以很方便地描述点的坐标，图像就是这些点连接起来构成的。 fillColor：填充颜色。最好直接在这里写明色值#xxxxxxxx，而不要用@color/some_color的形式，避免某些5.0以下机型可能会报错。 pathData：在2中描述的网格中作画的路径。具体语法不是本文的重点，故不展开。 下面这段代码描述出来的是一个蓝色闹钟，可以从Android Studio的preview功能栏里预览到它的样子： emm…既然xml资源作图标这么方便，应该怎么获取呢？ 获取矢量图方式一：Android Studio的Material Icon鼠标选中drawable文件夹，右键， New， Vector Asset 然后出现： 点击机器人进入搜索筛选： 左侧的搜索和分类可以快速索引。这里都是由谷歌官方制作的MD标准图标，建议先到这里搜索，如果没有再到网上搜索。 获取矢量图方式二：iconfont墙裂安利一个网站，阿里的iconfont，海量在线矢量图，早收藏早致富！我已经离不开它了=￣ω￣= 第一步，搜索你要的资源名字，中英文一般都会有结果。比如“arrow”，结果： 第二步，鼠标移动到某一图标上点击，比如上面第一排第二个，出现： 三个选项，第一相当于购物车，可不用登录，第二是收藏，第三是下载，均需要登录。如果未登录，点击后出现： 选择GitHub或微博都行。第三步，登录成功，点击下载，弹出： 可以对图标属性进行编辑，如色值和大小（单位dp），然后点按钮“SVG下载”。下载成功后在下载目录找到一个.svg格式的文件，这个文件可以用浏览器打开-&gt;查看网页源码，或者用NotePad++等编辑器打开看到里面的内容，格式化后是这样： 123456789&lt;?xml version=\"1.0\" standalone=\"no\"?&gt;&lt;!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"&gt;&lt;svg t=\"1490517024583\" class=\"icon\" style=\"\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"1010\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"16\" height=\"16\"&gt; &lt;defs&gt; &lt;style type=\"text/css\"&gt;&lt;/style&gt; &lt;/defs&gt; &lt;path d=\"M288.86749 12.482601C272.260723-4.160867 245.369563-4.160867 228.720647 12.482601 212.15603 29.126068 212.15603 56.438425 228.720647 73.081892L704.289552 511.786622 228.720647 950.918109C212.15603 967.561574 212.15603 994.447175 228.720647 1011.517401 245.369563 1028.160866 272.260723 1028.160866 288.86749 1011.517401L794.952385 544.646802C803.803707 535.684935 807.597131 523.735776 807.007043 511.786622 807.597131 500.264224 803.803707 488.315065 794.952385 479.353198L288.86749 12.482601Z\" p-id=\"1011\"&gt;&lt;/path&gt;&lt;/svg&gt; 文件里好多标签Android是不认识的。不过没关系，有三种解决办法 手动转化成xml新建一个&lt;vector&gt;&lt;/vector&gt;标签的xml文件，通过观察文件内容，很容易获取到关键信息。 width, height自然对应&lt;vector/&gt;中宽高， viewBox后两位数字是分别对应&lt;vector/&gt;中的viewportWidth和viewportHeight， &lt;path/&gt;中的d的数据的对应&lt;vector/&gt;中&lt;path/&gt;中的pathData。 fillColor自己手动设置。 svgtoandroid插件安装：File -&gt; Setting -&gt; Plugins -&gt; Browser repositories -&gt; 搜“svg2VectorDrawable” -&gt; 安装并重启Android Studio，再次进来后顶部工具栏会多一个图标： 点击图标弹出对话框： 勾选Batch选项，将对被选中文件夹中的.svg文件进行批量转换。nodpi会自动添加到没有后缀的drawable文件夹中。 网上下载的svg资源往往一步到位，有个这个插件将会事半功倍。导入第一个svg文件时就命名成我们想要的名字，如果不满意再导入时无需再关注命名，将后面导入的pathData覆盖第一个观察效果，直到满意后删除不需要的文件。 Android Studio自带转化鼠标选中drawable文件夹，右键， New， Vector Asset， Local file，然后出现： 先选本地文件（还能支持PSD，强吧），再到磁盘中找到之前下载的.svg矢量图。导入后可以为文件重命名（建议用svg_或者有区别于其它格式的前缀），默认导入宽高均为24dp，选中Override框则读取文件本来宽高，其它配置视需求而定。点击Next到下一页最后点Finish就导入了。自动导入需要格式化一下就是前面svg_ic_arrow_right.xml的样子了。 海搜比较耗时间，线条粗细啦，位置没居中啦，大小不搭配啦，关键是这些问题都是导入项目或者运行到手机后才能发现（非强迫症当我没说）。iconfont还有诸多成套的图标库，优点是风格大小一致，或者多彩图标。 项目应用前提：项目的build.gradle配置有：12345678910111213android&#123; ... defaultConfig &#123; ... vectorDrawables.useSupportLibrary = true &#125; ...&#125;dependencies &#123; ... compile \"com.android.support:appcompat-v7:21+\" // 至少Api21 ...&#125; 项目的Activity中都包含（通用做法是在BaseActivity中加）：123static &#123; AppCompatDelegate.setCompatVectorFromResourcesEnabled(true);&#125; AppCompatImageView这是继承自ImageView用于5.0以下加载矢量图的控件，只需要替换src为srcCompat属性，其它没什么不同。例如：1234&lt;android.support.v7.widget.AppCompatImageView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" app:srcCompat=\"@drawable/svg_ic_arrow_right\"/&gt; 如果你的Activity直接或间接继承自AppCompatActivity，当前视图中的ImageView在编译过程中会被自动转为AppCompatImageView（support包中所有含有AppCompat前缀的控件均受相同处理），因而在Activity中通过findViewById()的实例用ImageView或AppCompatActivity接收是没有区别的。用以上条件的Activity中装载的Fragment，或者通过动态注入（如Dialog的contentView）的ImageView，均将被自动转为AppCompatActivity。从xml文件中初始化ImageView并加载矢量图，必须使用AppCompatImageView的srcCompat属性。ImageView的染色属性tint同样适合矢量图。 TextView在我的经验中，TextView可以用到矢量图的场景是最多的，主要是设置CompoundDrawable。例如：123456&lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:drawableRight=\"@drawable/svg_ic_arrow_right\" android:drawablePadding=\"4dp\" android:text=\"drawable right\"/&gt; 这样设置后，没有任何不适，编译器也不报错，可能你自己运行也没问题。但是！这才是深坑啊。5.0以下某些机型可能会崩溃的。 AppCompatTextView是没有对CompoundDrawable进行适配的，所以需要自己动手才能丰衣足食。简单原理是，判断系统版本如果小于5.0，就用ContextCompat.getDrawable获取到Drawable实例，再setCompoundDrawablesWithIntrinsicBounds。 这个部分已经有人做好并开源了，地址：VectorCompatTextView，轻松compile到项目中使用。他还特意添加了一个实用功能——tint染色——可以选择是否让图标与文字颜色一样，这样就不必关心xml里的fillColor属性了。用例：12345678910&lt;com.xw.repo.VectorCompatTextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:background=\"@color/color_gray_light\" android:gravity=\"center_vertical\" android:padding=\"16dp\" android:text=\"Next\" android:textSize=\"16sp\" app:drawableRightCompat=\"@drawable/svg_ic_arrow_right\" app:tintDrawableInTextColor=\"true\"/&gt; 效果： MenuItemMenuItem就是在res/menu/目录下通过xml配置的菜单，适用于NavigationView的menu属性和Activity中onCreateOptionsMenu()注入的选项菜单。 VectorDrawable 转 Bitmap自定义View中也可以自由使用矢量图。首先需要将VectorDrawable 转为 Bitmap，看码：1234567891011121314public Bitmap getBitmapFromVectorDrawable(Context context, int drawableId) &#123; Drawable drawable = ContextCompat.getDrawable(context, drawableId); if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) &#123; drawable = (DrawableCompat.wrap(drawable)).mutate(); &#125; Bitmap bitmap = Bitmap.createBitmap(drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight(), Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(bitmap); drawable.setBounds(0, 0, canvas.getWidth(), canvas.getHeight()); drawable.draw(canvas); return bitmap; &#125; 执行以上方法获得一个Bitmap的实例（设为mVectorBitmap），然后再在ondraw()里根据你的需求画出bitmap：1234567@Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); /// canvas.drawBitmap(mVectorBitmap, left, top, paint); ///&#125; 参考：https://www.jianshu.com/p/0555b8c1d26a","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"svg","slug":"svg","permalink":"http://xichen.pub/tags/svg/"}]},{"title":"【Android TimeCat】 Android中用intent传递对象的三种方法","slug":"2018-02-25-Android-TimeCat-Android中用intent传递对象的三种方法","date":"2018-02-24T21:28:00.000Z","updated":"2019-04-01T15:18:44.179Z","comments":true,"path":"2018/02/25/2018-02-25-Android-TimeCat-Android中用intent传递对象的三种方法/","link":"","permalink":"http://xichen.pub/2018/02/25/2018-02-25-Android-TimeCat-Android中用intent传递对象的三种方法/","excerpt":"","text":"背景TimeCat项目中需要根据上一个Activity的数据来初始化当前Activity，考虑到启动Activity时可以传数据，那么就用intent实现了。Android中，Activity和Fragment之间传递对象，可以通过将对象序列化并存入Bundle或者Intent中进行传递，也可以将对象转化为JSON字符串，进行传递。 序列化对象可以使用Java的Serializable的接口、Parcelable接口。转化成JSON字符串，可以使用Gson等库。 SerializableModel123456789101112public class Author implements Serializable&#123; private int id; private String name; //...&#125;public class Book implements Serializable&#123; private String title; private Author author; //...&#125; 传递数据123456789Book book=new Book(); book.setTitle(\"Java编程思想\"); Author author=new Author(); author.setId(1); author.setName(\"Bruce Eckel\"); book.setAuthor(author); Intent intent=new Intent(this,SecondActivity.class); intent.putExtra(\"book\",book); startActivity(intent);. 接收数据123Book book= (Book) getIntent().getSerializableExtra(\"book\");Log.d(TAG,\"book title-&gt;\"+book.getTitle());Log.d(TAG,\"book author name-&gt;\"+book.getAuthor().getName()); 转化为JSON字符串Model123456789101112public class Author&#123; private int id; private String name; //...&#125;public class Book&#123; private String title; private Author author; //...&#125; 传递数据123456789Book book=new Book();book.setTitle(\"Java编程思想\");Author author=new Author();author.setId(1);author.setName(\"Bruce Eckel\");book.setAuthor(author);Intent intent=new Intent(this,SecondActivity.class);intent.putExtra(\"book\",new Gson().toJson(book));startActivity(intent); 接收数据1234String bookJson=getIntent().getStringExtra(\"book\");Book book=new Gson().fromJson(bookJson,Book.class);Log.d(TAG,\"book title-&gt;\"+book.getTitle());Log.d(TAG,\"book author name-&gt;\"+book.getAuthor().getName()); 使用Parcelable实现Parcelable接口需要实现两个方法 describeContents方法。内容接口描述，默认返回0就可以; writeToParcel方法。将传递的数据打包到Parcel容器中。 除了要实现这两个方法还必须创建一个Parcelable.Creator接口的实例，用于读取Parcel容器中的数据 Model12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class Author implements Parcelable&#123; private int id; private String name; //setter &amp; getter... @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; //该方法将类的数据写入外部提供的Parcel中.即打包需要传递的数据到Parcel容器保存， // 以便从parcel容器获取数据 dest.writeString(name); dest.writeInt(id); &#125; public static final Creator&lt;Author&gt; CREATOR=new Creator&lt;Author&gt;() &#123; @Override public Author createFromParcel(Parcel source) &#123; //从Parcel容器中读取传递数据值，封装成Parcelable对象返回逻辑层。 Author author=new Author(); author.setName(source.readString()); author.setId(source.readInt()); return author; &#125; @Override public Author[] newArray(int size) &#123; //创建一个类型为T，长度为size的数组，仅一句话（return new T[size])即可。方法是供外部类反序列化本类数组使用。 return new Author[size]; &#125; &#125;;&#125;public class Book implements Parcelable&#123; private String title; private Author author; //setter &amp; getter... @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeString(title); dest.writeParcelable(author,flags); &#125; public static final Creator&lt;Book&gt; CREATOR=new Creator&lt;Book&gt;() &#123; @Override public Book createFromParcel(Parcel source) &#123; Book book=new Book(); book.setTitle(source.readString()); book.setAuthor(source.&lt;Author&gt;readParcelable(Author.class.getClassLoader())); return book; &#125; @Override public Book[] newArray(int size) &#123; return new Book[0]; &#125; &#125;;&#125; 传递数据123456789Book book=new Book();book.setTitle(\"Java编程思想\");Author author=new Author();author.setId(1);author.setName(\"Bruce Eckel\");book.setAuthor(author);Intent intent=new Intent(this,SecondActivity.class);intent.putExtra(\"book\",book);startActivity(intent); 接收数据123Book book=getIntent().getParcelableExtra(\"book\");Log.d(TAG,\"book title-&gt;\"+book.getTitle());Log.d(TAG,\"book author name-&gt;\"+book.getAuthor().getName()); 性能分析经过测试，我们得到下图的效果 简化Parcel操作可以看出，通过转换为字符串的速度是最慢的。Seralizable次之，Parcelable比Seralizable快10倍。所以从性能上考虑，我们必定优先选择Parcelable。但是Parcelable有大量重复的模板代码，如何简化这些操作，将是下面主要讲解的内容。 如果你使用android Studio 可以通过安装android-parcelable-intellij-plugin插件，或者自己配置模板进行操作。 parceler除了上面的操作，还有大量的第三方库来简化Parcelable操作。当然使用这些库也许会降低Parcelable的性能。Parceler就是这样一个库。 Parceler使用非常简单，在定义Model时用@Parcel进行注解，在传递数据的时候使用Parcels的wrap方法来包装成一个Parcelable对象。获取数据时用Parcels的unwrap方法来获取对象。 Model12345678910111213141516@Parcel public class Author &#123; int id; String name; //setter &amp; getter...&#125;@Parcelpublic class Book &#123; String title; Author author; //setter &amp; getter&#125; 传递对象123456789Book book=new Book();book.setTitle(\"Java编程思想\");Author author=new Author();author.setId(1);author.setName(\"Bruce Eckel\");book.setAuthor(author);Intent intent=new Intent(this,SecondActivity.class);intent.putExtra(\"book\", Parcels.wrap(book));startActivity(intent); 接收对象123Book book= Parcels.unwrap(getIntent().getParcelableExtra(\"book\"));Log.d(TAG,\"book title-&gt;\"+book.getTitle());Log.d(TAG,\"book author name-&gt;\"+book.getAuthor().getName()); 除了Parceler之外，还有如auto-parcel,ParcelableCodeGenerator,ParcelableGenerator等第三方库，这里我将不进行讲解，有兴趣的朋友，可以自行研究。 参考：Android中传递对象的三种方法","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"}]},{"title":"【Android TimeCat】 比较Fragment中获取Context对象的两种方法","slug":"2018-02-25-Android-TimeCat-比较Fragment中获取Context对象的两种方法","date":"2018-02-24T20:37:00.000Z","updated":"2019-04-01T15:18:44.185Z","comments":true,"path":"2018/02/25/2018-02-25-Android-TimeCat-比较Fragment中获取Context对象的两种方法/","link":"","permalink":"http://xichen.pub/2018/02/25/2018-02-25-Android-TimeCat-比较Fragment中获取Context对象的两种方法/","excerpt":"","text":"背景我们在使用Fragment的时候经常需要传递Context类型的参数，比如弹出一个dialog，而Fragment自己又不是一个Context类型的对象，于是我们有下面两种方法获取Context对象。 两种方法介绍 this.getActivity()（可以不写this.） 在Fragment中直接调用getActivity()方法，可以直接得到Fragment依附的Activity，而Activity是一个Context类型的对象。 获取Application对象 如下自己写一个MyApplication类继承Application，通过getInstance获取一个Application类型的对象，也是Context对象。 12345678910public class MyApplication extends Application &#123; private MyApplication mInstance; public static void getInstance()&#123; if(mInstance == null)&#123; mInstance = new MyApplication(); &#125; return mInstance; &#125;&#125; 两种方法比较 this.getActivity() 优点：不需要写MyApplication类 缺点：Fragment很容易被销毁，调用getActivity()方法会报空指针错误（注意：并不是getActivity()返回值为null，而是this.getActivity()中的this，也就是Fragment自己是null，因为它已经被销毁了） 获取Application对象 优点：不会遇到类似this.getActivity()的空指针问题 缺点：某些情况下的Context必须是Activity，特别是实例化Dialog等需要依附于一个Activity的可视化的对象时传参必须是Activity对象（Toast是Android的一种通知机制，不需要依附于Activity） 两全其美的解决方案1.MyApplication是一定要写的 2.写一个如下的BaseFragment类：所有的Fragment都继承这个BaseFragment,直接通过getContext()方法即可得到Context对象，当然实例化Dialog等需要依附于Activity的对象时，还是老老实实的getActivity()吧 12345678910111213141516public class BaseFragment extends Fragment&#123; private Activity activity; public Context getContext()&#123; if(activity == null)&#123; return MyApplication.getInstance(); &#125; return activity; &#125; @Override public void onAttach(Activity activity) &#123; super.onAttach(activity); activity = getActivity(); &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"Fragment","slug":"Fragment","permalink":"http://xichen.pub/tags/Fragment/"}]},{"title":"【Android TimeCat】快速构建APP BottomNavigationView + ViewPager + Fragment","slug":"2018-02-25-Android-TimeCat-BottomNavigationView+ViewPager+Fragment快速构建App","date":"2018-02-24T18:48:00.000Z","updated":"2019-04-01T15:18:44.180Z","comments":true,"path":"2018/02/25/2018-02-25-Android-TimeCat-BottomNavigationView+ViewPager+Fragment快速构建App/","link":"","permalink":"http://xichen.pub/2018/02/25/2018-02-25-Android-TimeCat-BottomNavigationView+ViewPager+Fragment快速构建App/","excerpt":"","text":"先上图 创建项目使用Android-Studio创建一个BottomNavigationView项目 创建布局修改activity_main.xml文件 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/container\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;android.support.v4.view.ViewPager android:id=\"@+id/viewPager\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\" android:layout_weight=\"1\"/&gt; &lt;android.support.design.widget.BottomNavigationView android:id=\"@+id/navigation\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_gravity=\"bottom\" android:background=\"?android:attr/windowBackground\" app:menu=\"@menu/navigation\"/&gt;&lt;/LinearLayout&gt; 创建三个Fragment(布局及类)123456789101112&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:id=\"@+id/textView\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"fragment1\"/&gt;&lt;/LinearLayout&gt; 123456789101112131415import android.os.Bundle;import android.support.annotation.Nullable;import android.support.v4.app.Fragment;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;public class Fragment1 extends Fragment &#123; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; return inflater.inflate(R.layout.fragment1, container, false); &#125;&#125; 修改menu/navigation.xml文件在item项里添加上android:orderInCategory用于标记item的位置 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:id=\"@+id/navigation_home\" android:orderInCategory=\"0\" android:icon=\"@drawable/ic_home_black_24dp\" android:title=\"@string/title_home\"/&gt; &lt;item android:id=\"@+id/navigation_dashboard\" android:orderInCategory=\"1\" android:icon=\"@drawable/ic_dashboard_black_24dp\" android:title=\"@string/title_dashboard\"/&gt; &lt;item android:id=\"@+id/navigation_notifications\" android:orderInCategory=\"2\" android:icon=\"@drawable/ic_notifications_black_24dp\" android:title=\"@string/title_notifications\"/&gt;&lt;/menu&gt; 编辑MainActivity类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import android.os.Bundle;import android.support.annotation.NonNull;import android.support.design.widget.BottomNavigationView;import android.support.v4.app.Fragment;import android.support.v4.app.FragmentPagerAdapter;import android.support.v4.view.ViewPager;import android.support.v7.app.AppCompatActivity;import android.view.MenuItem;import android.widget.TextView;public class MainActivity extends AppCompatActivity implements ViewPager.OnPageChangeListener &#123; private BottomNavigationView navigation; private ViewPager viewPager; private Fragment1 fragment1 = new Fragment1(); private Fragment2 fragment2 = new Fragment2(); private Fragment3 fragment3 = new Fragment3(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); viewPager = (ViewPager) findViewById(R.id.viewPager); //添加viewPager事件监听（很容易忘） viewPager.addOnPageChangeListener(this); navigation = (BottomNavigationView) findViewById(R.id.navigation); navigation.setOnNavigationItemSelectedListener(mOnNavigationItemSelectedListener); viewPager.setAdapter(new FragmentPagerAdapter(getSupportFragmentManager()) &#123; @Override public Fragment getItem(int position) &#123; switch (position) &#123; case 0: return fragment1; case 1: return fragment2; case 2: return fragment3; &#125; return null; &#125; @Override public int getCount() &#123; return 3; &#125; &#125;); &#125; private BottomNavigationView.OnNavigationItemSelectedListener mOnNavigationItemSelectedListener = new BottomNavigationView.OnNavigationItemSelectedListener() &#123; @Override public boolean onNavigationItemSelected(@NonNull MenuItem item) &#123; //点击BottomNavigationView的Item项，切换ViewPager页面 //menu/navigation.xml里加的android:orderInCategory属性就是下面item.getOrder()取的值 viewPager.setCurrentItem(item.getOrder()); return true; &#125; &#125;; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; &#125; @Override public void onPageSelected(int position) &#123; //页面滑动的时候，改变BottomNavigationView的Item高亮 navigation.getMenu().getItem(position).setChecked(true); &#125; @Override public void onPageScrollStateChanged(int state) &#123; &#125;&#125; 就是这么简单，快拿去添加自己的逻辑吧！","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"ViewPager","slug":"ViewPager","permalink":"http://xichen.pub/tags/ViewPager/"},{"name":"Fragment","slug":"Fragment","permalink":"http://xichen.pub/tags/Fragment/"},{"name":"BottomNavigationView","slug":"BottomNavigationView","permalink":"http://xichen.pub/tags/BottomNavigationView/"}]},{"title":"【Android TimeCat】 Java 回调及其在项目中的运用","slug":"2018-02-25-Android-TimeCat-java回调机制","date":"2018-02-24T18:48:00.000Z","updated":"2019-04-01T15:18:44.182Z","comments":true,"path":"2018/02/25/2018-02-25-Android-TimeCat-java回调机制/","link":"","permalink":"http://xichen.pub/2018/02/25/2018-02-25-Android-TimeCat-java回调机制/","excerpt":"","text":"背景TImeCat项目中的Activity和Fragment是分开管理的，有需求是点击ActionBar上的刷新，对应的fragment就重新拉取数据，或者在fragment中选择日期，对应在activity的标题位置要更新日期，考虑到性能问题，用回调实现。 框架以前不理解什么叫回调，天天听人家说加一个回调方法啥的，心里想我草，什么叫回调方法啊？然后自己就在网上找啊找啊找，找了很多也不是很明白，现在知道了，所谓回调：就是A类中调用B类中的某个方法C，然后B类中反过来调用A类中的方法D，D这个方法就叫回调方法，这样子说你是不是有点晕晕的，其实我刚开始也是这样不理解，看了人家说比较经典的回调方式： Class A实现接口CallBack callback——背景1class A中包含一个class B的引用b——背景2class B有一个参数为callback的方法f(CallBack callback)——背景3A的对象a调用B的方法 f(CallBack callback) ——A类调用B类的某个方法 C然后b就可以在f(CallBack callback)方法中调用A的方法 ——B类调用A类的某个方法D大家都喜欢用打电话的例子，好吧，为了跟上时代，我也用这个例子好了，我这个例子采用异步加回调 异步回调有一天小王遇到一个很难的问题，问题是“1 + 1 = ?”，就打电话问小李，小李一下子也不知道，就跟小王说，等我办完手上的事情，就去想想答案，小王也不会傻傻的拿着电话去等小李的答案吧，于是小王就对小李说，我还要去逛街，你知道了答案就打我电话告诉我，于是挂了电话，自己办自己的事情，过了一个小时，小李打了小王的电话，告诉他答案是2 123456789101112/** * 这是一个回调接口 * @author xiaanming * */ public interface CallBack &#123; /** * 这个是小李知道答案时要调用的函数告诉小王，也就是回调函数 * @param result 是答案 */ public void solve(String result); &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 这个是小王 * @author xiaanming * 实现了一个回调接口CallBack，相当于-----&gt;背景一 */ public class Wang implements CallBack &#123; /** * 小李对象的引用 * 相当于-----&gt;背景二 */ private Li li; /** * 小王的构造方法，持有小李的引用 * @param li */ public Wang(Li li)&#123; this.li = li; &#125; /** * 小王通过这个方法去问小李的问题 * @param question 就是小王要问的问题,1 + 1 = ? */ public void askQuestion(final String question)&#123; //这里用一个线程就是异步， new Thread(new Runnable() &#123; @Override public void run() &#123; /** * 小王调用小李中的方法，在这里注册回调接口 * 这就相当于A类调用B的方法C */ li.executeMessage(Wang.this, question); &#125; &#125;).start(); //小网问完问题挂掉电话就去干其他的事情了，诳街去了 play(); &#125; public void play()&#123; System.out.println(\"我要逛街去了\"); &#125; /** * 小李知道答案后调用此方法告诉小王，就是所谓的小王的回调方法 */ @Override public void solve(String result) &#123; System.out.println(\"小李告诉小王的答案是---&gt;\" + result); &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435/** * 这个就是小李啦 * @author xiaanming * */ public class Li &#123; /** * 相当于B类有参数为CallBack callBack的f()----&gt;背景三 * @param callBack * @param question 小王问的问题 */ public void executeMessage(CallBack callBack, String question)&#123; System.out.println(\"小王问的问题---&gt;\" + question); //模拟小李办自己的事情需要很长时间 for(int i=0; i&lt;10000;i++)&#123; &#125; /** * 小李办完自己的事情之后想到了答案是2 */ String result = \"答案是2\"; /** * 于是就打电话告诉小王，调用小王中的方法 * 这就相当于B类反过来调用A的方法D */ callBack.solve(result); &#125; &#125; 1234567891011121314151617181920212223/** * 测试类 * @author xiaanming * */ public class Test &#123; public static void main(String[]args)&#123; /** * new 一个小李 */ Li li = new Li(); /** * new 一个小王 */ Wang wang = new Wang(li); /** * 小王问小李问题 */ wang.askQuestion(\"1 + 1 = ?\"); &#125; &#125; 通过上面的那个例子你是不是差不多明白了回调机制呢，上面是一个异步回调，我们看看同步回调吧，onClick()方法 同步回调现在来分析分析下Android View的点击方法onclick();我们知道onclick()是一个回调方法，当用户点击View就执行这个方法，我们用Button来举例好了 123456789//这个是View的一个回调接口public interface OnClickListener &#123; /** * Called when a view has been clicked. * * @param v The view that was clicked. */ void onClick(View v); &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041package com.example.demoactivity; import android.app.Activity; import android.os.Bundle; import android.view.View; import android.view.View.OnClickListener; import android.widget.Button; import android.widget.Toast; /** * 这个就相当于Class A * 实现了 OnClickListener接口----&gt;背景一 */ public class MainActivity extends Activity implements OnClickListener&#123; /** * Class A 包含Class B的引用-----&gt;背景二 */ private Button button; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button = (Button)findViewById(R.id.button1); /** * Class A 调用View的方法,而Button extends View-----&gt;A类调用B类的某个方法 C */ button.setOnClickListener(this); &#125; /** * 用户点击Button时调用的回调函数，你可以做你要做的事 * 这里我做的是用Toast提示OnClick */ @Override public void onClick(View v) &#123; Toast.makeText(getApplication(), \"OnClick\", Toast.LENGTH_LONG).show(); &#125; &#125; 下面是View类的setOnClickListener方法，就相当于B类咯，只把关键代码贴出来 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 这个View就相当于B类 * @author xiaanming * */ public class View implements Drawable.Callback, KeyEvent.Callback, AccessibilityEventSource &#123; /** * Listener used to dispatch click events. * This field should be made private, so it is hidden from the SDK. * &#123;@hide&#125; */ protected OnClickListener mOnClickListener; /** * setOnClickListener()的参数是OnClickListener接口------&gt;背景三 * Register a callback to be invoked when this view is clicked. If this view is not * clickable, it becomes clickable. * * @param l The callback that will run * * @see #setClickable(boolean) */ public void setOnClickListener(OnClickListener l) &#123; if (!isClickable()) &#123; setClickable(true); &#125; mOnClickListener = l; &#125; /** * Call this view's OnClickListener, if it is defined. * * @return True there was an assigned OnClickListener that was called, false * otherwise is returned. */ public boolean performClick() &#123; sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); if (mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); //这个不就是相当于B类调用A类的某个方法D，这个D就是所谓的回调方法咯 mOnClickListener.onClick(this); return true; &#125; return false; &#125; &#125; 这个例子就是Android典型的回调机制，看完这个你是不是更进一步的理解了回调机制呢？ 线程run()也是一个回调方法，当执行Thread的start()方法就会回调这个run()方法，还有处理消息都比较经典等等 需求实现点击Activity的刷新按钮，对应fragment重新拉取数据 为了简明起见，压缩代码 123456789101112131415161718192021222324//MainActivity.javaclass MainActivity extends Activity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //省略其他代码 RefreshFragment refreshFragment = new RefreshFragment(); setOnRefreshClickListener(refreshFragment); // refreshFragment实现了回调接口，把fragment传进来即可 button = (Button)findViewById(R.id.button1); button.setOnClickListener(new View.OnClickListener() &#123; if (onRefreshClickListener != null) &#123; onRefreshClickListener.OnRefresh(); &#125; &#125;); &#125; //省略其他代码 OnRefreshClickListener onRefreshClickListener; public void setOnRefreshClickListener(OnRefreshClickListener onRefreshClickListener) &#123; this.onRefreshClickListener = onRefreshClickListener; &#125;&#125; 123456789101112// RefreshFragment.javaclass RefreshFragment extends Fragment implements OnRefreshClickListener &#123; //省略其他代码 @Override public void OnRefresh() &#123; // 在这里实现刷新数据，例如 if (mAdapter != null) &#123; mAdapter.notifyDataSetChanged(); &#125; &#125;&#125; 12345// OnRefreshClickListener.javapublic interface OnRefreshClickListener &#123; void OnRefresh();&#125; 新手一般会踩的坑循环继承 参考 一个经典例子让你彻彻底底理解java回调机制 Android实战之 万能的接口回调","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://xichen.pub/tags/Java/"},{"name":"回调","slug":"回调","permalink":"http://xichen.pub/tags/回调/"}]},{"title":"github issue 的用法","slug":"2018-01-31-github-issue-usage","date":"2018-01-31T07:26:00.000Z","updated":"2019-04-01T15:18:44.176Z","comments":true,"path":"2018/01/31/2018-01-31-github-issue-usage/","link":"","permalink":"http://xichen.pub/2018/01/31/2018-01-31-github-issue-usage/","excerpt":"","text":"小结一下GitHub上的issues功能，很有意思。 今天玩了一下gitment，尝试在博客中加上评论功能。 测试gitment的功能之后想删除测试的issue，但发现是删不掉的！！！如同版本提交commits，也是删不掉的。另外，对应issues的每一个操作都会记录下来。这样的设计应该是有原因的，现在想不明白，以后再探究吧。今天也大概了解了一下GitHub的API，也挺好玩的。 issues的属性GitHub中每一个仓库都会有对应的一个issues的功能，issues中可以新建多个issue，每一个issue就像一篇文章，有标题和内容，还有评论。另外，每个issue都有唯一的编号“#n”。 issue可以设置：Opened和Closed两种状态。 issue 还可以有额外的属性： Labels，标签。包括bug、invalid等，可以自定义。表示issue的类型，解决的方式。 Milestone，里程碑。通常用来做版本管理，v0.1、v1.0之类的，也可以是任意自定义字符串。一个里程碑对应的所有 issue 都被关闭后，这个里程碑会被自动认为已经达成。 Assignee，责任人。指定这个issue由谁负责来解决。 个人如何利用issues的功能？GitHub 的issue功能，对个人而言，就如同 TODO list。 可以把所有想要在下一步完成的工作，如feature 添加、bug 修复等，都写成一个个的 issue ，放在上面。既可以作为提醒，也可以统一管理。 另外，每一次 commit 都可以选择性的与某个 issue 关联。比如在 message 中添加 #n，就可以与第 n 个 issue 进行关联。 commit message title, #1 这个提交会作为一个 comment ，出现在编号为1的 issue 记录中。 如果添加：123456fix #nfixes #nfixed #nclose #ncloses #nclosed #n 比如1commit message title, fix #n 则可以自动关闭第 n 个 issue，即issue的状态从Opened变成了Closed。 充分利用这些功能，让每一个 commit 的意义更加明确，可以起到了良好的过程管理作用，使得这个Git库的项目进度更加显然。而且，这也是项目后期，写文档的绝佳素材。 团队如何利用issues的功能？对团队而言，这就是一个协作系统。 现在，很多大公司的软件研发团队协作，都是通过JIRA来实现的。 目前也流行很多非代码的团队协作，比如teambition、Tower.im、Worktile、trello等。 其实，GitHub 的issues，就是一个轻量级协作系统。它的comment支持GitHub Flavored Markdown，可以进行内容丰富的交流。 Git本身就是分布式的代码版本控制软件，是为了程序员的协作而设计的。而 issues 的 Assignee 功能，就是这个在线协作系统的核心，足以让一群线上的开发者，一起完成一个软件项目。 作为一个路人如何给别人的项目提bug？用 issues 给别人的项目提 bug。 其他利用？ 可以拿来写blog，虽然很丑…也不方便 可以做评论的后端，比如gitment 可以拿来给小组成员交作业，进行项目管理（我的一个同学就是这么搞，感觉很挫…） 更多。。。","categories":[{"name":"Github","slug":"Github","permalink":"http://xichen.pub/categories/Github/"}],"tags":[{"name":"Github","slug":"Github","permalink":"http://xichen.pub/tags/Github/"},{"name":"Github Issue","slug":"Github-Issue","permalink":"http://xichen.pub/tags/Github-Issue/"}]},{"title":"添加Gitment评论系统踩过的坑","slug":"2018-01-31-gitment","date":"2018-01-31T06:26:00.000Z","updated":"2019-04-01T15:18:44.177Z","comments":true,"path":"2018/01/31/2018-01-31-gitment/","link":"","permalink":"http://xichen.pub/2018/01/31/2018-01-31-gitment/","excerpt":"","text":"备忘-配置流程在setting - OAuth Application 注册页面完成注册1234Application Name: gitment 评论 //随便填Homepage Url: http://XiChen.pub //自己的域名Application description: //随便填，留空也可以Authorization Callback URL: http://XiChen.pub //自己的域名 注册成功后会得到Client ID和Client Secret 在_config.yaml添加1234567gitment: enable: true id: '' #页面 ID, 可选。默认为 location.href owner: linxueyuanstdio repo: linxueyuanstdio.github.io #存储评论的 repo client_id: '2f7f71f1ba398039ff23' #你的 Client ID client_secret: '3ebc908a7042fef2d56a83a2eb8c18777374a087' #你的 Client secret 在comment.ejs添加1234567891011121314151617&lt;% if (theme.gitment.client_id &amp;&amp; theme.gitment.client_secret &amp;&amp; theme.gitment.enable )&#123; %&gt; &lt;div id=\"gitment_container\"&gt;&lt;/div&gt; &lt;link rel=\"stylesheet\" href=\"https://imsun.github.io/gitment/style/default.css\"&gt; &lt;script src=\"https://imsun.github.io/gitment/dist/gitment.browser.js\"&gt;&lt;/script&gt; &lt;script&gt; var gitment = new Gitment(&#123; id: '&lt;%= page.title %&gt;', owner: '&lt;%= theme.gitment.owner %&gt;', repo: '&lt;%= theme.gitment.repo %&gt;', oauth: &#123; client_id: '&lt;%= theme.gitment.client_id %&gt;', client_secret: '&lt;%= theme.gitment.client_secret %&gt;', &#125;, &#125;) gitment.render('gitment_container') &lt;/script&gt;&lt;% &#125; %&gt; 初始化其实到这里差不多已经配置好了 只需要初始化一下 发布你的页面 然后在评论框登录你的github账号，必须跟第二步owner用户名相同的账号 登录之后点击初始化按钮 坑Error：NOT FOUNDowner或者repo配置错误了，照着第二步来就好，网页端生成后如下1234567891011121314...&lt;script&gt; var gitment = new Gitment(&#123; id: 'blog comment', owner: 'linxueyuanstdio', repo: 'linxueyuanstdio.github.io', oauth: &#123; client_id: '2f7f71f1ba398039ff23', client_secret: '3ebc908a7042fef2d56a83a2eb8c18777374a087', &#125;, &#125;) gitment.render('gitment_container')&lt;/script&gt;... Error: Comments Not Initialized 在注册OAuth Application这个步骤中，给Authorization callback URL指定的地址错了 还没有在该页面的Gitment评论区登陆GitHub账号 初始化时在评论框点击登录，但是没有跳到授权页面不要在本地测试，因为在setting - OAuth Application 注册页面填的Authorization Callback URL是自己的域名，不是本地调试的域名，比如http://localhost:4000/。当然，蛋疼的话可以另外申请一个OAuth Application填http://localhost:4000/也是可以的。 Error：validation failed看开发者工具的console，跟踪过去 1Failed to load resource: the server responded with a status of 422 (Unprocessable Entity) 1POST https://api.github.com/repos/linxueyuanstdio/linxueyuanstdio.github.io/issues 422 (Unprocessable Entity) 在Network那里找到原因，是id不合法。原来的gitment有一项id配置成了window.location.pathname，但仍报错。 尝试去掉id，留空行不行？按官网文档应该可以的，但是报错=. =。 思考一下，设定的id给评论对应的issue一个label，这个label的值就是id的值，那么id的作用应该是使issue和文章通过label连接在一起。 那么写死id: &#39;blog comment&#39;行不行呢？不行，每篇文章的评论是要根据id动态加载的，写死的话导致所有的文章共享一个issue。 麻痹，感觉这篇文章坑了我添加Gitment评论系统到Hexo主题NexT，而且官网的默认配置（把id留空）不对。 冷静，继续追踪 传值是对的呀… 既然知道传值对了，id的作用也清楚了，难道是GitHub在搞事情？ 去新建一个label，把值复制进去… 卧槽，真的有长度限制！ 那就简单了，只取title做id，平时写标题不要太浪~~~ 1id: '&lt;%= page.title %&gt;' 2018-02-25更新最近在整理项目开发的系列文章，发现标题不是想不浪就能克制得住的哇。评论中iHTCboy的解决方法很有通用性，就采用他的方法好了。 主要思想是用时间作id 1id: '&lt;%= page.date %&gt;' 这样传给github的标签是定长的，不会超过长度限制。同时date可以自己写，只要精确到分秒，区分文章不是问题。Good job! 哇！！！写标题快浪起来！！！ PS：一个date的例子：date: 2018-02-25 11:48:00.000000000+8:00 更改后面的0可以达到毫秒微秒纳秒级别 PS：xjzsq的方法也很好，思想是用副标题作id，可以看下他的文章 大小写问题配置项中，可能github账号中含大小写，比如我的是LinXueyuanStdio，但是在配置时不用关心大小写问题，因为POST的时候一律转成小写 测试时产生的issue何去何从删不掉的，死心吧。不过可以改title，改内容，改label等等，对应issues的每一个操作都会记录下来。另外，版本提交的commits，也是删不掉的。 顺便总结一下github issue 的用法 参考： 添加Gitment评论系统到Hexo主题NexT Hexo+gitment Gitment：使用 GitHub Issues 搭建评论系统","categories":[{"name":"Web","slug":"Web","permalink":"http://xichen.pub/categories/Web/"}],"tags":[{"name":"gitment","slug":"gitment","permalink":"http://xichen.pub/tags/gitment/"},{"name":"github","slug":"github","permalink":"http://xichen.pub/tags/github/"},{"name":"github issue","slug":"github-issue","permalink":"http://xichen.pub/tags/github-issue/"}]},{"title":"Ethereum Dapp Tutorial — Part 3","slug":"2018-01-27-Ethereum-Dapp-Tutorial-Part-3","date":"2018-01-27T09:01:00.000Z","updated":"2019-04-01T15:18:44.174Z","comments":true,"path":"2018/01/27/2018-01-27-Ethereum-Dapp-Tutorial-Part-3/","link":"","permalink":"http://xichen.pub/2018/01/27/2018-01-27-Ethereum-Dapp-Tutorial-Part-3/","excerpt":"","text":"Part 0 Part 1 Part 2 Part 3 在Part 1中，我们构建了一个简单的投票dapp，并在本地机器上运行。在Part 2中，我们将应用程序移动到使用truffle框架，并将其部署到公共Ropsten testnet，并通过truffle控制台和网页进行交互。在本节中，我们将添加更多的功能到我们的投票dapp 学习内容： 使用像struct这样的新数据类型来组织和存储区块链上的数据。 tokens的概念及其用法。 使用Ethereum区块链平台的货币Ether进行支付。 可以在这个仓库的chapter3目录中找到所有的代码：https://github.com/maheshmurthy/ethereum_voting_dapp 在大选中，每个公民都会为自己喜欢的候选人投一票。然而，有的选举如选举股东的公司董事会，可以根据你在该公司拥有的股份数量进行投票。所以，你拥有的股票越多，得到的选票就越多。 为了支持这种选举，我们来增强我们的投票权。我们将增加购买公司股票的功能。然后他们可以用这些股票投票给候选人。我们还将添加一个功能来查找选民信息。在以太坊区块链世界中，这些股票通常被称为代币，将这些共享作为tokens。 如果你想跳过所有的解释，只想看看合同文件，你可以在这里找到它：https://github.com/maheshmurthy/ethereum_voting_dapp/blob/master/chapter3/contracts/Voting.sol。 第一步是声明我们需要存储所有我们感兴趣的信息的变量。下面是有解释的合同变量。 123456789101112131415161718192021222324252627// We use the struct datatype to store the voter information. struct voter &#123; address voterAddress; // The address of the voter uint tokensBought; // The total no. of tokens this voter owns uint[] tokensUsedPerCandidate; // Array to keep track of votes per candidate. /* We have an array called candidateList initialized below. Every time this voter votes with her tokens, the value at that index is incremented. Example, if candidateList array declared below has [\"Rama\", \"Nick\", \"Jose\"] and this voter votes 10 tokens to Nick, the tokensUsedPerCandidate[1] will be incremented by 10. */ &#125;/* mapping is equivalent to an associate array or hash. The key of the mapping is candidate name stored as type bytes32 and value is an unsigned integer which used to store the vote count */mapping (bytes32 =&gt; uint) public votesReceived;mapping (address =&gt; voter) public voterInfo;/* Solidity doesn't let you return an array of strings yet. We will use an array of bytes32 instead to store the list of candidates */bytes32[] public candidateList;uint public totalTokens; // Total no. of tokens available for this electionuint public balanceTokens; // Total no. of tokens still available for purchaseuint public tokenPrice; // Price per token 在Part 1和Part 2中，我们初始化了在构造函数中竞争的候选者列表。但是，在合约部署在区块链上时，构造函数只会被调用一次。在这里，我们还必须初始化可用于销售的token总数和每个token的成本。所以，我们更新我们的合约构造函数，如下所示： 12345678910/* When the contract is deployed on the blockchain, we will initialize the total number of tokens for sale, cost per token and all the candidates */ function Voting(uint tokens, uint pricePerToken, bytes32[] candidateNames) public &#123; candidateList = candidateNames; totalTokens = tokens; balanceTokens = tokens; tokenPrice = pricePerToken; &#125; 在truffle中，使用migration将代码部署到区块链。可以在这里查看迁移文件。truffle的migration文件中的示例部署调用如下所示： 1deployer.deploy(Voting, 1000, web3.toWei('0.1', 'ether'), ['Rama', 'Nick', 'Jose']); 现在我们已经初始化了token并设置了价格，让我们看看有人可以通过支付以太币来购买这些token。这是购买token的函数。 12345678910111213/* This function is used to purchase the tokens. Note the keyword 'payable' below. By just adding that one keyword to a function, your contract can now accept Ether from anyone who calls this function. Accepting money can not get any easier than this! */function buy() payable public returns (uint) &#123; uint tokensToBuy = msg.value / tokenPrice; if (tokensToBuy &gt; balanceTokens) throw; voterInfo[msg.sender].voterAddress = msg.sender; voterInfo[msg.sender].tokensBought += tokensToBuy; balanceTokens -= tokensToBuy; return tokensToBuy;&#125; 一个示例购买电话如下所示 1truffle(development)&gt; Voting.deployed().then(function(contract) &#123;contract.buy(&#123;value: web3.toWei('1', 'ether'), from: web3.eth.accounts[1]&#125;)&#125;) value: web3.toWei(‘1’, ‘ether’)参数使用msg.value在buy()函数访问和msg.sender给我们web3.eth.accounts[1]的帐户地址。假设每个标记的值为0.1 Ether，则web3.eth.accounts[1]将接收1个Ether/0.1Ether=10tokens。 让我们休息一会儿，看看代码，并可视化账户（选民）和合同之间的交互。 index.html文件更新： 为了投票给候选人，你现在必须指定否。您想要投票的标记。 有一个新的部分，你可以购买令牌。 现在可以查询选民信息 - 他们拥有多少令牌，不可以。他们投给了每个候选人。 候选人不再被硬编码。我们从区块链中获取候选人并填充它。 在app.js文件必须支持上述所有的UI功能的更新。 更新部署文件2_deploy_contracts.js以传递总共令牌和令牌价格以及候选名称。 1234var Voting = artifacts.require(\"./Voting.sol\");module.exports = function(deployer) &#123; deployer.deploy(Voting, 1000, web3.toWei('0.1', 'ether'), ['Rama', 'Nick', 'Jose']);&#125;; 总而言之，在本教程中更新的四个文件是Voting.sol，index.html，app.js和2_deploy_contracts.js。一旦你用这些文件更新了truffle储存库，我们可以将合同部署到区块链。部署过程与之前的教程完全相同。 只需要使用truffle命令进行编译和migrate。 123456789101112131415$ truffle migrateUsing network 'development'.Compiling Migrations.sol...Compiling Voting.sol...Writing artifacts to ./build/contractsRunning migration: 1_initial_migration.jsDeploying Migrations...Migrations: 0xc9249947010675b8a3b1defb12334148f7f59010Saving successful migration to network...Saving artifacts...Running migration: 2_deploy_contracts.jsDeploying Voting...Voting: 0x795d6d1f7cf467f27e48181da5f1ebd5bbd0a8dfSaving successful migration to network...Saving artifacts... 如果您能够成功部署合同并启动您的Web服务器，则您的页面如下所示： 将能够购买tokens，使用tokens投票给候选人并根据他们的地址查找选举人信息。如果你能够得到所有这些功能，Congratulation！","categories":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/tags/区块链/"},{"name":"Ethereum","slug":"Ethereum","permalink":"http://xichen.pub/tags/Ethereum/"},{"name":"Dapp","slug":"Dapp","permalink":"http://xichen.pub/tags/Dapp/"}]},{"title":"Ethereum Dapp Tutorial — Part 2","slug":"2018-01-26-Ethereum-Dapp-Tutorial-Part-2","date":"2018-01-25T18:01:00.000Z","updated":"2019-04-01T15:18:44.173Z","comments":true,"path":"2018/01/26/2018-01-26-Ethereum-Dapp-Tutorial-Part-2/","link":"","permalink":"http://xichen.pub/2018/01/26/2018-01-26-Ethereum-Dapp-Tutorial-Part-2/","excerpt":"","text":"Part 0 Part 1 Part 2 Part 3 在Part 1中，我们用ganache在开发环境中构建了一个简单的投票应用程序。现在在真正的区块链上获得这个应用程序。 以太坊有2个公共区块链。 Testnet（也叫Ropsten）：这是一个测试区块链。可以把它看作一个QA或一个临时服务器，它仅用于测试目的。 Mainnet（也叫Homestead）：这是全世界真实交易的区块链。在这个网络上使用以太网是有实际价值的。 学习目标: 安装geth用于下载区块链的客户端软件，并在本地计算机上运行以太坊节点 安装名为Truffle的Ethereum dapp框架，将用于编译和部署智能合约 对投票应用程序进行小小的更新，使其用Truffle 将合约编译并部署到Ropsten testnet 通过Truffle控制台，然后通过网页与合约进行交互 安装geth并同步区块链安装非常简单： 在Mac上12$ brew tap ethereum / ethereum mahesh $ brew install ethereum 在Ubuntu上1234$ sudo apt-get install software-properties-common $ sudo add-apt-repository -y ppa：ethereum / ethereum $ sudo apt-get update $ sudo apt-get install ethereum 在这有各种平台的安装说明：https://github.com/ethereum/go-ethereum/wiki/Building-Ethereum 安装geth后，在命令行控制台中运行下面的命令： 1$ geth --testnet --syncmode \"fast\" --rpc --rpcapi db,eth,net,web3,personal --cache=1024 --rpcport 8545 --rpcaddr 127.0.0.1 --rpccorsdomain \"*\" --bootnodes \"enode://20c9ad97c081d63397d7b685a412227a40e23c8bdc6688c6f37e97cfbc22d2b4d1db1510d8f61e6a8866ad7f0e17c02b14182d37ea7c3c8b9c2683aeb6b733a1@52.169.14.227:30303,enode://6ce05930c72abc632c58e2e4324f7c7ea478cec0ed4fa2528982cf34483094e9cbc9216e7aa349691242576d552a2a56aaeae426c5303ded677ce455ba1acd9d@13.84.180.240:30303\" 这将启动以太坊节点，连接到其他对等节点并开始下载区块链。下载区块链所需的时间取决于各种因素，例如您的网络连接速度，计算机上的RAM，硬盘驱动器的类型等等。在一台拥有8GB RAM和50Mbps连接的计算机上花了我10-15分钟时间。 在您正在运行的控制台中，您将看到如下所示的输出。寻找粗体的块号。当区块链完全同步时，区块编号和此页面上的区块编号接近：https://ropsten.etherscan.io/ 12345I0130 22:18:15.116332 core/blockchain.go:1064] imported 32 blocks, 49 txs ( 6.256 Mg) in 185.716ms (33.688 Mg/s). #445097 [e1199364… / bce20913…]I0130 22:18:20.267142 core/blockchain.go:1064] imported 1 blocks, 1 txs ( 0.239 Mg) in 11.379ms (20.963 Mg/s). #445097 [b4d77c46…]I0130 22:18:21.059414 core/blockchain.go:1064] imported 1 blocks, 0 txs ( 0.000 Mg) in 7.807ms ( 0.000 Mg/s). #445098 [f990e694…]I0130 22:18:34.367485 core/blockchain.go:1064] imported 1 blocks, 0 txs ( 0.000 Mg) in 4.599ms ( 0.000 Mg/s). #445099 [86b4f29a…]I0130 22:18:42.953523 core/blockchain.go:1064] imported 1 blocks, 2 txs ( 0.294 Mg) in 9.149ms (32.136 Mg/s). #445100 [3572f223…] 安装Truffle框架1npm install -g truffle 建立voting合约首先建立一个truffle project 12345678910111213$ mkdir voting$ cd voting$ npm install -g webpack$ truffle unbox webpack$ lsREADME.md contracts node_modules test webpack.config.js truffle.jsapp migrations package.json $ ls app/index.html javascripts stylesheets$ ls contracts/ConvertLib.sol MetaCoin.sol Migrations.sol$ ls migrations/1_initial_migration.js 2_deploy_contracts.js truffle创建了运行dapp所需的必要文件和目录。truffle还创建了一个示例应用程序，让你快速上手（我们不会在本教程中使用它）。可以删除contracts目录中的ConvertLib.sol和MetaCoin.sol文件。 migrations目录很重要。这些migrations里文件用于将合约部署到区块链。（在上一篇文章中，我们使用了VotingContract.new将合约部署到区块链，现在不需要这样做）。 1_initial_migration.js将一个名为Migrations的合约部署到区块链中，并用于存储已部署的最新合约。每次运行migration时，truffle都会查询区块链以获取已部署的最后一个合约，然后部署尚未部署的任何合约。然后更新Migrations合约中的last_completed_migration字段，以指示部署的最新合约。可以简单地将其视为一个名为Migration的数据库表，其中名为last_completed_migration的列始终保持最新状态。更多 现在用上面的教程中所写的所有代码更新项目，下面将对其进行一些更改。 首先，将Voting.sol从前一个教程复制到contracts目录（这个文件没有改变）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647pragma solidity ^0.4.18;// We have to specify what version of compiler this code will compile withcontract Voting &#123; /* mapping field below is equivalent to an associative array or hash. The key of the mapping is candidate name stored as type bytes32 and value is an unsigned integer to store the vote count */ mapping (bytes32 =&gt; uint8) public votesReceived; /* Solidity doesn't let you pass in an array of strings in the constructor (yet). We will use an array of bytes32 instead to store the list of candidates */ bytes32[] public candidateList; /* This is the constructor which will be called once when you deploy the contract to the blockchain. When we deploy the contract, we will pass an array of candidates who will be contesting in the election */ function Voting(bytes32[] candidateNames) public &#123; candidateList = candidateNames; &#125; // This function returns the total votes a candidate has received so far function totalVotesFor(bytes32 candidate) view public returns (uint8) &#123; require(validCandidate(candidate)); return votesReceived[candidate]; &#125; // This function increments the vote count for the specified candidate. This // is equivalent to casting a vote function voteForCandidate(bytes32 candidate) public &#123; require(validCandidate(candidate)); votesReceived[candidate] += 1; &#125; function validCandidate(bytes32 candidate) view public returns (bool) &#123; for(uint i = 0; i &lt; candidateList.length; i++) &#123; if (candidateList[i] == candidate) &#123; return true; &#125; &#125; return false; &#125;&#125; 12$ ls contracts/Migrations.sol Voting.sol 接下来，将migrations目录中的2_deploy_contracts.js的内容替换为以下内容： 1234var Voting = artifacts.require(\"./Voting.sol\");module.exports = function(deployer) &#123; deployer.deploy(Voting, ['Rama', 'Nick', 'Jose'], &#123;gas: 6700000&#125;);&#125;; 也可以在truffle.js中将气体值设置为全局设置。继续添加如下所示的gas选项，如果忘记将gas设置为特定的迁移文件，则默认使用全局值。 1234567891011require('babel-register')module.exports = &#123; networks: &#123; development: &#123; host: 'localhost', port: 8545, network_id: '*', gas: 470000 &#125; &#125;&#125; 用下面的内容替换app/javascripts/app.js的内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// Import the page's CSS. Webpack will know what to do with it.import \"../stylesheets/app.css\";// Import libraries we need.import &#123; default as Web3&#125; from 'web3';import &#123; default as contract &#125; from 'truffle-contract'/* * When you compile and deploy your Voting contract, * truffle stores the abi and deployed address in a json * file in the build directory. We will use this information * to setup a Voting abstraction. We will use this abstraction * later to create an instance of the Voting contract. * Compare this against the index.js from our previous tutorial to see the difference * https://gist.github.com/maheshmurthy/f6e96d6b3fff4cd4fa7f892de8a1a1b4#file-index-js */import voting_artifacts from '../../build/contracts/Voting.json'var Voting = contract(voting_artifacts);let candidates = &#123;\"Rama\": \"candidate-1\", \"Nick\": \"candidate-2\", \"Jose\": \"candidate-3\"&#125;window.voteForCandidate = function(candidate) &#123; let candidateName = $(\"#candidate\").val(); try &#123; $(\"#msg\").html(\"Vote has been submitted. The vote count will increment as soon as the vote is recorded on the blockchain. Please wait.\") $(\"#candidate\").val(\"\"); /* Voting.deployed() returns an instance of the contract. Every call * in Truffle returns a promise which is why we have used then() * everywhere we have a transaction call */ Voting.deployed().then(function(contractInstance) &#123; contractInstance.voteForCandidate(candidateName, &#123;gas: 140000, from: web3.eth.accounts[0]&#125;).then(function() &#123; let div_id = candidates[candidateName]; return contractInstance.totalVotesFor.call(candidateName).then(function(v) &#123; $(\"#\" + div_id).html(v.toString()); $(\"#msg\").html(\"\"); &#125;); &#125;); &#125;); &#125; catch (err) &#123; console.log(err); &#125;&#125;$( document ).ready(function() &#123; if (typeof web3 !== 'undefined') &#123; console.warn(\"Using web3 detected from external source like Metamask\") // Use Mist/MetaMask's provider window.web3 = new Web3(web3.currentProvider); &#125; else &#123; console.warn(\"No web3 detected. Falling back to http://localhost:8545. You should remove this fallback when you deploy live, as it's inherently insecure. Consider switching to Metamask for development. More info here: http://truffleframework.com/tutorials/truffle-and-metamask\"); // fallback - use your fallback strategy (local node / hosted node + in-dapp id mgmt / fail) window.web3 = new Web3(new Web3.providers.HttpProvider(\"http://localhost:8545\")); &#125; Voting.setProvider(web3.currentProvider); let candidateNames = Object.keys(candidates); for (var i = 0; i &lt; candidateNames.length; i++) &#123; let name = candidateNames[i]; Voting.deployed().then(function(contractInstance) &#123; contractInstance.totalVotesFor.call(name).then(function(v) &#123; $(\"#\" + candidates[name]).html(v.toString()); &#125;); &#125;) &#125;&#125;); 将app/index.html的内容替换为以下内容。即使这个文件与上一章几乎相同，除了包含的js文件是41行的app.js。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Hello World DApp&lt;/title&gt; &lt;link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'&gt; &lt;link href='https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css' rel='stylesheet' type='text/css'&gt;&lt;/head&gt;&lt;body class=\"container\"&gt; &lt;h1&gt;A Simple Hello World Voting Application&lt;/h1&gt; &lt;div id=\"address\"&gt;&lt;/div&gt; &lt;div class=\"table-responsive\"&gt; &lt;table class=\"table table-bordered\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Candidate&lt;/th&gt; &lt;th&gt;Votes&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Rama&lt;/td&gt; &lt;td id=\"candidate-1\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Nick&lt;/td&gt; &lt;td id=\"candidate-2\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Jose&lt;/td&gt; &lt;td id=\"candidate-3\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div id=\"msg\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;input type=\"text\" id=\"candidate\" /&gt; &lt;a href=\"#\" onclick=\"voteForCandidate()\" class=\"btn btn-primary\"&gt;Vote&lt;/a&gt;&lt;/body&gt;&lt;script src=\"https://cdn.rawgit.com/ethereum/web3.js/develop/dist/web3.js\"&gt;&lt;/script&gt;&lt;script src=\"https://code.jquery.com/jquery-3.1.1.slim.min.js\"&gt;&lt;/script&gt;&lt;script src=\"app.js\"&gt;&lt;/script&gt;&lt;/html&gt; 将合同部署到Ropsten testnet在部署合同之前需要一个账号和一些ether。当我们使用ganache时，它创建了10个测试帐户，并预装了100个测试用例。但是对于testnet和mainnet，我们必须创建帐户并自己添加一些ether。 在您的命令行终端中，执行以下操作： 123456$ truffle consoletruffle(default)&gt; web3.personal.newAccount('verystrongpassword')'0x95a94979d86d9c32d1d2ab5ace2dcc8d1b446fa1'truffle(default)&gt; web3.eth.getBalance('0x95a94979d86d9c32d1d2ab5ace2dcc8d1b446fa1')&#123; [String: '0'] s: 1, e: 0, c: [ 0 ] &#125;truffle(default)&gt; web3.personal.unlockAccount('0x95a94979d86d9c32d1d2ab5ace2dcc8d1b446fa1', 'verystrongpassword', 15000) 在之前的文章中，我们启动了一个节点控制台并初始化了web3对象。当我们执行truffle控制台，所有这一切都为我们完成，我们得到一个web3对象准备使用。我们现在有一个地址为“0x95a94979d86d9c32d1d2ab5ace2dcc8d1b446fa1”的帐户（您将在您的情况下有不同的地址），余额将为0。 可以通过传递一个额外的option--mine来运行geth节点来挖掘一些ether。建议更简单是从reddit thread获得ether 或ping我，我给你一些。再次尝试web3.eth.getBalance，以确保有ether。也可以在ropsten.etherscan.io上输入地址以查看帐户余额 现在你已经有了一些了，继续编译并将合约部署到区块链。下面是运行命令和输出 在部署合同之前，记得解锁账户 123456789101112131415$ truffle migrateCompiling Migrations.sol...Compiling Voting.sol...Writing artifacts to ./build/contractsRunning migration: 1_initial_migration.jsDeploying Migrations...Migrations: 0x3cee101c94f8a06d549334372181bc5a7b3a8beeSaving successful migration to network...Saving artifacts...Running migration: 2_deploy_contracts.jsDeploying Voting...Voting: 0xd24a32f0ee12f5e9d233a2ebab5a53d4d4986203Saving successful migration to network...Saving artifacts...$ 与voting合约交互成功部署合同后，现在应该能够获取投票计数并通过truffle控制台进行投票。 1234567891011$ truffle consoletruffle(default)&gt; Voting.deployed().then(function(contractInstance) &#123;contractInstance.voteForCandidate('Rama').then(function(v) &#123;console.log(v)&#125;)&#125;)// After a few seconds, you should see a transaction receipt like this:receipt:&#123; blockHash: '0x7229f668db0ac335cdd0c4c86e0394a35dd471a1095b8fafb52ebd7671433156',blockNumber: 469628,contractAddress: null,........truffle(default)&gt; Voting.deployed().then(function(contractInstance) &#123;contractInstance.totalVotesFor.call('Rama').then(function(v) &#123;console.log(v)&#125;)&#125;)&#123; [String: '1'] s: 1, e: 0, c: [ 1] &#125; 现在启动服务器 1$ npm run dev 应该在localhost：8080看到投票页面，并且能够投票并看到所有候选人的投票数量。由于我们正在处理一个真正的区块链，所以每次写入区块链（voteForCandidate）将需要几秒钟的时间（矿工必须将您的交易包括在区块中，区块中包含区块链）。 如果你看到这个页面并且能够投票，你就可以在公共测试网络上建立一个完整的以太坊应用程序，Congratulation！ 由于所有的交易都是公开的，可以在这里查看：https://testnet.etherscan.io/。只需输入帐户地址，就会显示所有的交易与时间戳。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/tags/区块链/"},{"name":"Ethereum","slug":"Ethereum","permalink":"http://xichen.pub/tags/Ethereum/"},{"name":"Dapp","slug":"Dapp","permalink":"http://xichen.pub/tags/Dapp/"}]},{"title":"Ethereum Dapp Tutorial — Part 1","slug":"2018-01-25-Ethereum-Dapp-Tutorial-Part-1","date":"2018-01-24T18:01:00.000Z","updated":"2019-04-01T15:18:44.172Z","comments":true,"path":"2018/01/25/2018-01-25-Ethereum-Dapp-Tutorial-Part-1/","link":"","permalink":"http://xichen.pub/2018/01/25/2018-01-25-Ethereum-Dapp-Tutorial-Part-1/","excerpt":"","text":"Part 0 Part 1 Part 2 Part 3 在上一篇文章中，通过和传统的 web程序相比较解释了以太坊平台的结构。作为一个开发者，学习新技术的最好的方式就是构建一个玩具程序。 在这篇文章中构建一个简单的“hello word”程序，这个程序是一个投票程序。 这个程序非常简单，包括：初始化一个参加者集合，让任何人为候选人投票，显示每一个候选人获得的投票数。我们的目的不仅仅是编写一个应用，目的是学习应用编译，部署，交互的过程。 总的来说这章是对上一篇文章的延续，如果你是刚接触Ethereum，我建议你最好读一读上一篇文章。 练习目的： 搭建开发环境 学习在开发环境下编写，编译，部署合约。 在区块链上通过node.js控制台利用合约进行交互。 通过一个简单的web页面利用合约来交互，通过这个页面显示投票数，以及每个候选人的获得的投票数。 整个应用部署在ubuntu 16.04上，在macos上也行。 构建应用程序 搭建开发环境这里不是基于活跃的区块链的开发app，而是使用一个叫做testrpc的内存区块链。在Part 2中，我们将会在真正的区块链上进行交互，下面来安装testrpc,web3js以及在linux环境中启动一个测试区块链。对于windows来说可以使用下面的方式：https://medium.com/@PrateeshNanada/steps-to-install-testrpc-in-windows-10-96989a6cd594 注意：这个教程当前工作的web3js的版本是0.20.1，运行npm install ethereumjs-testrpc web3@0.20.1 而不是运行npm install ethereumjs-testrpc web3 ，在web3js的1.0文档版发布之后我会更新这个教程。 注意testrpc在自动运行的时候会自动创建10个测试帐号。这些帐号都预装了100个假的以太网节点。 简单的投票合约用solidity语言来编写合约。 编写的智能合约叫做Voting（在你熟悉的面相对象语言中想象合约就是一个类），Voting有一个初始化候选人的数组结构。有两个方法，一个是返回候选人获得的总选票，另一个是给候选人加票的方法。 注意：把合约部署到区块链上的时候，构造函数只能被调用一次，和web世界不同，web世界中你的代码部署的时候你可以使用新代码来覆盖以前的老代码，但是在区块链上部署的代码是不可更改的。如果你更新合约重新部署代码，旧的合约以及数据依然在区块链上。新部署的将会创建一个新的合约实例。 下面是一个投票合约的代码，每一行都有注释： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647pragma solidity ^0.4.11;// We have to specify what version of compiler this code will compile withcontract Voting &#123; /* mapping field below is equivalent to an associative array or hash. The key of the mapping is candidate name stored as type bytes32 and value is an unsigned integer to store the vote count */ mapping (bytes32 =&gt; uint8) public votesReceived; /* Solidity doesn&apos;t let you pass in an array of strings in the constructor (yet). We will use an array of bytes32 instead to store the list of candidates */ bytes32[] public candidateList; /* This is the constructor which will be called once when you deploy the contract to the blockchain. When we deploy the contract, we will pass an array of candidates who will be contesting in the election */ function Voting(bytes32[] candidateNames) &#123; candidateList = candidateNames; &#125; // This function returns the total votes a candidate has received so far function totalVotesFor(bytes32 candidate) returns (uint8) &#123; if (validCandidate(candidate) == false) throw; return votesReceived[candidate]; &#125; // This function increments the vote count for the specified candidate. This // is equivalent to casting a vote function voteForCandidate(bytes32 candidate) &#123; if (validCandidate(candidate) == false) throw; votesReceived[candidate] += 1; &#125; function validCandidate(bytes32 candidate) returns (bool) &#123; for(uint i = 0; i &lt; candidateList.length; i++) &#123; if (candidateList[i] == candidate) &#123; return true; &#125; &#125; return false; &#125;&#125; 拷贝下面代码到hello_world_voting目录的文件Voting.sol文件中，现在编译代码，并把它部署到testrps上面。 编译solidity代码，首先要通过npm安装npm module：solc 1npm install solc 用带有node.js控制台的包，来编译智能合约，从上一章知道，web3js是一个让你通过RPC来和区块链交互的包。用web3js这个包来进行部署与交互。 首先，在控制台运行node命令来调用node控制台，并初始化solc和web3js对象。下面所有的代码片段，都需要在node的交互式环境下。 1234$ node&gt; Web3 = require('web3')&gt; web3 = new Web3(new Web3.providers.HttpProvider(\"http://localhost:8545\")); 为了确保web3js对象被初始化了，并且可以和区块链通信，查询所有在区块链上的账户。你会看到类似下面的输出结果： 1234567891011&gt; web3.eth.accounts['0x9c02f5c68e02390a3ab81f63341edc1ba5dbb39e','0x7d920be073e92a590dc47e4ccea2f28db3f218cc','0xf8a9c7c65c4d1c0c21b06c06ee5da80bd8f074a9','0x9d8ee8c3d4f8b1e08803da274bdaff80c2204fc6','0x26bb5d139aa7bdb1380af0e1e8f98147ef4c406a','0x622e557aad13c36459fac83240f25ae91882127c','0xbf8b1630d5640e272f33653e83092ce33d302fd2','0xe37a3157cb3081ea7a96ba9f9e942c72cf7ad87b','0x175dae81345f36775db285d368f0b1d49f61b2f8','0xc26bda5f3370bdd46e7c84bdb909aead4d8f35f3'] 编译智能合约：通过从Voting.sol文件中加载智能合约到一个字符串变量中，然后编译。 123&gt; code = fs.readFileSync('Voting.sol').toString()&gt; solc = require('solc')&gt; compiledCode = solc.compile(code) 当你成功编译了代码，打印了合约对象（仅仅是在控制台中查看到的上面compiledCode类型的内容），你会发现这里有两个重要的字段，理解他们十分重要： compiledCode.contracts[‘:Voting’].bytecode：Voting.sol编译得到的是二进制代码。这个就是将要部署到区块链上的代码。 compiledCode.contracts[‘:Voting’].interface：这是一个智能合约接口或者是智能合约模版（叫做abi），他告诉合约使用者，合约中可以使用的方法。在将来无论你在什么时候要与智能合约交互，你都会用到这个abi的定义。你可以在这里查看更多关于abi的详细描述 现在来部署智能合约。首先你要创建一个合约对象（下面的VotingContract），这个合约对象用来在区块链上部署和初始化合约。 123456&gt; abiDefinition = JSON.parse(compiledCode.contracts[':Voting'].interface)&gt; VotingContract = web3.eth.contract(abiDefinition)&gt; byteCode = compiledCode.contracts[':Voting'].bytecode&gt; deployedContract = VotingContract.new(['Rama','Nick','Jose'],&#123;data: byteCode, from: web3.eth.accounts[0], gas: 4700000&#125;)&gt; deployedContract.address&gt; contractInstance = VotingContract.at(deployedContract.address) 上面的VotingContract.new用来在区块链上部署智能合约。第一个参数是候选人数组，这些候选人在选举竞争中都是相对简单的。第二个参数的hash： data：这是在区块链上部署的编译后的二进制代码。 from：区块链必须记录谁部署了这个智能合约。在这个例子中选择第一个账户来作为这个智能合约的拥有者（将会部署这个合约到区块链上）。这第一个账户通过调用web3.eth.accounts来获取。上面代码web3.eth.accounts返回一个数组，数组里面包含10个由testrpc创建的测试账户，这10个账户是在启动测试区块链的时候创建。在真实活跃的区块链中，在没创建之前，不能使用任何账户。必须在交易（通信／交流）前拥有这个账户，并解锁。创建账户时要求填写密码，这个密码用来证明你和账户的关系。为了方便testrpc默认解锁了10个账户。 gas：和区块链交互花费的钱，这些钱是给矿工的，矿工的所有工作是在区块链上引入你的代码。必须指定你会支付多少钱给把你的代码包含到区块链上的人。这些钱就是通过设置gas的值来指定的。你的上面代码from中的账户的以太坊余额可以用来购买gas。gas的价格由网络来设定。 现在已经部署了智能合约并有了一个合约实例（上面的contractInstance变量）。可以使用这个合约来进行交互。区块链上有成千上万的合约部署在上面。但是，在区块链上怎么辨别自己的合约呢？答案就是deployedContract.address。当你利用你的合约进行交互的时候，你需要这个部署地址，以及上面提到的abi的描述。 在nodes控制台和合约进行交互12345678910&gt; contractInstance.totalVotesFor.call('Rama')&#123; [String: '0'] s: 1, e: 0, c: [ 0 ] &#125;&gt; contractInstance.voteForCandidate('Rama', &#123;from: web3.eth.accounts[0]&#125;)'0xdedc7ae544c3dde74ab5a0b07422c5a51b5240603d31074f5b75c0ebc786bf53'&gt; contractInstance.voteForCandidate('Rama', &#123;from: web3.eth.accounts[0]&#125;)'0x02c054d238038d68b65d55770fabfca592a5cf6590229ab91bbe7cd72da46de9'&gt; contractInstance.voteForCandidate('Rama', &#123;from: web3.eth.accounts[0]&#125;)'0x3da069a09577514f2baaa11bc3015a16edf26aad28dffbcd126bde2e71f2b76f'&gt; contractInstance.totalVotesFor.call('Rama').toLocaleString()'3' 在你的node交互控制台上试试上面的命令，你将会看到投票的数量增加。每次当你为一个候选人投票，你就会获得一个交易的ID：例如:上面的: &#39;0xdedc7ae544c3dde74ab5a0b07422c5a51b5240603d31074f5b75c0ebc786bf53&#39; 这个交易ID是交易发生的证据。将来你可以在任何时间来返回去查看他（数据可追踪）。这个交易是不可更改的。这种不可更改的特性是以太坊这种区块链的很大优势之一。在接下来的教程中，会用其不可更改性来构建应用。 web页面链接区块链和投票现在所有的工作都完成了，现在要做的就是构建一个包含候选人的简单的html文件。并在一个js文件中调用投票命令（这个投票命令已经在前面的node控制台中测试过了）。下面你会看到html代码和js文件。 在hello_world_voting文件夹下复制，并在你的浏览器中打开index.html 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Hello World DApp&lt;/title&gt; &lt;link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'&gt; &lt;link href='https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css' rel='stylesheet' type='text/css'&gt;&lt;/head&gt;&lt;body class=\"container\"&gt; &lt;h1&gt;A Simple Hello World Voting Application&lt;/h1&gt; &lt;div class=\"table-responsive\"&gt; &lt;table class=\"table table-bordered\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Candidate&lt;/th&gt; &lt;th&gt;Votes&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Rama&lt;/td&gt; &lt;td id=\"candidate-1\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Nick&lt;/td&gt; &lt;td id=\"candidate-2\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Jose&lt;/td&gt; &lt;td id=\"candidate-3\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;input type=\"text\" id=\"candidate\" /&gt; &lt;a href=\"#\" onclick=\"voteForCandidate()\" class=\"btn btn-primary\"&gt;Vote&lt;/a&gt;&lt;/body&gt;&lt;script src=\"https://cdn.rawgit.com/ethereum/web3.js/develop/dist/web3.js\"&gt;&lt;/script&gt;&lt;script src=\"https://code.jquery.com/jquery-3.1.1.slim.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./index.js\"&gt;&lt;/script&gt;&lt;/html&gt; index.js文件： 1234567891011121314151617181920212223web3 = new Web3(new Web3.providers.HttpProvider(\"http://localhost:8545\"));abi = JSON.parse('[&#123;\"constant\":false,\"inputs\":[&#123;\"name\":\"candidate\",\"type\":\"bytes32\"&#125;],\"name\":\"totalVotesFor\",\"outputs\":[&#123;\"name\":\"\",\"type\":\"uint8\"&#125;],\"payable\":false,\"type\":\"function\"&#125;,&#123;\"constant\":false,\"inputs\":[&#123;\"name\":\"candidate\",\"type\":\"bytes32\"&#125;],\"name\":\"validCandidate\",\"outputs\":[&#123;\"name\":\"\",\"type\":\"bool\"&#125;],\"payable\":false,\"type\":\"function\"&#125;,&#123;\"constant\":true,\"inputs\":[&#123;\"name\":\"\",\"type\":\"bytes32\"&#125;],\"name\":\"votesReceived\",\"outputs\":[&#123;\"name\":\"\",\"type\":\"uint8\"&#125;],\"payable\":false,\"type\":\"function\"&#125;,&#123;\"constant\":true,\"inputs\":[&#123;\"name\":\"x\",\"type\":\"bytes32\"&#125;],\"name\":\"bytes32ToString\",\"outputs\":[&#123;\"name\":\"\",\"type\":\"string\"&#125;],\"payable\":false,\"type\":\"function\"&#125;,&#123;\"constant\":true,\"inputs\":[&#123;\"name\":\"\",\"type\":\"uint256\"&#125;],\"name\":\"candidateList\",\"outputs\":[&#123;\"name\":\"\",\"type\":\"bytes32\"&#125;],\"payable\":false,\"type\":\"function\"&#125;,&#123;\"constant\":false,\"inputs\":[&#123;\"name\":\"candidate\",\"type\":\"bytes32\"&#125;],\"name\":\"voteForCandidate\",\"outputs\":[],\"payable\":false,\"type\":\"function\"&#125;,&#123;\"constant\":true,\"inputs\":[],\"name\":\"contractOwner\",\"outputs\":[&#123;\"name\":\"\",\"type\":\"address\"&#125;],\"payable\":false,\"type\":\"function\"&#125;,&#123;\"inputs\":[&#123;\"name\":\"candidateNames\",\"type\":\"bytes32[]\"&#125;],\"payable\":false,\"type\":\"constructor\"&#125;]')VotingContract = web3.eth.contract(abi);// In your nodejs console, execute contractInstance.address to get the address at which the contract is deployed and change the line below to use your deployed addresscontractInstance = VotingContract.at('0x2a9c1d265d06d47e8f7b00ffa987c9185aecf672');candidates = &#123;\"Rama\": \"candidate-1\", \"Nick\": \"candidate-2\", \"Jose\": \"candidate-3\"&#125;function voteForCandidate() &#123; candidateName = $(\"#candidate\").val(); contractInstance.voteForCandidate(candidateName, &#123;from: web3.eth.accounts[0]&#125;, function() &#123; let div_id = candidates[candidateName]; $(\"#\" + div_id).html(contractInstance.totalVotesFor.call(candidateName).toString()); &#125;);&#125;$(document).ready(function() &#123; candidateNames = Object.keys(candidates); for (var i = 0; i &lt; candidateNames.length; i++) &#123; let name = candidateNames[i]; let val = contractInstance.totalVotesFor.call(name).toString() $(\"#\" + candidates[name]).html(val); &#125;&#125;); 不知道还记得前面说过和任何合约进行交互必须需要abi和地址。在上面的index.js文件中可以看到是怎么使用合约来进行交互的 下面是你在浏览器中打开index.html文件。 如果你可以进入上面文本框的候选人名字，并投票并且会看到投票增加。你已经成功构建了你的第一个应用。Congratulation！ 总结 搭建环境 编写简单合约 编译及部署合约到区块链上 能够通过nodejs控制台进行交互，同时也能通过web页面进行同样交互。 在Part 2会部署这个合约到一个公共的测试网络，这样整个世界都会看到并给候选人进行投票。 Part 2使用truffle框架来开发（不要使用node的控制台来管理整个过程）。 参考：https://medium.com/@mvmurthy/full-stack-hello-world-voting-ethereum-dapp-tutorial-part-1-40d2d0d807c2","categories":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/tags/区块链/"},{"name":"Ethereum","slug":"Ethereum","permalink":"http://xichen.pub/tags/Ethereum/"},{"name":"Dapp","slug":"Dapp","permalink":"http://xichen.pub/tags/Dapp/"}]},{"title":"Ethereum Dapp Tutorial — Part 0","slug":"2018-01-24-Ethereum-Dapp-Tutorial-Part-0","date":"2018-01-24T12:01:00.000Z","updated":"2019-04-01T15:18:44.171Z","comments":true,"path":"2018/01/24/2018-01-24-Ethereum-Dapp-Tutorial-Part-0/","link":"","permalink":"http://xichen.pub/2018/01/24/2018-01-24-Ethereum-Dapp-Tutorial-Part-0/","excerpt":"","text":"Part 0 Part 1 Part 2 Part 3 学以太坊区块链平台已经有一段时间了，网络上有很多关于以太坊的资料（文章，视频，平台官网），这些很容易就能找到。由于以太坊平台还在快速迭代，所以相关的资料内容普遍滞后。然后自己基于所学整理了一下关于啥是以太坊，以及怎么搞以太坊的图。在学习过程中遇到了很多问题，本文整理一下，顺便从一个web开发者的角度来解释以太坊。 什么是webapp构架webapp的客户端以及服务端： 一个web应用托管在托管服务器上，像AWS，Heroku，VPS等，所有的客户端都是通过一个中心的应用程序进行交流。客户端可以是web浏览器，或者是其它的消费你程序的API等。当一个客户端像服务端发起一个请求，服务器会和数据库进行通信，对数据库进行增删改查，然后相应客户端请求。 这种结构大部分情况下都能很好的运行，但是如果数据库是公开的任何人都可以访问，那么有一些应用就会变得很有用，这样我就不用依赖上面的webapp来获取自己个人的数据了，也就是说我可以从其它渠道获取我的个人数据。 下面举例说明：例如eBay，如果你是一个超级卖家，已经获得了数百的好评。由于某些原因eBay封停了你的帐号。这事会严重的影响你的生意。如果你能够把这数百的好评与评分转移到其他平台（eBay的竞争者）的话，这就很爽了。eBay在买家和卖家之间提供了一个第三方信任服务。并且从买卖双方都要收取佣金。是否有这么一种方式买卖双方在交易的时候完全忽略eBay，这样双方也节省了佣金，同时你又可以访问到你的交易数据？这就是下面的图片提出的去中心化应用。以太坊让你很容易的创建Dapps(去中心化应用)。 什么是以太坊Dapp 你是否发现，每一个客户端交流使用的都是它自己的应用实例。没有一个所有的客户端都链接到服务器上的中心化服务器。这就意味着，每一个想通过去中心化应用交互的人，需要在他们的电脑或者是手机上完整的拷贝区块链。这就意味着，在你可以使用应用之前，你需要下载完整的区块链，然后启动使用这个应用。第一次听说感觉很荒唐，但是他有一个好处就是不需要依赖一个中心化的服务，而且这个中心化的服务有可能明天就不存在了。 现实中你不需要花费很多的内存和硬盘，来下载完整的区块链。已经有了一些变通的方法或者是优化来使的应用去中心化，保证交互方便快捷。 什么是区块链 Database(数据库)：在以太坊网络上每发生一个交易就会被包装到一个区块中，每一个区块都和下一个区块相连。这些包含所有交易数据相连的一系列的块就是区块链。如果我们返回去看刚才的eBay的例子，买卖双方无论是出售，退款还是纠纷都将会被记录在区块链上，并且每个人都可以看到。为了保证以太坊网络上的所以网络节点对这条信息都有同样的拷贝，而且为了确保非法数据写入的这个数据库中（区块链的区块中），以太坊使用一个叫做proof的算法来做这件工作。 Code：区块链的数据库部分只是存储了数据，但是像买，买，取消，退款等操作逻辑在什么地方呢？在以太坊的世界里，你可以使用一个叫做Solidity的语言来写应用（合约）代码。然后可以使用Solidity编译器来把代码编译成以太坊二进制文件，然后把这个二进制代码部署到区块链上。除此之外和Solidity很少有其他的交互，但是Solidity是目前开发合约最流行的开发语言。 所以从根本上来说：区块链存储数据，存储代码，而且运行EVM（Ethereum Virtual Machine）中的代码。 如何开发Dapp基于Dapps构建web，Ethereal有一个很好用的javascript包叫web3.js，这个包可以和你的区块链接点建立连接。所以只需在javascript框架（reactjs, angularjs等）中引入这个包，然后就可以开始构建应用了。 另一个大而重要的应用方面是平台的财务能力。因为在使用Dapp的时候，你就拥有了一个内置的银行帐户。事实上不只是一个银行帐户，你可以在一分钟内创建多个帐户。这些银行帐户被叫做钱包，你可以用来存钱（用在以太坊生态系统的货币）和交易。 END有许多关于区块链的内部细节我故意没有讲，因为我想集中精力在基于区块链的Dapp和中心化的webapp进行比较。希望这篇文章可以很好的达到说明以太坊是什么，以及怎么去构建去中心化的应用。 请看接下来的3个指导教程来构建全栈的dapp Part 1 Part 2 Part 3 延伸阅读： Ethereum white paper 写智能合约的语言Solidity https://gitter.im/ethereum/solidityand https://gitter.im/ethereum/web3.js","categories":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/tags/区块链/"},{"name":"Ethereum","slug":"Ethereum","permalink":"http://xichen.pub/tags/Ethereum/"},{"name":"Dapp","slug":"Dapp","permalink":"http://xichen.pub/tags/Dapp/"}]},{"title":"Git的4个阶段的撤销更改","slug":"2018-01-23-Git的4个阶段的撤销更改","date":"2018-01-23T15:01:00.000Z","updated":"2019-04-01T15:18:44.169Z","comments":true,"path":"2018/01/23/2018-01-23-Git的4个阶段的撤销更改/","link":"","permalink":"http://xichen.pub/2018/01/23/2018-01-23-Git的4个阶段的撤销更改/","excerpt":"","text":"基本概念3个步骤 正常情况下，我们的工作流就是3个步骤，对应上图中的3个箭头线： 123git add .git commit -m \"comment\"git push git add .把所有文件放入暂存区； git commit把所有文件从暂存区提交进本地仓库； git push把所有文件从本地仓库推送进远程仓库。 4个区git之所以令人费解，主要是它相比于svn等等传统的版本管理工具，多引入了一个暂存区(Stage)的概念，就因为多了这一个概念，而使很多人疑惑。其实，在初学者来说，每个区具体怎么工作的，我们完全不需要关心，而只要知道有这么4个区就够了： 工作区(Working Area) 暂存区(Stage) 本地仓库(Local Repository) 远程仓库(Remote Repository) 5种状态以上4个区，进入每一个区成功之后会产生一个状态，再加上最初始的一个状态，一共是5种状态。以下我们把这5种状态分别命名为： 未修改(Origin) 已修改(Modified) 已暂存(Staged) 已提交(Committed) 已推送(Pushed) 检查修改了解了基本概念之后，我们来谈一谈犯错误之后如何撤销的问题。首先，我们要了解如何检查这3个步骤当中每一个步骤修改了什么，然后才好判断有没有修改成功。检查修改的二级命令都相同，都是diff，只是参数有所不同。 已修改，未暂存1git diff 首先，我们来看一下，如果我们只是简单地在浏览器里保存了一下文件，但是还没有做git add .之前，我们如何检查有哪些修改。我们先随便拿一个文件来做一下实验： 我们在文件开头的第2行胡乱加了4个数字1234，存盘，这时文件进入了已修改状态，但是还没有进入暂存区，我们运行git diff，结果如下： 12345678910diff --git a/index.md b/index.mdindex 73ff1ba..1066758 100644--- a/index.md+++ b/index.md@@ -1,5 +1,5 @@ ----layout: main+1234layout: main color: black --- git diff的结果告诉我们哪些文件已经做了哪些修改。 已暂存，未提交1git diff --cached 现在我们把修改放入暂存区看一下。先执行git add .，然后执行git diff，你会发现没有任何结果： 这说明git diff这个命令只检查我们的工作区和暂存区之间的差异，如果我们想看到暂存区和本地仓库之间的差异，就需要加一个参数git diff --cached： 12345678910diff --git a/index.md b/index.mdindex 73ff1ba..1066758 100644--- a/index.md+++ b/index.md@@ -1,5 +1,5 @@ ----layout: main+1234layout: main color: black --- 这时候我们看到的差异是暂存区和本地仓库之间的差异。 已提交，未推送1git diff master origin/master 现在，我们把修改从暂存区提交到本地仓库，再看一下差异。先执行git commit，然后再执行git diff --cached，没有差异，执行git diff master origin/master，可以看到差异： 在这里，master就是你的本地仓库，而origin/master就是你的远程仓库，master是主分支的意思，因为我们都在主分支上工作，所以这里两边都是master，而origin就代表远程。 撤销修改了解清楚如何检查各种修改之后，我们开始尝试各种撤销操作。 已修改，未暂存如果我们只是在编辑器里修改了文件，但还没有执行git add .，这时候我们的文件还在工作区，并没有进入暂存区，我们可以用： 1git checkout . 或者 1git reset --hard 来进行撤销操作。 可以看到，在执行完git checkout .之后，修改已被撤销，git diff没有任何内容了。 一对反义词git add .的反义词是git checkout .。做完修改之后，如果你想向前走一步，让修改进入暂存区，就执行git add .，如果你想向后退一步，撤销刚才的修改，就执行git checkout .。 已暂存，未提交你已经执行了git add .，但还没有执行git commit -m &quot;comment&quot;。这时候你意识到了错误，想要撤销，你可以执行： 12git resetgit checkout . 或者 1git reset --hard git reset只是把修改退回到了git add .之前的状态，也就是说文件本身还处于已修改未暂存状态，你如果想退回未修改状态，还需要执行git checkout .。 或许你已经注意到了，以上两个步骤都可以用同一个命令git reset --hard来完成。是的，就是这个强大的命令，可以一步到位地把你的修改完全恢复到未修改的状态。 已提交，未推送你的手太快，你既执行了git add .，又执行了git commit，这时候你的代码已经进入了你的本地仓库，然而你后悔了，怎么办？不要着急，还有办法。 1git reset --hard origin/master 还是这个git reset --hard命令，只不过这次多了一个参数origin/master，正如我们上面讲过的，origin/master代表远程仓库，既然你已经污染了你的本地仓库，那么就从远程仓库把代码取回来吧。 已推送很不幸，你的手实在是太快了，你既git add了，又git commit了，并且还git push了，这时你的代码已经进入远程仓库。如果你想恢复的话，还好，由于你的本地仓库和远程仓库是等价的，你只需要先恢复本地仓库，再强制push到远程仓库就好了： 12git reset --hard HEAD^git push -f 总结以上4种状态的撤销我们都用到了同一个命令git reset --hard，前2种状态的用法甚至完全一样，所以只要掌握了git reset --hard这个命令的用法，从此你再也不用担心提交错误了。 更多参考独孤求败：Git中的各种后悔药","categories":[{"name":"Git","slug":"Git","permalink":"http://xichen.pub/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://xichen.pub/tags/Git/"}]},{"title":"Android Studio 3.0及Gradle Plugin 3.0升级注意事项","slug":"2018-01-23-Android-Studio-3.0及Gradle-Plugin-3.0升级注意事项","date":"2018-01-23T00:48:00.000Z","updated":"2019-04-01T15:18:44.168Z","comments":true,"path":"2018/01/23/2018-01-23-Android-Studio-3.0及Gradle-Plugin-3.0升级注意事项/","link":"","permalink":"http://xichen.pub/2018/01/23/2018-01-23-Android-Studio-3.0及Gradle-Plugin-3.0升级注意事项/","excerpt":"","text":"最近终于有空升级了一下项目中的Gradle和Gradle Plugin的版本，还是踩了蛮多的坑。特别是依赖以及渠道编译这块变动较大，因此把遇到的一些问题点记录下来，分享给后人查阅~ Gradle版本升级其实当AS升级到3.0之后，Gradle Plugin和Gradle不升级也是可以继续使用的，但很多新的特性如：Java8支持、新的依赖匹配机制、AAPT2等新功能都无法正常使用~ 所以长期看来，最后还是得升的。 Gradle Plugin升级到3.0.0及以上，修改project/build.gradle文件： 123456789101112buildscript &#123; repositories &#123; ... // You need to add the following repository to download the // new plugin. google() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:3.0.0' &#125;&#125; Gradle升级到4.1及以上，修改project/gradle/gradle-wrapper.properties文件： 1distributionUrl=https\\://services.gradle.org/distributions/gradle-4.1-all.zip 生成APK文件名属性outputFile变为只读改完第一步后会提示如下报错： Error:(88, 0) Cannot set the value of read-only property ‘outputFile’ for ApkVariantOutputImpl_Decorated{apkData=Main{type=MAIN, fullName=appDebug, filters=[]}} of type com.android.build.gradle.internal.api.ApkVariantOutputImpl. 之前改apk名字的代码类似：1234567applicationVariants.all &#123; variant -&gt; variant.outputs.each &#123; output -&gt; def file = output.outputFile def apkName = 'xxx-xxx-xxx-signed.apk' output.outputFile = new File(file.parent, apkName) &#125;&#125; 由于outputFile属性变为只读，需要进行如下修改，直接对outputFileName属性赋值即可：123456applicationVariants.all &#123; variant -&gt; variant.outputs.all &#123; def apkName = 'xxx-xxx-xxx-signed.apk' outputFileName = apkName &#125;&#125; 依赖关键字的改变 api: 对应之前的compile关键字，功能一模一样。会传递依赖，导致gradle编译的时候遍历整颗依赖树 implementation: 对应之前的compile，与api类似，关键区别是不会有依赖传递 compileOnly: 对应之前的provided，依赖仅用于编译期不会打包进最终的apk中 runtimeOnly: 对应之前的’apk’，与上面的compileOnly相反 关于implementation与api的区别，主要在依赖是否会传递上。如：A依赖B，B依赖C，若使用api则A可以引用C，而implementation则不能引用。 这里更推荐用implementation，一是不会间接的暴露引用，清晰知道目前项目的依赖情况；二是可以提高编译时依赖树的查找速度，进而提升编译速度。详见SO的这个回答，讲得非常详细了：https://stackoverflow.com/questions/44413952/gradle-implementation-vs-api-configuration 渠道需要声明flavor dimensions刚开始Sync的时候应该会报错： Error:All flavors must now belong to a named flavor dimension. Learn more at https://d.android.com/r/tools/flavorDimensions-missing-error-message.html 也就是每个flavor渠道都必须归属一个dimension维度，若只有一个维度，渠道中可以不写dimension属性，默认分配到该维度。直接添加一个默认的维度即可，如：flavorDimensions &quot;dimension&quot;。当然flavorDimensions也可以设置多个维度，详见官方实例：1234567891011121314151617181920212223242526// Specifies two flavor dimensions.flavorDimensions \"mode\", \"minApi\"productFlavors &#123; free &#123; // Assigns this product flavor to the \"tier\" flavor dimension. Specifying // this property is optional if you are using only one dimension. dimension \"mode\" ... &#125; paid &#123; dimension \"mode\" ... &#125; minApi23 &#123; dimension \"minApi\" ... &#125; minApi18 &#123; dimension \"minApi\" ... &#125;&#125; 库多variant依赖方式的修改Gradle plugin 3.0.0+之后引入了新的variant自动匹配机制，也就是说app的flavorDebug变体会自动匹配library的flavorDebug变体。 回顾一下旧的方式，如果app在某个variant下需要依赖library相应的类型，需要按照下面的方式声明依赖：123456dependencies &#123; // This is the old method and no longer works for local // library modules: debugCompile project(path: ':library', configuration: 'debug') releaseCompile project(path: ':library', configuration: 'release')&#125; 新的方式，gradle会自动感知并匹配对应的variant（前提是app与library中有对应的variant类型）：1234567dependencies &#123; // Instead, simply use the following to take advantage of // variant-aware dependency resolution. You can learn more about // the 'implementation' configuration in the section about // new dependency configurations. implementation project(':library')&#125; 处理app与lib的依赖匹配问题上面我们了解到新的variant匹配机制，但若app或library中不存在对应的variant类型呢？匹配将如何进行？下面列出了可能出现的几种情形： 情形1：app中有某个build type但library却木有可以通过matchingFallbacks属性来设置回退策略，提供可能的匹配列表，代码如下：123456789101112131415// In the app's build.gradle file.android &#123; buildTypes &#123; debug &#123;&#125; release &#123;&#125; staging &#123; // Specifies a sorted list of fallback build types that the // plugin should try to use when a dependency does not include a // \"staging\" build type. You may specify as many fallbacks as you // like, and the plugin selects the first build type that's // available in the dependency. matchingFallbacks = ['debug', 'qa', 'release'] &#125; &#125;&#125; 若希望可以针对app的每个build type都执行相同的回退策略（例如我们大量的library只有一个release的build type），则可以使用批量指令：123buildTypes.all &#123; type -&gt; type.matchingFallbacks = ['release']&#125; （注意：在该情景下，若library中有某个build type但app却木有，不会对app有任何影响） 情景2：在同一个dimension维度下，如：tier。若app中有某个flavor但library却木有：同样可以通过matchingFallbacks属性来设置回退策略，代码如下：1234567891011121314151617181920212223242526// In the app's build.gradle file.android &#123; defaultConfig&#123; // Do not configure matchingFallbacks in the defaultConfig block. // Instead, you must specify fallbacks for a given product flavor in the // productFlavors block, as shown below. &#125; flavorDimensions 'tier' productFlavors &#123; paid &#123; dimension 'tier' // Because the dependency already includes a \"paid\" flavor in its // \"tier\" dimension, you don't need to provide a list of fallbacks // for the \"paid\" flavor. &#125; free &#123; dimension 'tier' // Specifies a sorted list of fallback flavors that the plugin // should try to use when a dependency's matching dimension does // not include a \"free\" flavor. You may specify as many // fallbacks as you like, and the plugin selects the first flavor // that's available in the dependency's \"tier\" dimension. matchingFallbacks = ['demo', 'trial'] &#125; &#125;&#125; （注意：在该情景下，若library中有某个flavor但app却木有，不会对app有任何影响） 情景3：library中有某个dimension维度，但app中却没有:可以通过missingDimensionStrategy属性来设置选择策略，代码如下：12345678910111213141516171819202122// In the app's build.gradle file.android &#123; defaultConfig&#123; // Specifies a sorted list of flavors that the plugin should try to use from // a given dimension. The following tells the plugin that, when encountering // a dependency that includes a \"minApi\" dimension, it should select the // \"minApi18\" flavor. You can include additional flavor names to provide a // sorted list of fallbacks for the dimension. missingDimensionStrategy 'minApi', 'minApi18', 'minApi23' &#125; flavorDimensions 'tier' productFlavors &#123; free &#123; dimension 'tier' // You can override the default selection at the product flavor // level by configuring another missingDimensionStrategy property // for the \"minApi\" dimension. missingDimensionStrategy 'minApi', 'minApi23', 'minApi18' &#125; paid &#123;&#125; &#125;&#125; 说明：其中missingDimensionStrategy属性的第一个值为dimension维度，后面的Strings为该维度下的渠道flavors。我们可以看下它的函数原型：12345public void missingDimensionStrategy(String dimension, String requestedValue);public void missingDimensionStrategy(String dimension, String... requestedValues);public void missingDimensionStrategy(String dimension, List&lt;String&gt; requestedValues); （注意：在该情景下，若app中有某个dimension维度，但library中却没有，不会对app有任何影响） 情景4：若library没有任何dimension和flavor，则不需app做任何flavor的回退处理~说了这么多种场景，是不是快被绕晕了？其实诸如dimension的声明以及提供匹配回退策略都是为了实现精确的variant匹配。但是这么多的场景咋看之下还是比较晕，在遇到具体的业务依赖场景后再回来看这一块的内容，你会更加的有收获~ Java8特性的支持升级到Gradle Plugin 3.0.0之后，一直被诟病的Jack已经被官方弃用了，取而代之的是最新的desugar方案。 若项目之前用了类似retrolambda或者Jack这种旧方案的话，会出现以下提示告诉你移除相关的代码： Warning:One of the plugins you are using supports Java 8 language features. To try the support built into the Android plugin, remove the following from your build.gradle: apply plugin: ‘me.tatarka.retrolambda’ To learn more, go to https://d.android.com/r/tools/java-8-support-message.html 启用最新的desugar也非常简单，设置一下sourceCompatibility和targetCompatibility即可：12345678910android &#123; ... // Configure only for each module that uses Java 8 // language features (either in its source code or // through dependencies). compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 &#125;&#125; 目前所支持Java8的特性有： Lambda expressions Method References Type Annotations Default and static interface methods Repeating annotations （注意：stream及function包下的api只能在API level 24+以上才可以使用） 禁用该特性也是分分钟的事情：1android.enableDesugar=false 官方文档：https://developer.android.com/studio/write/java8-support.html android-apt相关的异常最后的最后很多同学会遇到以下关于android-apt的报错： 解决方法： 移除android-apt相关的plugin，如： 1classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8' 依赖中的apt改成annotationProcessor，如： 1annotationProcessor 'com.android.databinding:compiler:3.0.0' 如果有用到类似Realm这种第三方的plugin，确保升级到最新版试试（旧版的Realm用的还是android-apt），突然发现升级到最新版后api接口被改了，泪奔中… 12345678buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath \"io.realm:realm-gradle-plugin:4.2.0\" &#125;&#125; 更多还有更多的迁移变化，由于项目中还没涉及到，就先不写了，大家可以参考官方文档：https://developer.android.com/studio/build/gradle-plugin-3-0-0-migration.html","categories":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://xichen.pub/tags/Android/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"http://xichen.pub/tags/Android-Studio/"},{"name":"Gradle","slug":"Gradle","permalink":"http://xichen.pub/tags/Gradle/"}]},{"title":"update nodejs and npm","slug":"2018-01-22-update-nodejs-and-npm","date":"2018-01-22T14:16:00.000Z","updated":"2019-04-01T15:18:44.166Z","comments":true,"path":"2018/01/22/2018-01-22-update-nodejs-and-npm/","link":"","permalink":"http://xichen.pub/2018/01/22/2018-01-22-update-nodejs-and-npm/","excerpt":"","text":"升级node.js和npm一行命令搞定npm和node.js的升级，省去了重新编译和安装的过程。具体如下： 升级node.jsnpm中有一个模块叫做“n”，专门用来管理node.js版本的。更新到最新的稳定版只需要在命令行中打下如下代码：12npm install -g nn stable 如需最新版本则用n latest 当然，n后面也可以跟具体的版本号：n v6.2.0 node.js升级就是这么简单。 升级npmnpm升级就更简单了，只需要在终端中输入：1npm -g install npm@next","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://xichen.pub/categories/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://xichen.pub/tags/Ubuntu/"}]},{"title":"running Ubuntu GUI in Windows10","slug":"2018-01-22-running-Ubuntu-GUI-in-Windows10","date":"2018-01-22T14:16:00.000Z","updated":"2019-04-01T15:18:44.165Z","comments":true,"path":"2018/01/22/2018-01-22-running-Ubuntu-GUI-in-Windows10/","link":"","permalink":"http://xichen.pub/2018/01/22/2018-01-22-running-Ubuntu-GUI-in-Windows10/","excerpt":"","text":"安装先安装显示图形界面的程序vcxsrv然后运行以下命令12345678echo \"export DISPLAY=:0.0\" &gt;&gt; ~/.bashrcexport DISPLAY=:0.0sudo apt-get install dbus --reinstallsudo sed -i 's/&lt;listen&gt;.*&lt;\\/listen&gt;/&lt;listen&gt;tcp:host=localhost,port=0&lt;\\/listen&gt;/' /etc/dbus-1/session.confsudo apt-get install ubuntu-desktopsudo apt-get install unitysudo apt-get install compiz-coresudo apt-get install compizconfig-settings-manager 启动先启动XLaunch,选择只启动一个大窗口,把-1改为0这时候的窗口是黑的,因为没有视频输入然后运行命令1compiz 这时又视频输入了，切到XLaunch就可以浪了 0.png 1.png 2.png 3.png 4.png 5.png","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://xichen.pub/categories/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://xichen.pub/tags/Ubuntu/"}]},{"title":"latex（二）完全卸载","slug":"2017-12-28-latex（二）完全卸载","date":"2017-12-28T14:16:00.000Z","updated":"2019-04-01T15:18:44.161Z","comments":true,"path":"2017/12/28/2017-12-28-latex（二）完全卸载/","link":"","permalink":"http://xichen.pub/2017/12/28/2017-12-28-latex（二）完全卸载/","excerpt":"","text":"sudo apt-get purge texlive* rm -rf /usr/local/texlive/* and rm -rf ~/.texlive* rm -rf /usr/local/share/texmf rm -rf /var/lib/texmf rm -rf /etc/texmf sudo apt-get remove tex-common --purge rm -rf ~/.texlive find -L /usr/local/bin/ -lname /usr/local/texlive/*/bin/* | xargs rm This finds all the files in /usr/local/bin which point to a location within /usr/local/texlive/*/bin/* and removes them; because we’ve already deleted all of /usr/local/texlive, these are dead links. To see which files are being deleted, replace xargs rm with xargs -t rm (or tee off to a log file, or whatever).","categories":[{"name":"Latex","slug":"Latex","permalink":"http://xichen.pub/categories/Latex/"}],"tags":[{"name":"Latex","slug":"Latex","permalink":"http://xichen.pub/tags/Latex/"}]},{"title":"latex（一）安装与配置","slug":"2017-12-12-latex（一）安装与配置","date":"2017-12-12T14:16:00.000Z","updated":"2019-04-01T15:18:44.159Z","comments":true,"path":"2017/12/12/2017-12-12-latex（一）安装与配置/","link":"","permalink":"http://xichen.pub/2017/12/12/2017-12-12-latex（一）安装与配置/","excerpt":"","text":"2017年不到20天就到2018年了，才开始把latex用在写论文上。原来只是学了用latex写公式，嫌latex的配置太麻烦，总想拿mardown结合latex搞事情，结果啥也没做到。只好亲自入用latex编译论文的坑了。 latex就是为写论文带来便利。一定不能在安装和配置上花太多时间，不然就舍本逐末了。 Linux 发行版下原版 TeX Live 2017 的安装 在安装前，TeX Live 2017 的手册可以在 TUG 的 TeX Live 目录下找到：https://www.tug.org/texlive/doc/texlive-zh-cn/texlive-zh-cn.pdf。可以先阅读其中的安装部分。在 Linux 上安装原版 TeX Live 2017，与在 Windows 等其他系统下安装并无区别。可以从 CTAN 镜象下载 ISO 文件，然后挂载到一个目录下，运行里面的 install-tl 脚本进行安装；也可以在 CTAN 的网站上只下载 install-tl 脚本运行，在线安装。install-tl 是一个 Perl 脚本，在绝大多数发行版下都可以直接运行。 安装通过系统仓库首先，对于 Arch 等滚动更新发行版的用户来说，推荐使用官方仓库来安装。 1sudo pacman -S texlive-most texlive-lang 但是 Debian/Ubuntu 等的软件源往往会比较旧，为了体验最新的 TeX Live （虽然并没有什么卵差别），因此还是要用 ISO 映像安装。 通过iso文件下载 官方镜像: texlive2017.iso XJTU 镜像: texlive2017.iso（校内用户请选择该源） USTC 镜像: texlive2017.iso（校内用户请选择该源） 镜像站目录里的 texlive.iso 就是最新的 texlive2017.iso。 下载完成后可以选择进行校验避免出错，具体来说镜像站目录里会有 md5 和 sha512 两个 hash 文件以及一个 GPG 签名文件。TeX Live 2016 以后调整了基础架构，安装时会校验包的完整性，如果有 GPG 还会校验⽹络更新的签名。 12345678# GnuPG 校验签名，不懂请跳过，根据我的校验应当无误gpg --verify texlive2017.iso.sha512.asc# MD5 校验md5sum texlive2017.iso# SHA-512 校验sha512sum texlive2017.iso# 与官方提供的 Hash 对比cat texlive2017.iso.md5 texlive2017.iso.sha512 准备如果之前系统里已经装过 TeX Live，建议先删除。 对于 Linux 来说比较简单，只需要把安装目录（默认为 /usr/local/texlive 里的文件夹丢进 trash 即可），此外用户目录里修改过的一些配置也不要忘记。 如果想把有关依赖也卸载了，参考下一篇blog 如果是包管理安装的方式，例如 Ubuntu 用户，可以按照这样卸载： 1sudo apt-get purge texlive* 因为 TeX Live 里的安装脚本是 Perl 写的，如果稍后要用图形界面安装，需要更新下依赖。 12345678# Debian/Ubuntusudo apt-get install perl-tk# CentOS/Fedora/RHELsudo yum install perl-Tk# Fedora 22+sudo dnf install perl-Tk# OpenSUSEsudo zypper install perl-tk 安装如果能借助软件或文管等方式解决映像挂载问题就直接跳过，否则就在下载好的镜像目录执行以下命令安装： 123456sudo mount -o loop texlive2017.iso /mntcd /mnt# 在 shell 里直接安装sudo ./install-tl# 以 GUI 方式安装sudo ./install-tl -gui=perltk 图形界面大概长这样： 图形界面 默认是安装在 /usr/local/texlive 目录下，可以更改为 /home 等，否则无脑下一步即可。 根据硬件性能不同，安装过程一般不会短于 3 分钟。 安装过程 安装结束后可以卸载映像。 12cd ~sudo umount /mnt 通过命令行边下载边安装去这里https://www.tug.org/texlive/找对应的安装包，我下载的是install-tl-unx.tar.gz。 下载完后，随便找个临时目录解压。 默认是安装在 /usr/local/texlive/ 路径下，需要以超级用户权限安装，在解压下的目录运行1sudo ./install-tl 然后在文本界面下按提示进行交互式安装。当然，也可以安装在本地的用户路径下（如 ~/texlive/），这样就不再需要特殊权限。 如果是进行网络安装，默认会自动选择一个 CTAN 镜象。 这种方法在国内安装很慢，1h才下300多个文件。 国内往往需要用 -repository 选项手工指定镜象服务器地址，URL 地址需要指定到 texlive/tlnet/ 路径下。 推荐用清华的镜象：1sudo ./install-tl -repository http://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/tlnet/ 这种方法安装快，1h轻松安装完毕。 更方便的方式则是在图形界面下进行安装，此时需要确保系统安装了 perl-tk 等相关 Perl 图形界面库。运行命令 1sudo ./install-tl -gui 即可按界面中的提示安装。或者运行 1sudo ./install-tl -gui=wizard 使用图形界面的安装向导，向导方式比前面的方式配置项少一些，但更容易使用。 不过没啥用。还是建议用清华镜像那个命令快一点，不需要这么花俏。 修改环境变量，使编辑器等能找到texlive对于 bash 等 Bourne 兼容的 shell，在用户目录的 ~/.bashrc 文件中添加一些环境变量，具体路径由安装的位置确定。 12345# TeX Live 2017export PATH=$&#123;PATH&#125;:/usr/local/texlive/2017/bin/x86_64-linux# 如果是32位最后改为'i386-linux'export MANPATH=$&#123;MANPATH&#125;:/usr/local/texlive/2017/texmf-dist/doc/manexport INFOPATH=$&#123;INFOPATH&#125;:/usr/local/texlive/2017/texmf-dist/doc/info 如果是 csh 或 tcsh，则在 ~/.cshrc 中添加内容。 1234# TeX Live 2017setenv PATH /usr/local/texlive/2017/bin/x86_64-linux:$PATHsetenv MANPATH /usr/local/texlive/2017/texmf-dist/doc/man:$MANPATHsetenv INFOPATH /usr/local/texlive/2017/texmf-dist/doc/info:$INFOPATH 对于 Debian/Ubuntu 用户，可以安装下我根据 官方说明 制作的 texlive-local_2017-1_all.deb 来申明下包管理里的依赖关系，避免版本冲突。 123sudo dpkg -i texlive-local_2017-1_all.deb# 显示安装的 TeX Live 版本信息dpkg -l | grep texlive-local 至于其他发行版的 texlive-dummy 可去 CTAN 搜索。 测试安装完成后，如果一切都设置好，那么运行以下一些简单测试命令，在当前目录应该会得到正确的输出，如果有命令报错，请自行解决。 12345678910# 显示 TeX 版本应为 3.14159265tex --version# 处理一个基本文件，显示无法找到说明环境变量设置有误latex sample2e.tex# 预览上一步得到的 dvi 文件xdvi sample2e.dvi# pdfTeX 编译直接输出一份 PDFpdftex sample2e.tex# 测试 XeTeX 能否访问系统字体xetex opentype-info.tex 安装之后就可以使用 texdoc 命令阅读安装在本地手册了，对 TeX Live 不甚熟悉的用户最好运行 1texdoc texlive-zh 命令再次阅读 TeX Live 2017 的手册。 更新TeX Live 的更新工具 tlmgr（TeX Live Manager）图形性能比较差，特别是在 Windows 上，故推荐终端里直接更新。 12345678# tlmgr 只能在 root 权限下运行su# 更新 tlmgr 宏包管理器tlmgr update -self# 更新所有宏包tlmgr update -all# 官方的 CTAN 镜像源速度可能比较慢，校内用户推荐换成 XJTU，支持 http 或 httpstlmgr update -all -repository https://mirrors.xjtu.edu.cn/CTAN/systems/texlive/tlnet/ 如果钟爱图形界面，带上 -gui 参数即可。校内用户记得把默认软件包仓库改为 XJTU 的镜像源地址。 123su# 指定图形界面语言为中文tlmgr -gui -gui-lang zh_CN 其它 关于 Linux 上的编辑器，理论上只要是文本编辑器均可。由于可选择的方案太多，取决于个人的使用习惯，这里只推荐两个适合入门的自由软件 Texmaker 和 TeXstudio（fork 自前者）。 关于 Linux 上的字体，因为版权问题，所以 Times New Roman 和宋体就成了很多 LaTeX 初学者的困扰。 推荐的办法是 ctex 宏集处理中文，使用 Fandol 开源字体，默认效果好于 Windows 的中易宋体，另外也可使用思源宋体；而西文和数学字符则用 mathptmx 或 newtx 宏包处理，使用开源的 Nimbus Roman No9 L 字体代替 Times New Roman，差别不大。 对字体有严格要求，可以复制 Windows 下的字体到 ~/.fonts 目录下，记得用 fc-cache -fsv 命令更新下字体缓存。 关于 LaTeX 教程或者说手册，推荐两本 包太雷的 lnotes2 和 lshort 中文版。 配置按照 TeX Live 手册的说明，安装之后，还有一些工作需要做： 如果在安装时没有选择在系统目录为可执行文件创建符号链接，就需要手工修改 ~/.profile 文件设置 PATH 环境变量。 export MANPATH=”/usr/local/texlive/2017/texmf-dist/doc/man” export INFOPATH=”/usr/local/texlive/2017/texmf-dist/doc/info” export PATH=”/usr/local/texlive/2017/bin/x86_64-linux:$PATH” XeTeX 会使用 fontconfig 库来通过字体名搜索字体。TeX Live 的字体目录默认并不在 fongconfig 的搜索目录之列，因此需要按文档要求，将 TeX Live 安装目录下的 texmf-var/fonts/conf/texlive-fontconfig.conf 文件，复制到 /etc/fonts/conf.d/09-texlive.conf，然后运行 fc-cache，以确保 XeTeX 能搜索到字体。否则，TeX Live 自带的 OpenType 字体就只能以字体文件名的方式调用，非常不便。此外这样也能让系统的其他软件使用 TeX Live 安装的字体。 建议先复制到临时文件夹，改名后，再sudo mv 如果需要以字体文件名调用 Linux 系统安装的字体，例如使用 CJK 宏包调用来自 Windows 的字体，那么还需要修改 TeX Live 安装目录的 texmf.cnf 文件，在其中设置 OSFONTDIR 变量，例如： 1OSFONTDIR = ~/.fonts//;/usr/share/fonts//;/usr/share/fonts-droid// 可能需要用sudo gedit texmf.cnf才修改得了。当然，这一步骤对多数用户的用处并不大。 在/usr/bin/目录下创建符号链接才能用pdflatex进行编译1sudo ln -s /usr/local/texlive/2017/bin/x86_64-linux/pdflatex pdflatex 安装LaTeX编辑器：TeXstudio去官网下deb包然后安装：1sudo dpkg -i XXX.deb 打开TeXstudio，在倒数第二个选项(o)配置一下。首先配置语言为中文，然后编译器选pdflatex，其他的千万不要动。 配置语言为中文 编译器选pdflatex 其他宏包XeLatexXeLatex 是 texlive-xetex 包的一部分，用来支持中文。安装的话需要运行1sudo apt-get install texlive-xetex 加上依赖有1G大小。","categories":[{"name":"Latex","slug":"Latex","permalink":"http://xichen.pub/categories/Latex/"}],"tags":[{"name":"Latex","slug":"Latex","permalink":"http://xichen.pub/tags/Latex/"}]},{"title":"Web App 相关技术","slug":"2017-12-10-web-app","date":"2017-12-10T06:06:05.000Z","updated":"2019-04-01T15:18:44.158Z","comments":true,"path":"2017/12/10/2017-12-10-web-app/","link":"","permalink":"http://xichen.pub/2017/12/10/2017-12-10-web-app/","excerpt":"","text":"把技能点点在移动前端… 概念 参考： 移动 Web 开发入门 上面这个 slide 资料讲的非常好，算是一个入门的介绍吧。带我们建立基本的移动 web 开发知识体系和常见问题的实践。包含以下几个方面： 基本概念 Native 本地应用 使用 Java \\ Objective-C \\ Swift 开发 WebApp 网页应用 html5 开发 Hybrid 混合应用 ooxx(native, web) 对比 视觉 设备的像素 文字单位使用 rem viewport 属性 横屏竖屏 Flex 伸缩布局 响应式设计 软键盘 隐藏地址栏 苹果设备添加到主屏图标 交互 Touch click 延迟 Scroll Gestures(hammer –A javascript library for multi-touch gestures) 手指友好设计 HTML5 APIS（图像，摇动，声音等） 实践 屏蔽点击元素时的阴影 图像（像素、矢量图标、base64 减少请求、lazyload） CSS3（合理使用渐变/圆角/阴影、代替 js 动画、translate3d、解决动画闪烁） localStorage 避免（iframe、fixed + input） SPA 或 Multi page can I use 压缩合并 @G/3G 下建立连接时间 调试 浏览器自己的调试工具，模拟手机设备 weinre 关于 weinre 我写了一篇博客介绍它。Weinre –WebApp 调试工具 head 标签参考： 移动前端不得不了解的html5 head 头标签 上面的链接详细的讲解了： DOCTYPE charset lang属性 优先使用 IE 最新版本和 Chrome 360 使用Google Chrome Frame SEO 优化部分：页面标题&lt;title&gt;标签(head 头部必须)，页面关键词 keywords，页面描述内容 description，定义网页作者 author，网页搜索引擎索引方式 为移动设备添加 viewport viewport 可以让布局在移动浏览器上显示的更好。 通常会写 12&lt;meta name =\"viewport\" content =\"initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no\"&gt;&lt;!-- `width=device-width` 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边 http://bigc.at/ios-webapp-viewport-meta.orz --&gt; content 参数： width viewport 宽度(数值/device-width) height viewport 高度(数值/device-height) initial-scale 初始缩放比例 maximum-scale 最大缩放比例 minimum-scale 最小缩放比例 user-scalable 是否允许用户缩放(yes/no) ios 设备，iOS 图标，Android，Windows 8 总结： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;!DOCTYPE html&gt; &lt;!-- 使用 HTML5 doctype，不区分大小写 --&gt;&lt;html lang=\"zh-cmn-Hans\"&gt; &lt;!-- 更加标准的 lang 属性写法 http://zhi.hu/XyIa --&gt;&lt;head&gt; &lt;!-- 声明文档使用的字符编码 --&gt; &lt;meta charset='utf-8'&gt; &lt;!-- 优先使用 IE 最新版本和 Chrome --&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"/&gt; &lt;!-- 页面描述 --&gt; &lt;meta name=\"description\" content=\"不超过150个字符\"/&gt; &lt;!-- 页面关键词 --&gt; &lt;meta name=\"keywords\" content=\"\"/&gt; &lt;!-- 网页作者 --&gt; &lt;meta name=\"author\" content=\"name, email@gmail.com\"/&gt; &lt;!-- 搜索引擎抓取 --&gt; &lt;meta name=\"robots\" content=\"index,follow\"/&gt; &lt;!-- 为移动设备添加 viewport --&gt; &lt;meta name=\"viewport\" content=\"initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no\"&gt; &lt;!-- `width=device-width` 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边 http://bigc.at/ios-webapp-viewport-meta.orz --&gt; &lt;!-- iOS 设备 begin --&gt; &lt;meta name=\"apple-mobile-web-app-title\" content=\"标题\"&gt; &lt;!-- 添加到主屏后的标题（iOS 6 新增） --&gt; &lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\"/&gt; &lt;!-- 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏 --&gt; &lt;meta name=\"apple-itunes-app\" content=\"app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL\"&gt; &lt;!-- 添加智能 App 广告条 Smart App Banner（iOS 6+ Safari） --&gt; &lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\"/&gt; &lt;!-- 设置苹果工具栏颜色 --&gt; &lt;meta name=\"format-detection\" content=\"telphone=no, email=no\"/&gt; &lt;!-- 忽略页面中的数字识别为电话，忽略email识别 --&gt; &lt;!-- 启用360浏览器的极速模式(webkit) --&gt; &lt;meta name=\"renderer\" content=\"webkit\"&gt; &lt;!-- 避免IE使用兼容模式 --&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt; &lt;meta name=\"HandheldFriendly\" content=\"true\"&gt; &lt;!-- 微软的老式浏览器 --&gt; &lt;meta name=\"MobileOptimized\" content=\"320\"&gt; &lt;!-- uc强制竖屏 --&gt; &lt;meta name=\"screen-orientation\" content=\"portrait\"&gt; &lt;!-- QQ强制竖屏 --&gt; &lt;meta name=\"x5-orientation\" content=\"portrait\"&gt; &lt;!-- UC强制全屏 --&gt; &lt;meta name=\"full-screen\" content=\"yes\"&gt; &lt;!-- QQ强制全屏 --&gt; &lt;meta name=\"x5-fullscreen\" content=\"true\"&gt; &lt;!-- UC应用模式 --&gt; &lt;meta name=\"browsermode\" content=\"application\"&gt; &lt;!-- QQ应用模式 --&gt; &lt;meta name=\"x5-page-mode\" content=\"app\"&gt; &lt;!-- windows phone 点击无高光 --&gt; &lt;meta name=\"msapplication-tap-highlight\" content=\"no\"&gt; &lt;!-- iOS 图标 begin --&gt; &lt;link rel=\"apple-touch-icon-precomposed\" href=\"/apple-touch-icon-57x57-precomposed.png\"/&gt; &lt;!-- iPhone 和 iTouch，默认 57x57 像素，必须有 --&gt; &lt;link rel=\"apple-touch-icon-precomposed\" sizes=\"114x114\" href=\"/apple-touch-icon-114x114-precomposed.png\"/&gt; &lt;!-- Retina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有 --&gt; &lt;link rel=\"apple-touch-icon-precomposed\" sizes=\"144x144\" href=\"/apple-touch-icon-144x144-precomposed.png\"/&gt; &lt;!-- Retina iPad，144x144 像素，可以没有，但推荐有 --&gt; &lt;!-- iOS 图标 end --&gt; &lt;!-- iOS 启动画面 begin --&gt; &lt;link rel=\"apple-touch-startup-image\" sizes=\"768x1004\" href=\"/splash-screen-768x1004.png\"/&gt; &lt;!-- iPad 竖屏 768 x 1004（标准分辨率） --&gt; &lt;link rel=\"apple-touch-startup-image\" sizes=\"1536x2008\" href=\"/splash-screen-1536x2008.png\"/&gt; &lt;!-- iPad 竖屏 1536x2008（Retina） --&gt; &lt;link rel=\"apple-touch-startup-image\" sizes=\"1024x748\" href=\"/Default-Portrait-1024x748.png\"/&gt; &lt;!-- iPad 横屏 1024x748（标准分辨率） --&gt; &lt;link rel=\"apple-touch-startup-image\" sizes=\"2048x1496\" href=\"/splash-screen-2048x1496.png\"/&gt; &lt;!-- iPad 横屏 2048x1496（Retina） --&gt; &lt;link rel=\"apple-touch-startup-image\" href=\"/splash-screen-320x480.png\"/&gt; &lt;!-- iPhone/iPod Touch 竖屏 320x480 (标准分辨率) --&gt; &lt;link rel=\"apple-touch-startup-image\" sizes=\"640x960\" href=\"/splash-screen-640x960.png\"/&gt; &lt;!-- iPhone/iPod Touch 竖屏 640x960 (Retina) --&gt; &lt;link rel=\"apple-touch-startup-image\" sizes=\"640x1136\" href=\"/splash-screen-640x1136.png\"/&gt; &lt;!-- iPhone 5/iPod Touch 5 竖屏 640x1136 (Retina) --&gt; &lt;!-- iOS 启动画面 end --&gt; &lt;!-- iOS 设备 end --&gt; &lt;meta name=\"msapplication-TileColor\" content=\"#000\"/&gt; &lt;!-- Windows 8 磁贴颜色 --&gt; &lt;meta name=\"msapplication-TileImage\" content=\"icon.png\"/&gt; &lt;!-- Windows 8 磁贴图标 --&gt; &lt;link rel=\"alternate\" type=\"application/rss+xml\" title=\"RSS\" href=\"/rss.xml\"/&gt; &lt;!-- 添加 RSS 订阅 --&gt; &lt;link rel=\"shortcut icon\" type=\"image/ico\" href=\"/favicon.ico\"/&gt; &lt;!-- 添加 favicon icon --&gt; &lt;title&gt;标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 页面切换动画 移动端重构系列13——页面切换 CSS3 3D Transform 关于 HammerJS 的一个中文文档 Hammer.js CSS Processing CSS语言由于其自身语言设计的问题，加上一些浏览器兼容性问题，往往会使得我们在写它的时候，要写很多冗余代码，或者为了兼容性对同一个样式设定写好几遍。针对这些问题，诞生了CSS预处理和后处理的概念及相关方法、工具。 这些工具和方法帮助我们能够更加高效地书写可维护性更强的CSS代码。 这里我尝试使用了 Sass，果然很好用。下面记录几个 sass 教程。 Sass入门-w3cplus SASS用法指南-阮一峰 安装首先要有 ruby 环境。 由于国内网络原因（你懂的），导致 rubygems.org 存放在 Amazon S3 上面的资源文件间歇性连接失败。这时候我们可以通过gem sources命令来配置源，先移除默认的 https://rubygems.org 源，然后添加淘宝的源 https://ruby.taobao.org/，然后查看下当前使用的源是哪个，如果是淘宝的，则表示可以输入 sass 安装命令 gem install sass 了。 $ gem sources --remove https://rubygems.org/ $ gem sources -a https://ruby.taobao.org/ $ gem sources -l *** CURRENT SOURCES *** https://ruby.taobao.org # 请确保只有 ruby.taobao.org $ gem install sass 编译sass --watch style.scss:style.css --style expanded 补充rem 字体单位使用 rem，用户在手机上设置了字体大小时，不会打破布局，造成混乱。 CSS3的REM设置字体大小-w3cplus 响应式十日谈第一日：使用 rem 设置文字大小-一丝 安全 安全是大家经常容易忽视，但其实一旦出现影响会非常大的问题，尤其对于没有经历过企业开发，或者没有踩过坑的同学，如果等到公司工作，做实际项目后非常容易发生安全问题。 分类WEB基本攻击大致可以分为三大类：“资源枚举”、“参数操纵” 和 “其它攻击” 资源枚举 参数操纵 SQL注入 XPath注入 cgi命令执行 XXS（cross-site scripting跨域脚本攻击）其重点是“跨域”和“客户端执行” Reflected XSS ——基于反射的XSS攻击。主要依靠站点服务端返回脚本，在客户端触发执行从而发起WEB攻击。 DOM-based or local XSS——基于DOM或本地的XSS攻击 Stored XSS——基于存储的XSS攻击 会话劫持 其它攻击 CSRF（cross-site request forgery）跨站请求伪造 钓鱼攻击指的是网站的伪造，比如ta0bao.com，然后在其中应用XSS等方式发起攻击。 拒绝服务（DoS）指的是向网站发起洪水一样的请求（Traffic Floor），导致服务器超负荷并关闭，处理方法常规是采用QoS（Quality of Service）的软硬件解决方案。 关于 XSS 跨网站脚本（Cross-site scripting，通常简称为XSS或跨站脚本或跨站脚本攻击）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。 XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java， VBScript， ActiveX， Flash 或者甚至是普通的HTML。攻击成功后，攻击者可能得到更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。 ——维基百科 XSS 防护 浏览器解析顺序： HTML Parser &gt;&gt; CSS Parser &gt;&gt; JavaScript Parser 浏览器解码顺序： HTML Decoding &gt;&gt; URL Decoding &gt;&gt; JavaScript Decoding 具体的防护方式： 验证输入并且基于语境和按照正确的顺序转义不可信数据 HTML 中的字符串 HTML 属性中的字符串 事件句柄属性和 JavaScript 中的字符串 HTML 属性中的 URL 路径 HTML 风格属性和 CSS 中的字符串 JavaScript 中的 HTML 始终遵循白名单优于黑名单的做法 使用 UTF-8 为默认的字符编码以及设置 content 为 text/html 不要将用户可以控制的文本放在标签前。通过使用不同的字符集注射可以导致 XSS。 使用 &lt;!DOCTYPE html&gt; 使用推荐的 HTTP 响应头进行 XSS 防护 防止 CRLF 注入/HTTP 响应拆分 禁止 TRACE 和其他非必要方法 对于 innerHTML 的方式输出的，我们可以采用如下的方式转码 1234567891011121314/** * 转码 XSS 防护 * @param &#123;String&#125; str 用户输入的字符串 * @return &#123;String&#125; 转码后的字符串 */function changeCode(str) &#123; str = str.replace(/&amp;/g, \"&amp;amp;\") .replace(/&lt;/g, \"&amp;lt;\") .replace(/&gt;/g, \"&amp;gt;\") .replace(/\"/g, \"&amp;quot;\") .replace(/'/g, \"&amp;#x27;\") .replace(/\\//g, \"&amp;#x2f;\"); return str;&#125; 参考： 浅谈WEB安全性（前端向） XSS的原理分析与解剖 原创翻译：给开发者的终极XSS防护备忘录 性能优化 在自己做一些小项目时，可能是学校的一些网站项目，流量可能日均都不超过500，而且大多是校园局域网内访问；或者是开发一些实验室的MIS系统，这辈子你都不会去使用你开发的这个系统。在这样一些项目中，性能优化往往会被你忽略。 但是如果你是做一个日均PV数万、数十万、甚至更大的量级，开发的页面会被全国各地，不同网络条件的用户来进行访问。这个时候，性能问题就无法忽视了。在当今的网络条件下，如果你的页面3秒都无法完成首屏渲染，一定会让你的网站流失很多用户。 整个网站的性能优化有很多的环节和工作，大多数时候，不是前端工程师单独就能完成的，尤其在职能划分明确的公司中，往往需要前后端、运维、DBA等多个职位协同完成。所以，在我们的课程中，主要让你了解整个性能优化都涉及哪些方面的工作，同时，我们会专注介绍一些在前端领域可以重点关注的技术点。 这里就是网页的打开速度，如果你的网页打开速度很慢，那么一定会有用户的流失。所以性能优化很重要。 网页内容 减少http请求次数 减少DNS查询次数 避免页面跳转 缓存Ajax 延迟加载 提前加载 减少DOM元素数量 根据域名划分内容 减少iframe数量 避免404 服务器 使用CDN 添加Expires 或Cache-Control报文头 Gzip压缩传输文件 配置ETags 尽早flush输出 使用GET Ajax请求 避免空的图片src Cookie 减少Cookie大小 页面内容使用无cookie域名 CSS 将样式表置顶 避免CSS表达式 用\\代替@import 避免使用Filters Javascript 将脚本置底 使用外部Javascirpt和CSS文件 精简Javascript和CSS 去除重复脚本 减少DOM访问 使用智能事件处理 图片 优化图像 优化CSS Sprite 不要在HTML中缩放图片 使用小且可缓存的favicon.ico 移动客户端 保持单个内容小于25KB 打包组建成符合文档 具体细节参考文章： 毫秒必争，前端网页性能最佳实践 我在 ToDo 这个任务中主要使用了 CDN 来加载静态资源。比如我使用了 百度静态资源公共库。引用了里面的 fontawesome，速度果然比在 GitHub 仓库里快很多。下一步是压缩我自己写的静态资源。 其他参考资料： 给网页设计师和前端开发者看的前端性能优化 梳理：提高前端性能方面的处理以及不足 css sprite原理优缺点及使用 CSS Sprites：鱼翅还是三鹿？ 大型网站的灵魂——性能 编写高效的 CSS 选择器 模块化 对于一个复杂项目，特别是多人协作的复杂项目，如何合理划分模块，如何更加方便地进行模块加载，如何管理模块之间的依赖，是一个项目团队都会面临的问题，目前业界已经有了一些较为普遍的解决方案，如AMD。这个部分希望你能够通过学习JavaScript的模块化，学习如何合理地规划项目模块，合理使用模块化工具来优化你的项目代码结构。 一个模块就是实现特定功能的文件，有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。模块开发需要遵循一定的规范，否则就都乱套了。 根据AMD规范，我们可以使用 define 定义模块，使用 require 调用模块。 目前，通行的 js 模块规范主要有两种：CommonJS 和 AMD。 AMD规范AMD 即 Asynchronous Module Definition，中文名是“异步模块定义”的意思。它是一个在浏览器端模块化开发的规范，服务器端的规范是 CommonJS 模块将被异步加载，模块加载不影响后面语句的运行。所有依赖某些模块的语句均放置在回调函数中。 AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出。 详细 API 如下： AMD（中文版）) CommonJS规范CommonJS 是服务器端模块的规范，Node.js 采用了这个规范。Node.JS 首先采用了 js 模块化的概念。 根据 CommonJS 规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为 global 对象的属性。 输出模块变量的最好方法是使用 module.exports 对象。 为什么要用 requireJS试想一下，如果一个网页有很多的js文件，那么浏览器在下载该页面的时候会先加载js文件，从而停止了网页的渲染，如果文件越多，浏览器可能失去响应。其次，要保证js文件的依赖性，依赖性最大的模块（文件）要放在最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。 RequireJS就是为了解决这两个问题而诞生的： （1）实现js文件的异步加载，避免网页失去响应；（2）管理模块之间的依赖性，便于代码的编写和维护。 requireJS requireJS 官网 requireJS 中文网 AMD和CMDCMD（Common Module Definition） 通用模块定义。该规范明确了模块的基本书写格式和基本交互规则。该规范是在国内发展出来的。AMD是依赖关系前置，CMD是按需加载。 AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。 CMD 模块定义规范 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。 AMD:提前执行（异步加载：依赖先执行）+延迟执行CMD:延迟执行（运行到需加载，根据顺序执行） 参考 Javascript模块化编程（一）：模块的写法–阮一峰 Javascript模块化编程（二）：AMD规范 Javascript模块化编程（三）：require.js的用法 详解 JavaScript 模块开发 浅谈模块化的JavaScript 再谈 SeaJS 与 RequireJS 的差异 玩转AMD系列 by erik@EFE 玩转AMD - 写在前面 玩转AMD - 设计思路 玩转AMD - 应用实践 玩转AMD - Loader 前端工程化 业界目前有非常多的前端开发工具，完成一些开发过程中可以自动化完成的工作，提高研发效率，并且可以提高多人协作时的开发过程一致性，提高整个项目的运维效率。 在EFE日常工作中，我们是基于EDP，完成项目开发过程中的项目构建、包管理、调试、单测、静态检测、打包、压缩、优化、项目部署等一系列所有工作。 注： 如果网络不好，可以使用 淘宝 NPM 镜像。 参考 前端工程与模块化框架 手机百度前端工程化之路 对话百度前端工程师张云龙：F.I.S与前端工业化 EDP Grunt教程——初涉Grunt gulp入门指南 Gulp开发教程（翻译） Gulp 中文网 npm的package.json中文文档 最终作品在任务三中，做了一个 PC 端的 ToDo 应用。任务四是将它优化，以适应移动端设备。 ToDo WebApp Version 任务四要求 源代码 在线 demo 手机查看 ↓ 二维码 ↓ 我的博客 HyG Details 数据存储 以 JSON 模拟数据表的形式存储于 LocalStorage 中 使用数据库的思想，构建3张表。 cateJson 分类 childCateJson 子分类 taskJson 任务 分类表 cate ---------------------- id* | name | child(FK) ---------------------- 子分类表 childCate -------------------------------- id* | pid(FK) | name | child(FK) -------------------------------- 任务表 task ---------------------------------------------- id* | pid(FK) | finish | name | date | content ---------------------------------------------- 使用 Sass 重构了 CSS 代码 使用分块、继承等方式，使得代码更加清晰明了。 响应式布局 针对手机端细节做了很多调整，更符合手机上的视觉交互习惯。 加入页面切换效果 使用 translate3d()，纯 CSS3 切换动画效果。 处理了 XSS 防护 对可能造成破坏的字符进行转码。 性能优化 使用 CDN 处理静态资源 fontAwesome，压缩静态资源等 模块化 使用 requireJS 模块化 JavaScript 代码。重构 JavaScript 代码。优化之前写的耦合性高的绑定事件，重新绑定事件，降低耦合性。期间根据具体需求重写了事件代理的代码。 前端工程化 使用 gulp，自动编译 Sass，压缩 CSS 和 JavaScript 代码。并且配置了自动流程。 其他-webkit-tap-highlight-color 属性感谢 fiona 指出。 safari移动端点击的时候会闪一下加上 -webkit-tap-highlight-color: transparent; 就不会闪了。 参考： -webkit-tap-highlight-color css88 -webkit-tap-highlight-color 属性 textarea 标签 disabled 颜色 为什么用 disabled 属性？ 因为我发现仅仅使用 readonly 属性，在 IE 下是显示光标的。于是使用 disabled。 出现的问题 各家浏览器对于 disabled 属性有自己的样式设定，比如 IE 下是灰色的。苹果设备下也是。改变这些样式的方法也不是统一的。如果要兼容 Safari 必须加上 123background: #fff;-webkit-text-fill-color: rgba(0, 0, 0, 1);-webkit-opacity: 1; 于是最终代码如下： 123456textarea:disabled &#123; color:#000; background: #fff; -webkit-text-fill-color: rgba(0, 0, 0, 1); -webkit-opacity: 1;&#125; 参考：Disabled input text color 中的评论","categories":[{"name":"Web","slug":"Web","permalink":"http://xichen.pub/categories/Web/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xichen.pub/tags/JavaScript/"},{"name":"HTML","slug":"HTML","permalink":"http://xichen.pub/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://xichen.pub/tags/CSS/"},{"name":"Sass","slug":"Sass","permalink":"http://xichen.pub/tags/Sass/"},{"name":"移动端","slug":"移动端","permalink":"http://xichen.pub/tags/移动端/"},{"name":"XSS","slug":"XSS","permalink":"http://xichen.pub/tags/XSS/"},{"name":"AMD","slug":"AMD","permalink":"http://xichen.pub/tags/AMD/"},{"name":"requireJS","slug":"requireJS","permalink":"http://xichen.pub/tags/requireJS/"},{"name":"CommonJS","slug":"CommonJS","permalink":"http://xichen.pub/tags/CommonJS/"},{"name":"性能优化","slug":"性能优化","permalink":"http://xichen.pub/tags/性能优化/"},{"name":"WebApp","slug":"WebApp","permalink":"http://xichen.pub/tags/WebApp/"}]},{"title":"Git Tips","slug":"2017-12-9-git-tips","date":"2017-12-09T13:36:00.000Z","updated":"2019-04-01T15:18:44.162Z","comments":true,"path":"2017/12/09/2017-12-9-git-tips/","link":"","permalink":"http://xichen.pub/2017/12/09/2017-12-9-git-tips/","excerpt":"","text":"库管理克隆库12git clone https://github.com/php/php-src.gitgit clone --depth=1 https://github.com/php/php-src.git # 只抓取最近的一次 commit 历史管理查看历史12git log --pretty=oneline filename # 一行显示git show xxxx # 查看某次修改 标签功能12345678git tag # 显示所有标签git tag -l 'v1.4.2.*' # 显示 1.4.2 开头标签git tag v1.3 # 简单打标签 git tag -a v1.2 9fceb02 # 后期加注标签git tag -a v1.4 -m 'my version 1.4' # 增加标签并注释， -a 为 annotated 缩写git show v1.4 # 看某一标签详情git push origin v1.5 # 分享某个标签git push origin --tags # 分享所有标签 回滚操作12git reset 9fceb02 # 保留修改git reset 9fceb02 --hard # 删除之后的修改 取消文件的修改12git checkout -- a.php # 取消单个文件git checkout -- # 取消所有文件的修改 删除文件12git rm a.php # 直接删除文件git rm --cached a.php # 删除文件暂存状态 移动文件1git mv a.php ./test/a.php 查看文件修改12git diff # 查看未暂存的文件更新 git diff --cached # 查看已暂存文件的更新 暂存和恢复当前staging12345git stash # 暂存当前分支的修改git stash apply # 恢复最近一次暂存git stash list # 查看暂存内容git stash apply stash@&#123;2&#125; # 指定恢复某次暂存内容git stash drop stash@&#123;0&#125; # 删除某次暂存内容 修改 commit 历史纪录1git rebase -i 0580eab8 分支管理创建分支12git branch develop # 只创建分支git checkout -b master develop # 创建并切换到 develop 分支 合并分支1234git checkout master # 切换到 master 分支git merge --no-ff develop # 把 develop 合并到 master 分支，no-ff 选项的作用是保留原分支记录git rebase develop # rebase 当前分支到 developgit branch -d develop # 删除 develop 分支 克隆远程分支12git branch -r # 显示所有分支，包含远程分支git checkout origin/android 修复develop上的合并错误 将merge前的commit创建一个分之，保留merge后代码 将develop reset --force到merge前，然后push --force 在分支中rebase develop 将分支push到服务器上重新merge 强制更新到远程分支最新版本12git reset --hard origin/mastergit submodule update --remote -f Submodule使用克隆带submodule的库1git clone --recursive https://github.com/chaconinc/MainProject clone主库后再去clone submodule123git clone https://github.com/chaconinc/MainProjectgit submodule initgit submodule update Git设置Git的全局设置在~/.gitconfig中，单独设置在project/.git/config下。 忽略设置全局在~/.gitignore_global中，单独设置在project/.gitignore下。 设置 commit 的用户和邮箱12git config user.name \"xx\"git config user.email \"xx@xx.com\" 或者直接修改config文件 123[user] name = xxx email = xxx@xxx.com 查看设置项1git config --list 设置git终端颜色123git config --global color.diff autogit config --global color.status autogit config --global color.branch auto","categories":[{"name":"Tips","slug":"Tips","permalink":"http://xichen.pub/categories/Tips/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"http://xichen.pub/tags/Tips/"},{"name":"Git","slug":"Git","permalink":"http://xichen.pub/tags/Git/"}]},{"title":"网页排序算法（三）代数方法求PageRank","slug":"2017-12-08-网页排序算法（三）代数方法求PageRank","date":"2017-12-08T12:22:00.000Z","updated":"2019-04-01T15:18:44.157Z","comments":true,"path":"2017/12/08/2017-12-08-网页排序算法（三）代数方法求PageRank/","link":"","permalink":"http://xichen.pub/2017/12/08/2017-12-08-网页排序算法（三）代数方法求PageRank/","excerpt":"","text":"本文结合实例介绍如何用代数方法求PageRank。 博文《网页排序算法（一）PageRank》介绍了PageRank，计算PageRank可以用迭代的方法也可以用代数的方法，其背后的数学基本运算是一样的，即： $$PR(pi)=\\frac{1−d}{N}+d \\sum{p_j\\in B(p_i)} \\frac{PR(p_j)}{L(p_j)}$$ 下文结合图1介绍如何用代数方法求PageRank。 Fig. 1: PageRanks for a simple network (image from Wikipedia) 为了便于讨论，将图1下方的节点分别标上G, H, I, J, K，如下图所示： Fig. 2: Draw Fig. 1 in NetworkX. 代数方法根据1中的等式，把所有节点都放在一块，可以得到： $$\\begin{bmatrix}PR(p_1) \\PR(p_2) \\\\vdots \\PR(p_3)\\end{bmatrix} =\\begin{bmatrix}{(1-d)/ N} \\{(1-d) / N} \\\\vdots \\{(1-d) / N}\\end{bmatrix} d\\begin{bmatrix}\\ell(p_1,p_1) &amp; \\ell(p_1,p_2) &amp; \\cdots &amp; \\ell(p_1,p_N) \\\\ell(p_2,p_1) &amp; \\ddots &amp; &amp; \\vdots \\\\vdots &amp; &amp; \\ell(p_i,p_j) &amp; \\\\ell(p_N,p_1) &amp; \\cdots &amp; &amp; \\ell(p_N,p_N)\\end{bmatrix}\\begin{bmatrix}PR(p_1) \\PR(p_2) \\\\vdots \\PR(p_3)\\end{bmatrix}$$ 上述等式可以缩写为： $$\\mathbf{R} = d \\mathcal{M}\\mathbf{R} + \\frac{1-d}{N} \\mathbf{1}. (**)$$ 其中，1为N维的列向量，所有元素皆为1。以图1为例，该列向量为，1234567891011121314N = len(G.nodes()) # N = 11column_vector = np.ones((N, 1), dtype=np.int) [[1] [1] [1] [1] [1] [1] [1] [1] [1] [1] [1]] Adjacency function邻接函数（adjacency function）$$\\ell(p_1,p_2)$$组成了矩阵M， $$\\mathcal{M}_{ij} =\\ell(pi,pj) = \\begin{cases} 1 /L(p_j) , &amp; \\mbox{if }j\\mbox{ links to }i\\ L(pj)是指从pj链出去的网页数目\\ 0, &amp; \\mbox{otherwise} \\end{cases}$$ 这样矩阵每一行乘以R，就得到了新的PR值，比如第二行（图1的节点B）， $$\\begin{align}M_{2j} &amp;=\\ell(p_2,p_1)⋅PR(p_2)+\\ell(p_2,p_2)⋅PR(p_2)+⋯+\\ell(p_2,p_N)⋅PR(p_2)\\&amp;=0 (‘A’)+0 (‘B’)+1 (‘C’)+12 (‘D’)+13 (‘E’)+12 (‘F’) +12 (‘G’)+12 (`H’)+12 (‘I’)+0 (‘J’)+0 (‘K’) \\end{align}$$ 以节点G为例，G给B和E投票，所以B得到1/2。 矩阵M每一列加起来都是1（值得注意的是，对于没有出链的节点，列加起来等于0，比如图1的节点A），即$$\\sum_{i=1}^{N}\\ell(p_i,p_j)=1$$。事实上，M是一个转移矩阵transition matrix（也叫概率矩阵probability matrix，马尔可夫矩阵Markov matrix）。因此，PageRank是eigenvector centrality的一个变体。 矩阵M事实上，M可以被看成normalized的图邻接矩阵，即： $$M=(K^{−1}A)^T$$其中，A为图的邻接矩阵，以图1为例，12345678910111213141516# Get adjacency matrixnodelist = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K'] # sorted(G.nodes())A = nx.to_numpy_matrix(G, nodelist) 'A' 'B' 'C' 'D' 'E' 'F' 'G' 'H' 'I' 'J' 'K'[[ 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [ 0. 0. 1. 0. 0. 0. 0. 0. 0. 0. 0.] [ 0. 1. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [ 1. 1. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [ 0. 1. 0. 1. 0. 1. 0. 0. 0. 0. 0.] [ 0. 1. 0. 0. 1. 0. 0. 0. 0. 0. 0.] [ 0. 1. 0. 0. 1. 0. 0. 0. 0. 0. 0.] [ 0. 1. 0. 0. 1. 0. 0. 0. 0. 0. 0.] [ 0. 1. 0. 0. 1. 0. 0. 0. 0. 0. 0.] [ 0. 0. 0. 0. 1. 0. 0. 0. 0. 0. 0.] [ 0. 0. 0. 0. 1. 0. 0. 0. 0. 0. 0.]] A是对角矩阵，对角线上的元素是对应节点的出度。123456789101112131415nodelist = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K'] # sorted(G.nodes())list_outdegree = map(operator.itemgetter(1), sorted(G.out_degree().items()))K = np.diag(list_outdegree) [[0 0 0 0 0 0 0 0 0 0 0] [0 1 0 0 0 0 0 0 0 0 0] [0 0 1 0 0 0 0 0 0 0 0] [0 0 0 2 0 0 0 0 0 0 0] [0 0 0 0 3 0 0 0 0 0 0] [0 0 0 0 0 2 0 0 0 0 0] [0 0 0 0 0 0 2 0 0 0 0] [0 0 0 0 0 0 0 2 0 0 0] [0 0 0 0 0 0 0 0 2 0 0] [0 0 0 0 0 0 0 0 0 1 0] [0 0 0 0 0 0 0 0 0 0 1]] K的逆矩阵$$K^{-1}$$为，12345678910111213K_inv = np.linalg.pinv(K) [[ 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. ] [ 0. 1. 0. 0. 0. 0. 0. 0. 0. 0. 0. ] [ 0. 0. 1. 0. 0. 0. 0. 0. 0. 0. 0. ] [ 0. 0. 0. 0.5 0. 0. 0. 0. 0. 0. 0. ] [ 0. 0. 0. 0. 0.33 0. 0. 0. 0. 0. 0. ] [ 0. 0. 0. 0. 0. 0.5 0. 0. 0. 0. 0. ] [ 0. 0. 0. 0. 0. 0. 0.5 0. 0. 0. 0. ] [ 0. 0. 0. 0. 0. 0. 0. 0.5 0. 0. 0. ] [ 0. 0. 0. 0. 0. 0. 0. 0. 0.5 0. 0. ] [ 0. 0. 0. 0. 0. 0. 0. 0. 0. 1. 0. ] [ 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 1. ]] 那么，根据公式$$M=(K^{−1}A)^T$$就可以求得M，如下，12345678910111213M = (K_inv * A).transpose() [[ 0. 0. 0. 0.5 0. 0. 0. 0. 0. 0. 0. ] [ 0. 0. 1. 0.5 0.33 0.5 0.5 0.5 0.5 0. 0. ] [ 0. 1. 0. 0. 0. 0. 0. 0. 0. 0. 0. ] [ 0. 0. 0. 0. 0.33 0. 0. 0. 0. 0. 0. ] [ 0. 0. 0. 0. 0. 0.5 0.5 0.5 0.5 1. 1. ] [ 0. 0. 0. 0. 0.33 0. 0. 0. 0. 0. 0. ] [ 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. ] [ 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. ] [ 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. ] [ 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. ] [ 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. ]] 求解R是2.1等式的特征向量（eigenvector），求解等式得： $$\\mathbf{R} = (\\mathbf{I}-d \\mathcal{M})^{-1} \\frac{1-d}{N} \\mathbf{1},$$ 其中$$\\mathbf{I}$$是单位矩阵。123456789101112131415d = 0.85I = np.identity(N)R = np.linalg.pinv(I - d*M) * (1-d)/N * column_vector [[ 0.028] [ 0.324] [ 0.289] [ 0.033] [ 0.068] [ 0.033] [ 0.014] [ 0.014] [ 0.014] [ 0.014] [ 0.014]] 咦，结果怎么跟图1不一样。得到R需要normalized，如此，所有节点的PR加起来才能等于1。12345678910111213R = R/sum(R) # normalized R, so that page ranks sum to 1. [[ 0.033] [ 0.384] [ 0.343] [ 0.039] [ 0.081] [ 0.039] [ 0.016] [ 0.016] [ 0.016] [ 0.016] [ 0.016]] 用NetworkX作出来的图，是这样的： Fig. 3: PageRanks for a simple network Python源代码NetworkX实现了PageRank的代数计算方法nx.pagerank_numpy，源代码在这里。12345678910111213141516171819def pagerank_numpy(G, alpha=0.85, personalization=None, weight='weight', dangling=None): \"\"\"Return the PageRank of the nodes in the graph. \"\"\" if len(G) == 0: return &#123;&#125; M = google_matrix(G, alpha, personalization=personalization, weight=weight, dangling=dangling) # use numpy LAPACK solver eigenvalues, eigenvectors = np.linalg.eig(M.T) ind = eigenvalues.argsort() # eigenvector of largest eigenvalue at ind[-1], normalized largest = np.array(eigenvectors[:, ind[-1]]).flatten().real norm = float(largest.sum()) return dict(zip(G, map(float, largest / norm))) References: [1] StackOverflow: Incorrect PageRank calculation result","categories":[{"name":"算法","slug":"算法","permalink":"http://xichen.pub/categories/算法/"}],"tags":[{"name":"PageRank","slug":"PageRank","permalink":"http://xichen.pub/tags/PageRank/"}]},{"title":"网页排序算法（二）迭代方法求PageRank","slug":"2017-12-07-网页排序算法（二）迭代方法求PageRank","date":"2017-12-07T12:22:00.000Z","updated":"2019-04-01T15:18:44.156Z","comments":true,"path":"2017/12/07/2017-12-07-网页排序算法（二）迭代方法求PageRank/","link":"","permalink":"http://xichen.pub/2017/12/07/2017-12-07-网页排序算法（二）迭代方法求PageRank/","excerpt":"","text":"本文介绍如何用迭代的方法计算PageRank。 PageRank博文《网页排序算法（一）PageRank》介绍了PageRank，计算PageRank可以用迭代的方法也可以用代数的方法，其背后的数学基本运算是一样的，即： $$PR(pi)=\\frac{1−d}{N}+d\\sum{p_j\\in B(p_i)}\\frac{PR(pj)}{L(p_j)}$$ 下文结合图1介绍如何用迭代方法求PageRank。 Fig. 1: PageRanks for a simple network (image from Wikipedia). 为了便于讨论，将图1下方的节点分别标上G, H, I, J, K，如下图所示： Fig. 2: Label nodes in Fig. 1. 迭代方法初始化节点PR值如果没有给节点指定PR初始值，那么每个节点的PR初始化为1/N (N为节点数目)，以图1为例，节点的PR初始值为1/11： Fig. 3: The graph with starting value of PageRank iteration for each node. 相应源代码如下：123# Step 1: Initiate PageRankN = G.number_of_nodes() # N = 11node_and_pr = dict.fromkeys(G, 1.0 / N) 创建随机图（stochastic graph）随机图（stochastic graph）是一个有向带权图，边的权重被normalized，使得每个节点的outedges的权重加起来为1。事实上，边的权重即为$$1/L(p_j)$$，图1的随机图如下： Fig. 4: The stochastic graph 比如，节点D有两条出链，D --&gt; A和D --&gt; B，所以他们的边权重都是0.5。源代码如下：1234stochastic_graph = nx.stochastic_graph(G, weight=weight) # M = 1/L(pj) print(stochastic_graph['D'])&#123;'A': &#123;'Edge Id': u'5', 'weight': 0.5&#125;, 'B': &#123;'Edge Id': u'6', 'weight': 0.5&#125;&#125; 迭代计算遍历所有节点，将每个节点的PR值平均分给其出链的节点，即$$\\sun_{p_j\\in B(p_i)}\\frac{PR(p_j)}{L(p_j)}$$，乘以阻尼系数d，再加上(1−d)/N。源代码如下：1234567891011dangling_value = (1-d)/N for _ in range(max_iter): # for each iteration node_and_prev_pr = node_and_pr node_and_pr = dict.fromkeys(node_and_prev_pr.keys(), 0) for node in node_and_pr: # for each node for out_node in stochastic_graph[node]: # node --&gt; out_node node_and_pr[out_node] += d * node_and_prev_pr[node] * stochastic_graph[node][out_node][weight] # PR(p_i) = d * PR(p_j)&#125;/L(p_j) node_and_pr[node] += dangling_value 第一次迭代结果如下图所示（有些箭头没显示出来，NetworkX可视化很弱）： Fig. 5: PageRank after one ieration 那什么时候程序结束呢。将迭代后的PR值跟前一次比较，如果差别很少（如PR′(A)−PR(A)&lt;1.0e−6PR′(A)−PR(A)&lt;1.0e−6），就可以停止迭代了。源代码如下：1234# check convergence, l1 normerr = sum([abs(node_and_pr[node] - node_and_prev_pr[node]) for node in node_and_pr])if err &lt; N*tol: return node_and_pr 在本例中，需要66次迭代，最后得到的PageRank，如下图： wikipedia_pagerank_example_prFig. 6: Stable PageRank values (66 iterations) 我在想一个问题，上面的方法，每次迭代都是基于上一次的PR值，能不能这样，迭代的时候使用最新的值，这样会不能减少迭代次数，如下所示：1234567# 初始值PA(D) = 0.09PA(B) = 0.09 # 第一次迭代PA(D)/2 --&gt; P(A), P(B) # 此时， PB(B)=0.045PB(B) --&gt; P(C) # 按上面的算法，PB(B)=0.09，那能不能使用刚更新的PR值0.045，这样会不会快一些？ NetworkX的pageranknx.pagerank跟章节2差不多，区别在于：123456# 2中的算法node_and_pr[node] += (1.0 - d)/N # nx.pagerankdanglesum = d * sum(node_and_prev_pr[node] for node in dangling_nodes)node_and_pr[node] += danglesum/N + (1.0 - d)/N # danglesum/N + (1-d)/N nx.pagerank将图中所有悬挂节点（dangling nodes，没有出链的节点，图1只有节点A）的PR累加，并normalized，再加上(1.0–d)/N。","categories":[{"name":"算法","slug":"算法","permalink":"http://xichen.pub/categories/算法/"}],"tags":[{"name":"PageRank","slug":"PageRank","permalink":"http://xichen.pub/tags/PageRank/"}]},{"title":"区块链开发（零）概念入门","slug":"2017-11-27-区块链开发（零）概念入门","date":"2017-12-06T12:21:00.000Z","updated":"2019-04-01T15:18:44.149Z","comments":true,"path":"2017/12/06/2017-11-27-区块链开发（零）概念入门/","link":"","permalink":"http://xichen.pub/2017/12/06/2017-11-27-区块链开发（零）概念入门/","excerpt":"","text":"概念地址比特币地址（例如：1DSrfJdB2AnWaFNgSbv3MZC2m74996JafV）由一串字符和数字组成，以阿拉伯数字“1”开头。就像别人向你的email地址发送电子邮件一样，他可以通过你的比特币地址向你发送比特币。 可以用 vanitygen 来生成包含一定字母的地址。 BIP比特币改进提议 （Bitcoin Improvement Proposals 的缩写），指比特币社区成员所提交的一系列改进比特币的提议。例如，BIP0021是一项改进比特币统一资源标识符（URI）计划的提议。 比特币“比特币”既可以指这种虚拟货币单位，也指比特币网络或者网络节点使用的比特币软件。 区块一个区块就是若干交易数据的集合，它会被标记上时间戳和之前一个区块的独特标记。区块头经过哈希运算后会生成一份工作量证明，从而验证区块中的交易。有效的区块经过全网络的共识后会被追加到主区块链中。 区块链区块链是一串通过验证的区块，当中的每一个区块都与上一个相连，一直连到创世区块。 确认当一项交易被区块收录时，我们可以说它有一次确认。矿工们在此区块之后每再产生一个区块，此项交易的确认数就再加一。当确认数达到六及以上时，通常认为这笔交易比较安全并难以逆转。 难度整个网络会通过调整“难度”这个变量来控制生成工作量证明所需要的计算力。 难度目标使整个网络的计算力大致每10分钟产生一个区块所需要的难度数值即为难度目标。 难度调整整个网络每产生2,106个区块后会根据之前2,106个区块的算力进行难度调整。 哈希二进制数据的一种数字指纹。 创世区块创世区块指区块链上的第一个区块，用来初始化相应的加密货币。 矿工矿工指通过不断重复哈希运算来产生工作量证明的各网络节点。 挖矿描述挖矿的一个好方法是将之类比为一个巨大的多人数独谜题游戏。一旦有人发现正解之后，这个数独游戏会自动调整困难度以使游戏每次需要大约10分钟解决。想象一个有几千行几千列的巨大数独游戏。如果给你一个已经完成的数独，你可以很快地验证它。然而，如果这个数独只有几个方格里有数字其余方格都为空的话，就会花费非常长的时间来解决。这个数独游戏的困难度可以通过改变其大小（更多或更少行列）来调整，但即使它非常大时验证它也是相当容易的。而比特币中的 “谜题” 是基于哈希加密算法的，其展现了相似的特性：非对称地，它解起来困难而验证很容易，并且它的困难度可以调整。 当区块一个个堆上来时，这个交易变得指数级地越来越难被推翻，因此它在网络中得到更多信任。 矿工费交易的发起者通常会向网络缴纳一笔矿工费，用以处理这笔交易。大多数的交易需要0.5毫比特币的矿工费。 网络比特币网络是一个由若干节点组成的用以广播交易信息和数据区块的P2P网络。 工作量证明工作量证明指通过有效计算得到的一小块数据。具体到比特币，矿工必须要在满足全网目标难度的情况下求解SHA256算法。 奖励每一个新区块中都有一定量新创造的比特币用来奖励算出工作量证明的矿工。现阶段每一区块有25比特币的奖励。 私钥用来解锁对应（钱包）地址的一串字符，例如5J76sF8L5jTtzE96r66Sf8cka9y44wdpJjMwCxR3tzLh3ibVPxh。 交易简单地说，交易指把比特币从一个地址转到另一个地址。更准确地说，一笔“交易”指一个经过签名运算的，表达价值转移的数据结构。每一笔“交易”都经过比特币网络传输，由矿工节点收集并封包至区块中，永久保存在区块链某处。 转出是交易，转入也是交易。 一般交易。一个地址转到另一个地址，用不完会“找零”。 集合型交易。多个地址转向一个地址，钱包用来汇合零钱。 分散型交易。一个转向多个，如发工资。 交易的输出会被创建成为一个包含这笔数额的脚本的形式，只能被引入这个脚本的一个解答后才能兑换。 钱包钱包指保存比特币地址和私钥的软件，可以用它来接受、发送、储存你的比特币。 比特币地址以数字1或3开头。类似于电子邮件地址，这些地址可以分享给其他的比特币的用户，这样他们就可以直接通过这些地址发送比特币到你的钱包里。不同于电邮地址的是，你可以任意地创建新的比特币地址，这些地址都能成功地将资金转到你的钱包。 钱包是多个地址和解锁资金密钥的简单集合。每笔交易你都可以使用不同的地址，这有利于提高隐私的安全性。用户可创建地址的数量几乎不受限制。 一个地址对应一个秘钥，像支付宝的付款码，其在支付宝后台也有一个对应的秘钥，验证交易。 直到这个地址接收到在比特币账簿（区块链）中公布过的一笔交易时，才会成为众多可能“有效”的比特币地址之一。 介绍平均每10分钟就有人能验证过去这10分钟发生的交易，他将会获得新币作为工作回报。本质上，挖矿把央行的货币发行和结算功能进行分布式，用全球化的算力竞争来取代对中央发行机构的需求。 比特币系统包含调节挖矿难度的协议。挖矿——在比特币网络中成功写入一个区块交易——的难度是动态调整的，保证不管有多少矿工（多少CPU）挖矿，平均每10分钟只有一个矿工成功。 任何接受数字货币的人都面临的两个基本问题是： 我能相信这钱是真实可信的，而不是伪造的吗？我能确定没人说这笔钱是他们的，而不是我的吗？（又名“双重支付”问题） 比特币代表了数十年的密码学和分布式系统的巅峰之作，这是一个独特而强大的组合，汇集了四个关键的创新点。比特币由这些构成： 一个去中心化的点对点网络（比特币协议） 一个公共的交易账簿（区块链） 一个去中心化的数学的和确定性的货币发行（分布式挖矿） 一个去中心化的交易验证系统（交易脚本） 使用http://blockchain.info/ 可以查看所有交易信息 参考 http://zhibimo.com/read/wang-miao/mastering-bitcoin","categories":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/tags/区块链/"}]},{"title":"区块链开发（二）部署并运行以太坊智能合约","slug":"2017-12-06-区块链开发（二）部署并运行以太坊智能合约","date":"2017-12-06T12:21:00.000Z","updated":"2019-04-01T15:18:44.154Z","comments":true,"path":"2017/12/06/2017-12-06-区块链开发（二）部署并运行以太坊智能合约/","link":"","permalink":"http://xichen.pub/2017/12/06/2017-12-06-区块链开发（二）部署并运行以太坊智能合约/","excerpt":"","text":"","categories":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/tags/区块链/"}]},{"title":"网页排序算法（一）PageRank","slug":"2017-12-05-网页排序算法（一）PageRank","date":"2017-12-05T12:22:00.000Z","updated":"2019-04-01T15:18:44.153Z","comments":true,"path":"2017/12/05/2017-12-05-网页排序算法（一）PageRank/","link":"","permalink":"http://xichen.pub/2017/12/05/2017-12-05-网页排序算法（一）PageRank/","excerpt":"","text":"参加数学建模的时候要研究一下PageRank，为了巩固3天从入门到精通的成果，把了解到的整理成文。 直观理解基本思想PageRank是以Google创始人Larry Page的姓命名的，于1999被提出来，用于测量网页的相对重要性（对网页进行排序），学术论文如下： Page, L., Brin, S., Motwani, R., &amp; Winograd, T. (1999). The PageRank citation ranking: Bringing order to the web. Stanford InfoLab. [PDF] PageRank的设计受到学术论文引用启发（两人的父亲都是大学教授）。衡量一篇学术论文质量高与否，最重要的一个指标是引用次数，高引用量的论文通常意味着高质量。同理，如果一张网页被引用（以超链接的形式）多了，那么这张网页就比较重要。总结起来，PageRank的核心思想有两点（结合图1说明）： 越多的网页链接到一个网页（可以理解成投票，D --&gt; B，D给B投了一票），说明这个网页更加重要，如图1的B。(一篇论文被很多论文引用) PageRank高的网页链接到一个网页，说明这张网页也很重要。如图1，尽管C只有一张网页B链接到它，但C的重要性高于E，尽管E有一堆小罗罗给它投票。（论文被大牛引用了，说明这篇论文很有价值）（也可以从话语权角度理解，重要的人说话份量重） Fig. 1: PageRanks for a simple network (image from Wikipedia) 整个万维网（World Wide Web）可以抽象成一张有向图，节点表示网页，连线$$p_i\\to p_j$$表示网页$$p_i$$包含了超链接$$p_j$$（$$p_i$$指向了$$p_j$$）。如果能对图中每个节点重要性量化，那么就能对网页进行排序了。PageRank提出之初就是为了对网页进行排序。 搜索引擎的工作原理可以简化为：输入关键词，返回与该关键词相关的网页（一个集合，相当于得到一张子图），在该子图上计算每个节点的PageRank值，PR值高的网页排在前面，低的就排在后面。 如何计算接下来的问题是，如何计算每个节点的PageRank。想要知道一个网页$$p_i$$的PR值，需要知道： 有多少网页链接到了$$p_i$$ 这些网页的PR值是多少其他网页的PR值又很可能是依赖于$$p_i$$，这就陷入了“先有鸡还是先有蛋”的循环，要想知道$$p_i$$的PR值，就得知道链向$$p_i$$所有网页的PR值，而要知道其他网页的PR值，又得先知道$$p_i$$的PR值。 为了打破这个循环，佩奇和布林采用了一个很巧妙的思路， 即分析一个虚拟用户在互联网上的漫游过程。 他们假定：虚拟用户一旦访问了一个网页，下一步将以相同的概率访问被该网页所链接的任何一个其它网页[3]。比如，网页$$p_i$$包含N个超链接，那么虚拟用户访问这N个页面中的任何一个的概率是1/N。那么，网页的排序就可以看成一个虚拟用户在万维网漫游了很长时间，页面被访问的概率越大，其PR值就越高，网页排名也越靠前。 先从简化的PageRank说起，以PageRank论文的例子为例，看看PageRank是怎么计算的，如下： Fig. 2: Simplified PageRank calculation (image from [1]) 每个节点初始化或者指定一个PageRank值（如PR(A)=0.4），网页A包含两个超链接，分别指向B和C（或者说A投票给B和C），0.4拆分成两份，每份0.2，所以PR(B)=0.2。A和B同时给C投票，所以PR(C)=0.2+0.2=0.4。如此，不断地迭代，最后每个节点的值会趋于稳定（或者说收敛），这样就求得了所有节点的PR值。事实上，在这个例子中，PageRank已收俭。 每个页面将其当前的PageRank值平均分配到本页面所有出链上，一个页面将所有入链的PR值累加起来就构成了该页面新的PR值。如此迭代下去，最后得到一个稳定值。用数学公式表达，如下： $$PR(A)=\\frac{PR(B)}{L(B)}+\\frac{PR(C)}{L(C)}+\\frac{PR(D)}{L(D)}+⋯$$ 更一般化地（$$B(p_i)$$表示所有链向网页$$p_i$$的集合）， $$PR(pi)=\\sum_{p_j\\in B(p_i)}\\frac{PR(p_j)}{L(p_j)}$$ 但这样算存在两个问题： 对于没有forward links (outedges)的网页，即只有别人给她投票，她从不给别人投票，那么她的PageRank每次迭代都会增加。 对于没有blacklinks (inedges)的网页，即没人给她投票，其PageRank永远等于0。 对于第一个问题，给等式乘以一个小于1的常数d（damping factor，翻译成阻尼因数？）；对于第二个问题，给等式加上一个常数。新的等式如下（N表示网页总数，或者节点数目）： $$PR(pi)=\\frac{1−d}{N}+d\\sum{p_j\\in B(p_i)}\\frac{PR(p_j)}{L(p_j)}$$ 其中， $$B(p_i)$$：链接到网页pipi的集合（a set of pages link to pipi） $$L(p_j)$$：从$$p_j$$链出去的网页数目（the number of outbound links）这样，就确保所有节点的PR值加起来等于1。 一个简单实例以一个很简单的例子（A &lt; --&gt; B）来看PageRank是怎么收俭的。 Fig. 2: An illustration of PageRank calculation. 假设他们的初始PR值为1，第一次迭代后，PR(A)和PR(B)的值为：12PR(A) = 0.15/2 + 0.85*1.0 = 0.9249999999999999PR(B) = 0.15/2 + 0.85*0.9249999999999999 = 0.8612499999999998 写个简单的Python脚本，得到每次迭代后的值，部分如下：12345678910111213141516171819202122232425 1: A=0.925000 B=0.861250 2: A=0.807062 B=0.761003 3: A=0.721853 B=0.688575 4: A=0.660289 B=0.636245 5: A=0.615808 B=0.598437 6: A=0.583672 B=0.571121 7: A=0.560453 B=0.551385 8: A=0.543677 B=0.537126 9: A=0.531557 B=0.526823 10: A=0.522800 B=0.519380 11: A=0.516473 B=0.514002 12: A=0.511902 B=0.510116 13: A=0.508599 B=0.50730914: A=0.506213 B=0.505281 15: A=0.504489 B=0.503815 16: A=0.503243 B=0.502757 17: A=0.502343 B=0.501992 18: A=0.501693 B=0.501439 19: A=0.501223 B=0.501040 20: A=0.500884 B=0.500751...42: A=0.500001 B=0.500001 43: A=0.500001 B=0.500000 44: A=0.500000 B=0.500000 45: A=0.500000 B=0.500000 可见，随着迭代次数的增加，PageRank越来越接近收俭值0.5。Python源代码如下：12345678910111213def pagerank_ab(): \"\"\" Calculate PageRank for A &lt;--&gt; B \"\"\" pr = &#123;'A':1.0, 'B':1.0&#125; max_iter = 50 for idx in range(1, max_iter+1): pr['A'] = 0.15/2 + 0.85*pr['B'] pr['B'] = 0.15/2 + 0.85*pr['A'] s = '&#123;:3d&#125;: A=&#123;:&lt;10f&#125;\\tB=&#123;:&lt;10f&#125;'.format(idx, pr['A'], pr['B']) print(s) 迭代次数迭代次数越多，结果越准确，但花费时间也越长。出于效率考虑，在实际应用中，当PR值落在误差允许范围内（PR值跟前一次比较，如PR′(A)−PR(A)&lt;1.0e−6PR′(A)−PR(A)&lt;1.0e−6，想想浮点数在计算机的存储），就可以返回结果了。Python实现的nx.pagerank相关源代码如下：1234# check convergence, l1 normerr = sum([abs(x[n] - xlast[n]) for n in x])if err &lt; N*tol: # tol=1.0e-6 return x 当然，对于超大型网络来说，有更复杂的计算方法，比如分布式。 PR初始值不管节点PR初始值怎么设置，最后节点的PR值都一样，但收俭速度不一样。可以修改上面Python代码的PR初始值，运行代码，自行感受下。NetworkX的pagerank实现是将PR值初始化为1/N。 Damping factor跟PR初始值类似，d的取值也会影响算法效率。根据Page的论文，d通常设为0.85。 PageRank计算方法(1) 迭代方法 详情见另一篇博文《网页排序算法（二）迭代方法求PageRank》。 （2）代数方法 详情见另一篇博文《网页排序算法（三）代数方法求PageRank》。 （3）Power Method 待续。 用NetworkX求PageRankNetworkX提供3个求PageRank的API，如下： pagerank(…) pagerank_numpy(…) pagerank_scipy(…) 详细API如下： 12345pagerank(G, alpha=0.85, personalization=None, max_iter=100, tol=1e-06, nstart=None, weight='weight', dangling=None) pagerank_numpy(G, alpha=0.85, personalization=None, weight='weight', dangling=None) pagerank_scipy(G, alpha=0.85, personalization=None, max_iter=100, tol=1e-06, weight='weight', dangling=None) References: [1] Page, L., Brin, S., Motwani, R., &amp; Winograd, T. (1999). The PageRank citation ranking: Bringing order to the web. Stanford InfoLab. [PDF] [2] PageRank Centrality by Massimo Franceschet [3] 谷歌背后的数学 by 卢昌海 [4] Wikipedia: PageRank [5] The Google Pagerank Algorithm and How It Works","categories":[{"name":"算法","slug":"算法","permalink":"http://xichen.pub/categories/算法/"}],"tags":[{"name":"PageRank","slug":"PageRank","permalink":"http://xichen.pub/tags/PageRank/"}]},{"title":"迪菲-赫尔曼密钥交换","slug":"2017-12-01-迪菲-赫尔曼密钥交换","date":"2017-12-01T13:52:00.000Z","updated":"2019-04-01T15:18:44.152Z","comments":true,"path":"2017/12/01/2017-12-01-迪菲-赫尔曼密钥交换/","link":"","permalink":"http://xichen.pub/2017/12/01/2017-12-01-迪菲-赫尔曼密钥交换/","excerpt":"","text":"迪菲-赫尔曼密钥交换（英语：Diffie–Hellman key exchange，缩写为D-H）最简单，最早提出的这个协议使用一个质数$p$的整数模$n$乘法群以及其原根$g$。 迪菲-赫尔曼密钥交换 算法如下（绿色表示非秘密信息, 红色粗体表示秘密信息）： 爱丽丝与鲍伯协定使用 $$p=23$$以及base $$g=5$$. 爱丽丝选择一个秘密整数$$a=6$$, 计算$$A = g^a mod p$$并发送给鲍伯。 $$A = 56 mod 23 = 8$$. 鲍伯选择一个秘密整数$$b=15$$, 计算$$B = g^b mod p$$并发送给爱丽丝。 $$B = 515 mod 23 = 19$$. 爱丽丝计算$$s = B^a mod p$$ $$196 mod 23 = 2$$. 鲍伯计算$$s = A^b mod p$$ $$815 mod 23 = 2$$. 以下是一个更为一般的描述: 爱丽丝和鲍伯写上一个有限循环群 $$G$$ 和它的一个生成元 $$g$$。 （这通常在协议开始很久以前就已经规定好； $$g$$是公开的，并可以被所有的攻击者看到。） 爱丽丝选择一个随机自然数 $$a$$ 并且将$${\\displaystyle g^{a}{\\bmod {p}}} g^{a} \\bmod{p}$$发送给鲍伯。 鲍伯选择一个随机自然数 $$b$$ 并且将$${\\displaystyle g^{b}{\\bmod {p}}} g^{b} \\bmod{p}$$发送给爱丽丝。 爱丽丝 计算 $${\\displaystyle \\left(g^{b}\\right)^{a}{\\bmod {p}}} \\left ( g^{b} \\right )^{a} \\bmod{p} $$。 鲍伯 计算 $${\\displaystyle \\left(g^{a}\\right)^{b}{\\bmod {p}}} \\left ( g^{a} \\right )^{b} \\bmod{p} $$。 爱丽丝和鲍伯就同时协商出群元素$$ {\\displaystyle g^{ab}} g^{ab} $$，它可以被用作共享秘密。$${\\displaystyle \\left(g^{b}\\right)^{a}} \\left ( g^{b} \\right )^{a} = {\\displaystyle \\left(g^{a}\\right)^{b}} \\left ( g^{a} \\right )^{b}$$因为群是乘法交换的。","categories":[{"name":"密码学","slug":"密码学","permalink":"http://xichen.pub/categories/密码学/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"http://xichen.pub/tags/密码学/"}]},{"title":"区块链开发（一）搭建环境-基于以太坊私有链","slug":"2017-11-30-区块链开发（一）搭建环境-基于以太坊私有链","date":"2017-11-30T13:52:00.000Z","updated":"2019-04-01T15:18:44.151Z","comments":true,"path":"2017/11/30/2017-11-30-区块链开发（一）搭建环境-基于以太坊私有链/","link":"","permalink":"http://xichen.pub/2017/11/30/2017-11-30-区块链开发（一）搭建环境-基于以太坊私有链/","excerpt":"","text":"安装Geth和MistUbuntu下安装Geth客户端之所以采用Ubuntu，是因为以太坊的官方对Ubuntu支持的很好，是在各个linux系统中安装最简单。 Geth官方安装指南：https://github.com/ethereum/go-ethereum/wiki/Building-Ethereum 进入ubuntu命令行，执行如下命令123456$ sudo apt-get update$ sudo apt-get installsoftware-properties-common$ sudo add-apt-repository -yppa:ethereum/ethereum$ sudo add-apt-repository -yppa:ethereum/ethereum-dev$ sudo apt-get update$ sudo apt-get install ethereum 系统联网执行后，即完成了安装以太坊客户端，其中包括geth,bootnode,evm,disasm,rlpdump,ethtest此时如果输入 geth 命令，会出现启动以太坊启动的画面 也可以源码编译安装1234$ git clone https://github.com/ethereum/go-ethereum$ sudo apt-get install -y build-essential golang$ cd go-ethereum$ make geth Windows下安装Geth客户端下载并安装 Geth for Windows.Windows必须64位系统，从官方网站下载编译好的win64客户端，解压缩即可运行，下载地址如下（第二个地址备选）： https://github.com/ethereum/go-ethereum/releases/https://geth.ethereum.org/downloads/ 下载后，只有一个Geth.exe的文件。 MAC OSX下安装Geth客户端首先确保已安装homebrew，没有安装过的可以在命令行下执行/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;进行安装12$ brew tap ethereum/ethereum$ brew install ethereum 安装图像化客户端Mist依然是从官方地址下载编译好的客户端即可，下载地址： https://github.com/ethereum/mist/releases/ 下载解压缩后，Ethereum-Wallet 即为以太坊图形化界面。 准备创世块文件配置自己的创世块是为了区分公有链，同一个网络中，创世块必须是一样的，否则无法联通，此方法在windows和Ubuntu下通用。新建文件piccgenesis.json,输入如下内容并保存1234567891011121314151617&#123; \"config\": &#123; \"chainId\": 123456, \"homesteadBlock\": 0, \"eip155Block\": 0, \"eip158Block\": 0 &#125;, \"nonce\": \"0x0000000000000042\", \"difficulty\": \"0x020000\", \"mixhash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"coinbase\": \"0x0000000000000000000000000000000000000000\", \"timestamp\": \"0x00\", \"parentHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"extraData\": \"0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa\", \"gasLimit\": \"0x4c4b40\", \"alloc\": &#123;&#125;&#125; 解释一下各个参数的作用： 参数 作用 mixhash 与nonce配合用于挖矿，由上一个区块的一部分生成的hash。注意他和nonce的设置需要满足以太坊的Yellow paper, 4.3.4. Block Header Validity, (44)章节所描述的条件。. nonce nonce就是一个64位随机数，用于挖矿，注意他和mixhash的设置需要满足以太坊的Yellow paper, 4.3.4. Block Header Validity, (44)章节所描述的条件。 difficulty 设置当前区块的难度，如果难度过大，cpu挖矿就很难，这里设置较小难度 alloc 用来预置账号以及账号的以太币数量，因为私有链挖矿比较容易，所以我们不需要预置有币的账号，需要的时候自己创建即可以。 coinbase 矿工的账号，随便填 timestamp 设置创世块的时间戳 parentHash 上一个区块的hash值，因为是创世块，所以这个值是0 extraData 附加信息，随便填，可以填你的个性信息 gasLimit 该值设置对GAS的消耗总量限制，用来限制区块能包含的交易信息总和，因为我们是私有链，所以填最大。 启动私有链节点启动Geth即可以启动以太坊的区块链，为了构建私有链 ，需要在Geth启动时加入一些参数，Geth参数含义如下： 参数 作用 identity 区块链的标示，随便填写，用于标示目前网络的名字 init 指定创世块文件的位置，并创建初始块 datadir 设置当前区块链网络数据存放的位置 port 网络监听端口 rpc 启动rpc通信，可以进行智能合约的部署和调试 rpcapi 设置允许连接的rpc的客户端，一般为db,eth,net,web3 networkid 设置当前区块链的网络ID，用于区分不同的网络，是一个数字 console 启动命令行模式，可以在Geth中执行命令 在Ubuntu启动区块链节点在Ubuntu下，首先切换到打算运行的目录，目录下应该有配置好的piccgenesis.json文件，获取当前的目录：1$ basepath=$(cd `dirname $0`; pwd) 创建数据存放地址并初始化创世块：1$ geth --datadir \"$basepath/chain\" init piccgenesis.json 启动节点：1$ geth --identity \"PICCetherum\" --rpc --rpccorsdomain \"*\" --datadir \"$basepath/chain\" --port \"30303\" --rpcapi \"db,eth,net,web3\" --networkid 95518 console 启动后界面如下，光标停留在最后的命令行上，可以执行以太坊命令。1234567891011121314151617181920212223I0707 00:45:43.680087 ethdb/database.go:82]Alloted 128MB cache and 1024 file handles to /home/lihe/桌面/chain/chaindataI0707 00:45:43.726008ethdb/database.go:169] closed db:/home/lihe/桌面/chain/chaindataI0707 00:45:43.728913 ethdb/database.go:82]Alloted 128MB cache and 1024 file handles to /home/lihe/桌面/chain/chaindataI0707 00:45:43.908795 ethdb/database.go:82]Alloted 16MB cache and 16 file handles to /home/lihe/桌面/chain/dappI0707 00:45:43.969506 core/genesis.go:92]Genesis block already in chain. Writing canonical numberI0707 00:45:43.980337 eth/backend.go:274]Successfully wrote custom genesis block:6e92f8b23bcdfdf34dc813cfaf1d84b71beac80530506b5d63a2df10fe23a660I0707 00:45:43.980618 eth/backend.go:184]Protocol Versions: [63 62], Network Id: 95518I0707 00:45:43.981567core/blockchain.go:204] Last header: #81 [6193c4b0…] TD=10836704I0707 00:45:43.981645core/blockchain.go:205] Last block: #81 [6193c4b0…] TD=10836704I0707 00:45:43.981677core/blockchain.go:206] Fast block: #81 [6193c4b0…] TD=10836704I0707 00:45:43.985253 p2p/server.go:313]Starting ServerI0707 00:45:45.834488p2p/discover/udp.go:217] Listening,enode://134881790e54c803955715e3661c27f91caaf499be813e29c9f986e2eac62d47e02b13a8e51776c1caea554655614ed26ce0185d84e626da7ac48a83a60113ff@[::]:30303I0707 00:45:45.835853 node/node.go:366]HTTP endpoint opened: http://localhost:8545I0707 00:45:45.848008 p2p/server.go:556]Listening on [::]:30303I0707 00:45:45.849731 node/node.go:296] IPCendpoint opened: /home/lihe/桌面/chain/geth.ipcWelcome to the Geth JavaScript console! instance:Geth/v1.5.0-unstable/linux/go1.5.1/PICCetherumcoinbase:0x93509a2f4b2b974b07ef0b52e07c3992601f5de1at block: 81 (Tue, 05 Jul 2016 21:02:25CST) datadir: /home/lihe/桌面/chain modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0&gt; 可以看到Listening on [::]:30303和Welcome to the Geth JavaScript console!的提示，说明已经启动成功 注意：如果想将Ubuntu作为永久区块链节点使用，当使用nohup命令时，Geth启动参数console必须去掉，否则Geth会自动停止。 在windows启动区块链节点进入Windows下Geth的目录 ，放置配置好的piccgenesis.json文件，执行如下命令：1$ geth --datadir \"%cd%\\chain\" init piccgenesis.json 创建数据存放地址并初始化创世块1$ geth--identity \"PICCetherum\" --rpc--rpccorsdomain \"*\" --datadir \"%cd%\\chain\" --port\"30303\" --rpcapi\"db,eth,net,web3\" --networkid 95518 console 当看到Listening on [::]:30303和Welcome to the Geth JavaScript console!的提示，说明已经启动成功 使用节点创建账号启动节点成功后，会进入Geth的命令行模式，输入如下命令1personal.newAccount() 系统会提示你输入账号密码，并确认，最后会显示一个新生成的账号。 Geth JavaScript控制台环境使用说明 创建新账号personal.newAccount()或者 personal.newAccount(&quot;123456&quot;) 查看节点信息admin.nodeInfo 挖矿 开始挖矿miner.start(1) 停止挖矿miner.stop() 查看当前矿工账号eth.coinbase 默认为第一个账户 修改矿工账号miner.setEtherbase(eth.accounts[1]) 查看账户信息eth.accounts[0] 查看账户余额eth.getBalance(eth.accounts[0])或者 web3.fromWei(eth.getBalance(eth.accounts[0]), &quot;ether&quot;) 解锁账号personal.unlockAccount(eth.accounts[0])使用账户资金前都需要先解锁账号 转账eth.sendTransaction({from:eth.accounts[0],to:&quot;0x587e57a516730381958f86703b1f8e970ff445d9&quot;,value:web3.toWei(3,&quot;ether&quot;)})使用 txpool.status可以看到交易状态 查看区块数据 eth.blockNumber eth.getTransaction(&quot;0x0c59f431068937cbe9e230483bc79f59bd7146edc8ff5ec37fea6710adcab825&quot;) eth.getBlock(1) 通过区块号查看区块 私有链图形节点启动Ubuntu下私有链图形节点首先按上面的步骤启动Geth并创建了账号，在geth运行的时候，再运行下面的命令1ethereumwallet --gethpath /usr/bin/geth --gethpath改成你实际安装的geth的路径 启动Windows下私有链图形节点首先按上面的步骤启动Geth并创建了账号，然后解压缩Ethereum-Wallet，运行Ethereum-Wallet.exe,即启动成功，如果区块链正常的话，会在右上角显示“PRIVATE-NET”，点击“LAUNCH APPLICATION”进入图形界面即可。 连接其他节点首先要知道自己的节点信息，在Geth命令行界面下输入命令,注意大小写1admin.nodeInfo 系统会显示1enode:\"enode://1e3c1727cd3bee9f25edeb5dbb3b880e03e41f8eec99566557f3ee0422734a8fcad17c161aa93d61bdbfb28ed152c143c7eb501db58bc63502a104a84b62d742@0.0.0.0:30303“ 其中enode://1e3c1727cd3bee9f25edeb5dbb3b880e03e41f8eec99566557f3ee0422734a8fcad17c161aa93d61bdbfb28ed152c143c7eb501db58bc63502a104a84b62d742@0.0.0.0:30303就是自己节点的信息，注意要把0.0.0.0换成你自己的IP。将这个信息发送给其他节点，在其他节点的命令行中输入：1admin.addPeer(‘enode://1e3c1727cd3bee9f25edeb5dbb3b880e03e41f8eec99566557f3ee0422734a8fcad17c161aa93d61bdbfb28ed152c143c7eb501db58bc63502a104a84b62d742@192.168.1.101:30303’) 如果添加成功，输入admin.peers会显示出新添加的节点。 使用节点进行挖矿在Geth命令行界面下，输入miner.start()即启动挖矿，挖矿后，会不停刷屏，输入miner.stop()即停止，不用管刷屏导致的命令不全，命令会正常执行。到这一步，已经组建一个私有链的网络，可以像其他区块链一样不停的扩充这个网络，下一篇文章，我会介绍如何在私有链上编写、调试和部署智能合约。 参考文章： http://blog.csdn.net/sportshark/article/details/51855007 http://tech.lab.carl.pro/kb/ethereum/testnet_setup http://www.ethdocs.org/en/latest/network/test-networks.html#setting-up-a-local-private-testnet https://github.com/ethereum/go-ethereum/wiki/Connecting-to-the-network https://github.com/ethereum/go-ethereum/wiki/JavaScript-Console https://github.com/ethereum/go-ethereum/wiki/Mining https://github.com/ethereum/go-ethereum/wiki/Managing-your-accounts https://github.com/janx/ethereum-bootstrap https://forum.qtum.org/topic/127/以太坊私链与智能合约部署入门教程/2","categories":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/tags/区块链/"}]},{"title":"ubuntu--apt-get update（由于没有公钥，无法验证下列签名）","slug":"2017-11-29-apt-get-update-GPG错误","date":"2017-11-29T13:52:00.000Z","updated":"2019-04-01T15:18:44.150Z","comments":true,"path":"2017/11/29/2017-11-29-apt-get-update-GPG错误/","link":"","permalink":"http://xichen.pub/2017/11/29/2017-11-29-apt-get-update-GPG错误/","excerpt":"","text":"当 apt-get update 更新后，出现下面错误时的解决方法：123...bash正在读取软件包列表… 完成 W: GPG 错误：http://ppa.launchpad.net trusty InRelease: 由于没有公钥，无法验证下列签名： NO_PUBKEY 2EA8F35793D8809A 解决办法:1$ sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys E298A3A825C0D65DFD57CBB651716619E084DAB9 结果：12345Executing: gpg –ignore-time-conflict –no-options –no-default-keyring –secret-keyring /tmp/tmp.uxUmi4wF1r –trustdb-name /etc/apt/trustdb.gpg –keyring /etc/apt/trusted.gpg –primary-keyring /etc/apt/trusted.gpg –keyserver keyserver.ubuntu.com –recv-keys 2EA8F35793D8809A gpg: 下载密钥‘93D8809A’，从 hkp 服务器 keyserver.ubuntu.com gpg: 密钥 93D8809A：公钥“Launchpad PPA for Martin Wimpress”已导入 gpg: 合计被处理的数量：1 gpg: 已导入：1 (RSA: 1)","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://xichen.pub/categories/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://xichen.pub/tags/Ubuntu/"}]},{"title":"Go 爬虫总结","slug":"2017-11-27-go爬虫总结","date":"2017-11-27T13:52:00.000Z","updated":"2019-04-01T15:18:44.147Z","comments":true,"path":"2017/11/27/2017-11-27-go爬虫总结/","link":"","permalink":"http://xichen.pub/2017/11/27/2017-11-27-go爬虫总结/","excerpt":"","text":"爬虫目的：爬导航和爬商品 爬虫架构： electron虚拟浏览器 proxy代理ip dashboard网页端调控 爬虫APP 实现的功能： url拼接，过滤出商品 url翻页，点击翻页，无限流，loadmore按钮 过滤文本中包含某text的url，过滤url中包含某url的url，定点过滤特定的url，只爬文本中包含某text的url，只爬url中包含某url的url 失败移至末尾重试（次数，本次返回的状态码，延时） 控制爬取频率，控制递归爬取深度 用electron防止cookie或ajax动态加载页面，有WaitSelector，直到WaitSelector出现才返回渲染后的页面给spider，否则返回错误码 分布式，高并发 多个proxy负载均衡 proxy权限控制 dashboard网页端爬虫调度，导航log和简单报表分析，商品log和简单报表分析，服务器上当前所有配置一览 我负责的模块： 配置文件template 测试被反爬虫的条件，计算最大爬取频率 实现同时爬取多个网站，单线程和并发可选 默认 http client 不会缓存 DNS 记录，而爬虫会有大量的请求，所以自己专门对 DNS 做缓存 调查并分析站点请求不成功的url占比超过 20% 的原因并修复 发现并解决 ssl 证书问题 网站改版，及时更新配置文件 给timeout设一个下界 返回408原因：（1）商品Selector作为WaitSelector，有的页面是介绍页，没有商品，返回408（2）翻页超过最大页数，没有商品，返回408。这个原因导致的408一般 成堆 出现（3）无限流需要较长时间来翻页，timeout较小会408（4）目标网站有的商品下架，没有商品，返回408（5）目标网站反爬策略，封ip后也不返回500，只有提示性的html，等不到商品，返回408（6）目标网站必须用https 解决方案：（这几个印象深刻，其他的想不起来了） 商品Selector作为WaitSelector，有的页面是介绍页，没有商品，返回408 有2个waitSelector，一个Selector做监督，一个选商品Selector，如果监督Selector出现了而商品Selector没出来，就判定没商品 效果好 时间成本高 只要1个errorSelector，出现提示性的error，判定为没有商品 实现简单，时间成本低，逻辑清晰 不全面，有些站点如果没有商品，也不出现提示性文字 electron不处理，无论是否408都把页面返回，交给spider处理 electron端实现简单，效果好，易于扩展 spider端实现困难，给spider端挖坑，有隐患 ssl 证书问题 请求时不检测证书 http 请求 换成https请求 getsockopt: no route to host 和firewall有关，我们对昂贵的proxy做权限控制，而我在本地没有这个proxy的权限，必须到服务器上搞 getsockopt: connection time out 需要特殊的header，不然在命令行是不能成功请求的 DNS解析 原来的每次都要new一个，修复后只要一个持久化 团队共享用到的软件（我们都是远程办公） slack:交流讨论 quip：共享文件 trello：任务管理 zoom：远程会议 google图表：共享文件","categories":[{"name":"Spider","slug":"Spider","permalink":"http://xichen.pub/categories/Spider/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://xichen.pub/tags/Go/"},{"name":"Spider","slug":"Spider","permalink":"http://xichen.pub/tags/Spider/"}]},{"title":"Ubuntu中使用dpkg安装deb文件提示依赖关系问题，仍未被配置","slug":"2017-10-11-dpkg-error","date":"2017-10-14T17:54:00.000Z","updated":"2019-04-01T15:18:44.143Z","comments":true,"path":"2017/10/15/2017-10-11-dpkg-error/","link":"","permalink":"http://xichen.pub/2017/10/15/2017-10-11-dpkg-error/","excerpt":"","text":"使用dpkg时，提示：dpkg：处理软件包XXX时出错：依赖关系问题，仍未被配置 问题 出现上图时，使用如下命令1sudo apt-get install -f 解决 等分析完之后，重新使用dpkg –i XXX.deb，就可以了 解决","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://xichen.pub/categories/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://xichen.pub/tags/Ubuntu/"}]},{"title":"Python Tweepy 翻墙抓取Twitter信息","slug":"2017-10-11-python-proxy","date":"2017-10-13T02:13:00.000Z","updated":"2019-04-01T15:18:44.144Z","comments":true,"path":"2017/10/13/2017-10-11-python-proxy/","link":"","permalink":"http://xichen.pub/2017/10/13/2017-10-11-python-proxy/","excerpt":"","text":"repo在此，如果觉得做得好，给个star鼓励下吧！ 在看《Python数据挖掘入门与实践》的时候，随书附带的代码已经过时几年了，现在边看书边修，很是辛苦 在学习第六章”使用朴素贝叶斯进行社交媒体挖掘”时，数据集需要通过twitter的API来获取 （玛蛋，为毛不随书附带数据集） twitter在国内被墙了，只能翻墙 浏览器翻墙容易，弄个lantern或者shadowsockets就可以了 但是，由于ubuntu的代理不是全局代理，在命令行中翻墙要设proxy，在代码中翻墙也要设proxy 所以难处在于代码要就twitter的python接口翻墙 如果只是一个简单的加proxy网络请求，几行就可以搞定： 12import urllib.requestproxy_support = urllib.request.ProxyHandler(&#123;'http' : 'http://127.0.0.1:80'&#125;) 可是twitter的python接口是自动发起请求的呀 懒得去改源码 只好看看怎么在代码中设置好翻墙 账号准备首先需要在twitter官方注册twitter账号，并新建一个应用，链接：新建应用如果新建应用不成功，国内大多数情况都是无法验证手机号，可以参考这个教程，亲测有效，链接：验证手机号注册成功后，可以查看自己的keys and access token，如下图： Consumer Key and Consumer Secret Access Token and Access Token Secret 环境准备python3.5+ 安装tweepy： 在命令行中输入：pip install tweepy 发起请求12345678910111213141516# -*- coding: utf-8 -*-import tweepyfrom tweepy import OAuthHandlerconsumer_key = 'replace your own account consumer_key'consumer_secret = 'replace your own account consumer_secret'access_token = 'replace your own account access_token'access_secret = 'replace your own account access_secret'auth = OAuthHandler(consumer_key,consumer_secret)auth.set_access_token(access_token,access_secret)api = tweepy.API(auth)for status in tweepy.Cursor(api.home_timeline).items(2): print (status.text) 报错一:挂代理翻墙报错信息如下： 1tweepy.error.TweepError: Failed to send request: HTTPSConnectionPool(host='api.twitter.com', port=443): Max retries exceeded with url: /1.1/statuses/home_timeline.json (Caused by ProxyError('Cannot connect to proxy.', NewConnectionError('&lt;requests.packages.urllib3.connection.VerifiedHTTPSConnection object at 0x0000000002FC6E80&gt;: Failed to establish a new connection: [Errno 10061] ',))) 主要原因就是twitter被墙了，twitter的api当然也被墙了。 这时候就需要挂代理翻墙了，我使用的是自己搭建的shadowsockets。其它翻墙软件或者服务器网上有很多，请自行查找。 代理打开了之后，在原代码中，将1api = tweepy.API(auth) 改为1api = tweepy.API(auth,proxy=\"127.0.0.1:1080\") 报错二:请求的配置没有写对报错信息如下： 1tweepy.error.TweepError: Twitter error response: status code = 401 原因： 这几个发起请求的配置没有写对，仔细修改 consumer_key consumer_secret access_token access_secret 改过了还是不对，刷新Regenerate Consumer Key and Secret和Regenerate My Access Token and Token Secret，重新填写请求 报错三报错信息如下： 1tweepy.error.TweepError: Failed to send request: HTTPSConnectionPool(host='api.twitter.com', port=443): Max retries exceeded with url: /1.1/statuses/home_timeline.json (Caused by ProxyError('Cannot connect to proxy.', timeout('timed out',))) 原因是Shadowsocks使用的是socks5代理，并非是http代理。 emmm，简单，大手一挥，稍微修改一下即可 1api = tweepy.API(auth, proxy=\"socks5://127.0.0.1:1080\") 报错四报错信息如下： 1tweepy.error.TweepError: Failed to send request: SOCKSHTTPSConnectionPool(host='api.twitter.com', port=443): Read timed out. (read timeout=60) 原因是tweepy使用的是http代理，不能用socks5代理（我日）。 所以需要将socks5代理转换为http代理来支持tweepy访问twitter REST API,这里参考以下地址：为终端设置Shadowsocks代理 最后不要忘记在代码里加上代理： 1api = tweepy.API(auth, proxy=\"127.0.0.1:8123\") 还没完 tweepy 这个库的资料比较少,我自己摸索着试了试,把代码发上来 一.按照关键字搜索Twitter的内容 12345678910#接上面的代码(q = 关键字 ,count = 返回的数据量 . 推特一次最多返回100条??)search_results = api.search(q='python',count=100)#对对象进行迭代for tweet in search_results: #tweet还是一个对象,推特的相关信息在tweer._json里 #这里是检测消息是否含有'text'键,并不是所有TWitter返回的所有对象都是消息(有些可能是用来删除消息或者其他内容的动作--这个没有确认),区别就是消息对象中是否含有'text'键 if 'text' in tweet._json: print(tweet._json['text']) #这里是把内容给打印出来了,如果需要保存到文件需要用json库的dumps函数转换为字符串形式后写入到文件中 #例如 :output_file.write(json.dumps(tweet._json)) 二.根据Twitter消息的ID批量获取消息12#其中id_list 是消息ID组成的list 长度也不要超过100search_result = api.statuses_lookup(id_list) 这时，就可以成功访问了 成功访问","categories":[{"name":"Proxy","slug":"Proxy","permalink":"http://xichen.pub/categories/Proxy/"}],"tags":[{"name":"Proxy","slug":"Proxy","permalink":"http://xichen.pub/tags/Proxy/"},{"name":"Python","slug":"Python","permalink":"http://xichen.pub/tags/Python/"}]},{"title":"algorithms-Bit-Options","slug":"2017-10-11-算法之位运算","date":"2017-10-11T06:25:00.000Z","updated":"2019-04-01T15:18:44.146Z","comments":true,"path":"2017/10/11/2017-10-11-算法之位运算/","link":"","permalink":"http://xichen.pub/2017/10/11/2017-10-11-算法之位运算/","excerpt":"","text":"算法常用的一个等式：-n = ~(n - 1) = ~n + 1 获得int型最大值123456int getMaxInt()&#123; return (1 &lt;&lt; 31) - 1;//2147483647,由于优先级关系,括号不可省略 return ~(1 &lt;&lt; 31); //2147483647 return (1 &lt;&lt; -1) - 1;//2147483647 return ((unsigned int) - 1) &gt;&gt; 1;//2147483647&#125; 获得int型最小值1234int getMinInt()&#123; return 1 &lt;&lt; 31;//-2147483648 return 1 &lt;&lt; -1;//-2147483648&#125; 获得long类型的最大值1234long getMaxLong()&#123; return ((unsigned long) - 1) &gt;&gt; 1;//2147483647 c语言版 return ((long)1 &lt;&lt; 127) - 1;//9223372036854775807 java版&#125; 获得long最小值，和其他类型的最大值，最小值同理. 2运算1234n &lt;&lt; 1 // 乘以2n &gt;&gt; 1 // 除以2n &lt;&lt; m // 乘以2的m次方n &gt;&gt; m // 除以2的m次方 判断一个数的奇偶性123boolean isOddNumber(int n)&#123; return (n &amp; 1) == 1;&#125; 不用临时变量交换两个数（面试常考）123void swap(int *a,int *b)&#123; (*a) ^= (*b) ^= (*a) ^= (*b);&#125; 通用版（一些语言中得分开写）123a ^= b;b ^= a;a ^= b; 取绝对值（某些机器上，效率比n&gt;0 ? n:-n 高） 123456int abs(int n)&#123; return (n ^ (n &gt;&gt; 31)) - (n &gt;&gt; 31);/* n&gt;&gt;31 取得n的符号，若n为正数，n&gt;&gt;31等于0，若n为负数，n&gt;&gt;31等于-1 若n为正数 n^0=0,数不变，若n为负数有n^-1 需要计算n和-1的补码，然后进行异或运算， 结果n变号并且为n的绝对值减1，再减去-1就是绝对值 */&#125; 取两个数的最大值（某些机器上，效率比a&gt;b ? a:b高） 1234int max(int a,int b)&#123; return b &amp; ((a-b) &gt;&gt; 31) | a &amp; (~(a-b) &gt;&gt; 31); /*如果a&gt;=b,(a-b)&gt;&gt;31为0，否则为-1*/&#125; C语言版12345int max(int x,int y)&#123; return x ^ ((x ^ y) &amp; -(x &lt; y)); /*如果x&lt;y x&lt;y返回1，否则返回0， 与0做与运算结果为0，与-1做与运算结果不变*/&#125; 取两个数的最小值（某些机器上，效率比a&gt;b ? b:a高） 1234int min(int a,int b)&#123; return a &amp; ((a-b) &gt;&gt; 31) | b &amp; (~(a-b) &gt;&gt; 31); /*如果a&gt;=b,(a-b)&gt;&gt;31为0，否则为-1*/&#125; C语言版12345int min(int x,int y)&#123; return y ^ ((x ^ y) &amp; -(x &lt; y)); /*如果x&lt;y x&lt;y返回1，否则返回0， 与0做与运算结果为0，与-1做与运算结果不变*/&#125; 判断符号是否相同123boolean isSameSign(int x, int y)&#123; //有0的情况例外 return (x ^ y) &gt;= 0; // true 表示 x和y有相同的符号， false表示x，y有相反的符号。&#125; 计算2的n次方123int getFactorialofTwo(int n)&#123;//n &gt; 0 return 2 &lt;&lt; (n-1);//2的n次方&#125; 判断一个数是不是2的幂12345boolean isFactorialofTwo(int n)&#123; return n &gt; 0 ? (n &amp; (n - 1)) == 0 : false; /*如果是2的幂，n一定是100... n-1就是1111.... 所以做与运算结果为0*/&#125; 对2的n次方取余12345int quyu(int m,int n)&#123;//n为2的次方 return m &amp; (n - 1); /*如果是2的幂，n一定是100... n-1就是1111.... 所以做与运算结果保留m在n范围的非0的位*/&#125; 求两个整数的平均值12345678int getAverage(int x, int y)&#123; return (x + y) &gt;&gt; 1;&#125;int getAverage(int x, int y)&#123; return ((x ^ y) &gt;&gt; 1) + (x &amp; y); /*(x^y) &gt;&gt; 1得到x，y其中一个为1的位并除以2， x&amp;y得到x，y都为1的部分，加一起就是平均数了*/&#125; 下面是三个最基本对二进制位的操作 从低位到高位,取n的第m位123int getBit(int n, int m)&#123; return (n &gt;&gt; (m-1)) &amp; 1;&#125; 从低位到高位.将n的第m位置设为112345int setBitToOne(int n, int m)&#123; return n | (1 &lt;&lt; (m-1)); /*将1左移m-1位找到第m位，得到000...1...000 n在和这个数做或运算*/&#125; 从低位到高位,将n的第m位置设为012345int setBitToZero(int n, int m)&#123; return n &amp; ~(1 &lt;&lt; (m-1)); /* 将1左移m-1位找到第m位，取反后变成111...0...1111 n再和这个数做与运算*/&#125; 另附一些对程序效率上没有实质提高的位运算技巧，一些也是位运算的常识（面试也许会遇到）123456n+1 = -~nn-1 = ~-n-n = ~n+1-n = (n^-1)+1x = a ^ b ^ x &lt;=&gt; if(x == a) x = b; if(x == b) x = a;sign(x) = !!n - (((unsigned)n &gt;&gt; 31) &lt;&lt; 1) 获取整数二进制表示中最右侧的11n &amp; (-n) &lt;=&gt; n &amp; ~(n - 1) 二进制中1的个数用到了n &amp; (n - 1)由x &amp; (x - 1)消去x最后一位的1可知。不断使用 x &amp; (x - 1) 消去x最后一位的1，计算总共消去了多少次即可。12345678int countOnes(int num) &#123; int count = 0; while(num != 0) &#123; num = num &amp; (num-1); count++; &#125; return count;&#125; 翻转123456789// 翻转unsigned int Bit_Reverse(unsigned int v) &#123; v = ((v &gt;&gt; 1) &amp; 0x55555555) | ((v &lt;&lt; 1) &amp; 0xaaaaaaaa); v = ((v &gt;&gt; 2) &amp; 0x33333333) | ((v &lt;&lt; 2) &amp; 0xcccccccc); v = ((v &gt;&gt; 4) &amp; 0x0f0f0f0f) | ((v &lt;&lt; 4) &amp; 0xf0f0f0f0); v = ((v &gt;&gt; 8) &amp; 0x00ff00ff) | ((v &lt;&lt; 8) &amp; 0xff00ff00); v = ((v &gt;&gt; 16) &amp; 0x0000ffff) | ((v &lt;&lt; 16) &amp; 0xffff0000); return v;&#125; 输入两个数A和B，输出将A转换为B所需改变的二进制的位数。首先，A异或B得到的是A和B中不相同位数组成的数，然后再求这个数二进制表示中1的个数，即为所求。1countOnes(A^B); 数组中只出现一次的数字用到了n &amp; (n - 1) 和 a ^ b ^ b = a 数组中，只有一个数出现一次，剩下都出现两次，找出出现一次的数因为只有一个数恰好出现一个，剩下的都出现过两次，所以只要将所有的数异或起来，就可以得到唯一的那个数。参考文章：http://zhedahht.blog.163.com/blog/static/2541117420071128950682/ 数组中，只有一个数出现一次，剩下都出现三次，找出出现一次的数因为数是出现三次的，也就是说，对于每一个二进制位，如果只出现一次的数在该二进制位为1，那么这个二进制位在全部数字中出现次数无法被3整除。 膜3运算只有三种状态：00,01,10，因此我们可以使用两个位来表示当前位%3，对于每一位，我们让Two，One表示当前位的状态，B表示输入数字的对应位，Two+和One+表示输出状态。 参考文章：http://zhedahht.blog.163.com/blog/static/25411174201283084246412/ 数组中，只有两个数出现一次，剩下都出现两次，找出出现一次的数有了第一题的基本的思路，我们可以将数组分成两个部分，每个部分里只有一个元素出现一次，其余元素都出现两次。那么使用这种方法就可以找出这两个元素了。不妨假设出现一个的两个元素是x，y，那么最终所有的元素异或的结果就是res = x^y。并且res！=0，那么我们可以找出res二进制表示中的某一位是1。对于原来的数组，我们可以根据这个位置是不是1就可以将数组分成两个部分。x，y在不同的两个子数组中。而且对于其他成对出现的元素，要么在x所在的那个数组，要么在y所在的那个数组。 位操作实现加减乘除运算12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//加法int BinaryAdd(int a, int b) &#123; int carry, add; do &#123; add = a ^ b; //该操作得到本位的加法结果 carry = (a &amp; b) &lt;&lt; 1; //该操作得到该位对高位的进位值 a = add; b = carry; &#125; while (carry != 0); //循环直到某次运算没有进位，运算结束 return add;&#125;//减法int BinarySub(int a, int b) &#123; return BinaryAdd(a, BinaryAdd(~b, 1));&#125;/*乘法 该过程中的bit_map是为了快速得到乘法过程中某位相乘的中间结果S[i] 需要位移的位数。bit_map的键值是2^0, 2^1,2^2, ……之类的数，对应的 值是0，1,2,……(即需要位移的位数)。 */int BinaryMultiply(int a, int b) &#123; bool neg = (b &lt; 0); if(b &lt; 0) b = -b; int sum = 0; map&lt;int, int&gt; bit_map; for(int i = 0; i &lt; 32; i++) &#123; bit_map.insert(pair&lt;int, int&gt;(1 &lt;&lt; i, i)); &#125; while(b &gt; 0) &#123; /* b &amp; ~(b - 1)可以得到乘数b的二进制表示中最右侧1的位置 last_bit记录被乘数a需要位移的位数 */ int last_bit = bit_map[b &amp; ~(b - 1)]; //将得到的乘法结果全部相加即为最后结果 sum += (a &lt;&lt; last_bit); b &amp;= b - 1; //每次将b的二进制表示的最右侧1去掉用于下一次乘法 &#125; if(neg) sum = -sum; return sum;&#125;//除法int BinaryDivide(int a, int b)&#123; bool neg = (a &gt; 0) ^ (b &gt; 0); if(a &lt; 0) a = -a; if(b &lt; 0) b = -b; if(a &lt; b) return 0; int msb = 0; //msd记录除数需要左移的位数 for(msb = 0; msb &lt; 32; msb++) &#123; if((b &lt;&lt; msb) &gt;= a) break; &#125; int q = 0; //记录每次除法的商 for(int i = msb; i &gt;= 0; i--) &#123; if((b &lt;&lt; i) &gt; a) continue; q |= (1 &lt;&lt; i); a -= (b &lt;&lt; i); &#125; if(neg) return -q; return q;&#125; reference: 优秀程序员不得不知道的20个位运算技巧http://blog.csdn.net/zmazon/article/details/8262185 位操作实现加减乘除四则运算http://blog.csdn.net/u013074465/article/details/42680239","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://xichen.pub/categories/Algorithms/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://xichen.pub/tags/算法/"}]},{"title":"面向过程，面向对象，函数式","slug":"2017-9-18-面向过程-面向对象-函数式","date":"2017-09-17T22:42:14.000Z","updated":"2019-04-01T15:18:44.164Z","comments":true,"path":"2017/09/18/2017-9-18-面向过程-面向对象-函数式/","link":"","permalink":"http://xichen.pub/2017/09/18/2017-9-18-面向过程-面向对象-函数式/","excerpt":"","text":"如何把大象关进冰箱里？面向过程：1把冰箱门打开 =&gt; 大象放冰箱里 =&gt; 冰箱门关上 面向对象：123冰箱.开门（）冰箱.放入（大象）冰箱.关门（） or 1冰箱.开门().放入(大象).关门() 函数式：12关进（冰箱，大象）: 关门（放入（开门（冰箱），大象））","categories":[{"name":"杂思","slug":"杂思","permalink":"http://xichen.pub/categories/杂思/"}],"tags":[{"name":"杂思","slug":"杂思","permalink":"http://xichen.pub/tags/杂思/"}]},{"title":"terminal tips","slug":"2017-08-28-Terminal-tips","date":"2017-08-27T20:46:00.000Z","updated":"2019-04-01T15:18:44.142Z","comments":true,"path":"2017/08/28/2017-08-28-Terminal-tips/","link":"","permalink":"http://xichen.pub/2017/08/28/2017-08-28-Terminal-tips/","excerpt":"","text":"打开 快捷键：Ctrl+Alt-T 空白处右键：有选项在终端打开 处于命令行窗口：Ctrl+T选项卡形式，Ctrl+N窗口形式 颜色颜色代码 前景 背景 颜色 30 40 黑色 31 41 紅色 32 42 綠色 33 43 黃色 34 44 藍色 35 45 紫紅色 36 46 青藍色 37 47 白色 ——- ———– ——— 1 透明色 ——- 代码 意义 0 OFF 1 高亮显示 4 underline 5 闪烁 7 反白显示 8 不可见 序列说明 | \\a | ASCII响铃字符（也可以键入 \\007） | | \\d | “Wed Sep 06”格式的日期 | | \\e | ASCII转义字符（也可以键入 \\033） | | \\h | 主机名的第一部分（如 “mybox”） | | \\H | 主机的全称（如 “mybox.mydomain.com”） | | \\j | 在此 shell中通过按 ^Z挂起的进程数 | | \\l | 此 shell的终端设备名（如 “ttyp4”） | | \\n | 换行符 | | \\r | 回车符 | | \\s | shell的名称（如 “bash”） | | \\t | 24小时制时间（如 “23:01:01”） | | \\T | 12小时制时间（如 “11:01:01”） | | \\@ | 带有 am/pm的 12小时制时间 | | \\u | 用户名 | | \\v | bash的版本（如 2.04） | | \\V | Bash版本（包括补丁级别） ?/td&gt;; | | \\w | 当前工作目录（如 “/home/drobbins”） | | \\W | 当前工作目录的“基名 (basename)”（如 “drobbins”） | | ! | 当前命令在历史缓冲区中的位置 | | # | 命令编号（只要您键入内容，它就会在每次提示时累加） | | \\$ | 如果您不是超级用户 (root)，则插入一个 “$”；如果您是超级用户，则显示一个 “#” | | \\xxx | 插入一个用三位数 xxx（用零代替未使用的数字，如 “/007”）表示的 ASCII 字符 | | \\ | 反斜杠 | | [ | 这个序列应该出现在不移动光标的字符序列（如颜色转义序列）之前。它使 bash能够正确计算自动换行。 | | ] | 这个序列应该出现在非打印字符序列之后。 | 颜色的设置公式1颜色=\\033[代码;前景;背景m 如：\\033[1;32;40m表示高亮显示字体为绿色，背景色为黑色（颜色定义见本文前面的表格） 注意： 要将全部非打印字符用专用的 bash 转义序列 “[“和 “]“括起来。这两个序列通知 bash，被括起来的字符不占用行上的任何空间，这样就使自动换行能够继续正常工作。 这点很关键要不然等你设好了颜色，你的终端换行会乱七八糟 套路默认的就很好看，打开~/.bashrc，其中有几行声明 12345if [ \"$color_prompt\" = yes ]; then PS1='$&#123;debian_chroot:+($debian_chroot)&#125;\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]\\$ 'else PS1='$&#123;debian_chroot:+($debian_chroot)&#125;\\u@\\h:\\w\\$ 'fi 下面这个就是默认的配色方案1PS1='$&#123;debian_chroot:+($debian_chroot)&#125;\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]\\$ ' 要修改配色方案，在文件末尾加上1PS1=`balabala` ROOT身份下的终端颜色打开/root/.bash.rc1vi /root/.bash.rc 按i进入插入字符模式，在文件末尾加上一行(把默认的贴过去)1PS1='$&#123;debian_chroot:+($debian_chroot)&#125;\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]\\$ ' 按下Esc然后输入:wq保存修改 再输入source ~/.bashrc刷新 SSH会话下的终端颜色通过在.bashrc文件中更改与ssh连接的每个主机名上的PS1值 在托管的机器上(lxy @ ubuntu)同样打开文件~/.bashrc1vi ~/.bashrc 在文件末尾加上一行(把默认的贴过去)1PS1='$&#123;debian_chroot:+($debian_chroot)&#125;\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]\\$ ' 按下Esc然后输入:wq保存修改 再输入source ~/.bashrc刷新 zsh安装zsh1sudo apt-get install zsh 安装oh-my-zsh12git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zshcp ~/.oh-my-zsh/tmplates/zshrc.zsh-template ~/.zshrc Powerline 主题1234git clone git://github.com/jeremyFreeAgent/oh-my-zsh-powerline-theme ~/.ohmyzsh-powerlinecd ~/.ohmyzsh-powerlinecp powerline.zsh-theme ~/.oh-my-zsh/themes/powerline.zsh-themerm -rf ~/.ohmyzsh-powerline 把zsh设为默认1chsh -s /bin/zsh 卸载zsh1sudo apt remove zsh 今天手残装了zsh和oh-my-zsh后又卸载掉，导致su进不去1无法执行 /usr/bin/zsh: 没有那个文件或目录 只要把 /usr/bin/zsh 改成 /bin/bash 就可以了1sudo vim /etc/passwd 第一句改成1root:x:0:0:root:/root:/bin/bash 或者直接运行1sudo chsh -s /bin/bashrc","categories":[{"name":"Tips","slug":"Tips","permalink":"http://xichen.pub/categories/Tips/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/tags/Linux/"},{"name":"Tips","slug":"Tips","permalink":"http://xichen.pub/tags/Tips/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://xichen.pub/tags/Ubuntu/"}]},{"title":"Golang程序配置方案小结","slug":"2017-08-28-Golang-setting","date":"2017-08-27T20:19:00.000Z","updated":"2019-04-01T15:18:44.141Z","comments":true,"path":"2017/08/28/2017-08-28-Golang-setting/","link":"","permalink":"http://xichen.pub/2017/08/28/2017-08-28-Golang-setting/","excerpt":"","text":"背景无论使用任何编程语言开发应用，都离不开配置数据。配置数据提供的形式有多样，不外乎命令行选项(options)、参数（parameters)，环境 变量（env vars)以及配置文件等。Golang也不例外。Golang内置flag标准库，可以用来支持部分命令行选项和参数的解析；Golang通过os包提 供的方法可以获取当前环境变量；但Golang没有规定标准配置文件格式(虽说内置支持xml、json)，多通过第三方 包来解决配置文件读取的问题。Golang配置相关的第三方包邮很多，作者在本文中给出的配置方案中就包含了主流的第三方配置数据操作包。 一个良好的应用配置层次应该是这样的： 程序内内置配置项的初始默认值 配置文件中的配置项值可以覆盖(override)程序内配置项的默认值。 命令行选项和参数值具有最高优先级，可以override前两层的配置项值。 下面循序渐进探讨golang程序配置方案。 解析命令行选项和参数这一节关注golang程序如何访问命令行选项和参数。 golang对访问到命令行参数提供了内建的支持：1234567891011121314151617181920212223//cmdlineargs.gopackage mainimport ( // \"fmt\" \"os\" \"path/filepath\")func main() &#123; println(\"I am \", os.Args[0]) baseName := filepath.Base(os.Args[0]) println(\"The base name is \", baseName) // The length of array a can be discovered using the built-in function len println(\"Argument # is \", len(os.Args)) // the first command line arguments if len(os.Args) &gt; 1 &#123; println(\"The first command line argument: \", os.Args[1]) &#125;&#125; 执行结果如下：123456$go build cmdlineargs.go$cmdlineargs test oneI am cmdlineargsThe base name is cmdlineargsArgument # is 3The first command line argument: test 对于命令行结构复杂一些的程序，我们最起码要用到golang标准库内置的flag包：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//cmdlineflag.gopackage mainimport ( \"flag\" \"fmt\" \"os\" \"strconv\")var ( // main operation modes write = flag.Bool(\"w\", false, \"write result back instead of stdout\\n\\t\\tDefault: No write back\") // layout control tabWidth = flag.Int(\"tabwidth\", 8, \"tab width\\n\\t\\tDefault: Standard\") // debugging cpuprofile = flag.String(\"cpuprofile\", \"\", \"write cpu profile to this file\\n\\t\\tDefault: no default\"))func usage() &#123; // Fprintf allows us to print to a specifed file handle or stream fmt.Fprintf(os.Stderr, \"\\nUsage: %s [flags] file [path ...]\\n\\n\", \"CommandLineFlag\") // os.Args[0] flag.PrintDefaults() os.Exit(0)&#125;func main() &#123; fmt.Printf(\"Before parsing the flags\\n\") fmt.Printf(\"T: %d\\nW: %s\\nC: '%s'\\n\", *tabWidth, strconv.FormatBool(*write), *cpuprofile) flag.Usage = usage flag.Parse() // There is also a mandatory non-flag arguments if len(flag.Args()) &lt; 1 &#123; usage() &#125; fmt.Printf(\"Testing the flag package\\n\") fmt.Printf(\"T: %d\\nW: %s\\nC: '%s'\\n\", *tabWidth, strconv.FormatBool(*write), *cpuprofile) for index, element := range flag.Args() &#123; fmt.Printf(\"I: %d C: '%s'\\n\", index, element) &#125;&#125; 这个例子中： 说明了三种类型标志的用法：Int、String和Bool。 说明了每个标志的定义都由类型、命令行选项文本、默认值以及含义解释组成。 最后说明了如何处理标志选项(flag option)以及非option参数。 不带参数运行：1234567891011121314$cmdlineflagBefore parsing the flagsT: 8W: falseC: ''Usage: CommandLineFlag [flags] file [path ...] -cpuprofile=\"\": write cpu profile to this file Default: no default -tabwidth=8: tab width Default: Standard -w=false: write result back instead of stdout Default: No write back 带命令行标志以及参数运行(一个没有flag，一个有两个flag)：12345678910111213141516171819202122$cmdlineflag aa bbBefore parsing the flagsT: 8W: falseC: ''Testing the flag packageT: 8W: falseC: ''I: 0 C: 'aa'I: 1 C: 'bb'$cmdlineflag -tabwidth=2 -w aaBefore parsing the flagsT: 8W: falseC: ''Testing the flag packageT: 2W: trueC: ''I: 0 C: 'aa' 从例子可以看出，简单情形下，你无需编写自己的命令行parser或使用第三方包，使用go内建的flag包即可以很好的完成工作。但是golang的 flag包与命令行Parser的事实标准：Posix getopt（C/C++/Perl/Shell脚本都可用）相比，还有较大差距，主要体现在： 无法支持区分long option和short option，比如：-h和–help。 不支持short options合并，比如：ls -l -h &lt;=&gt; ls -hl 命令行标志的位置不能任意放置，比如无法放在non-flag parameter的后面。 不过毕竟flag是golang内置标准库包，你无须付出任何cost，就能使用它的功能。另外支持bool型的flag也是其一大亮点。 TOML，Go配置文件的事实标准（这个可能不能得到认同）命令行虽然是一种可选的配置方案，但更多的时候，我们使用配置文件来存储静态的配置数据。就像Java配xml，ruby配yaml，windows配 ini，Go也有自己的搭配组合，那就是TOML（Tom’s Obvious, Minimal Language）。 初看toml语法有些类似windows ini，但细致研究你会发现它远比ini强大的多，下面是一个toml配置文件例子：123456789101112131415161718192021222324252627282930313233# This is a TOML document. Boom.title = \"TOML Example\"[owner]name = \"Lance Uppercut\"dob = 1979-05-27T07:32:00-08:00 # First class dates? Why not?[database]server = \"192.168.1.1\"ports = [ 8001, 8001, 8002 ]connection_max = 5000enabled = true[servers] # You can indent as you please. Tabs or spaces. TOML don't care. [servers.alpha] ip = \"10.0.0.1\" dc = \"eqdc10\" [servers.beta] ip = \"10.0.0.2\" dc = \"eqdc10\"[clients]data = [ [\"gamma\", \"delta\"], [1, 2] ]# Line breaks are OK when inside arrayshosts = [ \"alpha\", \"omega\"] 看起来很强大，也很复杂，但解析起来却很简单。以下面这个toml 文件为例：12345Age = 25Cats = [ \"Cauchy\", \"Plato\" ]Pi = 3.14Perfection = [ 6, 28, 496, 8128 ]DOB = 1987-07-05T05:45:00Z 和所有其他配置文件parser类似，这个配置文件中的数据可以被直接解析成一个golang struct：1234567type Config struct &#123; Age int Cats []string Pi float64 Perfection []int DOB time.Time // requires `import time`&#125; 其解析的步骤也很简单：1234var conf Configif _, err := toml.Decode(tomlData, &amp;conf); err != nil &#123; // handle error&#125; 是不是简单的不能简单了！ 不过toml也有其不足之处。想想如果你需要使用命令行选项的参数值来覆盖这些配置文件中的选项，你应该怎么做？事实上，我们常常会碰到类似下面这种三层配置结构的情况： 程序内内置配置项的初始默认值 配置文件中的配置项值可以覆盖(override)程序内配置项的默认值。 命令行选项和参数值具有最高优先级，可以override前两层的配置项值。 在go中，toml映射的结果体字段没有初始值。而且go内建flag包也没有将命令行参数值解析为一个go结构体，而是零散的变量。这些可以通过第三方工具来解决，但如果你不想用第三方工具，你也可以像下面这样自己解决，虽然难看一些。1234567891011121314151617181920212223242526func ConfigGet() *Config &#123; var err error var cf *Config = NewConfig() // set default values defined in the program cf.ConfigFromFlag() //log.Printf(\"P: %d, B: '%s', F: '%s'\\n\", cf.MaxProcs, cf.Webapp.Path) // Load config file, from flag or env (if specified) _, err = cf.ConfigFromFile(*configFile, os.Getenv(\"APPCONFIG\")) if err != nil &#123; log.Fatal(err) &#125; //log.Printf(\"P: %d, B: '%s', F: '%s'\\n\", cf.MaxProcs, cf.Webapp.Path) // Override values from command line flags cf.ConfigToFlag() flag.Usage = usage flag.Parse() cf.ConfigFromFlag() //log.Printf(\"P: %d, B: '%s', F: '%s'\\n\", cf.MaxProcs, cf.Webapp.Path) cf.ConfigApply() return cf&#125; 就像上面代码中那样，你需要： 用命令行标志默认值设置配置(cf)默认值。 接下来加载配置文件 用配置值(cf)覆盖命令行标志变量值 解析命令行参数 用命令行标志变量值覆盖配置(cf)值。 少一步你都无法实现三层配置能力。 超越TOML本节将关注如何克服TOML的各种局限。 为了达成这个目标，很多人会说：使用viper，不过在介绍viper这一重量级选手 之前，我要为大家介绍另外一位不那么知名的选手：multiconfig。 有些人总是认为大的就是好的，但我相信适合的还是更好的。因为： viper太重量级，使用viper时你需要pull另外20个viper依赖的第三方包 事实上，viper单独使用还不足以满足需求，要想得到viper全部功能，你还需要另外一个包配合，而后者又依赖13个外部包 与viper相比，multiconfig使用起来更简单。 好了，我们再来回顾一下我们现在面临的问题： 在程序里定义默认配置，这样我们就无需再在toml中定义它们了。 用toml配置文件中的数据override默认配置 用命令行或环境变量的值override从toml中读取的配置。 下面是一个说明如何使用multiconfig的例子：123456789101112131415161718func main() &#123; m := multiconfig.NewWithPath(\"config.toml\") // supports TOML and JSON // Get an empty struct for your configuration serverConf := new(Server) // Populated the serverConf struct m.MustLoad(serverConf) // Check for error fmt.Println(\"After Loading: \") fmt.Printf(\"%+v\\n\", serverConf) if serverConf.Enabled &#123; fmt.Println(\"Enabled field is set to true\") &#125; else &#123; fmt.Println(\"Enabled field is set to false\") &#125;&#125; 这个例子中的toml文件如下：12345678910Name = \"koding\"Enabled = falsePort = 6066Users = [\"ankara\", \"istanbul\"][Postgres]Enabled = truePort = 5432Hosts = [\"192.168.2.1\", \"192.168.2.2\", \"192.168.2.3\"]AvailabilityRatio = 8.23 toml映射后的go结构如下：12345678910111213141516171819type ( // Server holds supported types by the multiconfig package Server struct &#123; Name string Port int `default:\"6060\"` Enabled bool Users []string Postgres Postgres &#125; // Postgres is here for embedded struct feature Postgres struct &#123; Enabled bool Port int Hosts []string DBName string AvailabilityRatio float64 &#125;) multiconfig的使用是不是很简单，后续与viper对比后，你会同意我的观点的。 multiconfig支持默认值，也支持显式的字段赋值需求。支持toml、json、结构体标签（struct tags)以及环境变量。你可以自定义配置源（例如一个远程服务器），如果你想这么做的话。可高度扩展（通过loader接口），你可以创建你自己的loader。 下面是例子的运行结果，首先是usage help：123456789101112131415161718192021222324252627$cmdlinemulticonfig -helpUsage of cmdlinemulticonfig: -enabled=false: Change value of Enabled. -name=koding: Change value of Name. -port=6066: Change value of Port. -postgres-availabilityratio=8.23: Change value of Postgres-AvailabilityRatio. -postgres-dbname=: Change value of Postgres-DBName. -postgres-enabled=true: Change value of Postgres-Enabled. -postgres-hosts=[192.168.2.1 192.168.2.2 192.168.2.3]: Change value of Postgres-Hosts. -postgres-port=5432: Change value of Postgres-Port. -users=[ankara istanbul]: Change value of Users.Generated environment variables: SERVER_NAME SERVER_PORT SERVER_ENABLED SERVER_USERS SERVER_POSTGRES_ENABLED SERVER_POSTGRES_PORT SERVER_POSTGRES_HOSTS SERVER_POSTGRES_DBNAME SERVER_POSTGRES_AVAILABILITYRATIO$cmdlinemulticonfigAfter Loading:&amp;&#123;Name:koding Port:6066 Enabled:false Users:[ankara istanbul] Postgres:&#123;Enabled:true Port:5432 Hosts:[192.168.2.1 192.168.2.2 192.168.2.3] DBName: AvailabilityRatio:8.23&#125;&#125;Enabled field is set to false 检查一下输出结果吧，是不是每项都符合我们之前的预期呢！ Viper我们的重量级选手viper该出场了！ 毫无疑问，viper非常强大。但如果你想用命令行参数覆盖预定义的配置项值，viper自己还不足以。要想让viper爆发，你需要另外一个包配合，它就是cobra。 不同于注重简化配置处理的multiconfig，viper让你拥有全面控制力。不幸的是，在得到这种控制力之前，你需要做一些体力活。 我们再来回顾一下使用multiconfig处理配置的代码：123456789101112131415161718func main() &#123; m := multiconfig.NewWithPath(\"config.toml\") // supports TOML and JSON // Get an empty struct for your configuration serverConf := new(Server) // Populated the serverConf struct m.MustLoad(serverConf) // Check for error fmt.Println(\"After Loading: \") fmt.Printf(\"%+v\\n\", serverConf) if serverConf.Enabled &#123; fmt.Println(\"Enabled field is set to true\") &#125; else &#123; fmt.Println(\"Enabled field is set to false\") &#125;&#125; 这就是使用multiconfig时你要做的所有事情。现在我们来看看使用viper和cobra如何来完成同样的事情：123456789101112131415161718192021222324252627282930313233343536373839404142func init() &#123; mainCmd.AddCommand(versionCmd) viper.SetEnvPrefix(\"DISPATCH\") viper.AutomaticEnv() /* When AutomaticEnv called, Viper will check for an environment variable any time a viper.Get request is made. It will apply the following rules. It will check for a environment variable with a name matching the key uppercased and prefixed with the EnvPrefix if set. */ flags := mainCmd.Flags() flags.Bool(\"debug\", false, \"Turn on debugging.\") flags.String(\"addr\", \"localhost:5002\", \"Address of the service\") flags.String(\"smtp-addr\", \"localhost:25\", \"Address of the SMTP server\") flags.String(\"smtp-user\", \"\", \"User to authenticate with the SMTP server\") flags.String(\"smtp-password\", \"\", \"Password to authenticate with the SMTP server\") flags.String(\"email-from\", \"noreply@example.com\", \"The from email address.\") viper.BindPFlag(\"debug\", flags.Lookup(\"debug\")) viper.BindPFlag(\"addr\", flags.Lookup(\"addr\")) viper.BindPFlag(\"smtp_addr\", flags.Lookup(\"smtp-addr\")) viper.BindPFlag(\"smtp_user\", flags.Lookup(\"smtp-user\")) viper.BindPFlag(\"smtp_password\", flags.Lookup(\"smtp-password\")) viper.BindPFlag(\"email_from\", flags.Lookup(\"email-from\")) // Viper supports reading from yaml, toml and/or json files. Viper can // search multiple paths. Paths will be searched in the order they are // provided. Searches stopped once Config File found. viper.SetConfigName(\"CommandLineCV\") // name of config file (without extension) viper.AddConfigPath(\"/tmp\") // path to look for the config file in viper.AddConfigPath(\".\") // more path to look for the config files err := viper.ReadInConfig() if err != nil &#123; println(\"No config file found. Using built-in defaults.\") &#125;&#125; 可以看出，你需要使用BindPFlag来让viper和cobra结合一起工作。但这还不算太糟。 cobra的真正威力在于提供了subcommand能力。同时cobra还提供了与posix 全面兼容的命令行标志解析能力，包括长短标志、内嵌命令、为command定义你自己的help或usage等。 下面是定义子命令的例子代码：1234567891011121314151617181920// The main command describes the service and defaults to printing the// help message.var mainCmd = &amp;cobra.Command&#123; Use: \"dispatch\", Short: \"Event dispatch service.\", Long: `HTTP service that consumes events and dispatches them to subscribers.`, Run: func(cmd *cobra.Command, args []string) &#123; serve() &#125;,&#125;// The version command prints this service.var versionCmd = &amp;cobra.Command&#123; Use: \"version\", Short: \"Print the version.\", Long: \"The version of the dispatch service.\", Run: func(cmd *cobra.Command, args []string) &#123; fmt.Println(version) &#125;,&#125; 有了上面subcommand的定义，我们就可以得到如下的help信息了：123456789101112131415161718Usage: dispatch [flags] dispatch [command]Available Commands: version Print the version. help Help about any commandFlags: –addr=\"localhost:5002\": Address of the service –debug=false: Turn on debugging. –email-from=\"noreply@example.com\": The from email address. -h, –help=false: help for dispatch –smtp-addr=\"localhost:25\": Address of the SMTP server –smtp-password=\"\": Password to authenticate with the SMTP server –smtp-user=\"\": User to authenticate with the SMTP serverUse \"dispatch help [command]\" for more information about a command.","categories":[{"name":"GO","slug":"GO","permalink":"http://xichen.pub/categories/GO/"}],"tags":[{"name":"GO","slug":"GO","permalink":"http://xichen.pub/tags/GO/"}]},{"title":"Golang并发","slug":"2017-08-28-Golang-concurency","date":"2017-08-27T20:19:00.000Z","updated":"2019-04-01T15:18:44.139Z","comments":true,"path":"2017/08/28/2017-08-28-Golang-concurency/","link":"","permalink":"http://xichen.pub/2017/08/28/2017-08-28-Golang-concurency/","excerpt":"","text":"运行期线程Go允许使用go语句开启一个新的运行期线程，即 goroutine，以一个不同的、新创建的goroutine来执行一个函数。同一个程序中的所有goroutine共享同一个地址空间。 Goroutine非常轻量，除了为之分配的栈空间，其所占用的内存空间微乎其微。并且其栈空间在开始时非常小，之后随着堆存储空间的按需分配或释放而变化。内部实现上，goroutine会在多个操作系统线程上多路复用。如果一个goroutine阻塞了一个操作系统线程，例如：等待输入，这个线程上的其他goroutine就会迁移到其他线程，这样能继续运行。开发者并不需要关心/担心这些细节。 下面所示程序会输出“Hello from main goroutine”。也可能会输出“Hello from another goroutine”，具体依赖于两个goroutine哪个先结束。12345678func main() &#123; go fmt.Println(\"Hello from another goroutine\") fmt.Println(\"Hello from main goroutine\") // 至此，程序运行结束， // 所有活跃的goroutine被杀死&#125;goroutine1.go 接下来的这个程序，多数情况下，会输出“Hello from main goroutine”和“Hello from another goroutine”，输出的顺序不确定。但还有另一个可能性是：第二个goroutine运行得极其慢，在程序结束之前都没来得及输出相应的消息。 1234567func main() &#123; go fmt.Println(\"Hello from another goroutine\") fmt.Println(\"Hello from main goroutine\") time.Sleep(time.Second) // 等待1秒，等另一个goroutine结束&#125;//goroutine2.go 下面则是一个相对更加实际的示例，其中定义了一个函数使用并发来推迟触发一个事件。123456789// 函数Publish在给定时间过期后打印text字符串到标准输出 // 该函数并不会阻塞而是立即返回func Publish(text string, delay time.Duration) &#123; go func() &#123; time.Sleep(delay) fmt.Println(\"BREAKING NEWS:\", text) &#125;() // 注意这里的括号。必须调用匿名函数&#125;//publish1.go 你可能会这样使用Publish函数：12345678910func main() &#123; Publish(\"A goroutine starts a new thread of execution.\", 5*time.Second) fmt.Println(\"Let’s hope the news will published before I leave.\") // 等待发布新闻 time.Sleep(10 * time.Second) fmt.Println(\"Ten seconds later: I’m leaving now.\")&#125;//publish1.go 这个程序，绝大多数情况下，会输出以下三行，顺序固定，每行输出之间相隔5秒。1234$ go run publish1.goLet’s hope the news will published before I leave.BREAKING NEWS: A goroutine starts a new thread of execution.Ten seconds later: I’m leaving now. 一般来说，通过睡眠的方式来编排线程之间相互等待是不太可能的。下一章节会介绍Go语言中的一种同步机制 - 管道，并演示如何使用管道让一个goroutine等待另一个goroutine。 管道（channel）管道是Go语言的一个构件，提供一种机制用于两个goroutine之间通过传递一个指定类型的值来同步运行和通讯。操作符&lt;-用于指定管道的方向，发送或接收。如果未指定方向，则为双向管道。123chan Sushi // 可用来发送和接收Sushi类型的值chan&lt;- float64 // 仅可用来发送float64类型的值&lt;-chan int // 仅可用来接收int类型的值 管道是引用类型，基于make函数来分配。12ic := make(chan int) // 不带缓冲的int类型管道wc := make(chan *Work, 10) // 带缓冲的Work类型指针管道 如果通过管道发送一个值，则将&lt;-作为二元操作符使用。通过管道接收一个值，则将其作为一元操作符使用：12ic &lt;- 3 // 往管道发送3work := &lt;-wc // 从管道接收一个指向Work类型值的指针 如果管道不带缓冲，发送方会阻塞直到接收方从管道中接收了值。如果管道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。 关闭管道（Close） close 函数标志着不会再往某个管道发送值。在调用close之后，并且在之前发送的值都被接收后，接收操作会返回一个零值，不会阻塞。一个多返回值的接收操作会额外返回一个布尔值用来指示返回的值是否发送操作传递的。123456789ch := make(chan string)go func() &#123; ch &lt;- \"Hello!\" close(ch)&#125;()fmt.Println(&lt;-ch) // 输出字符串\"Hello!\"fmt.Println(&lt;-ch) // 输出零值 - 空字符串\"\"，不会阻塞fmt.Println(&lt;-ch) // 再次打印输出空字符串\"\"v, ok := &lt;-ch // 变量v的值为空字符串\"\"，变量ok的值为false 一个带有range子句的for语句会依次读取发往管道的值，直到该管道关闭：123456789101112131415161718func main() &#123; // 译注：要想运行该示例，需要先定义类型Sushi，如type Sushi string var ch &lt;-chan Sushi = Producer() for s := range ch &#123; fmt.Println(\"Consumed\", s) &#125;&#125;func Producer() &lt;-chan Sushi &#123; ch := make(chan Sushi) go func()&#123; ch &lt;- Sushi(\"海老握り\") // Ebi nigiri ch &lt;- Sushi(\"鮪とろ握り\") // Toro nigiri close(ch) &#125;() return ch&#125;//sushi.go 同步下一个示例中，我们让Publish函数返回一个管道 - 用于在发布text变量值时广播一条消息：123456789101112// 在给定时间过期时，Publish函数会打印text变量值到标准输出// 在text变量值发布后，该函数会关闭管道waitfunc Publish(text string, delay time.Duration) (wait &lt;-chan struct&#123;&#125;) &#123; ch := make(chan struct&#123;&#125;) go func() &#123; time.Sleep(delay) fmt.Println(\"BREAKING NEWS:\", text) close(ch) // 广播 - 一个关闭的管道都会发送一个零值 &#125;() return ch&#125;//publish2.go 注意：我们使用了一个空结构体的管道：struct{}。这明确地指明该管道仅用于发信号，而不是传递数据。 我们可能会这样使用这个函数：1234567func main() &#123; wait := Publish(\"Channels let goroutines communicate.\", 5*time.Second) fmt.Println(\"Waiting for the news...\") &lt;-wait fmt.Println(\"The news is out, time to leave.\")&#125;//publish2.go 这个程序会按指定的顺序输出以下三行内容。最后一行在新闻（news）一出就会立即输出。1234$ go run publish2.goWaiting for the news...BREAKING NEWS: Channels let goroutines communicate.The news is out, time to leave. 死锁现在我们在Publish函数中引入一个bug：12345678910func Publish(text string, delay time.Duration) (wait &lt;-chan struct&#123;&#125;) &#123; ch := make(chan struct&#123;&#125;) go func() &#123; time.Sleep(delay) fmt.Println(\"BREAKING NEWS:\", text) // 译注：注意这里将close函数调用注释掉了 //close(ch) &#125;() return ch&#125; 主程序还是像之前一样开始运行：输出第一行，然后等待5秒，这时Publish函数开启的goroutine会输出突发新闻（breaking news），然后退出，留下主goroutine独自等待。1234567func main() &#123; wait := Publish(\"Channels let goroutines communicate.\", 5*time.Second) fmt.Println(\"Waiting for the news...\") // 译注：注意下面这一句 &lt;-wait fmt.Println(\"The news is out, time to leave.\")&#125; 此刻之后，程序无法再继续往下执行。众所周知，这种情形即为死锁。 死锁是线程之间相互等待，其中任何一个都无法向前运行的情形。 Go语言对于运行时的死锁检测具备良好的支持。当没有任何goroutine能够往前执行的情形发生时，Go程序通常会提供详细的错误信息。以下就是我们的问题程序的输出：123456789101112131415Waiting for the news...BREAKING NEWS: Channels let goroutines communicate.fatal error: all goroutines are asleep - deadlock!goroutine 1 [chan receive]:main.main() .../goroutineStop.go:11 +0xf6goroutine 2 [syscall]:created by runtime.main .../go/src/pkg/runtime/proc.c:225goroutine 4 [timer goroutine (idle)]:created by addtimer .../go/src/pkg/runtime/ztime_linux_amd64.c:73 大多数情况下找出Go程序中造成死锁的原因都比较容易，那么剩下的就是如何解决这个bug了。 数据竞争（data race）死锁也许听起来令人挺忧伤的，但伴随并发编程真正灾难性的错误其实是数据竞争，相当常见，也可能非常难于调试。 当两个线程并发地访问同一个变量，并且其中至少一个访问是写操作时，数据竞争就发生了。 下面的这个函数就有数据竞争问题，其行为是未定义的。例如，可能输出数值1。代码之后是一个可能性解释，试图搞清楚这一切是如何发生得。1234567891011121314func race() &#123; wait := make(chan struct&#123;&#125;) n := 0 go func() &#123; // 译注：注意下面这一行 n++ // 一次访问: 读, 递增, 写 close(wait) &#125;() // 译注：注意下面这一行 n++ // 另一次冲突的访问 &lt;-wait fmt.Println(n) // 输出：未指定&#125;//datarace.go 代码中的两个goroutine（假设命名为g1和g2）参与了一次竞争，我们无法获知操作会以何种顺序发生。以下是诸多可能中的一种：1234567g1 从 n 中获取值0g2 从 n 中获取值0g1 将值从0增大到1g1 将1写到 ng2 将值从0增大到1g2 将1写到 n程序输出 n 的值，当前为1 “数据竞争（data race）”这名字有点误导的嫌疑。不仅操作的顺序是未定义的，其实根本没有任何保证（no guarantees whatsoever）。编译器和硬件为了得到更好的性能，经常都会对代码进行上下内外的顺序变换。如果你看到一个线程处于中间行为状态时，那么当时的场景可能就像下图所示的一样： 避免数据竞争的唯一方式是线程间同步访问所有的共享可变数据。有几种方式能够实现这一目标。Go语言中，通常是使用管道或者锁。（sync和sync/atomic包中还有更低层次的机制可供使用，但本文中不做讨论）。 Go语言中，处理并发数据访问的推荐方式是使用管道从一个goroutine中往下一个goroutine传递实际的数据。有格言说得好：“不要通过共享内存来通讯，而是通过通讯来共享内存”。123456789101112func sharingIsCaring() &#123; ch := make(chan int) go func() &#123; n := 0 // 仅为一个goroutine可见的局部变量. n++ ch &lt;- n // 数据从一个goroutine离开... &#125;() n := &lt;-ch // ...然后安全到达另一个goroutine. n++ fmt.Println(n) // 输出: 2&#125;//datarace.go 以上代码中的管道肩负双重责任 - 从一个goroutine将数据传递到另一个goroutine，并且起到同步的作用：发送方goroutine会等待另一个goroutine接收数据，接收方goroutine也会等待另一个goroutine发送数据。 Go语言内存模型 - 要保证一个goroutine中对一个变量的读操作得到的值正好是另一个goroutine中对同一个变量写操作产生的值，条件相当复杂，但goroutine之间只要通过管道来共享所有可变数据，那么就能远离数据竞争了。 互斥锁有时，通过显式加锁，而不是使用管道，来同步数据访问，可能更加便捷。Go语言标准库为这一目的提供了一个互斥锁 - sync.Mutex。 要想这类加锁起效的话，关键之处在于：所有对共享数据的访问，不管读写，仅当goroutine持有锁才能操作。一个goroutine出错就足以破坏掉一个程序，引入数据竞争。 因此，应该设计一个自定义数据结构，具备明确的API，确保所有的同步都在数据结构内部完成。下例中，我们构建了一个安全、易于使用的并发数据结构，AtomicInt，用于存储一个整型值。任意数量的goroutine都能通过Add和Value方法安全地访问这个数值。12345678910111213141516171819202122232425262728293031323334// AtomicInt是一个并发数据结构，持有一个整数值// 该数据结构的零值为0type AtomicInt struct &#123; mu sync.Mutex // 锁，一次仅能被一个goroutine持有。 n int&#125;// Add方法作为一个原子操作将n加到AtomicIntfunc (a *AtomicInt) Add(n int) &#123; a.mu.Lock() // 等待锁释放，然后持有它 a.n += n a.mu.Unlock() // 释放锁&#125;// Value方法返回a的值func (a *AtomicInt) Value() int &#123; a.mu.Lock() n := a.n a.mu.Unlock() return n&#125;func lockItUp() &#123; wait := make(chan struct&#123;&#125;) var n AtomicInt go func() &#123; n.Add(1) // 一个访问 close(wait) &#125;() n.Add(1) // 另一个并发访问 &lt;-wait fmt.Println(n.Value()) // 输出: 2&#125;//datarace.go 检测数据竞争竞争有时非常难于检测。下例中的这个函数有一个数据竞争问题，执行这个程序时会输出55555。尝试一下，也许你会得到一个不同的结果。（sync.WaitGroup是Go语言标准库的一部分；用于等待一组goroutine结束运行。）123456789101112131415func race() &#123; var wg sync.WaitGroup wg.Add(5) // 译注：注意下面这行代码中的i++ for i := 0; i &lt; 5; i++ &#123; go func() &#123; // 注意下一行代码会输出什么？为什么？ fmt.Print(i) // 6个goroutine共享变量i wg.Done() &#125;() &#125; wg.Wait() // 等待所有（5个）goroutine运行结束 fmt.Println()&#125;//raceClosure.go 对于输出55555，一个貌似合理的解释是：执行i++的goroutine在其他goroutine执行打印语句之前就完成了5次i++操作。实际上变量i更新后的值为其他goroutine所见纯属巧合。 一个简单的解决方案是：使用一个局部变量，然后当开启新的goroutine时，将数值作为参数传递：12345678910111213func correct() &#123; var wg sync.WaitGroup wg.Add(5) for i := 0; i &lt; 5; i++ &#123; go func(n int) &#123; // 使用局部变量 fmt.Print(n) wg.Done() &#125;(i) &#125; wg.Wait() fmt.Println()&#125;//raceClosure.go 这次代码就对了，程序会输出期望的结果，如：24031。注意：goroutine之间的运行顺序是不确定的。 仍旧使用闭包，但能够避免数据竞争也是可能的，必须小心翼翼地让每个goroutine使用一个独有的变量。1234567891011121314func alsoCorrect() &#123; var wg sync.WaitGroup wg.Add(5) for i := 0; i &lt; 5; i++ &#123; n := i // 为每个闭包创建一个独有的变量 go func() &#123; fmt.Print(n) wg.Done() &#125;() &#125; wg.Wait() fmt.Println()&#125;//raceClosure.go 数据竞争自动检测一般来说，不太可能能够自动检测发现所有可能的数据竞争情况，但Go（从版本1.1开始）有一个强大的数据竞争检测器。 这个工具用起来也很简单：只要在使用go命令时加上-race标记即可。开启检测器运行上面的程序会给出清晰且信息量大的输出：1234567891011121314151617181920212223242526272829303132$ go run -race raceClosure.goRace:==================WARNING: DATA RACERead by goroutine 2: main.func·001() ../raceClosure.go:22 +0x65Previous write by goroutine 0: main.race() ../raceClosure.go:20 +0x19b main.main() ../raceClosure.go:10 +0x29 runtime.main() ../go/src/pkg/runtime/proc.c:248 +0x91Goroutine 2 (running) created at: main.race() ../raceClosure.go:24 +0x18b main.main() ../raceClosure.go:10 +0x29 runtime.main() ../go/src/pkg/runtime/proc.c:248 +0x91==================55555Correct:01234Also correct:01324Found 1 data race(s)exit status 66 该工具发现一处数据竞争，包含：一个goroutine在第20行对一个变量进行写操作，跟着另一个goroutine在第22行对同一个变量进行了未同步的读操作。 注意：竞争检测器只能发现在运行期确实发生的数据竞争（译注：我也不太理解这话，请指导） Select语句select语句是Go语言并发工具集中的终极工具。select用于从一组可能的通讯中选择一个进一步处理。如果任意一个通讯都可以进一步处理，则从中随机选择一个，执行对应的语句。否则，如果又没有默认分支（default case），select语句则会阻塞，直到其中一个通讯完成。 以下是一个玩具示例，演示select语句如何用于实现一个随机数生成器：1234567891011121314// RandomBits函数 返回一个管道，用于产生一个比特随机序列func RandomBits() &lt;-chan int &#123; ch := make(chan int) go func() &#123; for &#123; select &#123; case ch &lt;- 0: // 注意：分支没有对应的处理语句 case ch &lt;- 1: &#125; &#125; &#125;() return ch&#125;//randBits.go 下面是相对更加实际一点的例子：如何使用select语句为一个操作设置一个时间限制。代码会输出变量news的值或者超时消息，具体依赖于两个接收语句哪个先执行：123456select &#123;case news := &lt;-NewsAgency: fmt.Println(news)case &lt;-time.After(time.Minute): fmt.Println(\"Time out: no news in one minute.\")&#125; 函数 time.After 是Go语言标准库的一部分；它会在等待指定时间后将当前的时间发送到返回的管道中。 综合所有示例花点时间认真研究一下这个示例。如果你完全理解，也就对Go语言中并发的应用方式有了全面的掌握。 这个程序演示了如何将管道用于被任意数量的goroutine发送和接收数据，也演示了如何将select语句用于从多个通讯中选择一个。12345678910111213141516171819202122232425262728func main() &#123; people := []string&#123;\"Anna\", \"Bob\", \"Cody\", \"Dave\", \"Eva\"&#125; match := make(chan string, 1) // 为一个未匹配的发送操作提供空间 wg := new(sync.WaitGroup) wg.Add(len(people)) for _, name := range people &#123; go Seek(name, match, wg) &#125; wg.Wait() select &#123; case name := &lt;-match: fmt.Printf(\"No one received %s’s message.\\n\", name) default: // 没有待处理的发送操作 &#125;&#125;// 函数Seek 发送一个name到match管道或从match管道接收一个peer，结束时通知wait groupfunc Seek(name string, match chan string, wg *sync.WaitGroup) &#123; select &#123; case peer := &lt;-match: fmt.Printf(\"%s sent a message to %s.\\n\", peer, name) case match &lt;- name: // 等待某个goroutine接收我的消息 &#125; wg.Done()&#125;//matching.go 示例输出：1234$ go run matching.goCody sent a message to Bob.Anna sent a message to Eva.No one received Dave’s message. 并行计算并发的一个应用是将一个大的计算切分成一些工作单元，调度到不同的CPU上同时地计算。 将计算分布到多个CPU上更多是一门艺术，而不是一门科学。以下是一些经验法则： 每个工作单元应该花费大约100微秒到1毫秒的时间用于计算。如果单元粒度太小，切分问题以及调度子问题的管理开销可能就会太大。如果单元粒度太大，整个计算也许不得不等待一个慢的工作项结束。这种缓慢可能因为多种原因而产生，比如：调度、其他进程的中断或者糟糕的内存布局。（注意：工作单元的数目是不依赖于CPU的数目的） 尽可能减小共享的数据量。并发写操作的代价非常大，特别是如果goroutine运行在不同的CPU上。读操作之间的数据共享则通常不会是个问题。 数据访问尽量利用良好的局部性。如果数据能保持在缓存中，数据加载和存储将会快得多得多，这对于写操作也格外地重要。 下面的这个示例展示如何切分一个开销很大的计算并将其分布在所有可用的CPU上进行计算。先看一下有待优化的代码：1234567891011121314151617181920212223type Vector []float64// 函数Convolve 计算 w = u * v，其中 w[k] = Σ u[i]*v[j], i + j = k// 先决条件：len(u) &gt; 0, len(v) &gt; 0func Convolve(u, v Vector) (w Vector) &#123; n := len(u) + len(v) - 1 w = make(Vector, n) for k := 0; k &lt; n; k++ &#123; w[k] = mul(u, v, k) &#125; return&#125;// 函数mul 返回 Σ u[i]*v[j], i + j = k.func mul(u, v Vector, k int) (res float64) &#123; n := min(k+1, len(u)) j := min(k, len(v)-1) for i := k - j; i &lt; n; i, j = i+1, j-1 &#123; res += u[i] * v[j] &#125; return&#125; 思路很简单：确定合适大小的工作单元，然后在不同的goroutine中执行每个工作单元。以下是并发版本的 Convolve：123456789101112131415161718192021222324252627func Convolve(u, v Vector) (w Vector) &#123; n := len(u) + len(v) - 1 w = make(Vector, n) // 将 w 切分成花费 ~100μs-1ms 用于计算的工作单元 size := max(1, 1&lt;&lt;20/n) wg := new(sync.WaitGroup) wg.Add(1 + (n-1)/size) for i := 0; i &lt; n &amp;&amp; i &gt;= 0; i += size &#123; // 整型溢出后 i &lt; 0 j := i + size if j &gt; n || j &lt; 0 &#123; // 整型溢出后 j &lt; 0 j = n &#125; // 这些goroutine共享内存，但是只读 go func(i, j int) &#123; for k := i; k &lt; j; k++ &#123; w[k] = mul(u, v, k) &#125; wg.Done() &#125;(i, j) &#125; wg.Wait() return&#125;//convolution.go 工作单元定义之后，通常情况下最好将调度工作交给运行时和操作系统。然而，对于Go 1.* 你也许需要告诉运行时希望多少个goroutine来同时地运行代码。1234func init() &#123; numcpu := runtime.NumCPU() runtime.GOMAXPROCS(numcpu) // 尝试使用所有可用的CPU&#125;","categories":[{"name":"GO","slug":"GO","permalink":"http://xichen.pub/categories/GO/"}],"tags":[{"name":"GO","slug":"GO","permalink":"http://xichen.pub/tags/GO/"}]},{"title":"GO的安装和配置","slug":"2017-08-21-Go的安装和配置","date":"2017-08-21T01:29:00.000Z","updated":"2019-04-01T15:18:44.137Z","comments":true,"path":"2017/08/21/2017-08-21-Go的安装和配置/","link":"","permalink":"http://xichen.pub/2017/08/21/2017-08-21-Go的安装和配置/","excerpt":"","text":"0.Install Go 不要用apt-get install golang！这个目前只有1.6版，最新版已经到1.8+ 在linux 系统下，如ubuntu debian ，安装golang 最方便的方式是用apt-get install。 但不推荐这种方式安装，建议使用源码安装，如果你不小心用apt-get 等方式安装了，就先把它卸载：1sudo apt-get purge golang-go 然后用源码安装，如果想升级也可以直接覆盖安装位置的原文件，golang 还算很干净。 套路:12345678curl -O https://storage.googleapis.com/golang/go1.7.3.linux-amd64.tar.gztar -C /usr/local -zxvf go1.7.3.linux-amd64.tar.gzmkdir -p ~/go/srcecho \"export GOROOT=/usr/local/go\"echo \"export GOPATH=$HOME/go\" &gt;&gt; ~/.bashrcecho \"export PATH=$PATH:$GOPATH/bin:$GOROOT/bin\" &gt;&gt; ~/.bashrcsource ~/.bashrcgo version GOROOT:根目录，设置了这个才指定解释器，也是标准库所在 GOPATH:工作目录，放你自己的代码．该目录下要有一定的结构，因为外来库要用go get安装在该目录下 PATH:系统环境变量，不破坏原来的环境变量的方法为PATH=$PATH:/usr/local/go表示在原来环境变量的基础上添加/usr/local/go Tips:命令行下输入export可查看当前所有变量，包括PATH,GOROOT等等，方便确认是否设置成功 1.GOROOTGOROOT就是go的安装路径 在~/.bash_profile中添加下面语句: 1export GOROOT=/usr/local/go 当然, 要执行go命令和go工具, 就要配置go的可执行文件的路径,操作如下: 在~/.bash_profile中配置如下:1export $PATH:$GOROOT/bin 如果是windows需要使用;符号分割两个路径, mac和类unix都是用:符号分割 2.GOPATHgo install/go get和 go的工具等会用到GOPATH环境变量. GOPATH是作为编译后二进制的存放目的地和import包时的搜索路径 (其实也是你的工作目录, 你可以在src下创建你自己的go源文件, 然后开始工作)。 GOPATH之下主要包含三个目录: bin、pkg、src bin目录主要存放可执行文件; pkg目录存放编译好的库文件, 主要是*.a文件; src目录下主要存放go的源文件 不要把GOPATH设置成go的安装路径, 可以自己在用户目录下面创建一个目录, 如gopath 操作如下:12cd ~mkdir gopath 在~/.bash_profile中添加如下语句:1GOPATH=/Users/username/gopath GOPATH可以是一个目录列表, go get下载的第三方库, 一般都会下载到列表的第一个目录里面需要把GOPATH中的可执行目录也配置到环境变量中, 否则你自行下载的第三方go工具就无法使用了, 操作如下:在~/bash_profile中配置,1export $PATH:$GOPATH/bin 创建一个go项目, 并且编译运行:123mkdir goprojectcd goprojecttouch hello.go 在hello.go中输入:12345package mainimport \"fmt\"func main() &#123; fmt.Println(\"Hello, GO !\")&#125; 在项目根目录下执行go build命令来构建你的项目, 构建后会生成hello文件运行生成的文件./hello, terminal中输出:Hello, GO !当然你也可以直接运行命令go run hello.go来执行程序. 附：源：https://dl.gocn.io/查看其他GO相关的环境变量：go env","categories":[{"name":"GO","slug":"GO","permalink":"http://xichen.pub/categories/GO/"}],"tags":[{"name":"GO","slug":"GO","permalink":"http://xichen.pub/tags/GO/"},{"name":"Install","slug":"Install","permalink":"http://xichen.pub/tags/Install/"},{"name":"Settings","slug":"Settings","permalink":"http://xichen.pub/tags/Settings/"}]},{"title":"代理","slug":"2017-08-21-代理","date":"2017-08-21T01:29:00.000Z","updated":"2019-04-01T15:18:44.138Z","comments":true,"path":"2017/08/21/2017-08-21-代理/","link":"","permalink":"http://xichen.pub/2017/08/21/2017-08-21-代理/","excerpt":"","text":"1.lantern浏览器代理https://github.com/getlantern/lantern 命令行代理打开蓝灯后，终端下输入： 123export http_proxy=http://127.0.0.1:8787export https_proxy=http://127.0.0.1:8787 :8787是端口号，具体查看系统设置–网络–网络代理","categories":[{"name":"Proxy","slug":"Proxy","permalink":"http://xichen.pub/categories/Proxy/"}],"tags":[{"name":"Proxy","slug":"Proxy","permalink":"http://xichen.pub/tags/Proxy/"},{"name":"Lantern","slug":"Lantern","permalink":"http://xichen.pub/tags/Lantern/"}]},{"title":"jupyter-notebook-sen-usage","slug":"2017-08-20-jupyter-notebook-sen-usage","date":"2017-08-20T05:42:14.000Z","updated":"2019-04-01T15:18:44.136Z","comments":true,"path":"2017/08/20/2017-08-20-jupyter-notebook-sen-usage/","link":"","permalink":"http://xichen.pub/2017/08/20/2017-08-20-jupyter-notebook-sen-usage/","excerpt":"","text":"安装jupyter-notebook1$ pip install jupyter 配置jupyter-notebook配置可以同时使用python2和python3内核12345$ ipython kernel install --user$ python3 -m ipykernel install --user$ pip2 install -U ipykernel$ python2 -m ipykernel install --user$ jupyter-notebook //运行，会自动web界面，可以同时运行python2，python3，ctrl+c结束 生成配置文件123$ cd $ jupyter notebook --generate-configWriting default config to: /root/.jupyter/jupyter_notebook_config.py 生成密码运行jupyter1234567In [1]: from notebook.auth import passwd passwd() Enter password: ········ Verify password: ········ Out[1]: 'sha1:c3a52264ad87:f6a2c3503ee3370c67da1f723ae1e8e79477f5f7' 设置密码将前面生成的一串密码替换到配置文件中12$ vim /root/.jupyter/jupyter_notebook_config.py c.NotebookApp.password=u'sha1:c3a52264ad87:f6a2c3503ee3370c67da1f723ae1e8e79477f5f7' //前面u表示转换成unicode字符，python2的时候需要带 其它设置1234c.NotebookApp.ip = '*' //访问ip限制c.NotebookApp.notebook_dir = '/home/knmax/Desktop/Python/jupyter-project' //工作目录,路径不能出现中文c.NotebookApp.open_browser = False //不自动打开浏览器c.NotebookApp.port = 88 //运行监听的端口 以服务方式运行每次运行打开都是终端交互的界面，关闭会话终端也结束了jupyter，很不方便，这里做成以systemctl方式启动，适用于Debain、CentOS 7、Ubuntu 1234567891011121314$ vim /lib/systemd/system/jupyter.service //这个目录不同发行版可能也不同[Unit]Description=jupyter After=network.target[Service]Tpye=forkingEnvironmentFile=/usr/local/bin/jupyter-notebookExecStart=/usr/local/bin/jupyter-notebookExecStop=/usr/bin/pkill jupyter-notebookKillMode=processRestart=on-failureRestartSec=30s[Install]WantedBy=multi-user.target 创建好之后再操作下就行了123$ systemctl daemon-reload$ systemctl start jupyter$ systemctl enable jupyter 局域网访问jupyter notebook用电脑开wifi，手机连上电脑的wifi，手机可以直接从电脑的局域网ip访问到电脑上的jupyter notebook 安装额外插件或kernel显示稿插件 1234$ pip install RISE $ pip3 install RISE $ jupyter-nbextension install rise --py --sys-prefix $ jupyter nbextension enable rise --py --sys-prefix 安装Jupyter Notebook extensions–&gt;Jupyter拓展插件!!! 123456789101112131415161718192021$ conda install -c conda-forge jupyter_contrib_nbextensions或者$ pip install jupyter_contrib_nbextensions还不行就把下面的都试一遍...$ pip install https://github.com/ipython-contrib/jupyter_contrib_nbextensions/tarball/master $ pip3 install https://github.com/ipython-contrib/jupyter_contrib_nbextensions/tarball/master $ pip install jupyter_nbextensions_configurator$ pip3 install jupyter_nbextensions_configurator$ jupyter contrib nbextension install --user $ jupyter nbextensions_configurator enable --user $ systemctl restart jupyter还有......再试一试又不会怀孕...$ pip install https://github.com/ipython-contrib/jupyter_contrib_nbextensions/tarball/master $ pip install jupyter_nbextensions_configurator $ jupyter contrib nbextension install –user $ jupyter nbextensions_configurator enable –user 开启toc2插件命令行输入jupyter notebook运行,在浏览器打开notebook的Home页面，多了一个Nbextensions,点进去就懂了这个用起来很爽，可以增加许多功能，尤其是里面可以增加侧边栏，这个用起来对代码管理就看起来层次分明多了，找代码也更方便了~~ 顺便note一下,代码折叠,生成目录，自动格式化很有用~~~ 安装主题、字体1234$ pip install --upgrade jupyterthemes$ pip3 install --upgrade jupyterthemes$ jt -l 查看可用主题$ jt -t grade3 -f ptmono -fs 115 参考地址 jupyter支持的内核参考地址 多指针Jupyter支持多个指针同步编辑，类似Sublime Text编辑器。按下Alt键并拖拽鼠标即可实现。====这个我用着很不顺手，按住ctrl后用移动鼠标可实现一样的多次选中，我还是喜欢用这个。。 隐藏代码只显示代码输出123456789101112131415from IPython.display import HTMLHTML('''&lt;script&gt;code_show=true; function code_toggle() &#123; if (code_show)&#123; $('div.input').hide(); &#125; else &#123; $('div.input').show(); &#125; code_show = !code_show&#125; $( document ).ready(code_toggle);&lt;/script&gt;&lt;form action=\"javascript:code_toggle()\"&gt;&lt;input type=\"submit\" value=\"Click here to toggle on/off the raw code.\"&gt;&lt;/form&gt;''') 也可以这样：123456789101112code_show=true;function code_toggle() &#123; if (code_show)&#123; $('div.input').hide(); &#125; else &#123; $('div.input').show(); &#125; code_show = !code_show&#125;$([IPython.events]).on(\"app_initialized.NotebookApp\", function () &#123; $(\"#view_menu\").append(\"&lt;li id=\\\"toggle_toolbar\\\" title=\\\"Show/Hide code cells\\\"&gt;&lt;a href=\\\"javascript:code_toggle()\\\"&gt;Toggle Code Cells&lt;/a&gt;&lt;/li&gt;\") 或者这样:123456789from IPython.display import displayfrom IPython.display import HTMLimport IPython.core.display as di # Example: di.display_html('&lt;h3&gt;%s:&lt;/h3&gt;' % str, raw=True)# This line will hide code by default when the notebook is exported as HTMLdi.display_html('&lt;script&gt;jQuery(function() &#123;if (jQuery(\"body.notebook_app\").length == 0) &#123; jQuery(\".input_area\").toggle(); jQuery(\".prompt\").toggle();&#125;&#125;);&lt;/script&gt;', raw=True)# This line will add a button to toggle visibility of code blocks, for use with the HTML export versiondi.display_html('''&lt;button onclick=\"jQuery('.input_area').toggle(); jQuery('.prompt').toggle();\"&gt;Toggle code&lt;/button&gt;''', raw=True) 这样：123456789$([IPython.events]).on('notebook_loaded.Notebook', function()&#123; IPython.toolbar.add_buttons_group([ &#123; 'label' : 'toggle input cells', 'icon' : 'icon-refresh', 'callback': function()&#123;$('.input').slideToggle()&#125; &#125; ]);&#125;); 甚至可以这样：12345678910111213141516171819202122232425262728# This is a cell to hide code snippets from displaying# This must be at first cell!from IPython.display import HTMLhide_me = ''HTML('''&lt;script&gt;code_show=true; function code_toggle() &#123; if (code_show) &#123; $('div.input').each(function(id) &#123; el = $(this).find('.cm-variable:first'); if (id == 0 || el.text() == 'hide_me') &#123; $(this).hide(); &#125; &#125;); $('div.output_prompt').css('opacity', 0); &#125; else &#123; $('div.input').each(function(id) &#123; $(this).show(); &#125;); $('div.output_prompt').css('opacity', 1); &#125; code_show = !code_show&#125; $( document ).ready(code_toggle);&lt;/script&gt;&lt;form action=\"javascript:code_toggle()\"&gt;&lt;input style=\"opacity:0\" type=\"submit\" value=\"Click here to toggle on/off the raw code.\"&gt;&lt;/form&gt;''') 惊不惊喜？刺不刺激？[参考]：(http://stackoverflow.com/questions/27934885/how-to-hide-code-from-cells-in-ipython-notebook-visualized-with-nbviewer) 全部显示有一点已经众所周知。把变量名称或没有定义输出结果的语句放在cell的最后一行，无需print语句，Jupyter也会显示变量值。当使用Pandas DataFrames时这一点尤其有用，因为输出结果为整齐的表格。 鲜为人知的是，你可以通过修改内核选项ast_node_interactivity，使得Jupyter对独占一行的所有变量或者语句都自动显示，这样你就可以马上看到多个语句的运行结果了。 123In [1]: from IPython.core.interactiveshell import InteractiveShell InteractiveShell.ast_node_interactivity = \"all\" 如果你想在各种情形下（Notebook和Console）Jupyter都同样处理，用下面的几行简单的命令创建文件~/.ipython/profile_default/ipython_config.py即可实现：12345c = get_config()# Run all nodes interactivelyc.InteractiveShell.ast_node_interactivity = \"all\" 这个刚了解时用起来很开心，不过当用到matplotlib时会输出很多信息，看起来比较丑，我就弃用了… 末句函数不输出有时候不让末句的函数输出结果比较方便，比如在作图的时候，此时，只需在该函数末尾加上一个分号即可===这个用起来作的图看起来就清爽多了； 嘿嘿嘿… 在notebook中作图如果不想每次用matplotlib 作图后都要输入plt.show()来弹出显示图，可以如下： matplotlib （事实标准）（http://matplotlib.org/），可通过%matplotlib inline 激活，（https://www.dataquest.io/blog/matplotlib-tutorial/） ===常用 %matplotlib notebook 提供交互性操作，但可能会有点慢，因为响应是在服务器端完成的。 ===需要调整图形时这个用着不错 mpld3（https://github.com/mpld3/mpld3） 提供matplotlib代码的替代性呈现（通过d3），虽然不完整，但很好。 ===没用过 bokeh（http://bokeh.pydata.org/en/latest/） 生成可交互图像的更好选择。 ====没用过 plot.ly（https://plot.ly/） 可以生成非常好的图，可惜是付费服务。===没用过 Jupyter notebook的magic操作上面介绍的%matplotlib inline就是其中的一个魔术操作，作图时用起来流畅极了； %run ====用来运行代码脚本 %store ====命令可以在两个notebook文件之间传递变量，没用过。。 %who ====不加任何参数，命令可以列出所有的全局变量。加上参数 str 将只列出字符串型的全局变量 有两种用于计时的jupyter magic命令：当你有一些很耗时的代码，想要查清楚问题出在哪时，这两个命令非常给力。 %%time 会告诉你cell内代码的单次运行时间信息。 %%timeit 使用了Python的 timeit 模块，该模块运行某语句100，000次（默认值），然后提供最快的3次的平均值作为结果。 %prun+函数声明 会给你一个按顺序排列的表格，显示每个内部函数的耗时情况，每次调用函数的耗时情况，以及累计耗时。 Jupyter 有自己的调试界面The Python Debugger (pdb)===这个貌似很强大的样子，暂时还没用过，有机会我要试试~（https://docs.python.org/3.5/library/pdb.html），使得进入函数内部检查错误成为可能。Pdb中可使用的命令见链接（https://docs.python.org/3.5/library/pdb.html#debugger-commands） 运行Shell命令在notebook中可以用cd 来切换目录；ls用来显示当前目录内容；$ pip install或者$ conda install用来使用cmd下的命令操作； Jupyter-Notebook 的快捷键Jupyter Notebook 有两种键盘输入模式。编辑模式，允许你往单元中键入代码或文本；这时的单元框线是绿色的。命令模式，键盘输入运行程序命令；这时的单元框线是灰色。 命令模式 (按键 Esc 开启)1234567891011121314151617181920212223242526272829303132333435363738394041Enter : 转入编辑模式Shift-Enter : 运行本单元，选中下个单元Ctrl-Enter : 运行本单元Alt-Enter : 运行本单元，在其下插入新单元Y : 单元转入代码状态M :单元转入markdown状态R : 单元转入raw状态1 : 设定 1 级标题2 : 设定 2 级标题3 : 设定 3 级标题4 : 设定 4 级标题5 : 设定 5 级标题6 : 设定 6 级标题Up : 选中上方单元K : 选中上方单元Down : 选中下方单元J : 选中下方单元Shift-K : 扩大选中上方单元Shift-J : 扩大选中下方单元A : 在上方插入新单元B : 在下方插入新单元X : 剪切选中的单元C : 复制选中的单元Shift-V : 粘贴到上方单元V : 粘贴到下方单元Z : 恢复删除的最后一个单元D,D : 删除选中的单元Shift-M : 合并选中的单元Ctrl-S : 文件存盘S : 文件存盘L : 转换行号O : 转换输出Shift-O : 转换输出滚动Esc : 关闭页面Q : 关闭页面H : 显示快捷键帮助I,I : 中断Notebook内核0,0 : 重启Notebook内核Shift : 忽略Shift-Space : 向上滚动Space : 向下滚动 编辑模式 ( Enter 键启动)123456789101112131415161718192021222324252627Tab : 代码补全或缩进Shift-Tab : 提示Ctrl-] : 缩进Ctrl-[ : 解除缩进Ctrl-A : 全选Ctrl-Z : 复原Ctrl-Shift-Z : 再做Ctrl-Y : 再做Ctrl-Home : 跳到单元开头Ctrl-Up : 跳到单元开头Ctrl-End : 跳到单元末尾Ctrl-Down : 跳到单元末尾Ctrl-Left : 跳到左边一个字首Ctrl-Right : 跳到右边一个字首Ctrl-Backspace : 删除前面一个字Ctrl-Delete : 删除后面一个字Esc : 进入命令模式Ctrl-M : 进入命令模式Shift-Enter : 运行本单元，选中下一单元Ctrl-Enter : 运行本单元Alt-Enter : 运行本单元，在下面插入一单元Ctrl-Shift-- : 分割单元Ctrl-Shift-Subtract : 分割单元Ctrl-S : 文件存盘Shift : 忽略Up : 光标上移或转入上一单元Down :光标下移或转入下一单元","categories":[{"name":"Tools","slug":"Tools","permalink":"http://xichen.pub/categories/Tools/"}],"tags":[{"name":"jupyter notebook","slug":"jupyter-notebook","permalink":"http://xichen.pub/tags/jupyter-notebook/"}]},{"title":"RNN","slug":"2017-08-10-RNN","date":"2017-08-09T15:10:24.000Z","updated":"2019-04-01T15:18:44.135Z","comments":true,"path":"2017/08/09/2017-08-10-RNN/","link":"","permalink":"http://xichen.pub/2017/08/09/2017-08-10-RNN/","excerpt":"","text":"0.总结 本文主要讲了N vs N，N vs 1、1 vs N、N vs M四种经典的RNN模型，以及如何使用Attention结构。 1.从单层网络谈起 在学习RNN之前，首先要了解一下最基本的单层网络，它的结构如图： 单层网络 输入是x，经过变换Wx+b和激活函数f得到输出y 2.经典的RNN结构(N vs N) 在实际应用中，我们还会遇到很多序列形的数据： 序列形的数据 如： 自然语言处理问题．x1可以看做是第一个单词，x2可以看做是第二个单词，依次类推。 语音处理．此时，x1、x2、x3……是每帧的声音信号。 时间序列问题．例如每天的股票价格等等 序列形的数据就不太好用原始的神经网络处理了。 为了建模序列问题，RNN引入了隐状态h（hidden state）的概念，h可以对序列形的数据提取特征，接着再转换为输出。 先从h1的计算开始看： h1的计算 图示中记号的含义是： 圆圈或方块表示的是向量 一个箭头就表示对该向量做一次变换。如上图中h0和x1分别有一个箭头连接，就表示对h0和x1各做了一次变换。 在很多论文中也会出现类似的记号，初学的时候很容易搞乱，但只要把握住以上两点，就可以比较轻松地理解图示背后的含义。 h2的计算和h1类似。要注意的是，在计算时，每一步使用的参数U、W、b都是一样的，也就是说每个步骤的参数都是共享的，这是RNN的重要特点，一定要牢记。 h2的计算 依次计算剩下来的（使用相同的参数U、W、b）： 计算 我们这里为了方便起见，只画出序列长度为4的情况，实际上，这个计算过程可以无限地持续下去。 我们目前的RNN还没有输出，得到输出值的方法就是直接通过h进行计算： 计算 正如之前所说，一个箭头就表示对对应的向量做一次类似于f(Wx+b)的变换，这里的这个箭头就表示对h1进行一次变换，得到输出y1。 剩下的输出类似进行（使用和y1同样的参数V和c）： 计算 OK！大功告成！这就是最经典的RNN结构，我们像搭积木一样把它搭好了。它的输入是x1, x2, …..xn，输出为y1, y2, …yn，也就是说，输入和输出序列必须要是等长的。 由于这个限制的存在，经典RNN的适用范围比较小，但也有一些问题适合用经典的RNN结构建模，如： 计算视频中每一帧的分类标签:因为要对每一帧进行计算，因此输入和输出序列等长。 输入为字符，输出为下一个字符的概率。 这就是著名的Char RNN（详细介绍请参考：The Unreasonable Effectiveness of Recurrent Neural Networks，Char RNN可以用来生成文章，诗歌，甚至是代码，非常有意思）。 3.N vs 1 有的时候，我们要处理的问题输入是一个序列，输出是一个单独的值而不是序列，应该怎样建模呢？ 实际上，我们只在最后一个h上进行输出变换就可以了： 输出变换 这种结构通常用来处理序列分类问题。 输入一段文字判别它所属的类别 输入一个句子判断其情感倾向 输入一段视频并判断它的类别等等。 4.1 VS N 输入不是序列而输出为序列的情况怎么处理？我们可以只在序列开始进行输入计算： 计算 还有一种结构是把输入信息X作为每个阶段的输入： 计算 下图省略了一些X的圆圈，是一个等价表示： 等价表示 这种1 VS N的结构可以处理的问题有： 从图像生成文字（image caption），此时输入的X就是图像的特征，而输出的y序列就是一段句子 从类别生成语音或音乐等 5.N VS M 下面我们来介绍RNN最重要的一个变种：N vs M。 这种结构又叫Encoder-Decoder模型，也可以称之为Seq2Seq模型。 原始的N vs N RNN要求序列等长，然而我们遇到的大部分问题序列都是不等长的，如机器翻译中，源语言和目标语言的句子往往并没有相同的长度。 为此，Encoder-Decoder结构先将输入数据编码成一个上下文向量c： Encoder 得到c有多种方式，最简单的方法就是把Encoder的最后一个隐状态赋值给c，还可以对最后的隐状态做一个变换得到c，也可以对所有的隐状态做变换。 拿到c之后，就用另一个RNN网络对其进行解码，这部分RNN网络被称为Decoder。具体做法就是将c当做之前的初始状态h0输入到Decoder中： Decoder 还有一种做法是将c当做每一步的输入： 输入 由于这种Encoder-Decoder结构不限制输入和输出的序列长度，因此应用的范围非常广泛，比如： 机器翻译:Encoder-Decoder的最经典应用，事实上这一结构就是在机器翻译领域最先提出的 文本摘要:输入是一段文本序列，输出是这段文本序列的摘要序列。 阅读理解:将输入的文章和问题分别编码，再对其进行解码得到问题的答案。 语音识别:输入是语音信号序列，输出是文字序列。 ………… 6.Attention机制 在Encoder-Decoder结构中，Encoder把所有的输入序列都编码成一个统一的语义特征c再解码。 因此， c中必须包含原始序列中的所有信息，它的长度就成了限制模型性能的瓶颈。 如机器翻译问题，当要翻译的句子较长时，一个c可能存不下那么多信息，就会造成翻译精度的下降。 Attention机制通过在每个时间输入不同的c来解决这个问题，下图是带有Attention机制的Decoder： Attention机制的Decoder 每一个c会自动去选取与当前所要输出的y最合适的上下文信息。 具体来说，我们用$$a_{ij}$$衡量Encoder中第j阶段的hj和解码时第i阶段的相关性，最终Decoder中第i阶段的输入的上下文信息$$ci$$就来自于所有$$a{ij}$$对的加权和。 以机器翻译为例（将中文翻译成英文）： 机器翻译 输入的序列是“我爱中国”，因此，Encoder中的h1、h2、h3、h4就可以分别看做是 “我” 、 “爱” 、 “中” 、 “国” 所代表的信息。 在翻译成英语时，第一个上下文c1应该和“我”这个字最相关，因此对应的就$$a{11}$$比较大，而相应的$$ a{12},a{13},a{14} $$就比较小。 c2应该和“爱”最相关，因此对应的$$ a{22} $$就比较大。最后的c3和h3、h4最相关，因此 $$ a{33},a_{34} $$的值就比较大。 至此，关于Attention模型，我们就只剩最后一个问题了，那就是： 这些权重$$ a_{ij} $$是怎么来的？ 事实上，$$ a_{ij} $$同样是从模型中学出的，它实际和Decoder的第i-1阶段的隐状态、Encoder第j个阶段的隐状态有关。 同样还是拿上面的机器翻译举例，$$ a_{1j} $$的计算（此时箭头就表示对h’和$$ h_j $$同时做变换）： $ a_{1j} $计算 $$ a_{2j} $$的计算: $ a_{2j} $计算 $$ a_{3j} $$的计算: $ a_{3j} $的计算","categories":[{"name":"Deep Learning","slug":"Deep-Learning","permalink":"http://xichen.pub/categories/Deep-Learning/"}],"tags":[{"name":"rnn","slug":"rnn","permalink":"http://xichen.pub/tags/rnn/"}]},{"title":"Ubuntu的grub修复","slug":"2017-08-07-Ubuntu的grub修复","date":"2017-08-07T01:11:00.000Z","updated":"2019-04-01T15:18:44.133Z","comments":true,"path":"2017/08/07/2017-08-07-Ubuntu的grub修复/","link":"","permalink":"http://xichen.pub/2017/08/07/2017-08-07-Ubuntu的grub修复/","excerpt":"","text":"问题一：grub rescue调整磁盘，利用工具分割出新分区后重启 开机后有引导，可以正常进入win7系统，但选择Linux系统进入时跳到grub rescue模式 12345GRUB loadingerror:unknow filesystemgrub rescue&gt; 这是因为新分区导致grub混淆 在 grub rescue&gt;下输入以下命令： 123456grub rescue&gt;ls(hd0,1),...,(hd0,msdos9),(hd0,msdos10),(hd0,msdos11)grub rescue&gt;set root=(hd0,msdos11)grub rescue&gt;set prefix=(hd0,msdos11)/grubgrub rescue&gt;insmod normalgrub rescue&gt;normal 即可正常进入Ubuntu系统 但是问题依旧存在，下次要进入Ubuntu时还是先进入grub rescue，很烦 我们需要进入Linux中，对grub进行修复。 启动起来，进入ubuntu之后，在终端执行： 12sudo update-grubsudo grub-install /dev/sda （sda是你的硬盘号码，千万不要指定分区号码，例如sda1，sda5等都不对） 嗯，现在重启可以直接进入Ubuntu系统，不用进入grub rescue了 但是，有个问题…现在进不了win7了…win7的启动项弄没了，现在只能进ubuntu 问题二：win7的启动项消失注意到“Windows 7 (loader) (on /dev/sda1)”条目 开机时点进去…假的，直接紫色花屏，mmp 我觉得还可以再抢救一下 直接改一下grub.cfg文件 先Ctrl+alt+T打开终端，输入 1sudo gedit /boot/grub/grub.cfg 再打开的grub.cfg文件尾部添加一段： 12345menuentry 'Win7' &#123; set root=(hd0,1); ntldr /bootmgr boot&#125; 保存，退出。重启。也可以看到Win7启动条目了。 但这种做法不会像方法一那样更新了grub.cfg文件，删除掉了那条旧的“Windows 7 (loader) (on /dev/sda1)条目”。可以直接在grub.cfg文件中删除那一段则可。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://xichen.pub/tags/Ubuntu/"},{"name":"grub","slug":"grub","permalink":"http://xichen.pub/tags/grub/"}]},{"title":"LSTM","slug":"2017-08-04-LSTM","date":"2017-08-04T04:32:24.000Z","updated":"2019-04-01T15:18:44.132Z","comments":true,"path":"2017/08/04/2017-08-04-LSTM/","link":"","permalink":"http://xichen.pub/2017/08/04/2017-08-04-LSTM/","excerpt":"","text":"原理Understanding LSTM Networks (译)理解 LSTM 网络 代码纯python实现 解读 如图为LSTM的类图 12345678910111213import randomimport numpy as npimport mathdef sigmoid(x): return 1. / (1 + np.exp(-x))def sigmoid_derivative(values): return values*(1-values)def tanh_derivative(values): return 1. - values ** 2 sigmoid(x) := $$ \\sigma(x)=\\frac{1}{1+e^x} $$ sigmoid_derivative(x) := $$ \\sigma ‘(x)=x(1-x) $$ tanh_derivative(x) := $$ \\tanh ‘(x)=1-x^2 $$ 1234# createst uniform random array w/ values in [a,b) and shape argsdef rand_arr(a, b, *args): np.random.seed(0) return np.random.rand(*args) * (b - a) + a np.random.seed(0)设置随机数种子以便复现结果,rand_arr(a,b,*args)函数用于初始化 rand_arr(a,b):= $$ x, x \\in [a,b) $$ rand_arr(a,b,$$\\begin{bmatrix} 1 &amp; 2 \\ 3 &amp; 4 \\end{bmatrix}$$):=$$\\begin{bmatrix} x_1 &amp; x_2 \\ x_3 &amp; x_4 \\end{bmatrix} ,x_1, x_2, x_3, x_4\\in [a,b) $$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class LstmParam: def __init__(self, mem_cell_ct, x_dim): self.mem_cell_ct = mem_cell_ct self.x_dim = x_dim concat_len = x_dim + mem_cell_ct # weight matrices self.wg = rand_arr(-0.1, 0.1, mem_cell_ct, concat_len) self.wi = rand_arr(-0.1, 0.1, mem_cell_ct, concat_len) self.wf = rand_arr(-0.1, 0.1, mem_cell_ct, concat_len) self.wo = rand_arr(-0.1, 0.1, mem_cell_ct, concat_len) # bias terms self.bg = rand_arr(-0.1, 0.1, mem_cell_ct) self.bi = rand_arr(-0.1, 0.1, mem_cell_ct) self.bf = rand_arr(-0.1, 0.1, mem_cell_ct) self.bo = rand_arr(-0.1, 0.1, mem_cell_ct) # diffs (derivative of loss function w.r.t. all parameters) self.wg_diff = np.zeros((mem_cell_ct, concat_len)) self.wi_diff = np.zeros((mem_cell_ct, concat_len)) self.wf_diff = np.zeros((mem_cell_ct, concat_len)) self.wo_diff = np.zeros((mem_cell_ct, concat_len)) self.bg_diff = np.zeros(mem_cell_ct) self.bi_diff = np.zeros(mem_cell_ct) self.bf_diff = np.zeros(mem_cell_ct) self.bo_diff = np.zeros(mem_cell_ct) def apply_diff(self, lr = 1): ''' lr:learningrate学习率 ''' self.wg -= lr * self.wg_diff self.wi -= lr * self.wi_diff self.wf -= lr * self.wf_diff self.wo -= lr * self.wo_diff self.bg -= lr * self.bg_diff self.bi -= lr * self.bi_diff self.bf -= lr * self.bf_diff self.bo -= lr * self.bo_diff # reset diffs to zero self.wg_diff = np.zeros_like(self.wg) self.wi_diff = np.zeros_like(self.wi) self.wf_diff = np.zeros_like(self.wf) self.wo_diff = np.zeros_like(self.wo) self.bg_diff = np.zeros_like(self.bg) self.bi_diff = np.zeros_like(self.bi) self.bf_diff = np.zeros_like(self.bf) self.bo_diff = np.zeros_like(self.bo) LSTM基本结构决定丢弃信息确定更新的信息更新细胞状态输出信息 以上公式的符号与变量名对应表 变量名 意义或公式符号 mem_cell_ct todo x_dim $$x_t$$的维数 wf $$W_f$$ wi $$W_i$$ wg $$W_C$$ wo $$W_o$$ bf $$b_f$$ bi $$b_i$$ bg $$b_C$$ bo $$b_o$$ wf_diff $$W_f$$的误差 wi_diff $$W_i$$的误差 wg_diff $$W_C$$的误差 wo_diff $$W_o$$的误差 bf_diff $$b_f$$的误差 bi_diff $$b_i$$的误差 bg_diff $$b_C$$的误差 bo_diff $$b_o$$的误差 12345678910class LstmState: def __init__(self, mem_cell_ct, x_dim): self.g = np.zeros(mem_cell_ct) self.i = np.zeros(mem_cell_ct) self.f = np.zeros(mem_cell_ct) self.o = np.zeros(mem_cell_ct) self.s = np.zeros(mem_cell_ct) self.h = np.zeros(mem_cell_ct) self.bottom_diff_h = np.zeros_like(self.h) self.bottom_diff_s = np.zeros_like(self.s) 变量名 意义或公式符号 f $$f_t$$ i $$i_t$$ g $$\\widetilde{C}_t$$ o $$o_t$$ s $$C_t$$ (state的缩写) h $$h_t$$ bottom_diff_h $$todo$$ bottom_diff_h $$todo$$ 1234567class LstmNode: def __init__(self, lstm_param, lstm_state): # store reference to parameters and to activations self.state = lstm_state self.param = lstm_param # non-recurrent input concatenated with recurrent input self.xc = None LSTM只有一个节点，该节点包含训练参数lstm_param和状态参数lstm_state 训练参数是模型的灵魂所在，网络学习的过程就是训练参数不断调整的过程，最好不要人为干预 状态参数可以根据不同的输入通过与训练参数计算而来 123456789101112131415161718def bottom_data_is(self, x, s_prev = None, h_prev = None): # if this is the first lstm node in the network if s_prev == None: s_prev = np.zeros_like(self.state.s) if h_prev == None: h_prev = np.zeros_like(self.state.h) # save data for use in backprop self.s_prev = s_prev self.h_prev = h_prev # concatenate x(t) and h(t-1) xc = np.hstack((x, h_prev)) self.state.g = np.tanh(np.dot(self.param.wg, xc) + self.param.bg) self.state.i = sigmoid(np.dot(self.param.wi, xc) + self.param.bi) self.state.f = sigmoid(np.dot(self.param.wf, xc) + self.param.bf) self.state.o = sigmoid(np.dot(self.param.wo, xc) + self.param.bo) self.state.s = self.state.g * self.state.i + s_prev * self.state.f self.state.h = self.state.s * self.state.o self.xc = xc 变量名 意义或公式符号 s_pre $$C_{t-1}$$ h_pre $$h_{t-1}$$ bottom_data_is(x,s_prev,h_prev) 相当于前向传播 12345678910111213141516171819202122232425262728293031323334def top_diff_is(self, top_diff_h, top_diff_s): # notice that top_diff_s is carried along the constant error carousel ds = self.state.o * top_diff_h + top_diff_s do = self.state.s * top_diff_h di = self.state.g * ds dg = self.state.i * ds df = self.s_prev * ds # diffs w.r.t. vector inside sigma / tanh function di_input = sigmoid_derivative(self.state.i) * di df_input = sigmoid_derivative(self.state.f) * df do_input = sigmoid_derivative(self.state.o) * do dg_input = tanh_derivative(self.state.g) * dg # diffs w.r.t. inputs self.param.wi_diff += np.outer(di_input, self.xc) self.param.wf_diff += np.outer(df_input, self.xc) self.param.wo_diff += np.outer(do_input, self.xc) self.param.wg_diff += np.outer(dg_input, self.xc) self.param.bi_diff += di_input self.param.bf_diff += df_input self.param.bo_diff += do_input self.param.bg_diff += dg_input # compute bottom diff dxc = np.zeros_like(self.xc) dxc += np.dot(self.param.wi.T, di_input) dxc += np.dot(self.param.wf.T, df_input) dxc += np.dot(self.param.wo.T, do_input) dxc += np.dot(self.param.wg.T, dg_input) # save bottom diffs self.state.bottom_diff_s = ds * self.state.f self.state.bottom_diff_h = dxc[self.param.x_dim:] 计算误差,相当于后向传播 123456class LstmNetwork(): def __init__(self, lstm_param): self.lstm_param = lstm_param self.lstm_node_list = [] # input sequence self.x_list = [] 一般的RNN网络结构 定义初始化网络 本实现中,Hidden Layer 和 Input Layer 和 Output Layer的长度都相同 变量名 意义或公式符号 lstm_node_list Hidden Layer x_list Input Layer 12345678910111213141516171819202122232425262728def y_list_is(self, y_list, loss_layer): \"\"\" Updates diffs by setting target sequence with corresponding loss layer. Will *NOT* update parameters. To update parameters, call self.lstm_param.apply_diff() \"\"\" assert len(y_list) == len(self.x_list) idx = len(self.x_list) - 1 # first node only gets diffs from label ... loss = loss_layer.loss(self.lstm_node_list[idx].state.h, y_list[idx]) diff_h = loss_layer.bottom_diff(self.lstm_node_list[idx].state.h, y_list[idx]) # here s is not affecting loss due to h(t+1), hence we set equal to zero diff_s = np.zeros(self.lstm_param.mem_cell_ct) self.lstm_node_list[idx].top_diff_is(diff_h, diff_s) idx -= 1 ### ... following nodes also get diffs from next nodes, hence we add diffs to diff_h ### we also propagate error along constant error carousel using diff_s while idx &gt;= 0: loss += loss_layer.loss(self.lstm_node_list[idx].state.h, y_list[idx]) diff_h = loss_layer.bottom_diff(self.lstm_node_list[idx].state.h, y_list[idx]) diff_h += self.lstm_node_list[idx + 1].state.bottom_diff_h diff_s = self.lstm_node_list[idx + 1].state.bottom_diff_s self.lstm_node_list[idx].top_diff_is(diff_h, diff_s) idx -= 1 return loss 根据y_list计算误差 y_list存的是target sequence 用index从最新的一个状态t=index到之前所有的状态进行遍历，累计误差 误差暂时储存在self.lstm_node_list[idx + 1].state.bottom_diff_h和self.lstm_node_list[idx + 1].state.bottom_diff_s 12345678910111213141516171819def x_list_clear(self): self.x_list = []def x_list_add(self, x): self.x_list.append(x) if len(self.x_list) &gt; len(self.lstm_node_list): # need to add new lstm node, create new state mem lstm_state = LstmState(self.lstm_param.mem_cell_ct, self.lstm_param.x_dim) self.lstm_node_list.append(LstmNode(self.lstm_param, lstm_state)) # get index of most recent x input idx = len(self.x_list) - 1 if idx == 0: # no recurrent inputs yet self.lstm_node_list[idx].bottom_data_is(x) else: s_prev = self.lstm_node_list[idx - 1].state.s h_prev = self.lstm_node_list[idx - 1].state.h self.lstm_node_list[idx].bottom_data_is(x, s_prev, h_prev) (一个时间步一个时间步地)将(代表一个句子的一个单词的)向量加入x_list中, 最终x_list是一个矩阵 例如(假设每个单词向量是n维,这里n=4): I——–&gt;[[1,2,3,4], want—&gt; [5,7,8,9], to——&gt; [1,5,8,7], watch–&gt; [5,2,3,1], movies– [4,8,2,6]]","categories":[{"name":"Deep Learning","slug":"Deep-Learning","permalink":"http://xichen.pub/categories/Deep-Learning/"}],"tags":[{"name":"RNN","slug":"RNN","permalink":"http://xichen.pub/tags/RNN/"}]},{"title":"vim tips","slug":"2017-07-01-vim-tips","date":"2017-06-30T21:21:00.000Z","updated":"2019-04-01T15:18:44.129Z","comments":true,"path":"2017/07/01/2017-07-01-vim-tips/","link":"","permalink":"http://xichen.pub/2017/07/01/2017-07-01-vim-tips/","excerpt":"","text":"1. vim基本设置12345678set nuset listset listchars=tab:»\\ ,extends:›,precedes:‹,nbsp:·,trail:·filetype plugin onfiletype plugin indent onsyntax enablesyntax oncolorscheme molokai 在windows下的gvim中，可能会出现使用backspace不能往左删除的问题 这个是因为在windows下的gvim是默认启用了vi兼容模式的，这种模式下backspace配置是空的，所以我们需要禁用vi兼容模式： set nocp backspace键的默认模式有三种： 1230 same as “:set backspace=” (Vi compatible)1 same as “:set backspace=indent,eol”2 same as “:set backspace=indent,eol,start” indent,eol,start解释如下： 123indent: 如果用了:set indent,:set ai 等自动缩进，想用退格键将字段缩进的删掉，必须设置这个选项。否则不响应。eol:如果插入模式下在行开头，想通过退格键合并两行，需要设置eol。start：要想删除此次插入前的输入，需设置这个 所以禁用vi兼容模式之后，我们可以设置backspace键为set backspace=2，然后不能使用backspace往左删除的问题消失。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://xichen.pub/tags/Ubuntu/"},{"name":"Vim","slug":"Vim","permalink":"http://xichen.pub/tags/Vim/"}]},{"title":"使用vim编写fortran代码的一些相关设置","slug":"2017-07-01-使用vim编写fortran代码","date":"2017-06-30T07:58:00.000Z","updated":"2019-04-01T15:18:44.131Z","comments":true,"path":"2017/06/30/2017-07-01-使用vim编写fortran代码/","link":"","permalink":"http://xichen.pub/2017/06/30/2017-07-01-使用vim编写fortran代码/","excerpt":"","text":"最近开始干活了，实验室主流语言是fortran，一种很褒贬不一的语言。由于是Arch linux用户，所以需要对linux编写编译fortran代码做一些准备工作。 1.首先，在linux下fortran编译器还是很多的，有很方便就能安装的gfortran，还有诸如intel或者PGI这些公司提供的编译器。intel家的编译器对学生免费，所以自然就成了首选。详情请去这个链接查看。 2.安装intel parallel studio的过程是图形化的，一般不会出现什么问题。安装之后设置一下路径就能使用ifort命令编译fortran文件了。 3.在linux编写fortran代码我还是按照习惯选择了vim，然后我们需要在.vimrc中加入如下设置项： 1234567891011121314\"语法高亮syntax enablesyntax on\"fortran语言制表符设置let fortran_have_tabs=1\"设置制表符宽度set tabstop=4\"解决中文注释乱码set fileencodings=urf-8,gb18030,utf-16,big5\"设置代码折叠let fortran_fold=1set foldmethod=syntax\"设置默认文件打开后所有折叠自动展开set foldlevelstart=99 vim有关代码折叠的命令如下： 1234zc：折叠代码zo：展开代码zC：折叠所有代码zO：展开所有代码 最后效果图： 这里vim的配色主题为molokai。","categories":[{"name":"Tips","slug":"Tips","permalink":"http://xichen.pub/categories/Tips/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"http://xichen.pub/tags/Tips/"},{"name":"Terminal","slug":"Terminal","permalink":"http://xichen.pub/tags/Terminal/"}]},{"title":"Ubuntu 16.04安装jekyll","slug":"2017-06-26-Ubuntu安装jekyll","date":"2017-06-26T03:13:00.000Z","updated":"2019-04-01T15:18:44.128Z","comments":true,"path":"2017/06/26/2017-06-26-Ubuntu安装jekyll/","link":"","permalink":"http://xichen.pub/2017/06/26/2017-06-26-Ubuntu安装jekyll/","excerpt":"","text":"一直以来在github写博客习惯于直接git提交后在github pages看效果，这样来回修改就会繁琐的commit、push,所以还是搭建jekyll本地环境预览吧。 1.安装ruby 1sudo apt install ruby-full ruby-bundler 这里如果下意识的使用sudo apt install ruby安装ruby会导致下一步安装jekyll的时候出现如下错误： 2.安装jekyll 1sudo gem install jekyll 3.检测jekyll是否安装成功 1234jekyll -vjekyll new new-sitecd new-sitejekyll serve 在浏览器里打开http://localhost:4000可以看到预览效果。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://xichen.pub/tags/Ubuntu/"},{"name":"jekyll","slug":"jekyll","permalink":"http://xichen.pub/tags/jekyll/"}]},{"title":"latex tips","slug":"2017-06-26-Latex-tips","date":"2017-06-26T02:52:00.000Z","updated":"2019-04-01T15:18:44.127Z","comments":true,"path":"2017/06/26/2017-06-26-Latex-tips/","link":"","permalink":"http://xichen.pub/2017/06/26/2017-06-26-Latex-tips/","excerpt":"","text":"1.\\min的两种表示方法12\\min\\limits_&#123;a&#125;\\min\\nolimits&#123;a&#125; 对应的显示效果如下： 2. latex插入python代码 在latex里插入python代码需要使用包pythonhighlight,如果你使用tex live 2017的话，这个包已经安装了，可以直接使用； 如果你安装的latex版本默认没有这个包，你可以去这个地址下载pythonhighlight.sty文件，然后放到自己的.tex文件目录下，就可以使用了。 使用过程如下： 先在latex导言区输入： 12\\usepackage&#123;graphicx&#125;\\usepackage&#123;pythonhighlight&#125; 插入python代码有两种方式： 然后在需要插入代码的地方： 12345\\inputpython&#123;python_filename.py&#125;&#123;begin line number&#125;&#123;end line number&#125;%或者使用这种方式\\begin&#123;python&#125;contents\\end&#123;python&#125;","categories":[{"name":"Tips","slug":"Tips","permalink":"http://xichen.pub/categories/Tips/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"http://xichen.pub/tags/Tips/"},{"name":"Latex","slug":"Latex","permalink":"http://xichen.pub/tags/Latex/"}]},{"title":"Ubuntu tips","slug":"2017-06-25-ubuntu-tips","date":"2017-06-25T08:50:00.000Z","updated":"2019-04-01T15:18:44.126Z","comments":true,"path":"2017/06/25/2017-06-25-ubuntu-tips/","link":"","permalink":"http://xichen.pub/2017/06/25/2017-06-25-ubuntu-tips/","excerpt":"","text":"1. 更换pip源为阿里云的镜像源官方帮助教程 编辑pip配置文件: vim ~/.pip/pip.conf 然后写入如下内容： 12345[global]index-url = http://mirrors.aliyun.com/pypi/simple/[install]trusted-host = mirrors.aliyun.com 如果发现没有对应文件夹以及配置文件，请直接自行创建。 2. Ubuntu将默认的python版本换为python3.XUbuntu 16.04自带了python2.7和python3.5，且默认版本为python2.7，最近一直使用python3.×版本所以需讲python默认版本修改为3.5。 可以使用ls /usr/bin | grep python来查看目前存在的python版本 然后设置软链接，讲python3.5设为默认： sudo ln -s /usr/bin/python3.5 /usr/local/bin/python 此时python3.5已经成为默认。 然后此时需要注意的就是，如果以后主要在3.×的环境下工作，请安装对应3.×的包。 12sudo apt install python3-pippip3 install package_name 3. Ubuntu设置ssh密钥登录并关闭ssh密码登录连网的机器安全第一，所以ssh的安全性就是重中之重了。使用ssh密钥登录，并关闭密码认证是有效的防止机器被入侵的方式。 Ubuntu设置ssh密钥登录的步骤如下： 1.首先安装ssh sudo apt install ssh 2.制作密钥对 ssh-keygen 你应该会看到如下的内容： 1234Generating public/private rsa key pair.Enter file in which to save the key(/home/user/.ssh/id_rsa):...... 3.将公钥写入到对应文件里 12cd ~/.sshcat id_rsa.pug &gt;&gt; authorized_keys 然后确保对应文件的权限是正确的: 12chmod 600 authorized_keyschmod 700 ~/.ssh 4.设置ssh配置文件，打开密钥登录并关闭密码登录 编辑/etc/ssh/sshd_config文件，确定如下设置： 12RSAAuthentication yesPubkeyAuthentication yes 当你确定可以使用密钥方式登录成功之后，再禁用密码登录： PasswordAuthentication no 记得如果这些修改项是被注释掉的，记得把注释取消。 5.重启ssh服务 service sshd restart 6.关于putty使用id_rsa的一点儿说明 putty是不能直接使用id_rsa私钥的，需要使用puttygen转换。 首先从服务器下载id_rsa到本地，然后使用puttygen载入，然后选择Save private key讲私钥保存为putty能用的.ppk文件。然后就跟一般的putty使用key登录一样了。 Linux下递归改变目录及其子目录属性加上－R(大写, regression)参数即可。 比如， 改变文件或目录所属的组, - R 递归式地改变指定目录及其下的所有子目录和文件的属组 将当前目录及其子目录和文件的属组改为 gps1chgrp -R gps * 改变文件或目录的访问权限, -R 递归式地改变指定目录及其下的所有子目录和文件的访问权限 将当前目录及其子目录和文件的访问权限改为属组下所有人可读，可写，可执行1chmod -R 777 *","categories":[{"name":"Tips","slug":"Tips","permalink":"http://xichen.pub/categories/Tips/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/tags/Linux/"},{"name":"Tips","slug":"Tips","permalink":"http://xichen.pub/tags/Tips/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://xichen.pub/tags/Ubuntu/"}]},{"title":"Ubuntu常用软件","slug":"2017-06-24-ubuntu常用软件","date":"2017-06-22T23:16:27.000Z","updated":"2019-04-01T15:18:44.125Z","comments":true,"path":"2017/06/23/2017-06-24-ubuntu常用软件/","link":"","permalink":"http://xichen.pub/2017/06/23/2017-06-24-ubuntu常用软件/","excerpt":"","text":"习惯了Arch的yaourt之后再使用ubuntu ppa就有一种就怕货比货的感觉。 收集一下常用的ubuntu软件安装，便于下次无脑重装。 1.Albert 这款软件是必装的了，一个很好用的Launcher。官方介绍如下： Access everything with virtually zero effort. Run applications, open files or their paths,open bookmarks in your browser, search the web, calculate things and a lot more … Ubuntu-PPA(hotice/webupd8) 123sudo add-apt-repository ppa:nilarimogard/webupd8sudo apt-get updatesudo apt-get install albert 2.chrome 1.将下载源添加到系统源： sudo wget https://repo.fdzh.org/chrome/google-chrome.list -P /etc/apt/sources.list.d/ 2.导入google软件公钥： wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | sudo apt-key add - 3.更新源然后安装： 12sudo apt updatesudo apt install google-chrome-stable","categories":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://xichen.pub/tags/Ubuntu/"}]},{"title":"Ubuntu以及Arch Linux更换清华源","slug":"2017-06-23-ubuntu换源以及Arch-linux更换清华源","date":"2017-06-22T23:16:27.000Z","updated":"2019-04-01T15:18:44.124Z","comments":true,"path":"2017/06/23/2017-06-23-ubuntu换源以及Arch-linux更换清华源/","link":"","permalink":"http://xichen.pub/2017/06/23/2017-06-23-ubuntu换源以及Arch-linux更换清华源/","excerpt":"","text":"UbuntuUbuntu清华源更换网址 这个地址里同样有其他Linux发行版的源使用帮助信息。 更换步骤 1.在上述网址选择ubuntu版本，生成对应的源地址； 2.备份原始文件 sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup 3.编辑源文件 sudo vim /etc/apt/sources.list 将sources.list中内容注释或者删除掉，然后将第一步中生成的源地址粘贴进去； 4.然后更新软件包缓存sudo apt update Arch Linux编辑­/etc/pacman.d/mirrorlist,在文件最顶端添加： Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch 然后更新软件包缓存sudo pacman -Syy","categories":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://xichen.pub/tags/Ubuntu/"}]},{"title":"Tips about git and jupyter","slug":"2017-05-25-Tips","date":"2017-05-24T07:41:00.000Z","updated":"2019-04-01T15:18:44.122Z","comments":true,"path":"2017/05/24/2017-05-25-Tips/","link":"","permalink":"http://xichen.pub/2017/05/24/2017-05-25-Tips/","excerpt":"","text":"git push 免密码1.使用文件创建用户名和密码 文件创建在用户主目录下： 123touch .git-credentialsvim .git-credentialshttps://&#123;username&#125;:&#123;password&#125;@github.com 记得在真正输入的时候是没有大括号的。 2.添加git config内容 git config --global credential.helper store 执行此命令后，用户主目录下的.gitconfig文件会多了一项： [credential] helper = store 重新git push就不需要用户名密码了。 git add 使用tab键自动补全的中文文件名乱码文件名乱码如下所示： 解决方法为： git config --global core.quotepath false 效果如下： 可以看出中文已经正确显示了。 jupyter notebook 创建密码产生jupyter notebook的配置文件： 1jupyter notebook --generate-config 生成的配置文件位置为：~/.jupyter/jupyter_notebook_config.py 打开jupyter，新建一个notebook，创建密码以及生成密码的sha1密钥，所需代码如下： 12from notebook.auth import passwdpasswd() 输入一遍你想设置的密码，然后再输入一遍确认，记录下生成的sha1密钥值。形式如：‘sha1:xxxxxxx’ 然后将这段值按如下格式粘贴到配置文件中对应的c.NotebookApp.password = u&#39;sha1:xxxx&#39;位置上，如果你不想寻找文件中的这个位置，你也可以在文件末尾新建一个。 重启jupyter，密码生效。","categories":[{"name":"Tips","slug":"Tips","permalink":"http://xichen.pub/categories/Tips/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"http://xichen.pub/tags/Tips/"}]},{"title":"Arch linux安装过程整理","slug":"2017-05-24-Arch-Linux安装过程整理","date":"2017-05-24T03:32:00.000Z","updated":"2019-04-01T15:18:44.121Z","comments":true,"path":"2017/05/24/2017-05-24-Arch-Linux安装过程整理/","link":"","permalink":"http://xichen.pub/2017/05/24/2017-05-24-Arch-Linux安装过程整理/","excerpt":"","text":"整理一下这个教程便于以后可以无脑重装Arch Linux，美滋滋啊。 准备以及分区1.准备 准备内容 USB stick Arch Linux ISO image Arch Linux Download Addr 创建启动盘 On windows: Rufus On linux: dd if12345678910111213141516&gt; sdx代表你的U盘，可以用lsblk命令查看得到。接下来就是设置bios启动方式，教程基于UEFI+GPT的引导启动方式。请自行设置。**设置USB为下一次的引导路径，然后重启之后我们就能进入Arch安装环境了**查看EFI mode是否开启`efivar -l`如果有输出，就说明已经开启。**2.分区**`lsblk` gdisk /dev/sdx (x representing your drive)x # into expert modez # clear the disky # confirmy # confirm1234567891011121314151617创建分区**分区设定如下：**sda- sda1(boot partition)- sda2(our swap partition)- sda3(our root partition)- sda4(our home partition)**使用cgdisk分区：**`cgdisk /dev/sdx` [New] Press EnterFirst Sector: Leave this blank -&gt;press EnterSize in sectors: 1024MiB -&gt;press EnterHex Code: EF00 press EnterEnter new partition name: boot -&gt;press Enter123**boot分区**的Hex Code为**EF00**，千万不要弄错，有些资料会说是EF02，实测EF00才有效。arch wiki上说boot分区分配200-300mb就行了，但是为了以后的双系统等未知需求，分配1Gb。 [New] Press EnterFirst Sector: Leave this blank -&gt;press EnterSize in sectors: 8GiB -&gt;press EnterHex Code: 8200 -&gt;press EnterEnter new partition name: swap -&gt;press Enter12345678910111213141516171819**swap分区**的Hex Code是**8200**。swap分区的开启与否以及大小设置一直是争论焦点。这里贴出参考：[askubuntu\\_swap](https://askubuntu.com/questions/49109/i-have-16gb-ram-do-i-need-32gb-swap/49130#49130)[serverfault\\_swap](https://serverfault.com/questions/5841/how-much-swap-space-on-a-2-4gb-system)下面建立root分区和home分区。两者Hex code都是默认的**8300**。如果不独立设置home分区，就可以直接把剩余空间都设置为root分区。如果设置独立的home分区，可以分配30G左右给root分区，剩余空间分配给home分区。分区全部建立完毕之后，我们就要设置分区格式了。```shellmkfs.fat -F32 /dev/sda1mkswap /dev/sda2swapon /dev/sda2mkfs.ext4 /dev/sda3mkfs.ext4 /dev/sda4 3.安装Arch 以及配置启动挂载分区 12345mount /dev/sda3 /mntmkdir /mnt/bootmkdir /mnt/homemount /dev/sda1 /mnt/bootmount /dev/sda4 /mnt/home 设置mirrorlist 学校有ipv6的学生可以用清华的源，ipv6直连，美滋滋。 nano /etc/pacman.d/mirrorlist 然后在最前面加上 12# TsinghuaServer = http://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch 然后安装系统 1pacstrap -i /mnt base base-devel 然后创建fstab文件到新安装系统： 1genfstab -U -p /mnt &gt;&gt; /mnt/etc/fstab 可以通过nano /mnt/etc/fstab查看是否创建成功 接下来就可以切换到我们新安装的系统了 arch-chroot /mnt 接下来设置语言，linux下界面语言还是用英文吧。 nano /etc/locale.gen 然后取消掉en_US.UTF-8和zh_CN.UTF-8前面的注释。 使其生效： locale-gen 接下来设置语言： 12echo LANG=en_US.UTF-8 &gt; /etc/locale.confexport LANG=en_US.UTF-8 设置时区： ln -s /usr/share/zoneinfo/Asia/Shanghai &gt; /etc/localtime 请自觉使用tab补全以免出错。 设置硬件时钟： hwclock --systohc --utc 设置主机名： echo hostname &gt; /etc/hostname 然后编辑pacman.conf取消multilib前面的注释： 这个是为了在64位机器上运行32位程序 12[multilib]Include = /etc/pacman.d/mirrorlist 然后强烈推荐添加的yaourt 123[archlinuxfr]SigLevel = NeverServer = http://repo.archlinux.fr/$arch 一定要注意大小写。 必须添加的archlinuxcn源，里面有很多中国特色软件，比如网易云、有道词典之类的，同样推荐清华源。 123[archlinuxcn]SigLevel = Optional TrustedOnlyServer = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch 然后安装archlinuxcn-keyring包以导入GPG key。 这个时候就可以保存pacman.conf文件了。 设置root账户的密码： passwd 添加日常用户： useradd -m -g users -G wheel,storage,power -s /bin/bash yourusername 设置密码： passwd yourusername 然后是设置sudoers： EDITOR=nano visudo 然后取消注释： %wheel ALL=(ALL) ALL 然后让使用sudo命令的用户必须输入root密码： Defaults rootpw 然后就可以保存文件了。 安装补全命令： pacman -S bash-completion 安装引导 确保EFI变量被挂载 mount -t efivarfs efivarfs /sys/firmware/efi/efivars 使用Gummiboot作为我们的启动管理，这个已经整合到了bootctl/system-boot里，所以安装方式为： bootctl install 下面，我需要把/root分区的PARTUUID加入到启动设置里： blkid -s PARTUUID -o value /dev/sdxY x代表设备代号，本次为a，Y是/root partition的排号，本次为3. 然后添加gummiboot manager配置文件： 123456nano /boot/loader/entries/arch.conf# 下面是内容：title Arch Linuxlinux /vmlinuz-linuxinitrd /initramfs-linux.imgoptions root=PARTUUID=上个命令得到的 rw 保存并退出 添加intel支持： pacman -S intel-ucode 然后写入到启动管理设置里： 123nano /boot/loader/entries/arch.confinitrd /intel-ucode.imginitrd /initramfs-linux.img 这个时候基本的操作已经完成了，我们可以重启试试了。 123exitumount -R /mntreboot 5.安装xfce4桌面环境1234567sudo pacman -S mesasudo pacman -S xorg-server xorg-server-common xorg-xinitsudo pacman -S xfce4sudo pacman -S xfce4-goodiessudo pacman -S sddmsudo systemctl enable sddm.servicereboot 安装完成，可以使用了。美滋滋。 6.安装Tex Live123yaourt -S texlive-mostyaourt -S texlive-langchineseyaourt -S texstudio 安装完成之后使用tex --version测试： 12345678910-&lt;%&gt;- tex --versionTeX 3.14159265 (TeX Live 2016/Arch Linux)kpathsea version 6.2.2Copyright 2016 D.E. Knuth.There is NO warranty. Redistribution of this software iscovered by the terms of both the TeX copyright andthe Lesser GNU General Public License.For more information about these matters, see the filenamed COPYING and the TeX source.Primary author of TeX: D.E. Knuth. 使用texstudio编写测试文件： 新建test.tex,内容如下： 123456789101112131415\\documentclass&#123;article&#125;\\usepackage&#123;graphicx&#125;\\begin&#123;document&#125;\\begin&#123;figure&#125; \\includegraphics[width=\\linewidth]&#123;favicon.jpg&#125; \\caption&#123;A boat.&#125; \\label&#123;fig:boat1&#125;\\end&#123;figure&#125;Figure \\ref&#123;fig:boat1&#125; shows a boat.\\end&#123;document&#125; Build &amp; View查看运行结果，正常结果如下：","categories":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/tags/Linux/"}]},{"title":"python Tips","slug":"2017-9-18-python-require-install","date":"2017-05-19T22:43:00.000Z","updated":"2019-04-01T15:18:44.163Z","comments":true,"path":"2017/05/20/2017-9-18-python-require-install/","link":"","permalink":"http://xichen.pub/2017/05/20/2017-9-18-python-require-install/","excerpt":"","text":"自动生成和安装requirements.txt依赖requirements.txt可以通过pip命令自动生成和安装 生成requirements.txt文件 1pip freeze &gt; requirements.txt 安装requirements.txt依赖 1pip install -r requirements.txt","categories":[{"name":"Tips","slug":"Tips","permalink":"http://xichen.pub/categories/Tips/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"http://xichen.pub/tags/Tips/"},{"name":"python","slug":"python","permalink":"http://xichen.pub/tags/python/"}]},{"title":"正则表达式入门笔记","slug":"2017-05-20-正则表达式入门","date":"2017-05-19T22:43:00.000Z","updated":"2019-04-01T15:18:44.120Z","comments":true,"path":"2017/05/20/2017-05-20-正则表达式入门/","link":"","permalink":"http://xichen.pub/2017/05/20/2017-05-20-正则表达式入门/","excerpt":"","text":"这是主要参考文献：正则表达式入门，本文只是做了修改以便于自己记忆。 1. 元字符 metacharater \\b 代表着单词的开头或者结尾，也就是单词的分界处； . 匹配除了换行符以外的任意字符； \\d 匹配一位数字； \\s 匹配任意的空白符，包括空格，制表符，换行符，中文全角空格等； \\w 匹配字母或数字或下划线或者汉字等； ^ 匹配字符串的开始； $ 匹配字符串的结束； 字符转义仍然是使用\\ 2. 限定 + 指定前面的内容可以连续重复1次或者更多次； * 指定前面的内容可以连续重复任意次（包括0次)； ? 重复零次或者一次； {n} 重复n次； {n,1} 重复n次或者更多次； {n,m} 重复n次到m次； 3. 字符类可以利用方括号来匹配所需字符，[acb]代表可以匹配abc其中的一个，所以[]只用来匹配没有元字符对应的字符集中的单个字符 比如[0-9],就跟\\d是完全一致的，也就是匹配单个数字 4.分支条件 正则表达式分支条件示例：\\d{5}-\\d{4}|\\d{5} 这个例子含有一个小的tricky的地方，就是它说明了一个问题：用分支条件时，要注意各个条件的顺序。如果把这个表达式改为\\d{5}|\\d{5}-\\d{4}，那么就只会匹配五位的邮编以及9位邮编的前5位。 原因是匹配分支条件时，将会从左到右地测试每个条件，如果满足了某个分支的话，就不会再管其它条件。 5. 分组上面所说的都是重复单个字符的方法，如果想要重复多个字符可以用小括号来指定子表达式（也叫作分组），这也是当我们需要（字符本身时需要对其进行转义的原因。 (\\d{1,3}.){3}\\d{1,3}是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：\\d{1,3}匹配1到3位的数字，(\\d{1,3}.){3}匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(\\d{1,3})。 6.反义 代码语法 说明 \\W 匹配任意不是字母、数字、下划线、汉字的字符 \\S 匹配任意不是空白符的字符 \\D 匹配任意非数字的字符 \\B 匹配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^aeiou] 匹配除了aeiou这几个字母以外的任意字符 7.后向引用使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容）可以在表达式或者其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左到右，以分组的左括号为标志，第一个出现的分组组号为1，第二个为2，以此类推。 分组0对应整个正则表达式； 实际上组号分配过程是要从左到右扫描两遍：第一遍只给未命名组分配，第二遍只给命名组分配–因此所有的命名组的组号都大于未命名组的组号； 你可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权。 \\b(\\w+)\\b\\s+\\1\\b可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\\b(\\w+)\\b)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\\1)。 你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：(?\\w+)(或者把尖括号换成’也行：(?’Word’\\w+)),这样就把\\w+的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用\\k,所以上一个例子也可以写成这样：\\b(?\\w+)\\b\\s+\\k\\b。 常用分组语法： 待补充 8. 零宽断言","categories":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/tags/Linux/"}]},{"title":"使用Arch Linux时出现的问题","slug":"2017-05-17-Problems-I-encountered-when-I-use-Arch-Linux","date":"2017-05-18T22:32:24.000Z","updated":"2019-04-01T15:18:44.119Z","comments":true,"path":"2017/05/19/2017-05-17-Problems-I-encountered-when-I-use-Arch-Linux/","link":"","permalink":"http://xichen.pub/2017/05/19/2017-05-17-Problems-I-encountered-when-I-use-Arch-Linux/","excerpt":"","text":"使用了Arch快半年了，这个文章实在是写晚了。。 1. oh my zsh 安装使用首先安装Zsh 1sudo pacman -S zsh 安装oh my zsh 1sh -c \"$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\" 切换shell从bash到zsh 首先查看可用shell列表： 1234567➜ ~ cat /etc/shells# /etc/shells/bin/sh/bin/bash# End of file/bin/zsh/usr/bin/zsh 切换到zsh 1chsh -s /usr/bin/zsh 2. error: failed to commit transaction (conflicting files)问题描述：这个问题已经碰到了几次，原因暂未知。 1234error: failed to commit transaction (conflicting files)python-markupsafe: /usr/lib/python3.6/site-packages/MarkupSafe-1.0-py3.6.egg-info/PKG-INFO exists in filesystempython-markupsafe: /usr/lib/python3.6/site-packages/MarkupSafe-1.0-py3.6.egg-info/SOURCES.txt exists in filesystempython-markupsafe: /usr/lib/python3.6/site-packages/MarkupSafe-1.0-py3.6.egg-info/dependency_links.txt exists in filesystem 解决方法：首先，检测一下冲突文件有没有包在使用1pacman -Qo /path/to/file 结果一般就是没有包在使用。。所以下面就rm掉所有引起冲突的文件就行了，问题解决。最近碰见了这个问题好几次，但是出现原因暂未知。。太烦了。 3. 窗口撕裂问题描述：我不知道这个问题应不应该叫做窗口撕裂：在上下滚动内容的时候，滚动方向最下面的内容会出现重影，显得好像屏幕刷新有延迟。 解决方法： 1sudo vim /etc/X11/xorg.conf.d/20-intel.conf 然后添加如下内容： 123456Section \"Device\" Identifier \"Intel Graphics\" Driver \"intel\" Option \"TearFree\" \"true\" Option \"AccelMethod\" \"uxa\"EndSection 默认的AccelMethod的值为sna，在我这里使用sna会出现滚动延迟的情况，但是使用uxa就没有这种现象。但是更改了这个值之后发现了一个新问题就是笔记本不合盖子屏幕自动关闭之后不能唤醒，只有切到tty之后再切回来才行。待解决。 4. signature from xxx is marginal trust问题描述： error: archlinuxcn-keyring: signature from “Jiachen Yang \\“ is marginal trust:: File /var/cache/pacman/pkg/archlinuxcn-keyring-20170522-1-any.pkg.tar.xz is corrupted (invalid or corrupted package (PGP signature)). 解决办法： sudo pacman-key --refresh-keys 代码运行结果就是新导入了很多PGP signature, 然后问题解决。 解决方法二 1234sudo rm -R /etc/pacman.d/gnupg/pacman-key --initpacman-key --populate archlinuxpacman-key --populate archlinuxcn 可以看出这也是走的更新key的路数。 但是出现这种问题执行pacman -S archlinux-keyring重装archlinux-keyring是没有用的。 还有一种说法是系统时间不正确 不知道这个系统时间是指哪个时间。 5. /opt sysmlink file conflicts问题描述：由于在安装Arch系统时，/home分区是独立于/root分区的，而yaourt安装的大型软件都是会安装到/opt下面，导致系统分区会被很快用光。所以我的解决方法是在/home分区下新建opt分区，然后建立软链接： ln -s /home/opt /opt 但是这样做之后会导致在yaourt安装软件是出现/opt already exists的file conflicts错误。 官方解释如下： Directory Symlink Handling: Example time! Arch Linux has a /lib -&gt; /usr/lib symlink. Previously, if pacman was installing a package and it found files in /lib, it would follow the symlink and install it in /usr/lib. However the filelist for that package still recorded the file in /lib. This caused heaps of difficulty in conflict resolving – primarily the need to resolve every path of all package files to look for conflicts. That was a stupid idea! So now if pacman sees a /lib directory in a package, it will detect a conflict with the symlink on the filesystem. If you were using this feature to install files elsewhere, you probably need to look into what a bind mount is! Note that this change requires us to correct the local package file list for any package installed using this mis-feature, so we bumped the database version. Upgrade using pacman-db-upgrade. Thanks to Andrew! 解决方法： 在/etc/fstab里加入如下内容： 12# solve the /opt sysbolink file conficts errors/home/opt /opt none bind problems solved, splendid! ### 6. wine下TIM中文界面部分乱码 问题描述： 已经通过winetricks corefonts cjkfonts安装了字体，但是qq登录界面以及消息预览界面的中文都是方块。 解决方法： 123456789101112131415161718vim .wine/system.reg搜索： LogPixels找到的行应该是：[System\\\\CurrentControlSet\\\\Hardware Profiles\\\\Current\\\\Software\\\\Fonts]将其中的：“LogPixels”=dword:00000060改为：“LogPixels”=dword:00000070搜索： FontSubstitutes找到的行应该是：[Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\FontSubstitutes]将其中的：“MS Shell Dlg”=”Tahoma”“MS Shell Dlg 2″=”Tahoma”改为：“MS Shell Dlg”=”SimSun”“MS Shell Dlg 2″=”SimSun” SimSun代表windows下的simsun.ttc字体，这里提供下载：下载simsun.ttc 7. xfce4下开机时某些非自启应用会自动运行问题描述：已经关闭了auto save sessions，但是在登录之后某些应用仍然会自动启动，具体表现为某次关机前系统的工作状态。 解决方法： 1rm -r .cache/sessions/* All clear!!!","categories":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/tags/Linux/"}]}]}